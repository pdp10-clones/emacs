

	


	

	

   **********************************************************************
   *									*
   *									*
   *			    PRELIMINARY COPY				*
   *									*
   *									*
   **********************************************************************

   This is a preliminary copy of  the  TOPS-20	MONITOR  CALLS	REFERENCE
   MANUAL  which  is  provided only for field-test purposes.  This manual
   may not contain the very latest information	for  a	particular  JSYS.
   There will be some formatting errors, such as spurious running headers
   in the middle of  a	page,  etc.   Note  that  all  section	and  page
   references  in  the	table of contents and the text are indeterminate.
   However, the page numbers in the index are accurate.  While the  index
   is  in  a  very preliminary state, it will offset the lack of accurate
   page numbers in the table of contents.


			   TOPS-20 MONITOR CALLS

			      REFERENCE MANUAL

			       Order Number:

				AD-4166D-TM

				October 1979


   This manual describes all of the  monitor  calls  that  exist  in  the
   TOPS-20  operating  system.	 For  easy  reference,	the  monitor call
   descriptions are arranged alphabetically and presented concisely.

   This manual replaces the DECSYSTEM-20 Monitor Calls Reference  manual,
   Order No.  AA-4166C-TM and its update, AA-416C-T1.

   Operating System and Version:     TOPS-20 V4


					   First Printing, February 1976
					   Revised:  August 1976
					   Revised:  May 1977
					   Revised:  January 1978
					   Updated:  October 1978
					   Revised:  October 1979

   The information in this document is subject to change  without  notice
   and	should	not  be  construed  as	a commitment by Digital Equipment
   Corporation.  Digital Equipment Corporation assumes no  responsibility
   for any errors that may appear in this manual.

   The software described in this document is furnished under  a  license
   and	may  be  used or copied only in accordance with the terms of such
   license.

   Digital Equipment Corporation assumes no responsibility for the use or
   reliability	of  its  software  on  equipment  that is not supplied by
   DIGITAL.

   Copyright (C) 1976, 1977, 1978, 1979 by Digital Equipment Corporation

   The postage prepaid READER'S COMMENTS form on the last  page  of  this
   document  requests  the  user's  critical  evaluation  to assist us in
   preparing future documentation.

   The following are trademarks of Digital Equipment Corporation:

	   DIGITAL		  DECsystem-10	     MASSBUS
	   DEC			  TOPS-20	     OMNIBUS
	   PDP			  DECtape	     OS/8
	   DECUS		  DIBOL 	     PHA
	   UNIBUS		  EDUSYSTEM	     RSTS
	   COMPUTER LABS	  FLIP CHIP	     RSX
	   COMTEX		  FOCAL 	     TYPESET-8
	   DDT			  INDAC 	     TYPESET-11
	   DECCOMM		  LAB-8

				  CONTENTS

								  Page

   PREFACE							  ix

   CHAPTER 1	    INTRODUCTION				  1-1

	   1.1	    SOURCE/DESTINATION DESIGNATORS		  1-2
	   1.1.1      File Designator				  1-4
	   1.1.2      Device Designator 			  1-4
	   1.1.3      Byte Pointer to Strings			  1-4
	   1.1.4      Special Designators			  1-5
	   1.2	    PROCESS HANDLE				  1-5
	   1.3	    PROCESS/FILE HANDLE 			  1-6
	   1.4	    DATE AND TIME STANDARDS			  1-6
	   1.5	    CONVENTIONS USED IN THIS MANUAL		  1-6
	   1.5.1      Number Bases				  1-6
	   1.5.2      Abbreviations				  1-6
	   1.5.3      Symbols					  1-7
	   1.5.4      Unimplemented Features			  1-7

   CHAPTER 2	    FUNCTIONAL ORGANIZATION OF JSYS'S		  2-1

	   2.1	    ACCOUNTING FUNCTIONS			  2-1
	   2.2	    REFERENCING FILES				  2-1
	   2.2.1      File Specifications			  2-1
	   2.2.2      Logical Names				  2-3
	   2.2.3      File Handles				  2-3
	   2.2.4      File References				  2-4
	   2.2.5      Sample Program				  2-5
	   2.2.6      File Access				  2-7
	   2.2.7      Directory Access				  2-8
	   2.2.8      File Descriptor Block			  2-9
	   2.2.9      Primary Input and Output Files		  2-12
	   2.2.10     Methods of Data Transfer			  2-12
	   2.2.11     File Byte Count				  2-12
	   2.2.12     EOF Limit 				  2-13
	   2.2.13     Input/Output Errors			  2-13
	   2.3	    OBTAINING INFORMATION			  2-15
	   2.3.1      Error Mnemonics and Message Strings	  2-15
	   2.3.2      System Tables				  2-15
	   2.4	    COMMUNICATING WITH DEVICES			  2-18
	   2.4.1     Physical Card Reader (PCDR:)		  x-xx
	   2.4.2     Spooled Card Reader (CDR:) 		  x-xx
	   2.4.3     Physical Card Punch (PCDP:)		  x-xx
	   2.4.4     Spooled Card Punch (CDP:)			  x-xx
	   2.4.5      Physical Line Printer (PLPT:)		  x-xx
	   2.4.5.1    Status Bits				  x-xx
	   2.4.6      Spooled Line Printer (LPT:)		  x-xx
	   2.4.7      Physical Magnetic Tape (MTA:)		  x-xx
	   2.4.7.1    Buffered I/O				  x-xx
	   2.4.7.2    Unbuffered I/O				  x-xx
	   2.4.7.3    Magnetic Tape Status			  x-xx
	   2.4.7.4    Reading a Tape in the Reverse Direction	  x-xx
	   2.4.7.5    Hardware Data Modes			  x-xx
	   2.4.8     LOGICAL MAGNETIC TAPE (MT:)		  X-XX
	   2.4.9      Terminal (TTY:)				  x-xx
	   2.4.9.1    JFN Mode Word				  x-xx
	   2.4.9.2    Control Character Output Control		  x-xx
	   2.4.9.3    Character Set				  x-xx

			      CONTENTS (CONT.)

								  Page

	   2.4.9.4    Terminal Characteristics Control		  x-xx
	   2.4.9.5    Terminal Linking				  x-xx
 	   2.4.9.6    Terminal Advising 			  x-xx
	   2.5	   SOFTWARE DATA MODES
	   2.6	    SOFTWARE INTERRUPT SYSTEM			  2-33
	   2.6.1      Software Interrupt Channels		  2-34
	   2.6.2      Software Interrupt Priority Levels	  2-34
	   2.6.3      Software Interrupt Tables 		  2-35
	   2.6.4      Terminating Conditions			  2-35
	   2.6.5      Panic Channels				  2-35
	   2.6.6      Terminal Interrupts			  2-36
	   2.6.6.1    Terminal Interrupt Modes			  2-37
	   2.6.7      Dismissing An Interrupt			  2-38
	   2.7	    PROCESS CAPABILITIES			  2-39
 	   2.7.1      Assigned Capabilities			  2-39
 	   2.7.2      Access Control				  x-xx
	   2.7.3      Processes and Scheduling			  2-40
 	   2.7.4.1    Process Freezing				  2-40
 	   2.7.4.2     Execute-Only Files
 		       and Execute-Only Processes		  x-xx
	   2.8	    SAVE FILES					  2-41
	   2.8.1      Format For Nonsharable Save Files 	  2-41
	   2.8.2      Format of Sharable Save Files		  2-42
	   2.8.3      Entry Vector				  2-43
	   2.9	    INPUT/OUTPUT CONVERSION			  2-44
	   2.9.1      Floating Output Format Control Word	  2-44
	   2.9.1.1    Free Format				  2-44
	   2.9.1.2    General Format Control			  2-45
 	   2.9.2      Date and Time Conversion Monitor Calls	  2-46
 	   2.10     ARCHIVE/VIRTUAL DISK SYSTEM 		  X-XX
	   2.11     PRIVILEGED MONITOR CALLS			  2-47

   CHAPTER 3	    TOPS-20 MONITOR CALLS			  3-1

	   ACCES    (552)  Specifies access to a directory	  3-1
	   ADBRK    (570)  Controls address breaks		  3-3
	   AIC	    (131)  Activates software interrupt channels  3-5
 	   ALLOC    (520)  Allocates a device			  3-5
 	   ARCF     (247)  Archive/virtual disk operations x-xx
 	   ASND      (70)  Assigns a device			  3-6
 	   ASNSQ    (752)  Assigns ARPANET special
 			   message queue			  x-xx
 	   ATNVT    (274)  Creates ARPANET Network
 			   Virtual Terminal Connection		  x-xx
	   ATACH    (116)  Attachs a terminal to a job		  3-7
	   ATI	    (137)  Assigns a terminal code to an
			   interrupt channel			  3-8
	   BIN	     (50)  Performs byte input			  3-9
	   BKJFN     (42)  Backs up pointer by one byte 	  3-10
	   BOOT     (562)  Performs functions required
			   for loading front-end software	  3-10
	   BOUT      (51)  Performs byte output 		  3-14
	   CACCT      (4)  Changes account designator		  3-15
	   CFIBF    (100)  Clears the input buffer		  3-15
	   CFOBF    (101)  Clears the output buffer		  3-16
	   CFORK    (152)  Creates an inferior process		  3-16
	   CHFDB     (64)  Changes a File Descriptor Block	  3-17
	   CHKAC    (521)  Checks access to a file		  3-18
	   CIS	    (141)  Clears the interrupt system		  3-19
	   CLOSF     (22)  Closes a file			  3-20
	   CLZFF     (34)  Closes the process' files		  3-21
	   COMND    (544)  Parses a command			  3-22
	   CRDIR    (240)  Creates, changes, or deletes
			   a directory				  3-38
	   CRJOB      (2)  Creates a job			  3-42
 	   CRLNM    (502)  Defines or deletes a logical name	  3-47
 	   CVHST    (276)  Converts ARPANET host number
 			   to primary name			  x-xx
 	   CVSKT    (275)  Converts ARPANET local socket
 			   to absolute form			  x-xx

			      CONTENTS (CONT.)

								  Page

	   DEBRK    (136)  Dismisses current software interrupt   3-48
	   DELDF     (67)  Expunges deleted files		  3-48
	   DELF      (26)  Deletes files			  3-49
	   DELNF    (317)  Retains specified number of
			   generations of a file		  3-50
	   DEQ	    (514)  Removes request from resource queue	  3-51
	   DEVST    (121)  Translates a device designator
			   to a string				  3-53
	   DFIN     (234)  Inputs double-precision floating
			   point number 			  3-53
	   DFOUT    (235)  Outputs double-precision floating
			   point number 			  3-54
	   DIAG     (530)  Reserves or releases hardware channels 3-55
	   DIBE     (212)  Dismisses until input buffer is empty  3-56
	   DIC	    (133)  Deactivates software interrupt
			   channels				  3-57
	   DIR	    (130)  Disables software interrupt system	  3-57
	   DIRST     (41)  Translates a directory number to
			   a string				  3-58
	   DISMS    (167)  Dismisses the process		  3-59
	   DOBE     (104)  Dismisses until output buffer is empty 3-59
	   DSKAS    (244)  Assigns disk addresses		  3-60
	   DSKOP    (242)  Specifies disk transfers in hardware
			   terms				  3-61
	   DTACH    (115)  Detaches a terminal from a job	  3-62
	   DTI	    (140)  Deassigns a terminal code		  3-62
	   DUMPI     (65)  Reads data in unbuffered data mode	  3-63
	   DUMPO     (66)  Writes data in unbuffered data mode	  3-64
	   DVCHR    (117)  Retrieves device characteristics	  3-65
	   EFACT      (5)  Makes an entry in the FACT file	  3-66
	   EIR	    (126)  Enables  software interrupt system	  3-67
	   ENQ	    (513)  Places request in resource queue	  3-67
	   ENQC     (515)  Obtains status of resource queue	  3-73
	   EPCAP    (151)  Enables process capabilities 	  3-76
	   ERSTR     (11)  Converts error number to string	  3-77
	   ESOUT    (313)  Outputs an error string		  3-78
	   FFFFP     (31)  Finds first free page in file	  3-78
	   FFORK    (154)  Freezes processes			  3-79
 	   FFUFP    (211)  Finds first used page in file	  3-79
 	   FLHST    (277)  Flushes an ARPANET host		  x-xx
	   FLIN     (232)  Inputs floating-point number 	  3-80
	   FLOUT    (233)  Outputs floating-point number	  3-80
	   GACCT    (546)  Gets current account designator	  3-81
	   GACTF     (37)  Gets account designator of file	  3-81
	   GCVEC    (300)  Gets entry vector of compatibility
			   package				  3-82
	   GDSKC    (214)  Gets disk count			  3-83
	   GDSTS    (145)  Gets device's status 		  3-83
	   GDVEC    (542)  Gets entry vector of RMS		  3-84
	   GET	    (200)  Gets a save file			  3-84
	   GETAB     (10)  Gets a word from a monitor table	  3-85
	   GETER     (12)  Returns the last error in a process	  3-86
	   GETJI    (507)  Gets specified job information	  3-86
	   GETNM    (177)  Returns the program name currently
 			   being used				  3-87
 	   GETOK%   (574)  Requests access to a
 			   protected resource			  x-xx
	   GEVEC    (205)  Gets entry vector			  3-88
	   GFRKH    (164)  Gets process handle			  3-88
	   GFRKS    (166)  Gets process structure		  3-89

			      CONTENTS (CONT.)

								  Page

	   GFUST    (550)  Returns author and last writer
 			   name strings 			  3-90
 	   GIVOK%   (576)  Grants access to a
 			   protected resource			  x-xx
	   GJINF     (13)  Gets current job information 	  3-91
	   GNJFN     (17)  Gets the next JFN			  3-91
	   GPJFN    (206)  Gets the primary JFNs		  3-92
	   GTAD     (227)  Gets current date and time		  3-93
	   GTDAL    (305)  Gets disk allocation of a directory	  3-93
	   GTDIR    (241)  Gets information of directory entry	  3-94
	   GTFDB     (63)  Gets a File Descriptor Block 	  3-95
	   GTJFN     (20)  Gets a JFN
			   Short Form				  3-96
			   Long Form				  3-103
	   GTRPI    (172)  Get trap information 		  3-107
	   GTRPW    (171)  Gets trap words			  3-108
	   GTSTS     (24)  Gets a file's status 		  3-109
	   GTTYP    (303)  Gets the terminal type number	  3-109
	   HALTF    (170)  Halts the current process		  3-110
	   HFORK    (162)  Halts a process			  3-110
	   HPTIM    (501)  Returns values of high precision
			   clocks				  3-111
	   HSYS     (307)  Halts the system			  3-111
	   IDCNV    (223)  Inputs date and time conversion	  3-112
	   IDTIM    (221)  Inputs date and time 		  3-113
	   IDTNC    (231)  Inputs date/time without converting	  3-115
	   IIC	    (132)  Initiates software interrupts
			   on specified channels		  3-116
	   INLNM    (503)  Lists job's logical names		  3-117
	   JFNS      (30)  Translates a JFN to a string 	  3-117
	   KFORK    (153)  Kills a process			  3-119
	   LGOUT      (3)  Kills a job				  3-120
	   LNMST    (504)  Converts a logical name to a string	  3-121
	   LOGIN      (1)  Logs in a job			  3-121
	   LPINI    (547)  Loads VFU or translation RAM 	  3-122
	   MRECV    (511)  Receives an IPCF message		  3-123
	   MSEND    (510)  Sends an IPCF message		  3-125
	   MSFRK    (312)  Starts a process in monitor mode	  3-129
	   MSTR     (555)  Performs structure-dependent
			   functions				  3-129
	   MTALN    (774)  Associates magnetic tape drive
			   with logical unit number		  3-142
 	   MTOPR     (77)  Performs device-dependent functions	  3-142
 	   MTU%     (600)  Performs various functions
 			   for MT: devices			  x-xx
	   MUTIL    (512)  Performs IPCF control functions	  3-153
	   NIN	    (225)  Inputs an integer number		  3-158
	   NODE     (567)  Performs network utility functions	  3-158
	   NOUT     (224)  Outputs an integer number		  3-158
	   ODCNV    (222)  Outputs date and time conversion	  3-159
	   ODTIM    (220)  Outputs date and time		  3-160
	   ODTNC    (230)  Outputs date/time without converting   3-162
	   OPENF     (21)  Opens a file 			  3-163
	   PBIN      (73)  Inputs the next byte 		  3-166
	   PBOUT     (74)  Outputs the next byte		  3-167
	   PEEK     (311)  Obtains monitor data 		  3-167
	   PLOCK    (561)  Locks physical pages 		  3-168
	   PMAP      (56)  Maps pages				  3-168.1
	   PMCTL    (560)  Controls physical memory		  3-171
	   PPNST    (557)  Translates project-programmer
			   number to string			  3-173
	   PRARG    (545)  Reads/sets process argument block	  3-174
			      CONTENTS (CONT.)

								  Page

	   PSOUT     (76)  Outputs a string			  3-174
	   RCDIR    (553)  Translates string to directory number  3-175

			      CONTENTS (CONT.)

								  Page

 	   RCM	    (134)  Reads the channel word mask		  3-178
 	   RCVIM    (751)  Retrieves message from ARPANET
 			   special message queue		  x-xx
 	   RCVOK%   (575)  Retrieves access request from
 			   GETOK queue				  x-xx
	   RCUSR    (554)  Translates string to user number	  3-179
	   RDTTY    (523)  Reads data from primary input
			   designator				  3-180
 	   RELD      (71)  Releases a device			  3-182
 	   RELSQ    (753)  Deassigns ARPANET special
 			   message queue			  x-xx
	   RESET    (147)  Resets/initializes the current process 3-183
	   RFACS    (161)  Reads process' ACs			  3-183
	   RFBSZ     (45)  Reads files's byte size		  3-184
	   RFCOC    (112)  Reads file's control character output  3-184
	   RFMOD    (107)  Reads a file's mode			  3-185
	   RFORK    (155)  Resumes a process			  3-185
	   RFPOS    (111)  Reads terminal's position		  3-186
	   RFPTR     (43)  Reads file's pointer position	  3-187
	   RFRKH    (165)  Releases a process handle		  3-187
	   RFSTS    (156)  Reads a process' status		  3-188
	   RFTAD    (533)  Reads file's time and dates		  3-189
	   RIN	     (54)  Performs random input		  3-190
	   RIR	    (144)  Reads software interrupt table
			   addresses				  3-191
	   RIRCM    (143)  Reads inferior reserved channel mask   3-191
	   RLJFN     (23)  Releases JFNs			  3-192
	   RMAP      (61)  Obtains a handle on a page		  3-192
	   RNAMF     (35)  Renames a file			  3-193
	   ROUT      (55)  Performs random output		  3-194
	   RPACS     (57)  Reads a page's accessibility 	  3-195
	   RPCAP    (150)  Reads process capabilities		  3-196
	   RSCAN    (500)  Accepts a new string or uses the last
			   string as input			  3-196

	   RTFRK    (322)  Returns the handle of a process
			   suspended because of a monitor
			   call intercept			  3-198
	   RTIW     (173)  Reads terminal interrupt word	  3-198
	   RUNTM     (15)  Returns runtime of process or job	  3-199
	   RWM	    (135)  Reads waiting channel interrupt word
			   mask 				  3-199
	   RWSET    (176)  Releases the working set		  3-200
	   SACTF     (62)  Sets account designator of file	  3-200
	   SAVE     (202)  Saves a file as nonsharable		  3-201
	   SCTTY    (324)  Changes controlling terminal 	  3-202
	   SCVEC    (301)  Sets entry vector of compatibility
			   package				  3-203
	   SDSTS    (146)  Sets device's status 		  3-204
	   SDVEC    (543)  Sets entry vector of RMS		  3-205
	   SETER    (336)  Sets the last error in a process	  3-206
	   SETJB    (541)  Sets job parameters			  3-206
	   SETNM    (210)  Sets program name			  3-208
	   SETSN    (506)  Sets system name for a process	  3-208
	   SEVEC    (204)  Sets entry vector			  3-208
	   SFACS    (160)  Sets process' ACs			  3-209
	   SFBSZ     (46)  Sets file's byte size		  3-209
	   SFCOC    (113)  Sets file's control character output   3-210
	   SFMOD    (110)  Sets a file's mode			  3-211
	   SFORK    (157)  Starts a process			  3-211
	   SFPOS    (526)  Sets terminal's position		  3-212
	   SFPTR     (27)  Sets file's pointer position 	  3-212
	   SFRKV    (201)  Starts process using its entry vector  3-213
	   SFTAD    (534)  Sets file's time and dates		  3-214

			      CONTENTS (CONT.)

								  Page

	   SFUST    (551)  Sets author and last writer
			   name strings 			  3-215
	   SIBE     (102)  Skips if input buffer is empty	  3-216
 	   SIN	     (52)  Performs string input		  3-216
 	   SINM     (571)  Reads data from block-mode
 			   terminals				  x-xx
	   SINR     (531)  Performs record input		  3-218
	   SIR	    (125)  Sets software interrupt table
			   addresses				  3-219
	   SIRCM    (142)  Sets inferior reserved channel mask	  3-220
	   SIZEF     (36)  Gets the size of a file		  3-221
 	   SJPRI    (245)  Sets job's priority			  3-221
 	   SKED%    (577)  Performs services relating
 			   to the class scheduler		  x-xx
	   SKPIR    (127)  Tests the state of the software
 			   interrupt system			  3-222
 	   SNDIM    (750)  Sends a message to ARPANET
 			   special message queue		  x-xx
	   SMON       (6)  Sets monitor flags			  3-222
	   SNOOP    (516)  Performs system analysis		  3-223

	   SOBE     (103)  Skips if output buffer is empty	  3-227
	   SOBF     (175)  Skips if output buffer is full	  3-227
 	   SOUT      (53)  Performs string output		  3-228
 	   SOUTM    (572)  Writes data to block mode terminals	  x-xx
	   SOUTR    (532)  Performs record output		  3-229
	   SPACS     (60)  Sets a page's accessibility		  3-230
	   SPJFN    (207)  Sets the primary JFNs		  3-231
	   SPLFK    (314)  Splices a process structure		  3-232
	   SPOOL    (517)  Defines and initializes input spooling 3-232
	   SPRIW    (243)  Sets the priority word		  3-234
	   SSAVE    (203)  Saves a file as sharable		  3-235
	   STAD     (226)  Sets system date and time		  3-236
	   STCMP    (540)  Compares two strings 		  3-237
	   STDEV    (120)  Translates string to device designator 3-237
	   STI	    (114)  Simulates terminal input		  3-238
	   STIW     (174)  Sets terminal interrupt word 	  3-239
	   STO	    (246)  Simulates terminal output		  3-240
	   STPAR    (217)  Sets terminal parameters		  3-241
	   STPPN    (556)  Translates string to
			   project-programmer number		  3-242
	   STSTS     (25)  Sets a file's status 		  3-242
	   STTYP    (302)  Sets the terminal type number	  3-243
 	   SWJFN     (47)  Swaps two JFNs			  3-244
 	   SWTRP%   (573)  Traps for arithmetic underflow
 			   or overflow conditions		  x-xx
	   SYERR    (527)  Writes data to the system error file   3-244
	   SYSGT     (16)  Returns information for a system table 3-245
	   TBADD    (536)  Adds entry to command table		  3-245
	   TBDEL    (535)  Deletes entry from command table	  3-246
	   TBLUK    (537)  Looks up entry in command table	  3-246
	   TEXTI    (524)  Reads input from a terminal or a file  3-248
	   TFORK    (321)  Sets and removes monitor call
			   intercepts				  3-252
	   THIBR    (770)  Blocks the current job		  3-254
	   TIME      (14)  Returns time system has been up	  3-254
	   TIMER    (522)  Sets time limit for a job		  3-255
	   TLINK    (216)  Controls terminal linking		  3-256
	   TMON       (7)  Tests monitor flags			  3-258
	   TTMSG    (775)  Sends a message to a terminal	  3-259
	   TWAKE    (771)  Wakes a specified job		  3-259
	   UFPGS    (525)  Updates file's pages 		  3-260
	   USAGE    (564)  Writes entries into the accounting
			   data file				  3-260
	   USRIO    (310)  Places program in user I/O mode	  3-262
	   UTEST    (563)  Test monitor routines		  3-263
	   UTFRK    (323)  Resumes a process suspended because
			   of a monitor call intercept		  3-264

			      CONTENTS (CONT.)

								  Page

	   VACCT    (566)  Validates an account 		  3-265
	   WAIT     (306)  Dismisses process until interrupt
			   occurs				  3-266
 	   WFORK    (163)  Waits for processes to terminate	  3-266
 	   WILD%    (565)  Compares wild and non-wild strings	  x-xx

   APPENDIX A	    MONSYM.MAC					  A-1

   APPENDIX B	    MACSYM.MAC					  B-1

   APPENDIX C	    ACTSYM.MAC					  C-1

   INDEX							  Index-1

				  PREFACE				  

   The TOPS-20 Monitor Calls Reference Manual describes all of the  calls
   that exist in the TOPS-20 operating system.	The manual is written for
   the assembly language user who is already familiar  with  the  set  of
   monitor calls.

   Chapter 1 introduces the conventions and types of arguments used  with
   the	monitor  calls.   Chapter  2  presents	the calls in a functional
   order.  Chapter 3 contains the alphabetical descriptions  of  all  the
   monitor   calls.   Appendix	A  is  a  listing  of  the  system  file,
   MONSYM.MAC, which is the  definition  of  the  symbols  used  in  this
   manual.   Appendix B is a listing of the system file MACSYM.MAC, which
   lists  various  macros  useful  for	 assembly-language   programming.
   Appendix  C	is a listing of the system file, ACTSYM.MAC, which is the
   definition of the macros and symbols used with the USAGE monitor call.

   To understand how to use the basic monitor calls, the user is referred
   to  the  TOPS-20  Monitor Calls User's Guide (DEC-20-OMUGA-A-D).  This
   manual is organized according to the functions  an  assembly  language
   user  can request of the monitor.  It is not a reference manual nor is
   it complete documentation on the entire set of monitor calls.


				 CHAPTER 1

				INTRODUCTION				

   The TOPS-20 Monitor Calls Reference	Manual	describes  every  monitor
   call  in  the  TOPS-20  system.  Monitor calls for ARPANET systems and
   DECnet systems are also described.  However, the application of  these
   calls  are  more  completely  described in the TOPS-20AN Monitor Calls
   User's Guide (for ARPANET) and the DECnet-20  Programmer's  Guide  and
   Operations Manual.

   These calls invoke the TOPS-20 monitor through  the	JSYS  instruction
   (op code 104).  The UUO-type monitor calls (op codes 40-77) invoke the
   compatibility package, which simulates the action of  these	UUO's  in
   the	TOPS-10  monitor.   However,  programs	being written for TOPS-20
   should not be written with UUO's.

   For easy  reference,  monitor  call	descriptions  in  Chapter  3  are
   arranged  alphabetically and presented concisely.  This concise format
   begins with the JSYS name and numeric definition, followed by a  brief
   description	of  the JSYS function.	The calling sequence for the JSYS
   is next, indicated by statements in the format

   ACCEPTS IN ACn:  description

   where n is an accumulator  number.	Following  the	list  of  numeric
   accumulators,  and  a description of their contents, are statements of
   the form

   RETURNS     +1:  condition
	       +2:  condition

   that define where control returns, and under  what  conditions,  after
   execution  of  the  JSYS.   The  statement  RETURNS+1:   means control
   returns to the calling location plus  1;   RETURNS+2:   means  control
   returns  to	the  calling location plus 2.  Next, there is an optional
   description of the action taken by the JSYS.  A list of possible error
   mnemonics follows the JSYS definition.

   The monitor calls follow the conventions described in  the  paragraphs
   below.

   Arguments for the JSYS are placed in accumulators  (ACs).   The  first
   argument  is  in AC1, the second in AC2, and so forth, up to a maximum
   of four accumulators.  If more than four accumulators are needed by	a

   JSYS,  the  arguments  are  in  an argument block pointed to by an AC.
   (There are several  exceptions  to  this  convention;   refer  to  the
   individual descriptions in Chapter 3.)

   As mentioned above, after execution of the JSYS, control  is  returned
   to the caller at one of two locations.  The +1 return is often used to
   indicate failure of the JSYS to perform its intended function, and  an
   error  code	is  stored (and available via the GETER or ERSTR call) to
   indicate the exact cause of the failure.  This error code  is  usually
   stored  in  the  right half of AC1.	The +2 return is used to indicate
   successful completion of the JSYS.

   However, some JSYS's have only a single return (+1) to the instruction
   following  the  call.   On  successful  completion  of  the call, that
   instruction is executed.  When an error occurs during execution of the
   call,  the  monitor	examines  that	instruction.   If  it  is  a JUMP
   instruction with the AC field being	either	16  or	17,  the  monitor
   transfers  control  to  the address specified in the JUMP instruction.
   If the instruction following the call is not a JUMP	instruction,  the
   monitor generates an illegal instruction software interrupt, which the
   caller can process via the software interrupt system.  If  it  is  not
   prepared  to  process the interrupt, the process is usually terminated
   and a message is output.  (Refer to Section 2.5.)

   To include a JUMP instruction, the programmer can  place  one  of  the
   following symbols as the instruction following the call:

	ERJMP address
	ERCAL address

   These symbols correspond to JUMP 16, and JUMP 17, respectively,  which
   are machine no-ops.	However, the monitor simulates a

	JUMPA address

   instruction	when  an  ERJMP  is   used.    This   transfers   control
   permanently,  and  the routine at the address specified must include a
   JRST instruction to return.	The monitor simulates a

	PUSHJ 17, address

   instruction when an ERCAL is used.  This is a subroutine call, and the
   routine  must include a RETURN instruction to return.  Note that ERCAL
   requires accumulator 17 to be set up as  a  pushdown  pointer.   These
   symbols (usually defined by OPDEFs) allow the programmer to process an
   error without using	the  software  interrupt  system  and,	in  fact,
   override the interrupt system.

   The ERJMP or ERCAL symbol can be used with all JSYS's, independent  of
   whether  the  JSYS has one or two returns.  The ERJMP or ERCAL will be
   "executed" only if it is the next instruction following  a  JSYS  that
   fails;  otherwise, it is a no-op.

   Refer to the JSYS's descriptions in Chapter 3  for  specifics  on  the
   returns possible from each JSYS.

   Previous  JSYS  mnemonics  have  sometimes	caused	 conflicts   with
   user-defined  symbols  at assembly time.  To avoid this, all release 4
   and later JSYS  mnemonics  will  end  with  the  character  "%"  (e.g.
   WILD%).   Older, pre release-4 JSYS's may be specified with or without
   "%" (e.g.  GTJFN or GTJFN%).  Newer JSYS's must use "%".

   1.1	SOURCE/DESTINATION DESIGNATORS	 

   Many monitor calls operate on or transmit byte streams.  The source or
   destination	of these bytes can be any one of several items, including
   a file, a terminal, or a string in the  caller's  address  space.   In
   these cases, a standard 36-bit quantity, called the source/destination
   designator, is used as a JSYS argument to declare the byte  stream  on
   which to operate.  It can have one of the following formats.

   Symbol  Left Half	    Right Half		Meaning

     -	      0 		JFN	 a job file number.  Typically	a
					 small number starting at 1.  The
					 JFN is the job's  global  handle
					 on  a	file and is assigned with
					 the GTJFN monitor call.   (Refer
					 to Section 2.2.3.)

   .PRIIN     0 	       100	 primary input designator(1)

   .PRIOU     0 	       101	 primary output designator(1)

   .NULIO     0 	     377777	 null designator

   .TTDES     0 	     400000	 universal terminal designator

   .CTTRM     0 	     777777	 the job's controlling terminal

   .DVDES   600000	     000000	 universal device designator

	reasonable left   effective adr  a byte pointer to the beginning
	half of byte ptr		 of a string

	   777777	  effective adr  implicit byte pointer with left
			  (<777777)	 half to be  changed  to  440700.
					 (Refer to Section 1.1.3.)

	   777777	    777777	 universal default (i.e., -1)

	   5xxxxx	    xxxxxx	 immediate numeric value

   1. These designators are legal wherever a JFN is expected  and  cannot
   be assigned by the user;  that is, when the user is obtaining JFNs via
   GTJFN (or GNJFN), 100 and 101 are never assigned.

   The most commonly-used source/destination designators are:

	1.  A JFN identifying a particular instance of a file.	This  JFN
	    will  have previously been obtained from another monitor call
	    (GTJFN JSYS, refer to Section 2.2.3).

	2.  The primary input and output designators.  (Refer to  Section
	    2.2.9.)  These designators are the recommended ones to use to
	    refer to the logical controlling terminal because they can be
	    changed  to  cause "terminal" input and/or output to be taken
	    from  and/or  sent	to  a  file.   The  controlling  terminal
	    designator	(0,-1)	cannot be redirected in this way, and its
	    use is not recommended in normal situations.

	3.  A byte pointer to the beginning of the string being  read  or
	    written in the calling program's address space.

   1.1.1  File Designator	   

   A file designator is a subset of  the  source/destination  designator.
   It  includes  all  options except byte pointers to strings and numeric
   values.

   1.1.2  Device Designator	   

   Many monitor calls dealing with devices (refer to Section 2.4) take	a
   device designator as an argument.  This designator can be either

	LH:  .DVDES(600000)+device type number
	RH:  unit number for devices that have units, arbitrary code  for
	     structures, or -1 for non-structure devices that do not have
	     units

   or

	LH:  0
	RH:  .TTDES(400000)+ terminal number, or .CTTRM(777777) for
	     controlling terminal

   Thus, terminals can be represented in two ways;   the  second  way  is
   provided for compatibility with the source/destination designator.

   Because designators for structures contain an  arbitrary  code,  these
   designators	must  always  be obtained from the monitor (via the STDEV
   call) and cannot be created by the program.

   Section 2.4 describes the various devices and their type numbers.

   1.1.3  Byte Pointers To Strings	     

   Many  monitor  calls  deal  specifically  with  ASCII  strings.    The
   following conventions apply to such strings.

	1.  A file designator can be used if the file is in  7-bit  ASCII
	    format.  This is the usual format for text files.

	2.  One of the following ways is used to designate  a  string  in
	    the caller's address space:

	    a.	-1,, ADR to designate a 7-bit ASCII string  beginning  in
		the  leftmost  byte  of  ADR.	This  is for convenience,
		making	  HRROI 1,ADR	 functionally	 equivalent    to
		MOVE 1,[POINT 7,ADR].

	    b.	A full word byte pointer with a byte size of 7 bits.   If
		the byte size is not 7 bits, the results may be incorrect
		because the byte string is referenced via ILDB/IDPB  with
		no additional checking.

   Normally, ASCII strings are assumed to be terminated with a byte of	0
   (i.e.,  ASCIZ).   A	few  calls  terminate  on  other ASCII characters
   because of context (e.g., NIN call), and  some  optionally  accept  an
   explicit  byte  count  and/or  terminating  byte.   These latter calls
   (e.g., SIN and  SOUT  calls)  are  generally  those	that  can  handle
   non-ASCII strings and byte sizes other than 7 bits.

   After a JSYS is used  to  read  a  string,  the  source  byte  pointer
   argument  is  updated  such	that  an  ILDB	would  read the character
   following  the  terminating	character;   an  LDB  would  reread   the
   terminating character.

   After a JSYS is used to write a string, the destination  byte  pointer
   argument  is  updated  to  point  to  the character following the last
   nonnull character written.  If there is room, a null byte is  appended
   to the string, but the byte pointer returned is such that an IDPB will
   overwrite the null.

   1.1.4  Special Designators	   

   The universal default designator of -1 is used to indicate the current
   designator,	such  as the current job or the connected directory.  For
   example, the GETJI monitor call accepts  an	argument  of  -1  as  the
   designator for the current job.

   The designator 5xxxxx xxxxxx (where an immediate numeric value  is  in
   bits  3-35) is used to supply a numeric designator as an argument to a
   call.  For example, the CACCT monitor call accepts an  account  number
   as 5B2+33-bit number.

   1.2	PROCESS HANDLE	 

   Several monitor calls accept  an  18-bit  argument  called  a  process
   handle.

   Value     Symbol	    Meaning

   400000    .FHSLF    current process
     -1      .FHSUP    superior process
     -2      .FHTOP    top-level process
     -3      .FHSAI    current process and all of its inferiors
     -4      .FHINF    all of the current process' inferiors
     -5      .FHJOB    all processes in the job

   Use of the superior process argument (.FHSUP) is  legal  only  if  the
   process has the superior process access capability (SC%SUP) enabled in
   its capability word.  Use of the top level process  argument  (.FHTOP)
   is  legal  only  if	the  process has the WHEEL or OPERATOR capability
   enabled (SC%WHL or SC%OPR) in its capability word.  Refer  to  Section
   2.6.1 for information on the capability word.

   A process handle may also be in the range  400001  to  400777.   These
   process  handles are called relative process handles and are generated
   by the monitor (refer to the CFORK monitor call description) to  refer
   to  specific  processes.   These  handles  are  valid  only within the
   context of the process to which they are given.  Thus, they may not be
   meaningfully passed between processes.

   1.3	PROCESS/FILE HANDLE	 

   Some monitor calls accept an 18-bit	argument  called  a  process/file
   handle.  This handle is either a process handle (as defined in Section
   1.2) or a JFN.  Note that string  pointers  and  terminal  identifiers
   cannot  be  used  in this context.  This is not a limitation, however,
   because the operations that use the process/file handle are	used  for
   changing  page  maps.   Such  operations are not meaningful for string
   pointers or terminals.

   1.4	DATE AND TIME STANDARDS	   

   In TOPS-20, day 1 is November 18, 1858.  This is consistent	with  the
   Smithsonian	Astronomical  Date  Standard  which  is  used  by several
   computer systems.  The date uniformly increases by one for each day of
   the	week  since  day  1.  Internal dates are the number of days since
   November 17, 1858 .	Refer to Section 2.8.2 for more information about
   the date and time format.

   The internal time of day  standard  for  TOPS-20  is  specified  as	a
   fraction of a day.

   The internal  date  and  time  format  is  a  36-bit  quantity,  which
   frequently  occurs  as  a JSYS argument or is returned as a value.  In

   these cases, the day is in the left half, and the fraction of the  day
   is in the right half.

   The monitor calls that convert dates and times change from local dates
   and times to internal dates and times and vice versa.

   1.5	CONVENTIONS USED IN THIS MANUAL	    

   1.5.1  Number Bases	   

   Except where otherwise noted, numbers used in this  manual,	including
   those  in  the  definition  of  a  JSYS  description, are octal.  When
   indicated, bits in words are numbered in decimal with the leftmost bit
   of the word labeled B0 and the rightmost bit of the word labeled B35.

   1.5.2  Abbreviations	  

   The following abbreviations are used in this manual:

	     B0, B1, ...    Bit 0, bit 1, ...  of the computer word
	     nBm	    Field whose rightmost  bit	is  m  and  whose
			    value is n (e.g., 5B2).
	     LH 	    Left Half (B0-B17 of the word)
	     RH 	    Right Half (B18-B35 of the word)
	     JFN	    Job File Number
	     PSB	    Process Storage Block (a table containing all
			    monitor data for the process)
	     JSB	    Job Storage Block  (a  table  containing  all
			    monitor data relevant to the job)
	     CCOC words     Control Character Output Control words
			    (2	words  containing  36  2-bit  bytes  that
			    determine the way in which control characters
			    are output.  Refer to Section 2.4.4.2.)
	     FDB	    File  Descriptor  Block.   Refer  to  Section
			    2.2.8.

   1.5.3  Symbols	  

   The symbols used in this manual, including the names  of  the  JSYS's,
   are	defined  in the system file MONSYM.MAC.  The user must include in
   his program the statement

	SEARCH MONSYM

   before the first occurrence of a symbol to have the symbols defined in
   his assembly.  Refer to Appendix A for a listing of MONSYM.

   1.5.4  Unimplemented Features	   

   The MONSYM file contains symbol  names  for	several  JSYS's  and  bit
   positions  that  are not described in this manual.  These features are
   not implemented in the TOPS-20.  If an unimplemented JSYS is used in a
   user  program,  it  causes  an  illegal  instruction  interrupt unless
   followed by an ERJMP or ERCAL symbol.  In this case, the ERJMP will be
   "executed."	It  is	recommended  that  unimplemented or undefined bit
   positions be zero to allow for future expansion.

				 CHAPTER 2

		     FUNCTIONAL ORGANIZATION OF JSYS'S		        

   2.1	ACCOUNTING FUNCTIONS	 

   The monitor calls in this group are used to initiate and  delete  jobs
   from  the  system as well as to change and read accounting information
   about these jobs.

   The monitor calls pertaining to accounting functions are as follows:

	LOGIN	  Logs a job into the system
	CRJOB	  Creates a job and optionally logs it in
	LGOUT	  Kills a job
	CACCT	  Changes a job's account
	GACCT	  Reads a job's account
	SACTF	  Sets a file's account
	GACTF	  Reads a file's account
	USAGE	  Writes entries into the system's accounting data file
	VACCT	  Validates an account

   2.2	REFERENCING FILES	 

   All files in the system, including the system's  file  directory,  are
   normally  referenced  with  the  calls  in this group.  The privileged
   calls for directly referencing the disk are described in Section 2.9.

   2.2.1  File Specifications	   

   A file in TOPS-20 is identified by its device  name,  directory  name,
   filename, file type, and generation number.	These five items uniquely
   identify any file on the system that is accessible  to  a  user.   The
   device  name  identifies  the device on which the file is stored.  The
   directory name identifies the  directory  containing  the  file.   The
   filename,  type,  and  generation number identify a particular file in
   the directory given by the device and directory name.

   A file can also have attributes associated with it to further  specify
   information	about  the  file.   See  the description of the long-form
   GTJFN JSYS for a list of the possible file attributes.

   The general format of a file specification is:

   dev:<directory>name.typ.gen;attributes

   Refer to the TOPS-20 User's Guide for the complete description of file
   specifications.

   If a field of the specification is omitted, it may be supplied by  the
   program or from standard system values.  (Refer to Section 2.2.3.)

   Recognition is  done  on  file  specifications  in  a  uniform  manner
   regardless  of  the source of input.  However, the program can control
   certain aspects of recognition.  Whenever an ESC is encountered in the
   file  specification	string, the previous input is looked up according
   to the field currently being input.	A match is indicated if the input
   string  either exactly matches an entry in the appropriate table or is
   an initial substring of exactly one entry.  In the  latter  case,  the
   portion  of	the  matching  entry not appearing in the input string is
   output to a specified output file.  The  field  terminator  is  output
   also.   Recognition is done on successive fields with the fields being
   defaulted if need be.  If the file specification  cannot  be  uniquely
   determined,	as many entire fields as are unique are recognized, and a
   bell is output signifying that more input is required from  the  user.
   If	the   input  string  cannot  possibly  match  any  existing  file
   specification, an error is returned.

   CTRL/F behaves like ESC except recognition  stops  after  the  current
   field.   This  allows  the filename to be recognized, for example, but
   not the file type.

   If recognition is not used, then  each  field  must	be  delimited  as
   indicated  in  the general format above.  The input must exactly match
   some existing file specification unless the program specifies  in  the
   GTJFN call that new specifications are allowed (i.e., an output file).
   Without ESC or CTRL/F, no recognition is done, but completely  omitted
   fields are defaulted if the program has specified default values.  The
   file  specification	is  complete  whenever	all  fields   have   been
   recognized  or  a  terminator  has  been  input.   File  specification
   terminators are described in the GTJFN call description.

   The following editing characters are recognized during  the	input  of
   file specifications:

	DELETE	  erases one character.  If no more characters remain  in
		  the input, a bell is output.

	CTRL/W	  deletes back to the last punctuation character.  If  no
		  more characters remain in the input, a bell is output.

	CTRL/U	  aborts the entire filename-gathering operation.

	CTRL/R	  retypes the entire input as specified so far and awaits
		  further input.

   2.2.2  Logical Names	   

   Logical names are user-specified default values for one or more fields
   in  a  file specification.  Through the use of logical names, the user
   can override standard file specification  fields  built  into  TOPS-20
   programs  because  logical  name  fields  take precedence over default
   fields set by a program.  However, the  user  can  still  specify  any
   fields  explicitly since a logical name defines values to be used only
   if none are given by the user.  The user defines  logical  names  with
   the	DEFINE	command  or the CRLNM monitor call.  Refer to the TOPS-20
   User's Guide for the complete description of logical names.

   Recognition can be performed on a logical name by using ESC or CTRL/F.
   When  recognition is in effect for the first field of the string being
   entered to the GTJFN call, the list of user-defined logical	names  is
   scanned  first.   If  the  data  entered  by the user is sufficient to
   uniquely define one of his logical names, then  the	logical  name  is
   selected.   The  remaining  characters  of  the  logical  name and the
   terminating colon are output to the user.  If the data entered by  the
   user  for  the  first  field  does not define a logical name, then the
   directory is searched for a unique filename match.  Note that  logical
   names  are not searched in conjunction with directory entries and that
   a unique logical name will be recognized even though there  may  be	a
   filename with the same beginning character string.

   There  is  one  exception  to  the  recognition  procedure	described
   above:  if  an ESC or CTRL/F is typed as the first character, then the
   table of logical names will not be searched.  This allows programs  to
   define  defaults  that  can	be  used  by typing only the ESC and that
   cannot be circumvented if the user has only one logical name defined.

   2.2.3  File Handles	   

   It is necessary to have file handles that can be contained  in  a  few
   bits   and  do  not	require  extensive  lookup  procedures	for  each
   reference.  The file specification is  the  fundamental  handle  on	a
   file,  but this specification fits neither criterion above.	Therefore
   in TOPS-20, files are referenced by	handles  called  JFNs  (Job  File
   Numbers).   The  JFN is a small number and is valid within the context
   of the job (i.e., within any  process  of  the  job	to  which  it  is
   assigned).	However,  the handle is not valid between jobs.  That is,
   JFN 2 in job 11 will generally be a handle on a  completely	different
   file than JFN 2 in job 18.

   A JFN is associated with a file with either the GTJFN or GNJFN monitor
   call.   The	GTJFN call accepts a file specification and returns a JFN
   for the indicated file.  If a field of the specification  is  omitted,
   it  may  be	supplied  by the program defaults or from standard system
   values.  If the file specification refers to a group of files (because
   of  wildcard  characters,  see  below),  the GNJFN call can be used to
   associate the JFN to the next file in the group.

   A  logical  name  can  apply  to  one  or  more  fields  of	the  file
   specification  passed to the GTJFN call.  The logical name must be the

   first identifier passed to GTJFN and must be terminated with a colon.

   The GTJFN call uses a certain search order when obtaining a field in a
   file specification.	This order is as follows:

	1.  Use the field  explicitly  typed  by  the  user  or  the  one
	    specified in the primary input string.

	2.  Use the value for the field that is specified in the  logical
	    name specification.

	3.  Use the value for the field that is specified in the  default
	    block  by the program.  This is only for the long form of the
	    GTJFN call.

	4.  Use the system default value if all  of  the  above  searches
	    fail.

   In the special case of a device field specification where  the  device
   name  has  been obtained from either the program default or the system
   default, the device field is checked  to  see  if  it  is  actually	a
   logical  name.   If it is, then the values specified in its definition
   become defaults for all fields including the device field.

   If the specific call to GTJFN permits, a wildcard character (either an
   asterisk  or  a  percent  sign)  can  appear in the device, directory,
   filename, type, or generation number fields.  (The percent sign cannot
   appear  in  the  generation	number	field.)  An  asterisk matches any
   occurrence of the field, including a null field.  An asterisk as  part
   of  a field matches any remaining characters in the field, including a
   null character.  A percent sign matches any single existing	character
   in  the  field.   Upon  completion  of  the	GTJFN  operation, the JFN
   returned will  reference  the  first  file  found  when  scanning  the
   directory in the following order:

       In alphabetic order by directory name
       In alphabetic order by filename
       In aphabetic order by file type
       In ascending numeric order by generation number

   The GNJFN call can then be given to associate  the  JFN  to	the  next
   file.   Normally,  a  program  accepting  wildcard  characters in file
   specifications will successively reference all of  a  class	of  files
   using the same JFN and not obtain a new JFN for each file.

   The maximum number  of  JFNs  allowed  is  dependent  upon  the  space
   reserved  for  JFN-related information in the Job Storage Block (JSB).
   Currently the maximum number of JFNs allowed is 140 (octal).

   JFNs 100 (.PRIIN) and 101 (.PRIOU) are reserved for the primary  input
   and	output	designators,  respectively, and are never returned by the
   GTJFN (or GNJFN) call.  JFN 377777 (.NULIO) is reserved for	the  null
   designator.

   2.2.4  File References	   

   All file operations are initiated by acquiring a JFN on a  file  using
   the	GTJFN  (or  GNJFN) call.  Some file operations, such as deleting,
   renaming,  and  status  queries  about  the	file,  may  be	performed
   immediately	 after	 the   JFN   is  acquired.   Certain  operations,
   particularly data transfers, require that the file be opened  with  an
   OPENF  call	on the JFN.  When the user opens a file, he specifies the
   byte size to be used for byte I/O operations and the access	requested
   to the file.  Several implicit initialization operations, which affect
   subsequent references to the file, are also invoked	when  a  file  is
   opened.   For  example, a file's position pointer is normally reset to
   the beginning of  the  file	such  that  the  first	sequential  input
   operation reads the beginning data of the file.

   2.2.5  Sample Program	   

   A sample program follows which acquires JFNs, opens both an input  and
   an output file, and then copies data from the input file to the output
   file in 7-bit bytes until the end of the input file is encountered.


	 ;*** PROGRAM TO COPY INPUT FILE TO OUTPUT FILE. ***
   ;	   (USING BIN/BOUT AND IGNORING NULL'S)

	      TITLE FILEIO	      ;TITLE OF PROGRAM
	   SEARCH MONSYM	   ;SEARCH SYSTEM JSYS-SYMBOL LIBRARY

   ;*** IMPURE DATA STORAGE AND DEFINITIONS ***

	 INJFN:  BLOCK 1		 ;STORAGE FOR INPUT JFN
   OUTJFN: BLOCK 1		   ;STORAGE FOR OUTPUT JFN

	      PDLEN=3		      ;STACK HAS LENGTH 3
   PDLST:  BLOCK PDLEN		   ;SET ASIDE STORAGE FOR STACK

   A==1			      ;JSYS AC'S
   B==2
   C==3
   D==4
   T1==5			   ;TEMPORARY AC'S
				   ;....
   P==17			   ;PUSH DOWN POINTER

   ;*** PROGRAM INITIALIZATION ***

   START:  RESET		      ;CLOSE FILES AND INITIALIZE PROCESS
	   MOVE P,[IOWD PDLEN,PDLST] ;ESTABLISH STACK

   ;*** GET INPUT-FILE ***

   INFIL:  HRROI A,[ASCIZ /
   INPUT FILE: /]		   ;PROMPT FOR INPUT FILE
	   PSOUT		   ;ON CONTROLLING  TERMINAL
	   MOVE A,[GJ%OLD+GJ%FNS+GJ%SHT];SEARCH MODES FOR GTJFN
				   ;[EXISTING FILE ONLY , FILE-NR'S IN B
				   ; SHORT CALL ]

	      MOVE B,[.PRIIN,,.PRIOU] ;GTJFN'S I/O WITH CONTROLLING TERMINAL
	   GTJFN		   ;GET JOB FILE NUMBER (JFN)
	    ERJMP [ PUSHJ P,WARN   ;IF ERROR, GIVE WARNING
		   JRST INFIL]	   ;AND LET HIM TRY AGAIN
	   MOVEM A,INJFN	   ;SUCCESS, SAVE THE JFN

   ;*** GET OUTPUT-FILE ***

   OUTFIL: HRROI A,[ASCIZ /
   OUTPUT FILE: /]		   ;PROMPT FOR OUTPUT FILE
	   PSOUT		   ;PRINT IT
	   MOVE A,[GJ%FOU+GJ%MSG+GJ%CFM+GJ%FNS+GJ%SHT];GTJFN SEARCH MODES
				   ;[DEFAULT TO NEW GENERATION , PRINT
				   ; MESSAGE , REQUIRE CONFIRMATION
				   ; FILE-NR'S IN B , SHORT CALL ]

	      MOVE B,[.PRIIN,,.PRIOU] ;I/O WITH CONTROLLING TERMINAL
	   GTJFN		   ;GET JOB-FILE NUMBER
	    ERJMP [ PUSHJ P,WARN   ;IF ERROR, GIVE WARNING
		   JRST OUTFIL]    ;AND LET HIM TRY AGAIN
	   MOVEM A,OUTJFN	   ;SAVE THE JFN

	 ;NOW, OPEN THE FILES WE JUST GOT

   ;   INPUT

	      MOVE A,INJFN	      ;RETRIEVE THE INPUT JFN
	   MOVE B,[7B5+OF%RD]	   ;DECLARE MODES FOR OPENF [7-BIT BYTES + INPUT]
	   OPENF		   ;OPEN THE FILE
	    ERJMP FATAL 	   ;IF ERROR, GIVE MESSAGE AND STOP

   ;   OUTPUT

	      MOVE A,OUTJFN	      ;GET THE OUTPUT JFN
	   MOVE B,[7B5+OF%WR]	   ;DECLARE MODES FOR OPENF [7-BIT BYTES + OUTPUT]
	   OPENF		   ;OPEN THE FILE
	    ERJMP FATAL 	   ;IF ERROR, GIVE MESSAGE AND STOP

	 ;*** MAIN LOOP :COPY BYTES FROM INPUT TO OUTPUT ***

   LOOP:   MOVE A,INJFN	      ;GET THE INPUT JFN
	   BIN			   ;TAKE A BYTE FROM THE SOURCE
	   JUMPE B,DONE 	   ;IF 0, CHECK FOR END OF FILE.
	   MOVE A,OUTJFN	   ;GET THE OUTPUT JFN
	   BOUT 		   ;OUTPUT THE BYTE TO DESTINATION
	    ERJMP FATAL 	   ;IF ERROR, GIVE MESSAGE AND STOP
	   JRST LOOP		   ;LOOP, STOP ONLY ON A 0 BYTE (FOUND

				   ;AT LOOP+2)

   ;*** TEST FOR END OF FILE, ON SUCCESS FINISH UP ***

   DONE:   GTSTS		      ;GET THE STATUS OF INPUT FILE.
	   TLNN B,(GS%EOF)	   ;AT END OF FILE?
	   JRST LOOP		   ;NO, FLUSH NULL AND CONTINUE COPY

   CLOSIF: MOVE A,INJFN	      ;YES, RETRIEVE INPUT JFN
	   CLOSF		   ;CLOSE INPUT FILE
	    ERJMP FATAL 	   ;IF ERROR, GIVE MESSAGE AND STOP

   CLOSOF: MOVE A,OUTJFN	      ;RETRIEVE OUTPUT JFN
	   CLOSF		   ;CLOSE OUTPUT FILE
	    ERJMP FATAL 	   ;IF ERROR, GIVE MESSAGE AND STOP
	   HRROI A,[ASCIZ/
   [DONE]/]			   ;SUCCESSFULLY DONE
	   PSOUT		   ;PRINT IT
	   JRST ZAP		   ;STOP

	 ;*** ERROR HANDLING ***

   FATAL:  HRROI A,[ASCIZ/
   ?/]				   ;FATAL ERRORS PRINT ? FIRST
	   PUSHJ P,ERROR	   ;THEN PRINT ERROR MESSAGE,
	   JRST ZAP		   ;AND STOP

   WARN:   HRROI A,[ASCIZ/
   %/]				   ;WARNINGS PRINT % FIRST
				   ; AND FALL THRU 'ERROR' BACK TO CALLER

   ERROR:  PSOUT		      ;PRINT THE ? OR %
	   MOVE A,[.PRIOU]	   ;DECLARE PRINCIPAL OUTPUT DEVICE FOR ERROR MESSAGE
	   MOVE B,[.FHSLF,,-1]	   ;CURRENT FORK,, LAST ERROR
	   SETZB C,D		   ;NO LIMIT,, FULL MESSAGE
	   ERSTR		   ;PRINT THE MESSAGE
	    JFCL		   ;IGNORE UNDEFINED ERROR NUMBER
	    JFCL		   ;IGNORE ERROR DURING EXECUTION OF ERSTR
	   POPJ P,		   ;RETURN TO CALLER

   ZAP:    HALTF		      ;STOP
	   JRST START		   ;WE ARE RESTARTABLE
	   END START		   ;TELL LINKING LOADER START ADDRESS

   2.2.6  File Access	   

   TOPS-20 provides a general  mechanism  for  protecting  files  against
   unauthorized  access.  Generally, access to a file depends on the kind
   of access desired and the relationship of the user making  the  access
   to  the  directory  containing the file.  The possible relationships a
   user may have to the file's directory are:

	1.  The directory containing the file is the user's connected  or
	    accessed  directory.  Users satisfying this relationship have
	    owner access to the files in the directory.

	2.  The directory containing the file is in the same group as the
	    user.   Users  satisfying this relationship have group member
	    access to the files in the directory.

	3.  The directory  containing  the  file  is  outside  the  group
	    membership.   Users  satisfying  this relationship have world
	    access to the files in the directory.

   Both users and directories may belong  to  groups.	The  group-member
   relationship is satisfied if both the directory and the user belong to
   one or more of the same groups.  Groups are	assigned  by  the  system
   manager or operator.  (Refer to the TOPS-20 Operator's Guide.)

   The type of access permitted  to  a	file  for  each  relationship  is
   represented by the value of a 6-bit field.  The possible values are:

	Value	  Symbol	       Meaning

	  40	  FP%RD 	       Read access
 	  20	  FP%WR 	       Write access
 	  12	  FP%EX+FP%DIR	       Execute only
	  10	  FP%EX 	       Execute
	   4	  FP%APP	       Append access
	   2	  FP%DIR	       Directory listing access.  A GTJFN
				       call for the file will fail if the
				       user does not have at  least  this
				       access.

   This 6-bit field and the three relationships (owner, group,	remaining
   users)  are	represented  by  an  18-bit code, with bits 0-5 being the
   owner, bits 6-11 being the group, and bits 12-17 being  the	remaining
   users.   When  a  particular  bit  is  on, the corresponding access is
   permitted for the particular relationship.

   The access given to a group member includes the access  given  to  all
   members  outside  the  group.   Also,  the  access  given to the owner
   includes the access given to group members.	Thus, the owner of a file
   or  a  user	in  the  owner's group cannot have less access than users
   outside the group.

   2.2.7  Directory Access	   

   Access to a directory  is  protected  in  a	manner	similar  to,  but
   distinct  from,  that  of a file.  There is an 18-bit code, containing
   three 6-bit fields, associated with each directory.	Each of the three
   fields  controls  access by users in the same way that access to files
   is controlled.  For directories, however, each 6-bit  field	can  have
   one of the following values.

	Value	  Symbol			Meaning

	  40	  DP%RD     Accessing files in the directory according to
			    the  access  code  on the individual files is
			    allowed.  A GTJFN call  for  a  file  in  the
			    directory will fail if the user does not have
			    this access.

	  10	  DP%CN     Connecting to the directory without giving	a
			    password  is  allowed.   With  this access, a
			    group member  can  change  the  FDB  (as  the
			    owner)   as   well	 as   times,  dates,  and
			    accounting	information  for  files  in   the
			    directory.	Other operations on the files are
			    subject to the access codes of the files.  If
			    the  user  is  connected to the directory, he
			    has ownership access to the files;	if he  is
			    not   connected,   he  has	group  membership
			    access.

	   4	  DP%CF     Creating files in the directory is allowed.

   When a user	requests  access  to  a  file,	the  monitor  checks  the
   directory access code first.  If the directory code allows the desired
   access, the monitor then checks the	access	code  of  the  individual
   file.

   The access actually granted to a file is specified when the user opens
   the	file  with  the OPENF call.  If the access specified in the OPENF
   call is the same as the access permitted by the  18-bit  access  code,
   the	user  is  granted  access  to  the  file.  Thus, for a user to be
   granted access to a specific file, two conditions must be met:

	1.  The access code (both directory and  file)	must  permit  the
	    user  to  access  the file in the desired manner (e.g., read,
	    write).

	2.  The file must not be open for a conflicting type of access.

   2.2.8  File Descriptor Block	    

   Each file has an associated File Descriptor Block (FDB).  The FDB  can
   be  read  with the GTFDB call, and selected words of this block can be
   changed with the CHFDB call.  The name strings of the author and  last
   user who wrote to the file can be read with the GFUST call and changed
   with the SFUST call.

   The format of the FDB is shown  in  Table  2-1.   Words  that  can  be
   changed  with  the  CHFDB  call  are  indicated  by the listing of the
   minimum capability (refer to Section 2.6.1)	required  to  change  the
   word.

				 Table 2-1
			File Descriptor Block (FDB)

     Word    Symbol		      Meaning

       0     .FBHDR	    FDB header word.  Individual fields are  as
 					follows:

 			    B0-B28	     Reserved for DEC

 			    B29-35(FB%LEN)   Length of this file's FDB

       1     .FBCTL	    B0(FB%TMP)	File is  temporary.   This  bit
					can be changed by owner.

			    B1(FB%PRM)	File is  permanent.   This  bit
					can be changed by owner.

			    B2(FB%NEX)	File does not have a file  type
					yet;	file  does  not  really
					exist.	 This  bit  cannot   be
					changed.

 			    B3(FB%DEL)	File is deleted.  This bit  can
 					be   changed   by   the   owner
 					providing that bit  FB%ARC  (in
 					.FBCTL) is not set.

			    B4(FB%NXF)	File does not exist because  it
					has  not yet been closed.  This
					bit cannot be changed.

			    B5(FB%LNG)	File is longer than 512  pages.
					This bit cannot be changed.

			    B6(FB%SHT)	Reserved for DEC.

			    B7(FB%DIR)	File is a directory.  This  bit
					cannot be changed.

			    B8(FB%NOD)	File is not to be saved by  the
					backup system.	This bit can be
					changed by owner or  user  with
					write access.

 			    B9(FB%BAT)	File may have one or  more  bad
 					pages.	This bit indicates that
 					I/O errors have occurred for  a
 					page  (or  pages) of a file and
 					the contents of these pages are
 					suspect.    This   bit	is  set
 					whenever the system has a  disk
 					I/O  error on a page of an open

 					file.  The faulty disk	address
 					is  also  added  to the list in
 					the  system's  BAT  blocks  for
 					that disk structure.

 					If an EXPUNGE is performed  for
 					a  file for which bit FB%BAT is
 					set,  the  system  performs  an
 					additional   function	as   it
 					releases the pages of the  file
 					back  to the available resource
 					pool:	it  checks  each   disk
 					address in the file against the
 					list  of  bad  regions	in  the
 					structure's  BAT  blocks and if
 					it finds  a  match,  it  leaves
 					that page marked as "in use" in
 					the bit map of	available  disk
 					pages,	so that the faulty page
 					is not reused.

			    B10(FB%SDR) Directory  has	subdirectories.
					This bit cannot be changed.

 			    B11(FB%ARC) File   has   archive	status.
 					Appropriate  words  in	the FDB
 					(below) specify where the  file
 					is   archived.	  This	bit  is
 					modified  by  the  ARCF   JSYS;
 					CHFDB cannot change it.

 			    B12(FB%INV) File is  invisible.   Puts  the
 					file in the "invisible" section
 					of the directory.  These  files
 					can  be  seen only by using the
 					G1%IIN option to GTJFN.  FB%INV
 					can  be modified with the CHFDB
 					JSYS  by  anyone  having  owner
 					access.

 			    B13(FB%OFF) File is offline.  This	is  set
 					by  DELF  when	it  removes the
 					contents from disk and	cleared
 					when ARCF restores the contents
 					to  disk.   FB%OFF  cannot   be
 					changed with the CHFDB JSYS.

			     Table 2-1 (Cont.)
			File Descriptor Block (FDB)

     Word    Symbol		      Meaning

       1     .FBCTL	    B14-B17	File  class field.  This  field
	     (Cont.)	    (FB%FCF)	can be changed	by  owner.   If

					value  of  field  is 0(.FBNRM),
					file is not an	RMS  file.   If
					value  of  field  is 1(.FBRMS),
					file is an RMS file.

       2     .FBEXL	    Link to FDB of next file with the same name
			    but  different file type.  This word cannot
			    be changed.

       3     .FBADR	    Disk address of  file  index  block.   This
			    word cannot be changed.

       4     .FBPRT	    File access code.
			    LH:  500000
			    RH:  file access bits.  This field	can  be
			    changed by owner.

       5     .FBCRE	    Date and time of last write  to  the  file.
			    Is	modified when any program writes to the
			    file.   This  word	can  be  changed  by  a
			    process with OPERATOR capability enabled.

       6     .FBAUT	    Pointer to string containing  the  name  of
			    the  author.   This  name  is read with the
			    GFUST monitor call and can be changed  with
			    the SFUST monitor call.

       7     .FBGEN	    Generation and directory numbers of file.
			    LH(FB%GEN):  generation number of the file.
			    RH(FB%DRN):  monitor   internal   directory
					 number of the file (only if B7
					 of .FBCTL is on).

			    This word cannot be changed.

      10     .FBACT	    Account information.  This word is either a
			    pointer    to   an	 alphanumeric	account
			    designator	 or    5B2 + numeric	account
			    designator.   This word can be changed with
			    the SACTF monitor call.

      11     .FBBYV	    File I/O information.
			    B0-B5(FB%RET)    Number of	generations  to
					     retain  (retention count).
					     If two generations of  the
					     same  file  have different
					     retention	 counts,    the
					     count  is	taken  from the
					     generation currently being
					     used.   This  field can be
					     changed by owner.

			     Table 2-1 (Cont.)
			File Descriptor Block (FDB)

     Word    Symbol		      Meaning

      11     .FBBYV	    B6-B11(FB%BSZ)   File  byte   size.    This
	     (Cont.)			     field can	be  changed  by
					     user with write access.

			    B14-B17(FB%MOD)  Data mode of last open  of
					     file.   This  field can be
					     changed by user with write
					     access.

			    B18-B35(FB%PGC)  Page count of file.   This
					     field  can be changed by a
					     process  with   WHEEL   or
					     OPERATOR	     capability
 					     enabled.	Note  that  the
 					     monitor   keeps  the  page
 					     count  updated,  so  under
 					     normal   curcumstances   a
 					     user need not  and  should
 					     not alter this count.

      12     .FBSIZ	    Number of bytes in	the  file.   (Refer  to
			    Section  2.2.11.)  This word can be changed
			    by user with write access.

      13     .FBCRV	    Date and time of creation  of  file.   This
			    word  can  be  changed  by	user with write
			    access.

      14     .FBWRT	    Date and time of last user write  to  file.
			    Is	modified  only	by the user.  This word
			    can be changed by user with write access.

      15     .FBREF	    Date and time of last  nonwrite  access  to
			    file.   This  word	can  be changed by user
			    with write access.

      16     .FBCNT	    Count word.
			    LH:  number of writes to file.
			    RH:  number of references to file.
			    This word can be changed by a process  with
 			    OPERATOR capability enabled.

      17-21  .FBBK0-
 	     .FBBK2	    Three words for backup system.   The  first
 			    word   is	used  by  the  DUMPER  program;
 			    remaining  words  are  reserved   for   the
 			    future.

      22     .FBBBT	    The right half contains the number of pages
 			    in	the file when the contents were deleted
 			    from disk and may be changed with the CHFDB
 			    JSYS.   The  left  half  is  used  for  the
 			    following flags:

 			    B1(AR%RAR)	     User request for a file to
 					     be   archived.   This  can
 					     only be  modified	by  the
 					     ARCF JSYS.

 			    B2(AR%RIV)	     System  request   for   an
 					     involuntary migration of a
 					     file.  The  ARCF  JSYS  is
 					     used  to  modify this bit,
 					     and the caller  must  have
 					     WHEEL	or     OPERATOR
 					     capabilities enabled.

 			    B3(AR%NDL)	     Do not delete the contents
 					     of the file from disk when
 					     the archival is  complete.
 					     Set by ARCF.

 			    B4(AR%NAR)	     Resist	    involuntary
 					     migration.   This bit is a
 					     note from the user to  the
 					     system    policy	 module
 					     asking that the  file  not
 					     be    moved   offline   if
 					     possible.	Set by ARCF.

 			    B5(AR%EXM)	     File   is	 exempt    from
 					     involuntary     migration.
 					     Modified only by ARCF with
 					     WHEEL	or     OPERATOR
 					     capabilities enabled.

 			    B6(AR%1ST)	     First    pass    of     an
 					     archival-collection run is
 					     in   progress.    Modified
 					     only  by  CHFDB  and  used
 					     only by DUMPER.   Requires
 					     WHEEL	or     OPERATOR
 					     capabilities enabled.

 			    B7(AR%RFL)	     Restore  failed.	Set  by
 					     ARCF    to   indicate   to
 					     another process  that  the
 					     restore  it is waiting for
 					     has failed.

 			    1B10(AR%WRN)     Generate a message warning
 					     that   the   file	offline
 					     expiration     date     is
 					     approaching.   This bit is
 					     currently	 reserved   and
 					     unimplemented.
 			    7B17(AR%RSN      Reason  file   was   moved
 					     offline:

 					     .AREXP(1) file expired

 					     .ARRAR(2)	archiving   was
 					     requested
 					     .ARRIR(3)	migration   was
 					     requested

 			    B18-B35(AR%PSZ)  The right half  of  .FBBBT
 					     is   used	 to  store  the
 					     number of pages in a  file
 					     when   the  contents  were
 					     removed from  disk.   This
 					     value  is	set by the DELF
 					     JSYS (DF%CNO  option)  and
 					     can  be read with CHFDB or
 					     ARCF.

      23     .FBNET	    On-line   expiration   date    and	  time.
			    Specifies the date and time at which a file
			    is	considered  expired,  or  specifies  an
			    interval  (in days) after which the file is
			    considered expired.  This word is  modified
			    by the SFTAD JSYS.

      24     .FBUSW	    User  settable  word.   This  word	can  be
			    changed by owner.

      25     .FBGNL	    Address of FDB for next generation of file.
			    This word cannot be changed.

			     Table 2-1 (Cont.)
			File Descriptor Block (FDB)

     Word    Symbol		      Meaning

      26     .FBNAM	    Pointer  to  filename  block.   This   word
			    cannot be changed.

      27     .FBEXT	    Pointer to	file  type  block.   This  word
			    cannot be changed.

      30     .FBLWR	    Pointer to string containing  the  name  of
			    the  user who last wrote to the file.  This
			    name is read with the  GFUST  monitor  call
			    and  can  be changed with the SFUST monitor
			    call.

      31     .FBTDT	    Archive of collection tape-write  date  and
 			    time.   This  is  the  date  and  time  (in
 			    internal format) that file was last written
 			    to	  tape	 (for	either	 archiving   or
 			    migration).

      32     .FBFET	    Offline   expiration   date    and	  time.
 			    Specifies  the  date and time (or interval)
 			    after which a file in the  archives  or  on

 			    virtual  disk  is considered expired.  Used
 			    for tape  recycling.   Modified  by  SFTAD.
 			    This  word	is  currently  reserved and not
 			    implemented.

      33     .FBTP1	    Contains the tape ID for the first	archive
 			    or	collection  run.  Modified only by ARCF
 			    with   WHEEL   or	OPERATOR   capabilities
 			    enabled.

      34     .FBSS1	    Contains the saveset and tape file	numbers
 			    for  the  first tape.  The left half is the
 			    saveset number the file is recorded in, and
 			    the  right	half  is  the  tape file number
 			    within that saveset.  Modified only by ARCF
 			    with   WHEEL   or	OPERATOR   capabilities
 			    enabled.

      35     .FBTP2	    Tape ID for second	archive  or  collection
 			    run.  Otherwise similar to .FBTP1.

      36     .FBSS2	    Saveset  and  tape	file  numbers  for  the
 			    second    archive	 or   collection   run.
 			    Otherwise similar to .FBSS1.

   The maximum length FDB block that TOPS-20 will create (37  octal)  may
   be specified with the symbol .FBLEN.

   2.2.9  Primary Input And Output Files	      

   Each process in a job has a primary input file and  a  primary  output
   file.   Both  files	are normally the controlling terminal, but can be
   changed to other files (with the SPJFN call).  The primary  input  and
   output  files  are  referenced  with  designators .PRIIN (JFN 100) and
   .PRIOU (JFN 101), respectively.  Programs should be coded to do  their
   "terminal"  I/O  to	these  designators, so that they can be used with
   command files without modification;	only in extreme  cases	should	a
   program reference its controlling terminal (0,,-1) directly.

   2.2.10  Methods Of Data Transfer	      

   The most simple form of I/O is sequential byte I/O, as  shown  in  the
   sample  program.  (Refer to Section 2.2.5.) This form of data transfer
   may be used with any file.  A pointer maintained  in  the  monitor  is
   implicitly  initialized  when a file is opened and advanced as data is
   transferred.  For files on disk, there are two other methods  of  data
   transfers.	First,	random	access	byte I/O is possible by using the
   SFPTR call or the RIN/ROUT calls.  Second, entire pages of data may be
   mapped with the PMAP call.

   2.2.11  File Byte Count	     

   For disk files, TOPS-20 maintains a file byte count	(.FBSIZ)  in  the
   FDB.   This	count is set by the monitor when sequential output (e.g.,
   BOUT, SOUT) occurs  to  the	file  and  thus,  on  sequential  output,
   reflects the number of bytes written in the file.

   When output occurs to the file using the PMAP call, the  monitor  does
   not set the file byte count.  In this case, the number of bytes in the
   file may be different from the file byte count stored in the FDB.   To
   allow  sequential  I/O  to occur later to the file, the program should
   update the file byte count (.FBSIZ) and the file byte size (FB%BSZ) in
   the	FDB  before  closing  the  file.  The values are updated with the
   CHFDB monitor call.

   When output occurs to the file using random output calls (e.g., ROUT),
   the	file  byte  count  is  a number one greater than the highest byte
   number in the file.

   The file byte count is interpreted according to the byte  size  stored
   in the FDB, not the byte size specified when the file is opened.  When
   a new file is opened, the byte size stored in  the  FDB  is	36  bits,
   regardless  of  the	byte  size  specified  in the OPENF call.  If the
   program executes a CHFDB call to change the file byte  count,  usually
   it must also change the byte size (FB%BSZ) so that both values reflect
   the same size bytes.

   2.2.12  EOF Limit	    

   There is an EOF limit associated with every opening of a  file.   This
   limit  is the number of bytes that can be read with a sequential input
   call (e.g., BIN, SIN).  When the program attempts to read beyond  this
   limit  using  sequential  input,  the  call	returns  a  0 byte and an
   end-of-file	condition.   This  condition  may  generate  a	 software
   interrupt (refer to Section 2.5) if the user has not included an ERJMP
   or ERCAL as the  next  instruction  following  the  call.   (Refer  to
   Chapter 1.)

   The EOF limit is computed when the file is opened with the OPENF call.
   The	monitor  computes  this  limit by determining the total number of
   words in the file and dividing this number by the byte size	given  in
   the	OPENF  call.  The total number of words in the file is determined
   from the file byte count (.FBSIZ) and  the  file  byte  size  (FB%BSZ)
   stored in the FDB.

   2.2.13  Input/Output Errors	    

   While performing I/O or I/O-related	operations,  it  is  possible  to
   encounter one or more error conditions.  Some of these are user-caused
   errors (e.g., illegal access attempts), and others are I/O  device  or
   medium  errors.   TOPS-20  indicates  such error conditions by setting
   error bits in the JFN status word (refer to the  GTSTS  call)  and  by

   initiating  a software interrupt request (refer to Section 2.5) if the
   user has not included an ERJMP  or  ERCAL  after  the  call.   If  the
   process  in	which  an I/O error occurs is not prepared to process the
   interrupt,  the  interrupt  is  changed  into  a  process  terminating
   condition  with  the  expectation that the process' immediate superior
   will handle the error condition.   The  TOPS-20  Command  Language  is
   prepared  to  detect and diagnose I/O errors;  thus, a process running
   directly beneath the process containing the Command Language need  not
   do  its  own  I/O  error  handling  unless  it chooses to do something
   special.

   I/O errors can occur while a process  is  executing	ordinary  machine
   instructions  as  well as JSYS's.  For example, if a PMAP operation is
   performed that maps a page of a file into a page  of  a  process,  the
   file I/O transfer usually does not actually occur until a reference is
   made by the process to that particular page of the file.  If there  is
   an  I/O  error  in  the  transfer,  it is detected at the time of this
   reference.

   An attempt to do I/O to a terminal that is assigned to another job (as
   a  controlling  terminal or with the ASND call) normally results in an
   error, but is legal if the process has the WHEEL capability enabled.

   The monitor calls used in referencing files are:

	GTJFN	  Assigns a JFN to a file
	GNJFN	  Assigns a JFN to the next file
	JFNS	  Translates a JFN to a string
	SPJFN	  Sets primary JFNs
	GPJFN	  Returns primary JFNs
	SWJFN	  Transposes two JFNs
	RLJFN	  Releases a JFN

	OPENF	  Opens a file
	CLOSF	  Closes a file
 	CLZFF	  Closes a process' files
 	WILD%	  Compares a wild file spec against a non-wild file spec

	PSOUT	  Outputs string to primary output designator
	PBIN	  Reads byte from primary input designator
	PBOUT	  Output byte to primary output designator
	BIN	  Reads the next byte
	BOUT	  Outputs the next byte
	SIN	  Reads a string
	SOUT	  Outputs a string
	SINR	  Reads a record
 	SOUTR	  Outputs a record
 	SINM	  Reads data from block-mode terminals
 	SOUTM	  Writes data to block-mode terminals
	RIN	  Reads a byte nonsequentially
	ROUT	  Outputs a byte nonsequentially
	DUMPI	  Reads data in unbuffered data mode
	DUMPO	  Outputs data in unbuffered data mode
	PMAP	  Maps pages

	RSCAN	  Reads and outputs rescan buffer
	RDTTY	  Reads data from primary input designator
	TEXTI	  Reads data from terminal or file

	CRLNM	  Creates a logical name
	INLNM	  Outputs logical names
	LNMST	  Translates logical name to string

	CHFDB	  Changes a File Descriptor Block
	GTFDB	  Reads a File Descriptor Block
	SFUST	  Changes the author or last writer name string
	GFUST	  Reads the author or last writer name string
	CHKAC	  Checks access to a file
	ACCES	  Specifies access to a directory
	DIRST	  Translates directory or user number to a string
	RCDIR	  Translates directory name to number
	RCUSR	  Translates user name to number

	SIZEF	  Obtains file's length
	SFBSZ	  Sets file's byte size
	RFBSZ	  Reads file's byte size
	SFPTR	  Sets file's pointer
	RFPTR	  Reads file's pointer
	BKJFN	  Backspaces file's pointer
	RNAMF	  Renames a file
	SFTAD	  Sets file's time and dates
	RFTAD	  Reads file's time and dates
	STSTS	  Sets file's status
	GTSTS	  Reads file's status
	UFPGS	  Updates file's pages

	DELF	  Deletes a file
	DELDF	  Expunges deleted files
	DELNF	  Retains specified number of generations of file

	FFFFP	  Finds first free file page
	FFUFD	  Finds first used file page

   2.3	OBTAINING INFORMATION	 

   The monitor calls in this group are used to	obtain	information  from
   the	system,  such  as  the time of day, resources used by the current
   job, error conditions, and the contents of system tables.

   Several  of	these  calls  return  time   values   (e.g.,   intervals,
   accumulated	times).   Unless  otherwise  specified,  these values are
   integer numbers in units of milliseconds.

   2.3.1  Error Mnemonics And Message Strings	      

   Each failure for a JSYS is associated with an error number identifying
   the	particular  failure.   These  error  numbers are indicated in the
   manual by mnemonics (e.g., DEVX1) and are listed with the  appropriate
   calls.   Some  calls  return  the error number in the right half of an
   accumulator, usually in AC1;  however, all calls leave the  number  in
   the Process Storage Block for the process in which the error occurred.
   Thus, a process can obtain (via the GETER call)  the  number  for  the
   last error that occurred.

   In addition to the mnemonic of six  characters  or  less,  each  error
   number  has a text message associated with it that describes the error
   in more detail.  These messages are listed along with  the  mnemonics.
   The	ERSTR  call  can  be used to return the message string associated
   with any given error number.  The use of this call is recommended  for
   handling error returns.

   Refer to Chapter 3 and  Appendix  A	for  the  listing  of  the  error
   numbers, mnemonics, and messages.

   2.3.2  System Tables	   

   The contents of several system tables are available	to  programs  for
   such  purposes  as  generating  status  reports  and collecting system
   performance statistics.  Each table is identified by a fixed  name  of
   up  to  six	characters  and consists of a variable number of entries.
   The -1 entry in each table is the  negative	of  the  number  of  data
   entries  in	the  table;   the data entries are identified by an index
   which increments from 0.

   Two calls exist for accessing tables.  The  first,  SYSGT,  accepts	a
   table  name	and returns the table length, its first data entry, and a
   number identifying the table.  The second, GETAB,  accepts  the  table
   number  returned by SYSGT or obtained from the MONSYM file and returns
   additional entries from the table.

   The system tables are as follows.  Numeric table indexes are given  in
   octal.

       Name	 Index		      Contents

       APRID			   Processor serial number

       BLDTD			   Date   and	time   system	 was
				   generated

       DBUGSW			   Debugging information

		 0		   state of operator coverage
				   0 = unattended
				   1 = attended
				   2 = debugging
		 1		   state of BUGCHK handling

				   0=proceed
				   1=breakpoint)

       DEVCHR			   Device characteristics  word,  as
				   described under the DVCHR JSYS in
				   Chapter 3, except that B5 (DV%AV)
				   is not meaningful.

       DEVNAM			   SIXBIT device name including unit
				   number, e.g., MTA3

       DEVUNT		      LH:  Job number  to  which  device  is
				   assigned  (with  ASND),  or -1 if
				   device is not assigned
			      RH:  unit number, or -1 if device  has
				   no units (e.g., DSK:)

       DRMERR			   Information on drum errors

		 0		   number of recoverable errors
		 1 to n 	   varies depending on type of	drum
				   being used

       DSKERR			   Information on disk errors

		 0		   number of recoverable disk errors
		 1 to n 	   varies depending on type of	disk
				   being used

       DWNTIM			   Downtime information

		 0		   date and time when system will be
				   shut down next
		 1		   date and time  when	system	will
				   subsequently be up

       HQLAV			   High queue load averages

       IMPLT1	  c		   ARPANET -  1  fullword  for	each
 				   link:

 			      LH:  internal connection number, index
 				   for:

 				   NETAWD
 				   NETBAL
 				   NETBTC
 				   NETBUF
 				   NETFSK
 				   NETLSK
 				   NETSTS

 				   or -1 if control link

 			      RH:  B18-19  00  receive
 					   01  send

 					   11  free
 					   01  delete
 				   B20-27  host number
 				   B28-35  link number

 					   c (index) is derived from
 					   bits 24-35 of NETAWD.

       IMPLT2	  c	      ARPANET - 1 fullword for each link:

 			      LH:  B0-9    flags
 				   B10-17  byte size of buffer
 			      RH:  address of input buffer

 				   c (index) is  derived  from	bits
 				   24-35 of NETAWD.

       IMPLT3	  c		   ARPANET -  1  fullword  for	each
 				   link:

 			      LH:  address of output buffer
 			      RH:  message saved for retransmission

 				   c (index) is  derived  from	bits
 				   24-35 of NETAWD.

       IMPLT4	  c		   ARPANET - 1 full  word  for	each
 				   link

 			      LH:  address of current buffer
 			      RH:  message allocation in bits

 				   c (index) is  derived  from	bits
 				   24-35 of NETAWD.

       IMPLT5	  c		   ARPANET - 1 full  word  for	each
 				   link:

 				   B4-11   Network number (ARPAnet =
 					   12 octal)
 				   B12-27  IMP
 				   B28-35  host

 					   c (index) is derived from
 					   bits 24-35 of NETAWD.

       JBONT			   Job	  #    Owning	 job	 for
				   CRJOB-created jobs.

       JOBNAM	  Job #       LH:  reserved for DEC
			      RH:  index  into	the  system  program
				   tables  for	the  system  program
				   being   used    by	 this	 job
				   (determined	by  the  last  SETSN
				   call executed by the job)

       JOBPNM	  Job # 	   SIXBIT name of program running in
				   this job

       JOBRT	  Job # 	   CPU	time   used   by   the	 job
				   (negative if no such job)

       JOBTTY	  Job #       LH:  controlling terminal line number,
				   or
				   -1  if   none   (i.e.,   job   is
				   detached)
			      RH:  reserved for DEC

       LOGDES			   Logging information

		  0		   designator	   for	     logging
				   information

		  1		   designator for job  0  and  error
				   information

       LQLAV			   Low queue load averages

       NETHST	  c		   ARPANET - 1 full  word  for	each
 				   internal connection:

 				   -1 if no foreign host,  otherwise
 					   the	same  as  IMPLT5.  c
 					   (index) is  derived	from
 					   bits 24-35 of NETAWD.

       NETAWD	  c		   ARPANET - 1 full  word  for	each
 				   internal connection:

 				   B0-8    link number
 				   B9-17   unused
 				   B18-23  timeout countdown
 				   B24-35  index to link tables

 				   c (index) is internal  connection
 				   (see IMPLT1).

       NETBAL	  c		   ARPANET   -	 number   of	bits
 				   allocated	to   each   internal
 				   connection

 				   c (index) is internal  connection
 				   (see IMPLT1).

       NETBTC	  c		   ARPANET - byte count  statistics:
 				   the	 number   of  bits  sent  or
 				   received   over   each   internal
 				   connection  since  the socket was
 				   created.

 				   c (index) is internal  connection
 				   (see IMPLT1).

       NETBUF	  c		   ARPANET -  1  fullword  for	each
 				   internal connection:
 			      LH:  bytes per buffer
 			      RH:  buffer location -1

 				   c (index) is internal  connection
 				   (see IMPLT1).

       NETFSK	  c		   ARPANET - foreign  socket  number
 				   (32	 bits)	 for  each  internal
 				   connection

 				   c (index) is internal  connection
 				   (see IMPLT1).

       NETLSK	  c		   ARPANET - local socket number for
 				   each internal connection

 				   c (index) is internal  connection
 				   (see IMPLT1).

       NETRDY			   ARPANET operational status table

 		  0		   0	   IMP down
 				   .GT.0   IMP going down
 				   -1	   IMP up
 		  1		   0 = network	 off,	 non-zero =
 				   network on
 		  2		   flags for NETSER (not for user)
 		  3		   time of last NCP cycle up
 		  4		   last IMP GOING DOWN message
 				   B0-15   reserved
 				   B16-17  0  panic
 					   1  scheduled hardware PM
 					   2  software reload
 					   3  emergency restart
 				   B18-21  number    of     5-minute
 					   intervals before IMP goes
 					   down
 				   B22-31  number    of     5-minute
 					   intervals   IMP  will  be
 					   down
 		  5		   time of last IMP ready drop
 		  6		   time of last IMP ready up
 		  7		   time of IMP GOING DOWN message

       NCPGS			   One-word table containing  number
				   of  pages of real (physical) user
				   core available in system.

       NSWPG			   Default swapping pages

       PTYPAR			   Pseudo-TTY parameter information

		  0	      LH:  number of PTYs in system
			      RH:  TTY number of first PTY

       QTIMES	  0 to n	   Accumulated runtime	of  jobs  on
				   the n scheduler queues

       SNAMES			   SIXBIT name of system program, or
				   0 if this entry is unused in this
				   and	 the   corresponding	four
				   tables.

       SNBLKS			   Number of samples in working  set
				   size integral

       SPFLTS			   Total number of  page  faults  of
				   system program

       SSIZE			   Time integral of working set size

       STIMES			   Total runtime of system program

       SYMTAB			   SIXBIT table names of  all  GETAB
				   tables

       SYSTAT			   Monitor statistics.	The  entries
				   in this table are as follows:

		 0		   time with no runnable jobs
		 1		   waiting  time  with	1  or	more
				   runnable  jobs  (waiting for page
				   swapping)
		 2		   time spent in scheduler
		 3		   time spent processing pager traps
		 4		   number of drum reads
		 5		   number of drum writes
		 6		   number of disk reads
		 7		   number of disk writes
		10		   number of terminal wakeups
		11		   number of terminal interrupts
		12		   time  integral   of	 number   of
				   processes in the balance set
		13		   time  integral   of	 number   of
				   runnable processes
		14		   exponential 1-minute  average  of
				   number of runnable processes
		15		   exponential 5-minute average  of
				   number  of  runnable processes
		16		   exponential 15-minute average  of
				   number of runnable processes
		17		   time  integral   of	 number   of
				   processes waiting for the disk
		20		   time  integral   of	 number   of
				   processes waiting for the drum
		21		   number    of    terminal    input
				   characters
		22		   number   of	  terminal    output
				   characters
		23		   number of system core  management
				   cycles

		24		   time spent doing postpurging
		25		   number  of  forced  balance	 set
				   process removals
		26		   time  integral   of	 number   of
				   processes in swap wait
		27		   scheduler overhead time (same  as
				   entry 2) in high precision units
		30		   idle time (same as  entry  0)  in
				   high precision units
		31		   lost time (same as  entry  1)  in
				   high precision units
		32		   user time

						 NOTE

				       This table is subject  to
				       change		(usually
				       additions)  as  measuring
				       routines are added to the
				       system.

       SYSVER			   An ASCIZ string  identifying  the
				   system name, version, and date.

       TICKPS			   One-word table containing  number
				   of clock ticks per second.

       TTYJOB	  line #      LH:  positive  job  number  for  which
				   this is the controlling terminal,
				   or
				   -1 for unassigned line, or
				   -2  for  line   currently   being
				   assigned,  or job number to which
				   this line is assigned.

			      RH:  -1 if no process is	waiting  for
				   input  from this terminal;  other
				   than  -1  if  some	process   is
				   waiting for input.

   The device tables DEVNAM, DEVCHR, and DEVUNT are parallel in that
   the same entry in each table pertains to the same device.

   The system program tables  SNAMES,  STIMES,	SPFLTS,  SSIZE,  and
   SNBLKS are parallel in that the same entry in each table pertains
   to the same system program.	The system program being  run  by  a
   specific  job  may  be  determined  from  SNAMES,  using an index
   obtained from table JOBNAM.

   The following monitor calls are used for obtaining information:

   GETER	  Returns the last error condition
   SETER	  Sets the last error condition

   ERSTR	  Translates an error number to a string
   ESOUT	  Returns an error string
   SYSGT	  Returns values for a system table
   GETAB	  Returns a word from a system table
   SETNM	  Sets the program's private name
   SETSN	  Sets the program's system and private names
   GETNM	  Returns the program name being used by the job
   SETJB	  Sets a job's parameters
   GETJI	  Returns job information for specified job
   GJINF	  Returns job information for current job
   STAD 	  Sets the system's date
   GTAD 	  Returns the system's date
   TIME 	  Returns the time since the system was restarted
   TIMER	  Sets the runtime limit of a job
   RUNTM	  Returns the runtime of a job or process
   HPTIM	  Returns the high-precision clock values
   GTDAL	  Returns the disk allocation of a directory
   GTRPI	  Returns the paging trap information
   GTRPW	  Returns the trap words

   2.4	COMMUNICATING WITH DEVICES	  

   The monitor calls in this group  are  used  to  communicate	with  the
   devices  on	the  system.   Some  of  these devices are line printers,
   magnetic tapes, terminals, and card readers.

   Many of the monitor calls in this group take a device designator as an
   argument.  This designator can be either

	LH: .DVDES(600000)+device type number
	RH: unit number for devices that have units, arbitrary code
	    for structures, or -1 for non-structure devices that do not
	    have units

   or

	LH: 0
	RH: .TTDES(400000)+terminal number, or .CTTRM(-1)  for
	    controlling terminal

   The	STDEV  monitor	call  is  used	to  convert  a	string	 to   its
   corresponding device designator.

   The various devices are:

	Name   Description		 Type  Units	  Symbol

 	ATS:   application terminal
 	       services device		 24		  .DVATS
 	CDP:   spooled card punch	 21	yes
 	PCDP:  physical card punch	 21	yes	  .DVCDP
 	CDR:   spooled card reader	 10	yes
 	PCDR:  physical card reader	 10	yes	  .DVCDR
 	DCN:   DECnet active

 	       component		 22		  .DVDCN
 	DSK:   disk structure		 0		  .DVDSK
 	FE:    front-end
 	       pseudo-device		 11		  .DVFE
 	LPT:   spooled line printer		yes
 	PLPT:  physical line printer	 7	yes	  .DVLPT
 	MTA:   magnetic tape		 2	yes	  .DVMTA
 	MT:    logical magnetic tape	 2	yes	  .DVMTA
 	NET:   ARPA network		 16		  .DVNET
 	NUL:   null device		 15		  .DVNUL
 	PTY:   pseudo-terminal		 13	yes	  .DVPTY
 	SRV:   DECnet passive
 	       component		 23		  .DVSRV
 	TTY:   terminal 		 12	yes	  .DVTTY

   The null device is an infinite sink for unwanted output and returns an
   EOF on input.

   Device-dependent status bits are defined for some devices.  These bits
   can be set or returned with the SDSTS or GDSTS call, respectively.

   When an assignable device is assigned (by the ASND call) or opened (by
   the OPENF call) by one job, other jobs cannot

	1.  Assign the device with ASND.

	2.  Execute an OPENF  call  for  the  device,  even  if  the  JFN
	    properly represents the device.

   Structures are not restricted to these  limitations;   more	than  one
   user   can	simultaneously	execute  the  OPENF  call  for	files  on
   structures.

   2.4.1  Physical Card Reader (PCDR:)	     

   The following device-dependent status bits are defined  for	the  card
   reader.   These  bits  can be obtained with the .MORST function of the
   MTOPR call.

   Bit	    Symbol		       Meaning

   0	    MO%COL	   Device is on line.

   10	    MO%FER	   Fatal hardware error.  This error generates an
			   interrupt  on software channel .ICDAE.  (Refer
			   to Section 2.5.1.)

   12	    MO%EOF	   Card reader is at end of file.

   13	    MO%IOP	   I/O in progress.

   14	    MO%SER	   Software error (e.g., interrupt character).

   15	    MO%HE	   Hardware  error.   This  error  generates   an

			   interrupt on software channel .ICDAE.

   Bit	    Symbol		       Meaning

   16	    MO%OL	   Device is off line.

   17	    MO%FNX	   Device is nonexistent.

   31	    MO%SFL	   Output stacker full.

   32	    MO%HEM	   Input hopper empty.

   33	    MO%SCK	   Stack check.

   34	    MO%PCK	   Pick check.

   35	    MO%RCK	   Read check.


   2.4.2  Spooled Card Reader (CDR:) 	     

   On most systems, the physical card reader devices (PCDR:  devices) are
   under  the  control	of  the  card reader spooler, SPRINT and thus the
   ordinary user cannot OPEN a PCDR:  device and must,	instead,  OPEN	a
   spooled card reader device (CDR:).

   When a GTJFN is performed on device CDR:, the  device  characteristics
   (returned  by  DEVCHR)  are the same as those for device PCDR:.  Thus,
   CDR:  devices have units, and a unit number may be specified  for  the
   GTJFN.    However,	when   the   OPENF   is   performed,  the  device
   characteristics become the same as device DSK:.  This is because  data
   read  from  device  CDR:   is  actually  read from a file in the spool
   directory <SPOOL>.  The file is spooled from the PCDR:  device to  the
   spool directory by SPRINT.

   Thus device CDR:  is effectively a disk device, and	no  monitor  call
   that  can be used to set the characteristics of a PCDR:  device can be
   used for a CDR:  device.  Both ASCII and image mode are supported  for
   CDR:  devices.

   2.4.3  Physical Card Punch (PCDP:) 	     

   The following device-dependent bits are defined for the  card  reader.
   These  functions can be obtained with the .MORST function of the MTOPR
   monitor call.

   Bit	    Symbol		       Meaning

   B10	    MO%FER	   Fatal error condition

   B12	    MO%EOF	   All pending output has been processed

   B13	    MO%IOP	   Output in progress

   B14	    MO%SER	   Software error has  occurred  (would  generate
 			   interrupt on an assignable channel)

   B15	    MO%HE	   Hardware error has  occurred  (would  generate
 			   interrupt on channel .ICDAE)

   B16	    MO%OL	   Card-punch is off-line.  This bit is set  when
 			   operator  intervention  is required (card jam,
 			   hopper empty, stacker full).

   B17	    MO%FNX	   Card punch doesn't exist

   B32	    MO%HEM	   Hopper is empty or stacker full

   B33	    MO%SCK	   Stacker is full or hopper is empty

   B34	    MO%PCK	   Pick check

   2.4.4  Spooled Card Punch (CDP:) 	     

   On most systems, the physical card punch devices (PCDP:  devices)  are
   under  the  control	of  the  card  punch spooler, SPROUT and thus the
   ordinary user cannot OPEN a PCDP:  device and must,	instead,  OPEN	a
   spooled card punch device (CDP:).

   When a GTJFN is performed on device CDP:, the  device  characteristics
   (returned  by  DEVCHR)  are the same as those for device PCDP:.  Thus,
   CDP:  devices have units, and a unit number may be specified  for  the
   GTJFN.    However,	when   the   OPENF   is   performed,  the  device
   characteristics become the same as device DSK:.  This is because  data
   written  to	device	CDP:   is actually written to a file in the spool
   directory <SPOOL>.  The file is then spooled from the spool	directory
   to the PCDR:  device by SPROUT.

   Thus device CDP:  is effectively a disk device, and	no  monitor  call
   that  can be used to set the characteristics of a PCDP:  device can be
   used for a CDP:  device.  Both ASCII and image mode are supported  for
   CDP:  devices.

   2.4.5  Physical Line Printer (PLPT:)	     

   The line printer normally accepts the 128 7-bit ASCII character  codes
   (0-177  octal).   However, by specifying a byte size of 8 when opening
   the printer, a program can transfer 8-bit bytes.   Thus,  the  program
   can take advantage of printers that have more than 128 characters.

   Each code sent usually causes a graphic to be printed.  (Note that  on
   a  64-character  printer,  lower case letters are represented as upper
   case.) However, the carriage control characters do not cause a graphic
   to  be printed;  instead they cause specific actions to be taken.  The

   actions taken are determined by the translation RAM and  the  Vertical
   Formatting  Unit.  These actions can be redefined by the installation,
   and the method by which they are redefined  depends	on  the  type  of
   printer being used.

   For	the  LP10  printer,  which  has  a  carriage  control  tape,  the
   installation must change the tape to redefine the resulting actions.

   For the LP05 and LP14 printers, which have a  direct  access  Vertical
   Formatting  Unit  and a programmable translation RAM, the installation
   can redefine the resulting actions by:

	1.  Reprogramming the VFU by  changing	the  VFU  file	with  the
	    MAKVFU program and reloading this file and the RAM.

	2.  Reprogramming the translation RAM by changing  the	RAM  file
	    with the MAKRAM program and reloading this file.

   Refer to the LPINI and MTOPR monitor calls for the functions  used  in
   loading the VFU and RAM files.

   The default actions taken on the carriage  control  characters,  along
   with  the  default  channels  that  determine  these  actions,  are as
   follows:

   ASCII Character  Default   Name		       Default
	Code	    Channel			       Action

	 11		      Tab	     No vertical  motion.   Skips
					     to  the  beginning  of every
					     8th column on the same line.

	 12	      8       Line feed      Skips to  column  1  on  the
					     next  line.   The	last  six
					     lines  of	each   page   are
					     skipped.

	 13	      7       Vertical tab   Skips to  column  1  on  the
					     line  at the next third of a
					     page.

	 14	      1       Form feed      Skips to column 1 on the top
					     of the next page.

	 15		      Carriage	     No vertical motion.  Returns
			      return	     to column 1 of  the  current
					     line  and	does  not advance
					     the paper.

	 20	      2       Half page      Skips to  column  1  on  the
					     next half page.

	 21	      3       Alternate      Skips  to	column	1 on  the
			      lines	     next even line.

	 22	      4       Three lines    Skips to  column  1  on  the

					     next of every third line.

	 23	      5       Next line      Skips to  column  1  on  the
					     next  line  without skipping
					     the  last	six  lines  on	a
					     page.

	 24	      6       Sixth page     Skips to  column  1  on  the
					     next sixth of a page.

   The association between the ASCII code and the channel  is  determined
   by  the  RAM.   The	association  between  the channel and the default
   action is determined by the VFU.   Therefore,  a  change  in  the  VFU
   changes  the  association  between  the  channel and the action, which
   causes the ASCII code to be associated with the new action.

   2.4.1.1  Status Bits - The following device-dependent status bits  are	     
   defined  for  the  line  printer.  These bits can be obtained with the
   .MORST function of the MTOPR call.

   Bit	       Symbol			    Meaning

    0	       MO%LCP		   Lower case printer

    10	       MO%FER		   Fatal  hardware  error.   This   error
				   generates  an  interrupt  on  software
				   channel  .ICDAE  (refer   to   Section
				   2.5.1).

    12	       MO%EOF		   All	data  sent  to	the  printer  has
				   actually been printed.

    13	       MO%IOP		   I/O in progress

    14	       MO%SER		   Software   error   (e.g.,	interrupt
				   character, page counter overflow)

    15	       MO%HE		   Hardware   error.	Forms	must   be
				   realigned.	This  error  generates an
				   interrupt on software channel .ICDAE.

    16	       MO%OL		   Device is off line

    17	       MO%FNX		   Device is nonexistent

    30	       MO%RPE		   RAM parity error

    31	       MO%LVU		   Optical VFU

    33	       MO%LVF		   VFU error

    34	       MO%LCI		   Character interrupt.   This	generates

				   an interrupt on channel .ICDAE.

    35	       MO%LPC		   Page counter register overflow

   2.4.6  Spooled Line Printer (LPT:) 	     

   On most systems, the physical line printer  devices	(PLPT:	 devices)
   are under the control of the line printer spooler, LPTSPL and thus the
   ordinary user cannot OPEN a PLPT:  device and must,	instead,  OPEN	a
   spooled line printer device (LPT:)

   When a GTJFN is performed on device LPT:, the  device  characteristics
   (returned  by  DEVCHR)  are the same as those for device PLPT:.  Thus,
   LPT:  devices have units, and a unit number may be specified  for  the
   GTJFN.    However,	when   the   OPENF   is   performed,  the  device
   characteristics become the same as device DSK:.  This is because  data
   written  to	device	LPT:   is actually written to a file in the spool
   directory <SPOOL>.  When device LPT:  is closed, the file  in  <SPOOL>
   is  closed  and  a  message	sent  to  the line printer spooler LPTSPL
   causing it to print the file on the line printer.

   Thus device LPT:  is effectively  a	disk  device,  and  none  of  the
   monitor  calls  that can be used to set the characteristics of a PLPT:
   device can be used for a LPT:  device.  Note that LPTSPL  only  writes
   7-bit  bytes, so opening an LPT:  device with any other byte size will
   cause erroneous results.  Also, only ASCII mode is supported for  LPT:
   devices.

   2.4.7  Physical Magnetic Tape (MTA:)	     

   The following device-dependent bits are defined for the magnetic tape.

   Bit	     Symbol		 Meaning

   18	     MT%ILW    Drive is write protected

   19	     MT%DVE    Device error (hung or data late)

   20	     MT%DAE    Data error

   21	     MT%SER    Suppress automatic error recovery procedures

   Bit	     Symbol		 Meaning

   22	     MT%EOF    Device EOF (file) mark

   23	     MT%IRL    Incorrect record length (not the  same  number  of
		       words  as specified by the read operation or not a
		       whole number of words)

   24	     MT%BOT    Beginning of tape

   25	     MT%EOT    End of tape

   26	     MT%EVP    Even parity

   29-31     MT%CCT    Character counter if MT%IRL is on.

   Data transfers to and from the magnetic tape can  be  performed  using
   either buffered or unbuffered I/O.

   2.4.7.1  Buffered  I/O - The  monitor  uses	buffered  I/O  when   the	      
   sequential  I/O calls (e.g., BIN/BOUT, SIN/SOUT) are used to read from
   or write to the magnetic tape.  When the tape is opened for sequential
   I/O (data mode 0 on the OPENF call), the monitor reserves buffer space
   large enough to hold two records of data.  The  maximum  size  of  the
   records  is	specified  with the SET TAPE RECORD-LENGTH command or the
   .MOSRS function of the MTOPR monitor call.  The  buffers  reserved  by
   the	monitor  allow the user's program to overlap computation with the
   transfer of data to and from the tape.

   The BIN monitor call is used to read one byte from the tape	with  the
   monitor  filling  one  buffer with data as the user program is reading
   bytes from the other buffer.  A program reading  data  from	the  tape
   with  successive BIN calls obtains a stream of bytes until a tape mark
   is read.  The SIN monitor call is used to read a specified  number  of
   bytes  with	the  monitor again performing the double buffering.  Both
   the BIN and the SIN calls read across record boundaries on  the  tape.
   The SINR monitor call is used to read variable-length records from the
   tape because each call returns one record to the user program.  If the
   record  on the tape contains more data than the SINR call request, the
   remaining bytes in the record are  discarded.   The	SINR  call  never
   reads  across  record  boundaries  on  the tape.  Thus, each SINR call
   begins reading at the first byte of the next record on the tape.  With
   all	three  calls, the specified record size must be at least as large
   as the largest record being read from the tape.

   The BOUT monitor call is used to  write  one  byte  on  the	tape.	A
   program  writing  data on the tape with successive BOUT calls writes a
   stream of bytes packed into records of the specified size.	The  SOUT
   monitor  call  is  used  to write a specified number of bytes into one
   record equal to the given record size.  The	SOUTR  call  is  used  to
   write  variable-length records on the tape because each call writes at
   least one record.  The size of the  record  is  equal  to  either  the
   number  of  bytes  specified  in the SOUTR call or the number of bytes
   specified in the maximum record size, whichever is  smaller.   If  the
   number  of  bytes  requested in the call is greater than the specified
   record size, then records  of  the  maximum	size  are  written,  plus
   another  record  containing	the  remaining bytes.  If the end of tape
   marker is reached during sequential mode output, the data  is  written
   and	an  error  return  is  given.	Bit MT%EOT (bit 25) in the device
   status word will be set to indicate this condition.

   When a CLOSF monitor call is executed for a	magnetic  tape	to  which

   buffered  output  is  being	done, any data remaining in the monitor's
   buffers will be written to the tape.   The  monitor	writes	two  tape
   marks  after  the  last  record written and backspaces over the second
   mark.  This allows a subsequent write operation to overwrite the  last
   tape  mark,	and  always leaves two tape marks (a logical end of tape)
   after the last record written.

   The monitor does not write records of less than four words long.  Thus
   if  the user requests less than four words to be written on a SOUTR or
   DUMPO (see below) call, the monitor will  write  a  four-word  record,
   completing  it  with  zeros.   On a SOUT call, if less than four words
   remain in the buffer at the time of the CLOSF call, the monitor  again
   fills the record with zeros.

   2.4.7.2  Unbuffered I/O - The DUMPI and DUMPO monitor calls	are  used	     
   to read from or write to the magnetic tape without using buffered I/O.
   (Unbuffered I/O is sometimes called dump mode.) Unbuffered I/O uses	a
   program-supplied command list to determine where to transfer data into
   or out of the program's address space.  The command list  can  contain
   three types of entries:

	1.  IOWD n, loc transfers n words from loc through loc+n-1.   The
	    next  command  is  obtained  from  the location following the
	    IOWD.  Each IOWD word reads or  writes  a  separate  magnetic
	    tape record.

	2.  XWD 0, y takes the next command from location y.

	3.  0 terminates the command list.

   Refer to the DUMPI call description for more information.

   On input, a new record is read for each  IOWD  entry  in  the  command
   list.   If  the  IOWD  request  does  not equal the actual size of the
   record on the tape, an error (IOX5) is returned.   The  GDSTS  monitor
   call  can  then  be	executed  to  examine  the status bits set and to
   determine the number of words transferred.  In  addition,  if  a  tape
   mark is read, an error (IOX4) is returned.  On output, a new record is
   written for each IOWD entry in the command list.

   There are two modes available in unbuffered I/O.  In the normal  mode,
   the	monitor  waits for the data transfer to complete before returning
   control to the program.  In the  no-wait  mode,  the  monitor  returns
   control  immediately  after	queueing  the  first transfer so that the
   program can set up the second transfer.  The monitor  then  waits  for
   the	first  transfer  to  complete before queueing the second.  If the
   first transfer is successful, the second one is started,  and  control
   is  returned to the program.  If the first transfer is not successful,
   an error is returned in AC1, and the second one is not  started.   The
   desired  mode  is specified by bit DM%NWT in AC1 on the DUMPI or DUMPO
   call.

   2.4.7.3  Magnetic Tape Status - The status word of a magnetic tape can	      
   be  obtained  with  the  GDSTS  call  or individual status bits can be
   obtained with the MTOPR call.  The GDSTS call waits for  all  activity
   to  stop  during  sequential  mode  output,	dump  mode,  and  spacing
   operations before obtaining the status.  A GDSTS call executed  during
   sequential mode input returns the status of the current record.

   Reading from or writing to a magnetic tape cannot be done if there are
   any	errors	set  in  the  device  status word.  The program can clear
   errors with the SDSTS call or the .MOCLE function of the MTOPR call.

   2.4.7.4  Reading A Tape in the  Reverse  Direction - With  the  .MOSDR	            
   function  of the MTOPR call, the program can cause the tape to move in
   the reverse direction (toward the beginning of the tape)  during  read
   operations.	 The  data  in	each  record  are returned in the forward
   order, but the records themselves are returned in the  reverse  order.
   The	sensing-foil  marking  the beginning of tape is treated as an EOF
   tape mark.

   When the SIN call is used to read data in the reverse direction, it is
   recommended	that  the  number  of bytes requested by the call and the
   record size be equal to the size of the  record  on	the  tape.   This
   returns  the  bytes	in  the  entire  record in the correct order, but
   returns the records in reverse order.  If the request does  not  equal
   the	sizes,	the bytes returned will be out of phase with the bytes in
   the actual record.

   When the SINR call is used to read data in the reverse direction,  the
   number  of  bytes requested by the call should be at least as large as
   the size of the record on  the  tape.   If  the  requested  number  is
   smaller  than the actual record, the remaining bytes in the record are
   discarded from the beginning of the record and not from the end of the
   record.

   2.4.7.5  Hardware Data Modes - By using the	.MOSDM	function  of  the	      
   MTOPR  call,  the  program  can  set  the  mode  for storing data on a
   magnetic tape.  The	following  descriptions  indicate  how	bits  are
   stored  in  the  tracks  and  the number of frames required to store a
   36-bit word of data.  Note that the diagrams demonstrate how  data  is
   transmited  to  or  from  the  tape	controller.   Data  will  not  be
   physically stored on the tape in the format shown in the diagrams.

   Unbuffered (Dump) Mode

   This mode stores a word of data as a 36-bit byte in five frames  of	a
   9-track tape.  Note that the fifth frame is partially used.	This mode
   is normally the default mode.

			    TRACKS			    FRAMES

       9     8	   7	 6     5     4	   3	 2     1

      B0    B1	  B2	B3    B4    B5	  B6	B7     P      1
      B8    B9	 B10   B11   B12   B13	 B14   B15     P      2
     B16   B17	 B18   B19   B20   B21	 B22   B23     P      3
     B24   B25	 B26   B27   B28   B29	 B30   B31     P      4
       0     0	   0	 0   B32   B33	 B34   B35     P      5

   Industry Compatible Mode

   This mode stores a word of data as four 8-bit bytes in four frames  of
   a  9-track  tape.  On a read operation, four frames of 8-bit bytes are
   read, left-justified, into a word.  The remaining  four  bits  of  the
   word  are  0  or  are  copies  of  the  parity  bits, depending on the
   hardware;  these bits  are  not  data.   On	a  write  operation,  the
   leftmost  four  8-bit  bytes (i.e., bits 0 through 31) of the word are
   written in four frames on the tape.	The rightmost  four  bits  (i.e.,
   bits 32 through 35) of the word are ignored and are not written on the
   tape.  This mode is compatible with any machine that reads and  writes
   8-bit bytes.

			    TRACKS			    FRAMES

       9     8	   7	 6     5     4	   3	 2     1

      B0    B1	  B2	B3    B4    B5	  B6	B7     P      1
      B8    B9	 B10   B11   B12   B13	 B14   B15     P      2
     B16   B17	 B18   B19   B20   B21	 B22   B23     P      3
     B24   B25	 B26   B27   B28   B29	 B30   B31     P      4

   ANSI ASCII Mode

   This mode stores a word of data as five 7-bit bytes in five frames  of
   a  9-track  tape.  On a read operation, five frames of 7-bit bytes are
   read, left-justified, into a word.  The remaining bits  (bits  35)  of
   each  frame	are  ORed together, and the result is placed in bit 35 of
   the word.  On a write operation, the leftmost five 7-bit bytes of  the
   word  are written in five frames on the tape.  Bit 35 of the word must
   be zero to  conform	to  ANSI  standards.   It  is  written	into  the
   high-order  bit  of the fifth frame, and the remaining high-order bits
   of the first four frames are 0.  This mode is useful when transferring
   ASCII data from the TOPS-20 to machines that read 8-bit bytes.

			    TRACKS			    FRAMES

       9     8	   7	 6     5     4	   3	 2     1

       0    B0	  B1	B2    B3    B4	  B5	B6     P      1
       0    B7	  B8	B9   B10   B11	 B12   B13     P      2
       0   B14	 B15   B16   B17   B18	 B19   B20     P      3
       0   B21	 B22   B23   B24   B25	 B26   B27     P      4
     B35   B28	 B29   B30   B31   B32	 B33   B34     P      5

   SIXBIT Mode

   This mode stores a word of data as six 6-bit bytes in six frames of	a
   7-track  tape.   This  mode	is  the  only supported hardware mode for
   7-track tapes.

			TRACKS			FRAMES

       7     6	   5	 4     3     2	   1

      B0    B1	  B2	B3    B4    B5	   P	  1
      B6    B7	  B8	B9   B10   B11	   P	  2
     B12   B13	 B14   B15   B16   B17	   P	  3
     B18   B19	 B20   B21   B22   B23	   P	  4
     B24   B25	 B26   B27   B28   B29	   P	  5
     B30   B31	 B32   B33   B34   B35	   P	  6

   High Density Mode

   In this mode, two 36-bit words are stored in 9 frames.   High  density
   mode is available on any 9-track drive connected to a DX20 controller.

 			    TRACKS			    FRAMES

       9     8	   7	 6     5     4	   3	 2     1

      B0    B1	  B2	B3    B4    B5	  B6	B7     P      1
      B8    B9	 B10   B11   B12   B13	 B14   B15     P      2
     B16   B17	 B18   B19   B20   B21	 B22   B23     P      3
     B24   B25	 B26   B27   B28   B29	 B30   B31     P      4
     B32   B33	 B34   B35    B0    B1	  B2	B3     P      5
      B4    B5	  B6	B7    B8    B9	 B10   B11     P      6
     B12   B13	 B14   B15   B16   B17	 B18   B19     P      7
     B20   B21	 B22   B23   B24   B25	 B26   B27     P      8
     B28   B29	 B30   B31   B32   B33	 B34   B35     P      9

     2.4.8  Logical Magnetic Tape (MT:)	       

     Logical magnetic tape devices are used so that the  system  operator
     can fulfill a MOUNT request with any available tape drive that meets
     the requirements of the MOUNT request.  The  user	never  knows  and
     need  not	know which physical drive (MTA:) is mapped to the logical
     drive (MT:).  Some JSYS functions available for  MTA:   devices  are
     not available for MT:  devices.  Also, MT:  devices will commonly be
     used in a tape-labeled environment and this environment  will  cause
     further  restrictions  in	the  JSYS  functions  available  for  MT:
     devices.  See the appropriate JSYS's for any restrictions	that  may
     apply.

     2.4.9  Terminal (TTY:)	     

     Most monitor calls in this group  return  an  error  if  the  device
     referenced  is  assigned  to  another  job.  However, a process with
     WHEEL capability  enabled	can  reference	a  terminal  assigned  to
     another  job  (as	controlling  terminal or with ASND).  The monitor
     calls  pertaining	to  terminals	have   no   effect,   or   return
     default-value information, when used with other devices.

     2.4.9.1  JFN Mode Word - Each terminal in TOPS-20 is associated with	        
     a	mode word.  This word can be read with the RFMOD call and changed
     with the SFMOD and STPAR calls.  The SFMOD  call  affects	only  the
     modes that are logically program related (i.e., wakeup control, echo
     mode, and terminal data mode).  The STPAR call affects  fields  that
     describe  device  parameters (i.e., mechanical characteristics, page
     length and width, case conversion, and  duplex  control).	 Thus,	a
     program	can    execute	  a    SFMOD   call   without	affecting
     previously-established device modes.

     The format of the JFN word is shown below.

   Bit	   Symbol  Changed by	     Function

   0	   TT%OSP     SFMOD	output suppress control (1=ignore output;
				0=allow output)
   1	   TT%MFF     STPAR	has mechanical form feed
   2	   TT%TAB     STPAR	has mechanical tab
   3	   TT%LCA     STPAR	has lower case
   4-10    TT%LEN     STPAR	page length
   11-17   TT%WID     STPAR	page width
   18-23   TT%WAK     SFMOD	wakeup control on:
				B18: not used
 	   TT%IGN		B19: ignore the other TT%WAK bits
	   TT%WKF		B20: formatting control character
	   TT%WKN		B21: non-formatting control character
	   TT%WKP		B22: punctuation character
	   TT%WKA		B23: alphanumeric character
   24	   TT%ECO     SFMOD	echos on
   25	   TT%ECM     STPAR	echo mode
   26	   TT%ALK     TLINK	accept links
   27	   TT%AAD     TLINK	accept advice
   28-29   TT%DAM     SFMOD	terminal data mode
	   .TTBIN		00:  no translation
	   .TTASC		01:  translate both echo and output
	   .TTATO		10:  translate output only
	   .TTATE		11:  translate echo only
   30	   TT%UOC     STPAR	upper case output control
				0:   do not indicate
				1:   indicate by 'X
   31	   TT%LIC     STPAR	lower case input control
				0:   no conversion
				1:   convert lower to upper
   32-33   TT%DUM     STPAR	duplex mode
	   .TTFDX		00:  Full duplex

	   .TTHDX		10:  Character half duplex
	   .TTLDX		11:  Line half duplex
				01:  Reserved for DEC
   34	   TT%PGM     STPAR	output	 page	mode   (1=display   mode,
				0=hardcopy mode)
   35	   TT%CAR     system	carrier state;	on if line is  a  dataset
				and the carrier is on.

   Bit 0 (TT%OSP) implements the CTRL/O function.  If this  bit  is  set,
   all	program  output  directed to the terminal is discarded.  When the
   bit is off, program output is buffered and sent as usual.  The current
   contents  of  the  output buffer are not cleared when this bit is set;
   clearing the buffer must be done explicitly (via the  CFOBF	call)  if
   output is to be stopped immediately.

   Bits 1, 2, and 3 (TT%MFF, TT%TAB, and TT%LCA) define  several  of  the
   mechanical  capabilities of the terminal and affect character handling
   on both input and output.  Form feeds and tabs are  simulated  if  the
   terminal  does  not	have  the  required  mechanical  capability or if
   simulation has been requested by the SFCOC call.

   Bits 4-10 (TT%LEN) determine the number of  line  feeds  necessary  to
   simulate  a	formfeed  or  the  number  of lines to fit on the display
   screen.   A	0  value  means  the  declared	length	of  the  page  is
   indefinitely large.

   Bits 11-17 (TT%WID) determine the point at which the output line  must
   be  continued  on  the  next  line by inserting a carriage return-line
   feed.  If 0, no line folding occurs.

   Bits 18-23 (TT%WAK) define the particular class  of	characters  that,
   when  input	from the terminal, will wake up a waiting program.  Refer
   to Section 2.4.3.3 for the definitions of the  wakeup  classes.   Note
   that  the  class-wakeup  scheme  is	maintained for compatibility with
   older programs.  Newer programs should use the .MOSBM function of  the
   MTOPR JSYS as it has more resolution and causes less overhead.

   Bit 24 (TT%ECO) defines if echos are to be given.  If this bit is off,
   echoing is turned off.  This is useful when the program is accepting a
   password or is simulating non-standard echoing procedures.

   Bit 25 (TT%ECM) defines when the echo will occur.  If this bit is off,
   the	echo  will  occur when the program reads the character.  That is,
   the echo occurs immediately if the program is waiting for input or  is
   deferred  if  the  program  is  not	waiting  for  input.  This is the
   standard echo mode and produces a correctly-ordered typescript  (i.e.,
   program  input and output appear in the order in which they occurred).
   If this bit is on, the echo occurs as soon as the character is  typed.
   Note  that  this  mode may cause editing to appear out of order on the
   typescript.	This occurs because editing is performed as  the  program
   reads the character and not necessarily when the echo occurs.

   Bits 28-29 (TT%DAM) define the terminal data mode.  The four  possible
   data modes are:

	00   Binary (.TTBIN), 8-bit input and output.  There is no format

	     control or control group translation and no echoing.

	01   ASCII (.TTASC), 7-bit input and output, plus parity  on  for
	     control  group  output.   There is format control as well as
	     simulation and translation of control group for input (echo)
	     and output according to the control words given on the SFCOC
	     JSYS.  This is the usual terminal data mode.

	10   Disable the translation of  echo  (.TTATO).   In  all  other
	     respects, same as .TTASC.

	11   Disable the translation of output (.TTATE).   In  all  other
	     respects, same as .TTASC.

   The last two data modes allow the  user  to	selectively  disable  the
   translation	 of   control  characters  for	input  or  output.   When
   translation	is  disabled,  control	characters   are   always   sent.
   Simulation  of  formatting  control	characters  is still performed if
   requested by  the control  words  of the RFCOC or SFCOC JSYS or if the
   device   does  not  have  the  required  mechanical	capability.   The
   translation	typically  results  in	some  control  characters   being
   indicated  by  graphics  instead  of  being	sent as is.  For example,
   disabling the translation of output characters is appropriate for some
   display  terminals  when  the  program  must send untranslated control
   characters to control the  display,	but  requires  that  the  control
   characters typed by the user be indicated in the usual way.

   Bit 30 (TT%UOC) specifies that upper case terminal  output  is  to  be
   indicated  by 'X (single quote preceding character that is upper case)
   on terminals that are not capable of lower case output.

   Bit 31 (TT%LIC) specifies that lower case  terminal	input  is  to  be
   translated  to  upper  case	and  that  codes  175  and  176 are to be
   converted to code 33.

   Bits 32-33 (TT%DUM) define the three duplex modes presently available.
   Full  duplex  (.TTFDX) requires the system to generate the appropriate
   echo for each character typed  in.	Character  half  duplex  (.TTHDX)
   assumes  the  terminal  will  internally echo each character typed but
   will require an additional echo  for  formatting  characters  such  as
   carriage  return.   Line  half duplex (.TTLDX) is similar to character
   half duplex but does not generate a line feed echo  after  a  carriage
   return.

   Bit 34 (TT%PGM) specifies the output mode.  In display mode, the  user
   can	create	a  pause in the output while he reads material that would
   otherwise quickly disappear off the screen.	 The  output  is  stopped
   with  the  CTRL/S  character  and  started  with the CTRL/Q character.
   Also, output automatically  stops  whenever	a  page,  as  defined  by
   TT%LEN, has been output;  output is resumed with CTRL/Q.

   Bit 35 (TT%CAR) indicates  the  carrier  state.   If  the  line  is	a
   dataset,  this  bit	is on if the carrier is on.  If the line is not a
   dataset, this bit is undefined.

   2.4.9.2  Control Character  Output  Control - Each  terminal  has  two	         
   control  character output control (CCOC) words.  Each word consists of
   2-bit bytes, one byte for each of the control characters (ASCII  codes
   0-37).  The bytes are interpreted as follows:

	00:  ignore (send nothing)
	01:  indicate by ^X (where X is the character)
	10:  send actual code
	11:  simulate format action

   The specific byte for each character is given  in  the  character  set
   table  in Section 2.4.3.3.  The CCOC words can be read and manipulated
   with the RFCOC and SFCOC monitor calls.

   2.4.9.3  Character  Set - The  following  information  describes  each	      
   character  in  the  TOPS-20	character  set	that  is pertinent to the
   monitor calls in this group.  The wakeup class  (refer  to  TT%WAK  in
   Section 2.4.3.1) is abbreviated as follows:

	F  formatting control character
	C  non-formatting control character
	P  punctuation character
	A  alphanumeric character

   Refer to Section 2.4.3.2 for the explanation of the control	character
   output control (CCOC) words.

   ASCII    Wakeup   CCOC	  Character or Control Character
   Code     Class    Word(bits)

      0       C      1(B0,1)	  CTRL/@   null,break
      1       C      1(B2,3)	  CTRL/A
      2       C      1(B4,5)	  CTRL/B
      3       C      1(B6,7)	  CTRL/C
      4       C      1(B8,9)	  CTRL/D
      5       C      1(B10,11)	  CTRL/E
      6       C      1(B12,13)	  CTRL/F
      7       C      1(B14,15)	  CTRL/G   bell
     10       F      1(B16,17)	  CTRL/H   backspace
     11       P      1(B18,19)	  CTRL/I   horizontal tab
     12       F      1(B20,21)	  CTRL/J   line feed
     13       C      1(B22,23)	  CTRL/K   vertical tab
     14       F      1(B24,25)	  CTRL/L   form feed
     15       F      1(B26,27)	  CTRL/M   carriage return
     16       C      1(B28,29)	  CTRL/N
     17       C      1(B30,31)	  CTRL/O
     20       C      1(B32,33)	  CTRL/P
     21       C      1(B34,35)	  CTRL/Q
     22       C      2(B0,1)	  CTRL/R
     23       C      2(B2,3)	  CTRL/S
     24       C      2(B4,5)	  CTRL/T
     25       C      2(B6,7)	  CTRL/U
     26       C      2(B8,9)	  CTRL/V
     27       C      2(B10,11)	  CTRL/W

     30       C      2(B12,13)	  CTRL/X
     31       C      2(B14,15)	  CTRL/Y
     32       C      2(B16,17)	  CTRL/Z
     33       all    2(B18,19)	  escape (altmode)
     34       C      2(B20,21)	  FS	   CTRL/backslash
     35       C      2(B22,23)	  GS	   CTRL/right square bracket
     36       C      2(B24,25)	  RS	   CTRL/uparrow
     37       F      2(B26,27)	  US	   CTRL/backarrow
     40       P 		  space
     41       P 		  !
     42       P 		  "
     43       P 		  #
     44       P 		  $
     45       P 		  %
     46       P 		  &
     47       P 		  '
     50       P 		  (
     51       P 		  )
     52       P 		  *
     53       P 		  +
     54       P 		  ,
     55       P 		  -
     56       P 		  .
     57       P 		  /
     60-71    A 		  0-9
     72       P 		  :
     73       P 		  ;
     74       P 		  <
     75       P 		  =

   ASCII    Wakeup   CCOC	  Character or Control Character
   Code     Class    Word(bits)

     76       P 		  >
     77       P 		  ?
    100       P 		  @
    101-132   A 		  upper case letters A-Z
    133       P 		  [
    134       P 		  \
    135       P 		  ]
    136       P 		  ^
    137       P 		  
    140       P 		  accent (grave)
    141-172   A 		  lower case letters a-z
    173(1)    P 		  left brace
    174(1)    P 		  vertical bar
    175(1)    P 		  right brace
    176(1)    P 		  tilde
    177       all		  delete (rubout)

				    NOTE

		  ESC(33) and DELETE(177)  are	considered
		  to be in all wakeup classes.

   1. If the terminal has B31(TT%LIC) on in the JFN mode word, codes  175
   and 176 are converted to code 33 on input.

 				    NOTE

 		  The class-wakeup  scheme  is	maintained
 		  for  compatibility  with older programs.
 		  New  programs  should  use  the   .MOSBM
 		  function  of	the  MTOPR  JSYS as it has
 		  more	resolution  (it  allows  a  4-word
 		  character  mask  to  specify	individual
 		  wakeup  characters)  and   causes   less
 		  overhead (low-level monitor I/O routines
 		  are subjected to fewer  wakeups).   Both
 		  SFMOD  and  .MOSBM  set  the	same mask;
 		  however SFMOD  computes  wakeup  classes
 		  from	 the   mask   while   .MOSBM  uses
 		  character-oriented wakeups.

   2.4.9.4  Terminal  Characteristics  Control - The  various  types   of	        
   terminals   have  different	characteristics  for  output  processing,
   depending on their type and speed.  The characteristics  that  can  be
   associated with terminals are:

	1.  mechanical form feed and tab

	2.  lower case

	3.  padding after carriage return

	4.  padding after line feed

	5.  padding after mechanical tab

	6.  padding after mechanical form feed

	7.  page width and length

   Instead of setting each of these parameters for his line, the user can
   specify   a	 terminal  type  number,  which  causes  the  appropriate
   parameters to be set.  Refer to the STTYP monitor call.   The  defined
   terminal types, along with their characteristics, are listed below.

   Number     Terminal	 Symbol 	  Characteristics

      0    TTY model 33  .TT33	  no mechanical form feed or tab,
				  has upper case only,
				  no padding after carriage return
				  and line feed,
				  padding after tab and form feed,

				  page width 72, page length 66

      1    TTY model 35  .TT35	  has mechanical form feed and tab,
				  has upper case only,
				  no padding after carriage return
				  and line feed,
				  padding after tab and form feed,
				  page width 72, page length 66

      2    TTY model 37  .TT37	  no mechanical form feed or tab,
				  lower case,
				  no padding after carriage return
				  and line feed,
				  padding after tab and form feed,
				  page width 72, page length 66

      3    TI/EXECUPORT  .TTEXE   no mechanical form feed or tab,
				  lower case,
				  padding after carriage return only
				  page width 80, page length 66

      4-7			  reserved for customer

      10   Default	 .TTDEF   no mechanical form feed or tab,
				  lower case,
				  full padding,
				  page width 72, page length 66

      11   Ideal	 .TTIDL   has mechanical form feed and tab,
				  lower case,
				  no padding,
				  no specified width and length

      12   VT05 	 .TTV05   no mechanical form feed,
				  has mechanical tab,
				  has upper case only,
				  no padding after carriage return
				  and tab,
				  padding after line feed and form feed,
				  page width 72, page length 20

      13   VT50 	 .TTV50   no mechanical form feed or tab,
				  has upper case only,
				  no padding,
				  page width 80, page length 12

      14   LA30 	 .TTL30   no mechanical form feed or tab,
				  has upper case only,
				  full padding,
				  page width 80, page length 66

      15   GT40 	 .TTG40   no mechanical form feed or tab,
				  lower case,
				  no padding,
				  page width 80, page length 30

   Number     Terminal	 Symbol 	  Characteristics

      16   LA36 	 .TTL36   no mechanical form feed or tab,
				  lower case,
				  no padding,
				  page width 132, page length 66

      17   VT52 	 .TTV52   no mechanical form feed,
				  has mechanical tab,
				  lower case,
				  no padding,
				  page width 80, page length 24

      20   VT100	 .TT100   no mechanical form feed,
 				  has mechanical tab,
 				  lower case,
 				  no padding,
 				  page width 80, page length 24

      21   LA38 	 .TTL38   no mechanical form feed,
 				  has mechanical tab,
 				  lower case,
 				  no padding,
 				  page width 132, page length 66

      22   LA120	 .TT100   has mechanical form feed and tab,
 				  lower case,
 				  no padding,
 				  page width 132, page length 60

   The STTYP monitor call sets the terminal type number for a  line,  and
   the GTTYP monitor call obtains the terminal type number.

   2.4.9.5  Terminal Linking - It is possible to link the output  of  any	     
   line to up to four other lines.  The refuse/accept link bit TT%ALK(bit
   26) in the JFN mode word controls terminal linking.	If the bit is off
   for	a  particular  terminal,  users  cannot  link  to  that terminal.
   Although this bit can be read with the RFMOD monitor call, the bit can
   only be set with the TLINK call.

   Refer to the TLINK monitor call for a description of terminal linking.

   2.4.9.6  Terminal Advising - It is possible to receive advice from any	     
   terminal line in the system.  The refuse/accept advice bit TT%AAD (bit
   27) in the JFN mode word controls terminal advising.  If this  bit  is
   off	for  a	particular terminal, users cannot simulate typing on that
   terminal via the STI monitor call.  Although this bit can be read with
   the RFMOD monitor call, it can only be set with the TLINK call.

   Refer to  the  TLINK  monitor  call	for  a	description  of  terminal
   advising.

   The following monitor calls are used when communicating with devices:

	ASND	  Assigns a device
	RELD	  Releases a device
	SPOOL	  Defines and initializes input spooling
	LPINI	  Loads VFU or translation RAM
	DVCHR	  Returns device characteristics
	GDSTS	  Returns the device status
	SDSTS	  Sets the device status
	GDSKC	  Returns disk usage
	MSTR	  Performs structure-dependent functions
 	MTOPR	  Performs device-dependent functions
 	MTU%	  Performs functions for logical tape devices
 		  (MT: devices)
	STDEV	  Translates a string to a device designator
	DEVST	  Translates a device designator to a string
	GTTYP	  Returns terminal type number
	STTYP	  Sets terminal type number
	ATACH	  Attaches controlling terminal to a job
	DTACH	  Detaches controlling terminal from a job
	TLINK	  Controls terminal linking
	RFMOD	  Returns the JFN mode word
	SFMOD	  Sets program-related fields in the JFN mode word
	STPAR	  Sets device-related fields in the JFN mode word
	RFPOS	  Returns current position of the terminal
	SFPOS	  Sets current position of the terminal
	RFCOC	  Returns control character output control words
	SFCOC	  Sets control character output control words
	CFIBF	  Clears terminal's input buffer
	CFOBF	  Clears terminal's output buffer
	SIBE	  Skips if input buffer is empty
	SOBE	  Skips if output buffer is empty
	SOBF	  Skips if output buffer is full
	DIBE	  Dismisses until terminal input buffer is empty
	DOBE	  Dismisses until terminal output buffer is empty

   2.5	SOFTWARE DATA MODES	  

   I/O may be performed in one of several modes, depending on the device.
   (The mode is specified with the OPENF call.) The range of possible I/O
   modes is from 0 to 17 (octal).  However, except  for  ARPANET  devices
   and	less common hardware devices (such as paper-tape punches/readers)
   the only meaningful modes are 0, 10, and 17.

   The following discussion lists the major devices supported by  TOPS-20
   and the applicable I/O modes:

   DEVICE    MODE   SYMBOL   EXPLANATION

   ATS			     No  mode  can  be	specified.   This  device
 			     allows  a	single multiplexed JFN to service
 			     multi-drop block mode  terminals.	 Requires
 			     DECnet and ATS software.

   PCDP:
   CDP:      0	     .GSNRM  Normal mode  -  allows  unit-record  output.
 			     For  card	punches,  this mode converts each
 			     7-bit   ASCII   character	 to   a    12-bit
 			     card-column   code   (Hollerith   code)  and
 			     outputs that code to the device.

 	     10      .GSIMG  Image mode - sends an "image"  (rather  than
 			     converting   to  Hollerith)  of  each  byte.
 			     These are 12-bit bytes and are assumed to be
 			     in  Hollerith code.  If the device is opened
 			     with a byte size smaller than 12-bits,  each
 			     byte sent is zero-padded on the left to form
 			     a 12-bit byte.

   PCDR:

   CDR:      0	     .GSNRM  Normal mode - allows unit-record input.  For
 			     card readers, this mode converts each 12-bit
 			     card-column code (Hollerith code) to a 7-bit
 			     ASCII   character	 and  returns  the  ASCII
 			     character(s) to the program.

 	     10      .GSIMG  Image mode - returns an "image" (rather than
 			     converting to ASCII) of the 12-bit card-code
 			     for  each	character  read.   In  order   to
 			     receive  the  full 12 bits, the program must
 			     use 12-bit bytes.

 			     Augmented image mode  -  this  is	a  16-bit
 			     version  of image mode.  The leftmost 4 bits
 			     are returned by the card reader  controller.
 			     The  first bit indicates that the column has
 			     a Hollerith error (and thus the card  should
 			     be  rejected).   The  next  3 bits contain a
 			     value ranging from 0 to 7.  If the value  is
 			     from  1  to  7,  it  indicates  that a punch
 			     occurred in that row.  If the value is 0, it
 			     indicates	that no punch occurred in columns
 			     1 - 7.  Effectively, a zero value	indicates
 			     that  a  non-ASCII  character  was  punched.
 			     This mechanism allows  conversion	to  ASCII
 			     using  a  table  with  only  256  entries as
 			     opposed to a table  with  4096  entries  for
 			     12-bit  characters.   This mode is available
 			     on  PCDR:	 devices  only	and  is  used  by
 			     specifying   mode	 .GSIMG   with	a  16-bit
 			     bytesize.

   DCN:      0	     .GSNRM  Normal mode - allows byte I/O.  This  device
 			     may  be  opened  with  7, 8 or 36-bit bytes.
 			     However, all  transfers  are  actually  done
 			     with  8-bit  bytes,  and  opening the device
 			     with  an  8-bit  bytesize	will   give   the
 			     greatest	 efficiency.	Requires   DECnet
 			     software.

   DSK:      0	     .GSNRM  Normal mode - allows buffered byte,  string,
 			     and  paged  I/O  in  1  to 36-bit bytes.  By
 			     definition, a DSK:  device may be opened  in
 			     any I/O mode, however the effect is the same
 			     as mode 0.

   PLPT:
   LPT:      0	     .GSNRM  Normal  mode  -  allows  buffered	byte  and
 			     string output.

   PTY:      0	     .GSNRM  Normal mode -  for  a  PTY,  the  "mode"  is
 			     merely  used  to  open  the device.  The PTY
 			     will receive data according to the I/O  mode
 			     of the TTY associated with it.

   MTA:
   MT:	     0	     .GSNRM  Normal  mode  -  allows  buffered	byte  and
 			     string  I/O.   This  is  the most common I/O
 			     mode.

 	     17      .GSDMP  Dump mode	-  this  mode  is  unbuffered  by
 			     default	(it    can    be   set	 up   for
 			     double-buffering) and  is	usually  used  to
 			     transfer blocks of data from tape to disk or
 			     disk to tape.  For tape,  a  dump-mode  read
 			     (performed  by DUMPI JSYS) performs reads on
 			     the basis of physical records.  If less than
 			     a	physical  record  is  read,  the  data is
 			     transfered and  an  error	is  returned.	A
 			     subsequent  DUMPI	will position the tape at
 			     the start of the next physical record.

   NET: 		     Allows buffered  or  non-buffered	byte  and
 			     string ARPANET I/O in 8, 32, or 36-bit bytes
 			     as follows:

 	     0		     Non-buffered send mode with wait.	Waits for
 			     state   of   connection  to  be  other  than
 			     "request for  connection  sent"  before  the
 			     OPENF returns.  Data is transmitted on every
 			     JSYS.

 	     5		     Buffered send mode  with  wait.   Waits  for
 			     state   of   connection  to  be  other  than
 			     "request for  connection  sent"  before  the
 			     OPENF  returns.   Data is sent a buffer-load
 			     (8000 bits)  at  a  time.	 The  concept  of
 			     buffering does not apply to input.

 	     6		     Non-buffered send mode with no wait.   Waits
 			     for  state  of  connection  to be other than
 			     "request for connection sent" before the I/O
 			     JSYS returns.

 	     7		     Buffered send mode with no wait.  Waits  for
 			     state   of   connection  to  be  other  than

 			     "request for connection sent" before the I/O
 			     JSYS  returns.   Data  is sent a buffer-load
 			     (8000 bits)  at  a  time.	 The  concept  of
 			     buffering does not apply to input.

   NUL:      0	     .GSNRM  Normal mode
 	     10      .GSIMG  Image mode
 	     17      .GSDMP  Dump mode

 			     The NUL device is a pseudo  device  used  to
 			     "throw away" unwanted output from a program.
 			     The device may be opened in any mode.

   SRV:      0	     .GSNRM  Normal mode - allows byte I/O.  This  device
 			     may  be  opened  with 7, 8, or 36-bit bytes.
 			     However, all  transfers  are  actually  done
 			     with  8-bit  bytes,  and  opening the device
 			     with  an  8-bit  bytesize	will   give   the
 			     greatest	 efficiency.	Requires   DECnet
 			     software.

   TTY:      0	     .GSNRM  Normal  mode  -  allows  buffered	byte  and
 			     string  I/O.   In	this mode, format control
 			     and simulation and  translation  of  control
 			     characters  are performed by the monitor for
 			     input (echo) and  output.	 (These  services
 			     can be turned off by setting the appropriate
 			     bit in the JFN mode word.)  Using	an  8-bit
 			     bytesize in this mode implicitly changes the
 			     mode to .GSIMG (see below).

 	     10      .GSIMG  Image mode - allows buffered byte and string
 			     I/O,   but   disables   format  control  and
 			     simulation  and   translation   of   control
 			     characters.   On  input, if the byte size is
 			     8-bits, a parity bit (odd) is returned  with
 			     the  character.   The  parity  bit is on the
 			     left  of  the  8-bit   byte.    On   output,
 			     attempting  to  send  an 8-bit byte that has
 			     incorrect parity may cause a  device  error.
 			     However,	most   terminals  will	ignore	a
 			     user-supplied parity bit.

 			     This mode can cause significant reduction in
 			     system  overhead  for doing TTY output.  The
 			     reduction is small, however, for TTY  input.
 			     This  is because the average process outputs
 			     many more characters  than  it  inputs  (the
 			     average ratio is approximately 20 characters
 			     output for each character input).

   2.6	SOFTWARE INTERRUPT SYSTEM	  

   The monitor calls in this group are used for controlling the  software
   interrupt  system.	Note  that  if	the program has an ERJMP or ERCAL
   after a monitor call that normally causes an interrupt on failure, the
   ERJMP  or ERCAL overrides the interrupt.  Refer to the TOPS-20 Monitor
   Calls User's Guide for an overview and  description	of  the  software
   interrupt system.

   2.6.1  Software Interrupt Channels	    

   Each interrupt  is  associated  with  one  of  36  software	interrupt
   channels below.  The user program can assign channels 0-5 and 23-35 to
   various conditions, such  as  terminal  interrupts,	IPCF  interrupts,
   ENQ/DEQ  interrupts,  PTY  conditions,  and	terminal buffers becoming
   empty.  The remaining channels are  permanently  assigned  to  certain
   error  conditions.	Any  channel  may  be  used for program-initiated
   interrupts (IIC call).

   Channel   Symbol		  Meaning

   0-5			    Assignable by user program

   6	     .ICAOV	    Arithmetic overflow (includes NODIV)

   7	     .ICFOV	    Arithmetic floating point overflow	(includes
			     FXU)

   8			    Reserved for DEC

   9	     .ICPOV	    Pushdown list (PDL) overflow(1)

   10	     .ICEOF	    End of file condition

   11	     .ICDAE	    Data error file condition(1)

   12	     .ICQTA	    Disk full or quota exceeded when  creating	a
			    new page (1)

   13-14		    Reserved for DEC

   15	     .ICILI	    Illegal instruction(1)

   16	     .ICIRD	    Illegal memory read(1)

   17	     .ICIWR	    Illegal memory write(1)

   18			    Reserved for DEC

   19	     .ICIFT	    Inferior process termination or forced freeze

   20	     .ICMSE	    System resources exhausted(1)

   21			    Reserved for DEC

   22	     .ICNXP	    Reference to non-existent page

   23-35		    Assignable by user program

   ----------

   1.  These  channels	are  panic  channels  and  cannot  be  completely
   deactivated.  (Refer to Section 2.5.5.)

   2.6.2  Software Interrupt Priority Levels	     

   Each channel is  assigned  to  one  of  three  priority  levels.   The
   priority  levels  are  numerically referenced as level 1, 2, or 3 with
   level 1 being the highest level interrupt.  Level 0	is  not  a  legal
   priority level.  If an interrupt request occurs in a process where the
   level associated with the channel  is  0,  the  system  considers  the
   process  not  prepared  to  handle the interrupt.  The process is then
   frozen or terminated according to the setting of SC%FRZ  (bit  17)  in
   its capabilities word.  (Refer to Section 2.6.1.)

   2.6.3  Software Interrupt Tables	    

   Before using the software interrupt system, a process must set up  the
   following two tables and declare their addresses with the SIR call.

   LEVTAB

	A 3-word table, indexed by priority level minus 1.  The left half
	of  each  word is not used.  The right half of each word contains
	the address in the process' address space in which to  store  the
	PC  at	the  time  of  the interrupt and flags for the associated
	priority level.

   CHNTAB

	A 36-word table, indexed by channel number.   The  left  half  of
	each  word  contains  the  priority  level  (1, 2, or 3) for that
	channel.  The right half contains the address  of  the	interrupt
	routine that will handle interrupts on that channel.

   2.6.4  Terminating Conditions	   

   If an interrupt is received on a channel which is activated,  but  the
   interrupt cannot be initiated because

	1.  the interrupt system for the  process  is  not  enabled  (EIR
	    JSYS)  and	the  channel on which the interrupt occurred is a
	    panic channel,

	2.  the table addresses have not been defined (SIR call),

	3.  no priority level has been assigned  to  the  channel  (i.e.,
	    left half of channel's word in CHNTAB is 0), or

	4.  the channel has  been  "reserved"  by  the	superior  process
	    (refer to the SIRCM call description),

   then the interrupt is considered a process termination condition.   In
   this  case  the  process  that  was	to have received the interrupt is
   halted or frozen according to the setting of SC%FRZ (bit  17)  in  its
   capabilities  word, and a process termination interrupt is sent to its
   superior.  The superior process can then execute  the  RFSTS  call  to
   determine the status of the inferior process.

   2.6.5  Panic Channels	   

   Panic  channels  (refer  to	Section  2.5.1)  cannot   be   completely
   deactivated	by  disabling the channel or the entire interrupt system.
   A software interrupt  received  on  a  panic  channel  that	has  been
   deactivated	will  be  considered  a  process  terminating  condition.
   However, panic channels will respond normally to  the  channel  on/off
   and read channel mask monitor calls.

   2.6.6  Terminal Interrupts	   

   There are 36 (decimal) codes used to specify  terminal  characters  or
   conditions on which interrupts can be initiated.  A process can assign
   a  character  or  condition	to  any  one  of  the  program-assignable
   interrupt  channels	with  the  ATI call.  Once the particular code is
   assigned to	a  channel  and  the  channel  is  activated  (via  AIC),
   occurrence  of  the	character  or condition corresponding to the code
   causes an interrupt to be generated.  The terminal codes,  along  with
   their associated conditions, are shown in the table below.

   Terminal	  Symbol       Character or Condition
   Code

      0 	  .TICBK	  CTRL/@ or break
      1 	  .TICCA	  CTRL/A
      2 	  .TICCB	  CTRL/B
      3 	  .TICCC	  CTRL/C
      4 	  .TICCD	  CTRL/D
      5 	  .TICCE	  CTRL/E
      6 	  .TICCF	  CTRL/F
      7 	  .TICCG	  CTRL/G
      8 	  .TICCH	  CTRL/H
      9 	  .TICCI	  CTRL/I (tab)
      10	  .TICCJ	  CTRL/J (line feed)
      11	  .TICCK	  CTRL/K (vertical tab)
      12	  .TICCL	  CTRL/L (form feed)

      13	  .TICCM	  CTRL/M (carriage return)
      14	  .TICCN	  CTRL/N
      15	  .TICCO	  CTRL/O
      16	  .TICCP	  CTRL/P
      17	  .TICCQ	  CTRL/Q
      18	  .TICCR	  CTRL/R
      19	  .TICCS	  CTRL/S
      20	  .TICCT	  CTRL/T
      21	  .TICCU	  CTRL/U
      22	  .TICCV	  CTRL/V
      23	  .TICCW	  CTRL/W
      24	  .TICCX	  CTRL/X
      25	  .TICCY	  CTRL/Y
      26	  .TICCZ	  CTRL/Z
      27	  .TICES	  escape (altmode)
      28	  .TICRB	  delete (rubout)
      29	  .TICSP	  space
      30	  .TICRF	  dataset carrier off
      31	  .TICTI	  typein
      32	  .TICTO	  typeout
      33-35			  reserved for DEC

   The terminal code .TICRF (30) is used to generate  an  interrupt  when
   the	dataset  carrier  state  changes  from	on  to off.  Although any
   process can enable for this interrupt, only the top-level  process  in
   the	job  is  guaranteed to receive it when the carrier state changes.
   If other processes enable for the  interrupt,  they	can  receive  the
   interrupt  either  when the carrier state changes to off or later when
   the job is reattached after	the  detach  caused  by  the  carrier-off
   condition.	In  general,  the occurrence of the change in the dataset
   carrier state is usable only by the top-level process.

   The terminal codes .TICTI (31) and .TICTO (32) are  used  to  generate
   interrupts	on  receipt  of  any  character  instead  of  a  specific
   character.  The .TICTI code generates an interrupt when the terminal's
   input buffer becomes nonempty (i.e., when a character is typed and the
   buffer was empty before the input of the character).  The .TICTO  code
   generates  an  interrupt  when  the	terminal's  output buffer becomes
   nonempty.  Note that neither one of these codes generates an interrupt
   if  the buffer is not empty when the character is placed into it.  The
   SIBE and SOBE calls can be used to determine if the buffers are empty.

   The frozen or unfrozen state (refer to Section 2.6.2.1) of  a  process
   determines  if  the	interrupt  is  initiated  immediately.	 Terminal
   interrupts are effectively deactivated when a process is frozen,  even
   though the interrupts are indicated in the process' terminal interrupt
   word (obtained with the RTIW JSYS).	When the process is unfrozen, the
   terminal interrupts are automatically reactivated.

   When an operation is completed that explicitly  changes  the  terminal
   interrupt  word  for  the  job  (e.g.,  a  process  freeze or unfreeze
   operation), the interrupt word for the job (and for the terminal  line
   if  the  job  is attached) is set to the inclusive OR (IOR) of all the
   unfrozen processes  in  the	job.   When  an  interrupt  character  is
   received,  frozen  processes  are  not considered when searching for a
   process to interrupt.

   The user cannot directly access the actual  terminal  interrupt  word.
   However,  by  specifying  a process identifier of -5 as an argument to
   the RTIW or STIW JSYS's, he can read or change the terminal	interrupt
   enable  mask.  The function of this mask is to allow processes to turn
   off interrupt codes activated by superior  processes.   Normally,  the
   mask  is -1, thereby enabling all terminal interrupts to be activated.
   A zero in any position of the mask prevents the corresponding terminal
   interrupt  from  being active.  However, the fact that a code has been
   activated will be remembered, and the code will be activated when  the
   mask  is  changed with a one in the corresponding position.	Note that
   the process must have SC%CTC enabled in its capabilities  word  (refer
   to Section 2.6.1) to activate the terminal code for CTRL/C interrupts.

   The SCTTY monitor call can be used to change the  source  of  terminal
   interrupts  for  a  process.   Note	that the process must have SC%SCT
   enabled in its capabilities word (refer to Section  2.6.1)  to  change
   the source of terminal interrupts.

   2.6.6.1  Terminal Interrupt Modes - TOPS-20 handles the receipt  of	a	      
   terminal  interrupt	character  in  either  immediate mode or deferred
   mode.  An interrupt character handled in  immediate	mode  causes  the
   initiation of a software interrupt immediately upon its receipt by the
   system (i.e., as soon as the user types it).  An  interrupt	character
   handled in deferred mode is placed in the input stream and initiates a
   software interrupt only when the program attempts to read it from  the
   input  buffer.   In	either	case,  the character is not passed to the
   program.  If two occurrences of the same deferred interrupt	character
   are	received  without any intervening character, the interrupt has an
   immediate effect.  To detect this situation, the  system  maintains	a
   separate  one-character  buffer  in case the input buffer is otherwise
   full.   The	system	assumes  that  interrupts  are	to   be   handled
   immediately	unless	the  process  has declared them deferred with the
   STIW monitor call.

   The purpose of deferred mode is to allow interrupt actions to occur in
   sequence  with  other  actions  in  the  input  stream.  However, with
   multiple processes, the deferred interrupt occurs when any process  of
   the	job  reads  the  interrupt character.  If this process is the one
   enabled for the interrupt, it will  be  interrupted	before	any  more
   characters	are  passed  to  the  program.	 If  the  process  to  be
   interrupted is the top process, then the interrupt occurs before  more
   characters  are  passed to the program, unless another process is also
   reading from the same source  (usually  an  abnormal  condition).   If
   neither  of	the  above  situations	applies,  then	the process doing
   terminal input continues to run and	may  receive  several  characters
   before  the	interrupt can take effect.  This is unavoidable since the
   process doing input and the process to be  interrupted  are	logically
   running in parallel.

   2.6.7  Dismissing An Interrupt	    

   Once the processing of an interrupt is complete, the user's	interrupt
   routine returns control to the interrupted process via the DEBRK call.
   When the DEBRK call is executed, the monitor examines the contents  of
   the	return	PC word to determine where to resume the process.  If the
   PC word has not been changed, the process is  restored  to  its  state
   prior  to  the  interrupt.	For example, if the process was dismissed
   waiting for I/O to complete,  it  is  restored  to  that  state  after
   execution  of  the  DEBRK  call.  If the PC word has been changed, the
   process resumes execution at the new PC location.

   The	process  can  determine  if  an  interrupt  occurred  during  the
   execution of monitor code or user code by examining the user/exec mode
   bit (bit 5) of the return PC word.  If the bit is on, the process  was
   executing  user  code;   if	the bit is off, the process was executing
   monitor code (i.e., a JSYS).  If the  interrupt  routine  changes  the
   return  PC during the processing of an interrupt, the user-mode bit of
   the new PC word must be on.	Note that the process  may  be	executing
   monitor  code  but that the address portion of the PC is referencing a
   location in user code.  To return to that user code location (i.e., to
   interrupt  the  execution of a monitor call), the process must turn on
   the user-mode bit.

   The monitor calls for controlling the software interrupt system are:

	SIR	  Sets the interrupt table addresses
	RIR	  Reads the interrupt table addresses
	EIR	  Enables the interrupt system
	DIR	  Disables the interrupt system
	CIS	  Clears the interrupt system
	SKPIR	  Skips if the interrupt system is enabled
	AIC	  Activates interrupt channels
	IIC	  Initiates interrupts on specific channels in a process
	DIC	  Deactivates interrupt channels
	RCM	  Reads activated channel word mask
	RWM	  Reads waiting channel word mask
	SIRCM	  Sets inferior reserved channel mask
	RIRCM	  Reads inferior reserved channel mask
	DEBRK	  Dismisses current interrupt
	ATI	  Assigns terminal code to channel
	DTI	  Deassigns terminal code
	STIW	  Sets terminal interrupt word
	RTIW	  Reads terminal interrupt word
	GTRPW	  Returns trap words
	SCTTY	  Changes source of terminal interrupts

   2.7	PROCESS CAPABILITIES	 

   The TOPS-20 system allows capabilities, such as the ability to examine
   the	monitor  and  to  enable  for  CTRL/C  interrupts, to be given to
   certain  processes.	 Each  capability  is  separately  protected  and
   activated.	The capabilities are assigned on a per-process basis, and
   their status is kept in the process' PSB.  The number of  capabilities

   is  limited	to  36,  and two words are used to store the status.  For
   each capability, there is a bit in the first word which is set if  the
   capability  is  available to the process.  If the corresponding bit in
   the other word is also set, the capability is currently enabled.  This
   allows  the	user  to  protect  himself against accidental use without
   actually giving up the capability.

   Inferior processes are created by superior processes  (via  the  CFORK
   monitor  call) with either no special capabilities or the capabilities
   of the creating process.  Most capabilities relate to system functions
   and	may  be  passed  from  superior  to  inferior process only if the
   superior itself has the  capability.   Some	capabilities  relate  the
   inferior  to  the  superior	process  and  may be given to an inferior
   whether or not available in the superior.

   2.7.1  Assigned Capabilities	   

   Bit	Symbol		    Meaning

		 B0-8 Job Capabilities

   0	SC%CTC	 Process can enable for CTRL/C software interrupts.

   1	SC%GTB	 Process can examine monitor tables with the GETAB call.

   2	SC%MMN	 Process can map the running monitor.

   3	SC%LOG	 Process can execute protected log functions.

   4	SC%MPP	 Process can map privileged pages of files.

   5	SC%SDV	 Process can use special devices.

   6	SC%SCT	 Process can change source  of	terminal  interrupts  for
		 other processes.

		 B9-17 Capabilities that can  be  given  to  an  inferior
		 whether  or not the superior itself has them.	Of these,
		 SC%FRZ (B17) cannot be changed by a process for itself.

   9	SC%SUP	 Process can manipulate its superior process.

   17	SC%FRZ	 Unprocessed software interrupts can cause the process to
		 be frozen instead of terminated.

		 B18-35 User capabilities

   18	SC%WHL	 User has wheel privileges.

   19	SC%OPR	 User has operator privileges.

   20	SC%CNF	 User has confidential information access.

   21	SC%MNT	 User has maintenance privileges.

   Bit	Symbol		    Meaning

   22	SC%IPC	 User has IPCF privileges.

   23	SC%ENQ	 User has ENQ/DEQ privileges.

   24	SC%NWZ	 User has ARPANET wizard privileges.

   25	SC%NAS	 User has absolute ARPANET socket privileges.

   The capabilities are originally  established  when  the  directory  is
   created.  (Refer to CRDIR monitor call.)

   The	capability  word  can  be  read  with  the  RPCAP  monitor  call.
   Capabilities can be enabled with the EPCAP monitor call.

   2.7.2  Access Control 	   

   It is often necessary for an installation to have further control over
   system  resources  than  that  offered by the process capability word.
   The	following  JSYS's  allow  each	installation  to  write  its  own
   access-control program:

 	1.  GETOK%

 	2.  GIVOK%

 	3.  RCVOK%

 	4.  SMON

 	5.  TMON

   The access control facility works as follows:

 	1.  The installation writes its own access-control program.  This
 	    program  uses  the	SMON  JSYS  (privileged) to (1) enable or
 	    disable access checking for a variety of system resources and
 	    (2)  allow	or disallow access by default for those resources
 	    that  are  not  explicitly	checked  by  the   access-control
 	    program.

 	2.  The  access-control  program  is  started	by   TOPS-20   at
 	    system-startup  time.   After  the	program  has  initialized
 	    itself, it	issues	an  RCVOK%  JSYS  (privileged).   As  the
 	    request  queue  will  be  empty  at  system-startup time, the
 	    RCVOK% JSYS causes the access-approval program to go  into	a
 	    sleep state.

 	3.  A user program or a monitor operation issues a  GETOK%  JSYS,
 	    causing  an access request block to be appended to the GETOK%
 	    request queue (maintained by the monitor).	The user  program
 	    or monitor operation blocks.

 	4.  The monitor wakes  up  the	access-control	program  and  the
 	    blocked  RCVOK%  JSYS  completes  execution,  retrieving  the
 	    access request block from the  GETOK%  request  queue.   This
 	    block contains information supplied by the user, plus certain
 	    job parameters.

 	5.  The access-control program determines  whether  to	allow  or
 	    deny the request and issues the GIVOK% JSYS (privileged) with
 	    the   appropriate	response   for	 this	 request.     The
 	    access-control  program now issues another RCVOK% JSYS, which
 	    blocks  or	completes,  depending  on  whether  or	not   any
 	    additional requests are in the queue.

 	6.  The user program or monitor operation  unblocks  and  gets	a
 	    normal  return  from  the original GETOK% JSYS if the request
 	    has been granted, or receives an error return if the  request
 	    has been denied.

   Note that internal JSYS's performed by the access-control  program  or
   job 0 will not invoke access control.

   Also, note that after a system has been brought up, the first fork  to
   execute an RCVOK% JSYS defines itself as the access-control fork.  Any
   other fork that subsequently tries to issue an RCVOK% JSYS,	A  GIVOK%
   JSYS,  or  an  SMON	JSYS  with function .SFSOK will receive an error.
   Thus it is important that only the access-control fork be  allowed  to
   execute the first RCVOK% JSYS after system startup.

   If the access-job  fails,  the  system  reverts  to	whatever  default
   protection  has been specified.  Failure of the access-control program
   does not open up a "security hole".

   2.7.3  Processes And Scheduling	    

   These monitor calls	deal  with  establishing  and  interrogating  the
   process structure of a job.	Refer to the TOPS-20 Monitor Calls User's
   Guide for an overview and description of the process structure.

   2.7.4.1  Process Freezing - A superior process can cause one or all of	     
   its	inferior  processes  to be frozen.  A frozen process is one whose
   execution is suspended (as soon as it is stoppable from  the  system's
   point  of view) in such a way that it can be continued at the point it
   was suspended.  A process can be frozen  directly  or  indirectly.	A
   process is directly frozen when its superior makes an explicit request
   to freeze it.  A process is indirectly frozen  when	its  superior  is
   frozen.   When  a  process  is  directly  frozen,  all of its inferior

   processes are indirectly frozen.  Therefore, a  process  can  be  both
   directly  frozen  by its superior process and indirectly frozen if its
   superior process is subsequently frozen.

   The explicit unfreezing of a process clears both its direct freeze and
   the	indirect  freeze on all its inferior processes unless an inferior
   process has a direct freeze.  The indirect  unfreezing  of  a  process
   clears  only  the freeze on that process.  This means that an explicit
   freeze of a process prevents  the  running  of  any	of  its  inferior
   processes,  and  an	explicit  unfreezing  of  a process automatically
   resumes its inferiors.

   The FFORK and RFORK monitor calls are  used	to  freeze  and  unfreeze
   processes,  respectively.   An  argument of -4 to these calls directly
   freezes  or	resumes  all  immediately  inferior  processes,  and  any
   processes below the immediately inferior ones are indirectly frozen or
   resumed.  (The freeze and unfreeze operations are never legal  on  any
   process that is not inferior to the one executing the monitor call.)

   The frozen or  unfrozen  state  of  a  process  can	only  be  changed
   directly.   Thus,  monitor  calls  like  SFORK  and HFORK change other
   states of a process but do  not  affect  the  frozen  state.   If  the
   process  is	frozen	and  a	call  is executed that changes one of its
   states, the process remains frozen and does not begin operating in the
   changed  state until it is resumed.	For example, a program can change
   a frozen process' PC with the SFORK call, but  the  process	will  not
   begin  running  at  the  new  PC until it is unfrozen.  Similarly, the
   HFORK call can be executed on a frozen process, but the  process  will
   not	be  in the halted state until it is unfrozen.  The changed status
   is always reflected in the information returned by the RFSTS call.  In
   the first example above, RFSTS would return the changed PC, and in the
   second, it would return the halted code in the status word.

   The monitor calls associated with capabilities and processes are:

	RPCAP	  Returns process capabilities word
	EPCAP	  Enables process capabilities word
	RESET	  Resets and initializes current process
	CFORK	  Creates inferior process
	SFORK	  Starts process
	HFORK	  Halts an inferior process
	HALTF	  Halts a process
	DISMS	  Dismisses process for specified amount of time
	WAIT	  Dismisses process until interrupt occurs
	WFORK	  Waits for process to terminate
	KFORK	  Kills one or more processes
	FFORK	  Freezes one or more processes
	RFORK	  Resumes one or more processes
	TFORK	  Sets and removes monitor call intercepts
	RTFRK	  Returns the handle of the process suspended
		  because of a monitor call intercept
	UTFRK	  Resumes a process suspended because of a
		  monitor call intercept
	RFSTS	  Returns process' status
	SFACS	  Sets process' accumulators
	RFACS	  Returns process' accumulators

	PRARG	  Sets or returns process argument block
	RFRKH	  Releases process handles
	GFRKS	  Gets current process structure
	GFRKH	  Gets process handle
	SPLFK	  Splices a process structure
	RMAP	  Obtains a handle on a page in a process
	SPACS	  Sets accessibility of page
	RPACS	  Returns accessibility of page
	RWSET	  Releases working set
	ADBRK	  Controls address breaks

   2.7.4.2  Execute-Only Files	and  Execute-Only  Processes - Before  we 	     	    
   discuss this topic, consider the following definitions:

 	1.  A "virgin" process is one that has just been  created  (using
 	    CFORK) but no operations which change its context or map into
 	    the process have been performed on the process.

 	2.  The "context" of the process includes its address space,  PC,
 	    AC's, interrupt system, traps, etc.

 	3.  An execute-only process can be  started  only  at  its  entry
 	    vector.

 	4.  A process which is created by an  execute-only  process  with
 	    the  same  address	space  (using CFORK) becomes execute-only
 	    itself.

   The basic definition of an execute-only file is  one  that  cannot  be
   copied,  read, or manipulated in the usual manner, but can be run as a
   program.  An execute-only file has the following charactersitics:

 	1.  The file must be protected with EXECUTE  access  allowed  but
 	    with READ access not allowed.

 	2.  The  file  cannot  be  read  or  written  using  any  of  the
 	    file-oriented  monitor  calls  (SIN,  SOUT,  BIN, BOUT, PMAP,
 	    etc.).

 	3.  The file can be mapped into a process (using GET),	but  only
 	    in its entirety and only into a virgin process.  A process so
 	    created will be called an execute-only process.

 	4.  Only disk-resident files can be considered execute-only.

 	5.  A process with WHEEL or  OPERATOR  capabilities  enabled  can
 	    gain  READ	access	to  any  file and can thus circumvent the
 	    execute-only features of an execute-only file.

   An execute-only process has the following characteristics:

 	1.  No other process  can  read  anything  from  an  execute-only
 	    process' address space or accumulators.

 	2.  No other process can  change  any  part  of  an  execute-only
 	    process'  context  in such a way as to cause the execute-only
 	    process to unintentionally reveal any  part  of  its  address
 	    space.

 	3.  An execute-only process will not be  prevented  from  mapping
 	    pages  of its own address space into an inferior process.  It
 	    is the programmer's  responsibility  to  avoid  revealing  an
 	    execute-only process through its inferior forks.

 	4.  No JSYS will explicitly indicate  that  a  given  process  is
 	    execute-only.   However,  the RFACS JSYS will always fail for
 	    an execute-only process and can be	used  to  determine  this
 	    information, if it is required.

   A program will be execute-only for particular users based on its  file
   protection.	If a user tries to RUN a file and can't READ it, but does
   have EXECUTE access, a process will be created  as  usual.	The  file
   will  be  mapped  into  this  virgin  process,  circumventing the READ
   protection on the file.  This process will  then  be  an  execute-only
   process.

   Users may select a file to be execute-only by allowing EXECUTE but not
   READ  access  to the file.  This can be done by setting the protection
   field for the desired class of  users  (owner,  group,  or  world)  to
   FP%EX+FP%DIR,  or  12 octal.  For example, to make a file execute-only
   for everybody except the owner of the  file,  set  the  protection  to
   771212  octal.   This can be done with the SET FILE PROTECTION command
   or by applying the ;P attribute to the file specification in the  SAVE
   or CSAVE command.

   The	following  TOPS-20  commands  will  not  work  for   execute-only
   programs:

    1.	DEPOSIT

    2.	DDT

    3.	EXAMINE

    4.	INFORMATION (ABOUT) VERSION

    5.	MERGE

    6.	SET ADDRESS-BREAK

    7.	SET ENTRY-VECTOR

    8.	SET NO UUO-SIMULATION

    9.	SET PAGE-ACCESS

   The CONTINUE command will not work after an execute-only  process  has
   halted.   The  START  command  cannot  be  used  with  a start address
   argument for an execute-only process.  A program which is execute-only
   must  be written to protect itself.	The program should not map itself
   out to inferior processes.  The  program  should  not  do  a  GET  and
   execute programs in its address space for which it has no control.

   2.8	SAVE FILES	 

   TOPS-20 handles two formats of save files: nonsharable  and	sharable.
   A  nonsharable  save  file  contains  sequences  of	words,	whereas a
   sharable save file contains sequences of pages.  The  formats  of  the
   two types of save files are discussed below.

   2.8.1  Format For Nonsharable Save Files	      

   The format of a nonsharable save file is as follows:

	       IOWD   length, address of data

	       IOWD   length, address of data

	       XWD    length of entry vector, pointer to first word of
		      entry vector

   2.8.2  Format Of Sharable Save Files	      

   A sharable save file  is  divided  into  two  main  parts:	one  part
   contains  information  about the structure of the file, and the second
   part contains the data of the file.	Currently, page  0  of	the  save
   file contains the information about the structure, and pages 1 through
   n contain the data.	(Future releases of TOPS-20 may use more than one
   page for the structure).

   Page 0 of the save file has three distinct  sections:   the	directory
   section,  the entry vector section, and the terminating section.  Each
   of the three sections begins with a	word  containing  its  identifier
   code  in the left half and its length in the right half.  Each section
   is described in the paragraphs below.

   The directory section is the first of the three sections and describes
   groups  of contiguous pages that have identical access.  The format of
   the directory section is as follows:

		 0	      8 9	  17 18 		     35

		!=======================================================!
		!      Identifier code	    !	   Number of words	!
		!	    1776	    !	(including this word)	!
		!			    !	in directory section	!
		!=======================================================!
		!    Access    !   Page number in file, or 0 if group	!
		!     bits     !	  of pages is all zero		!
		!=======================================================!
		!    Repeat    !       Page number in the process	!
		!    count     !					!
		!=======================================================!
		/      word pairs to describe each group of pages	/
		/	      in the process address space		/
		!=======================================================!
		! Access bits  !	Page number in the file 	!
		!=======================================================!
		! Repeat count !       Page number in the process	!
		!=======================================================!

   The access bits are determined from the access bits specified  by  the
   user  on the SSAVE monitor call (refer to the SSAVE call for details).
   The bits currently defined in the directory section are:

	B1     The process page is sharable

	B2     The process page is writable

   The remaining access bits in the directory section are zero.

   The repeat count is the number (minus 1) of consecutive pages  in  the
   group  described  by  the  word pair.  Pages are considered to be in a
   group when the following three conditions are met:

	1.  The pages are contiguous.

	2.  The pages have the same access.

	3.  The pages either  are  all	zero  or  are  all  existent  and
	    readable.

   A page is considered to be all zero if it is  nonexistent  or  is  not
   readable.   A  page containing all zeros is considered to be existent.
   A group of all zero pages is indicated by a file page number of 0.

   The word pairs are repeated for each group of  pages  in  the  address
   space.

   The entry vector section follows the directory section and  points  to
   the	entry  vector  word  that  is  used  when the GET monitor call is
   executed.  The format of the entry vector section is as follows:

		 0			  17 18 		      35
		!=======================================================!
		!      Identifier code	    !	   Number of words	!
		!	    1775	    !	(including this word)	!

		!			    !  in entry vector section	!
		!=======================================================!
		!	     Number of words in entry vector		!
		!=======================================================!
		!		 Address of entry vector		!
		!=======================================================!

   The data for this section is obtained  from	the  entry  vector  word.
   (Refer to Section 2.7.3 for a description of the entry vector.)

   The terminating section, called the end  section,  follows  the  entry
   vector section.  Its format is as follows:

		!=======================================================!
		!      Identifier code	    !				!
		!	    1777	    !		  1		!
		!=======================================================!

   The remaining words in page 0 of the save file are filled  with  zeros
   and are ignored by the monitor.

   2.8.3  Entry Vector	   

   The entry vector is a block of data that describes entry conditions to
   be  used  when the program in the process is executed.  The first word
   of the entry vector contains the program  start  address,  the  second
   word contains the program reenter address, and the third word contains
   the program version number.	(The version  number  format  is:   B0-B2
   containing  the group who last modified the program, B3-B11 containing
   major version number, B12-B17 containing  minor  version  number,  and
   B18-B35 containing edit number.)  Subsequent words in the entry vector
   can contain data applicable to the  particular  entry  (refer  to  the
   GCVEC and GDVEC monitor calls).

   Each process has an entry vector word in its  process  storage  block.
   The format of the entry vector word is:

	LH:  length of the entry vector (1-777)
	RH:  address of the first word of the entry vector.

   The data for this word is obtained from the entry vector in	the  save
   file when a GET monitor call is executed for the file.

   Note that if the left half of the entry vector (usually the length) is
   254000 (octal), then there is no real entry vector.	The program start
   address is in the right half of location 120, the reenter  address  is
   in  the  right  half  of  location  124, and the program version is in
   location 137.

   The following monitor calls are used in conjunction with save files:

	GET	  Obtains a saved file
	SAVE	  Saves a process as nonsharable
	SSAVE	  Saves a process as sharable
	SEVEC	  Sets process entry vector
	GEVEC	  Gets process entry vector
	SFRKV	  Starts process using its entry vector
	SCVEC	  Sets compatibility package entry vector
	GCVEC	  Gets compatibility package entry vector
	SDVEC	  Sets RMS entry vector
	GDVEC	  Gets RMS entry vector

   2.9	INPUT/OUTPUT CONVERSION	 

   The monitor calls  in  this	group  perform	input/output  conversion.
   Calls  are  available to convert in both directions between ASCII text
   (in core or in a file) and integer numbers,	floating  point  numbers,
   and TOPS-20 internal dates and times.

   2.9.1  Floating Output Format Control	     

   2.9.1.1  Free Format - The most common format control  used	with  the	     
   FLOUT  JSYS	is  free  format.   This  is  specified by setting B18-23
   (FL%FST) of the format control word to 0.  (Refer to Section 2.8.1.2.)
   Normally,  the  entire  format  control  word  is  set to 0;  however,
   certain fields may be specified to force a particular output.

   Most numbers greater than or equal to 10^-4 but less than  10^6  (with
   some  exceptions)  are  output  in a typical FORTRAN F format.  If the
   number is an exact integer, it is output with no  terminating  decimal
   point  unless  B6(FL%PNT)  is  on.  If the number is a fraction, it is
   output as .xxxx with no leading O's.  Nonsignificant trailing zeros in
   the	fraction  are  never  output.	A maximum of seven digits will be
   output if the second field (FL%SND) is not specified.  The sign of the
   number is output only if negative.

   If the number is outside the range above, it is output  in  a  typical
   FORTRAN  E  format  (with some exceptions).	The exponent is output as
   Esxx, where s is the sign output only on negative exponents and xx are
   the digits of the exponent.	The above exceptions about outputting the
   decimal point and suppressing trailing, nonsignificant zeros apply.

   Another free format similar to that above is invoked by  specifying	a
   nonzero  value  for	B13-17	(FL%RND) of the format control word.  The
   value in this field specifies  the  place  at  which  rounding  should
   occur.   If	this  value  is 7, the output is the same as if the value
   were 0 as above.  If this value is less than 7, rounding occurs at the
   specified  place,  but the output will be as above with a maximum of 7
   digits (e.g., 12360 with a rounding specification of 3 will output  as
   12400).   If  this  value  is  greater  than 7, rounding occurs at the
   specified position, but more than 7 digits are output.  In this  case,

   digits  are	output	until either the rounding specification number is
   reached or until trailing, nonsignificant zeros are reached.

   2.9.1.2  General Format Control - The format  control  word	specifies	      
   the	format for floating point output when free format is not desired.
   The control word indicates the desired output for the three fields  of
   the	number,  plus additional control for items such as rounding.  The
   first field of the number is up to  the  decimal  point.   The  second
   field  is  from the decimal point to the exponent.  The third field is
   the exponent.

   The format control word is as follows:

   Bit	     Symbol		 Meaning

   0-1	     FL%SGN    Sign control for first field.  The first character
		       position is always used for the minus for negative
		       numbers.   For	positive   numbers,   the   first
		       character  position  is	defined  according to the
		       values below:

		       Value   Symbol	 Meaning

			 0     .FLDIG	 First character is digit.
			 1     .FLSPC	 First character is space.
			 2     .FLPLS	 First character is plus sign.
			 3     .FLSPA	 First character is space.

   2-3	     FL%JUS    Justification control for first field.

		       Value   Symbol	 Meaning

			 0     .FLLSP	 Right	 justify   number   using
					 leading spaces.
			 1     .FLLZR	 Right	 justify   number   using
					 leading 0's.
			 2     .FLLAS	 Right	 justify   number   using
					 leading asterisks.
			 3     .FLTSP	 Left  justify	 number   up   to
					 decimal   point  using  trailing
					 spaces after third field.

    4	     FL%ONE    Output at least one  digit  (0  if  necessary)  in
		       first field.

    5	     FL%DOL    Prefix the number with a dollar sign ($).

    6	     FL%PNT    Output a decimal point.

   7-8	     FL%EXP    Third (exponent) field control.

		       Value   Symbol	 Meaning

			 0     .FLEXN	 No exponent field.

			 1     .FLEXE	 Output E as first  character  of
					 exponent field.
			 2     .FLEXD	 Output D as first  character  of
					 exponent field.
			 3     .FLEXM	 Output *10^ as first  characters
					 of exponent field.

   Bit	     Symbol		 Meaning

   9-10      FL%ESG    Exponent  sign  control.   The	first	character
		       position is always used for the minus for negative
		       exponents.   For  positive  exponents,  the  first
		       character  position  is	defined  according to the
		       values below:

		       Value   Symbol	 Meaning

			 0     .FLDGE	 First character  after  exponent
					 prefix is digit.
			 1     .FLPLE	 First character after prefix  is
					 plus sign.
			 2     .FLSPE	 First character after prefix  is
					 space.
			 3     .FLDGT	 First character  after  exponent
					 prefix is digit.

   11	     FL%OVL    Use free format on overflow of the first field and
		       expand  exponent  on  overflow of the third field.
		       If this bit  is	not  set,  no  additional  output
		       occurs on column overflow.

   13-17     FL%RND    Digit position at which rounding will  occur.   If
		       field is 0, rounding occurs at the 12th digit.  If
		       field is 37, no rounding occurs.

   18-23     FL%FST    Number of characters  in  first	field  (refer  to
		       FL%JUS).

   24-29     FL%SND    Number of characters in second field.

   30-35     FL%THD    Number of characters in third field.

   As an example, to output a number in the format xx.yy,  the	following
   bits should be set in AC3 of the FLOUT monitor call.

   B4(FL%ONE)	    output at least one digit in the first field
   B6(FL%PNT)	    output a decimal point
   B13-B17(FL%RND)  do not round the number
   B22		    output a maximum of two digits in the first field
   B28		    output a maximum of two digits in the second field

   Examples of numbers output in this format are:

		    43.86  4.24  0.43

   2.9.2  Date And Time Conversion Monitor Calls	       

   TOPS-20 internal date and time is maintained in a 36-bit word  and  is
   based on Greenwich Mean Time.  The date is in the left half and is the
   number of days since November 17, 1858;  the time is in the right half
   and	is  represented  as  a fraction of a day.  This allows the 36-bit
   value to be in units of days with a binary point between the left  and
   right  halves.  The resolution is approximately one-third of a second;
   that is, the least significant bit represents approximately	one-third
   of  a  second.  The date changes at the transition from 11:59:59 PM to
   12:00:00 midnight.

   For conversions between local and internal date  and  time,	the  time
   zone  in  which  the  installation  is  located is normally used, with
   daylight saving applied from 4AM on the next to last Sunday	in  April
   to 3:59:59AM on the next to last Sunday in October.

   Two monitor calls in this group, IDTIM and  ODTIM,  convert	date  and
   time  between text strings (in core or in a file) and internal format.
   These should satisfy most users.  However, there are four more  calls,
   which  are subsets of IDTIM and ODTIM.  The calls ODTNC, IDTNC, ODCNV,
   and IDCNV make available separately the  conversion	between  internal
   format  date  and time and separate numbers for local year, month, and
   day, and the conversion between those numbers and text strings.   They
   also  provide  additional  options, which give the caller more control
   over the conversion performed than IDTIM and ODTIM.

   Time zones occur in the calling sequences of the latter  four  JSYS's.
   A  time  zone is represented internally as a number between -12 and 12
   decimal, representing the number of	hours  west  of  Greenwich.   For
   example,  EST is zone 5.  Zones -12 and 12 represent the same time but
   different days  because  the  zones	are  on  opposite  sides  of  the
   international date line.

   The following are examples of valid dates and times:

 	6-FEB-76
 	FEB-6-76
 	FEB 6 76
 	FEB 6, 1976
 	6 FEB 76
 	6/2/1976
 	2/6/76

   Below are examples of valid times:

 	1:12:13
 	1234
 	16:30		  (4:30PM)
 	1630
 	1234:56
 	1:56AM
 	1:56-EST
 	1200NOON
 	12:00:00AM	  (midnight)
 	11:59:59AM-EST	  (late morning)

 	12:00:01AM	  (early morning)

   "AM" or "PM" can follow a time specification that is not greater  than
   12:59:59.   "NOON"  or  "MIDNIGHT"  can  follow  12:00:00.	Any  time
   specification can be followed by a dash and a  time	zone.	The  time
   zones  are:	EST and EDT (Eastern), CST and CDT (Central), MST and MDT
   (Mountain), PST and PDT (Pacific), AST and ADT (Atlantic), YST and YDT
   (Yukon), HST and HDT (Hawaii), BST and BDT (Bering), GMT, GST, and GDT
   (Greenwich), DAYLIGHT (local daylight savings), STD or STANDARD (local
   standard).

   All strings (e.g., months, time  zones,  AM-PM-NOON-MIDNIGHT)  can  be
   represented	by  any  non-ambiguous	abbreviation  (e.g.,  D=DECEMBER,
   M=MIDNIGHT).

   Spaces are ignored before and between  fields  whenever  they  do  not
   terminate  the input string.  This means spaces are not allowed before
   colons, AM,PM,NOON, and MIDNIGHT, the dash before the  time	zone,  or
   the time zone.  A tab is also allowed between the date and time.

   The input string can be terminated by any non-alphanumeric character.

   Monitor calls relating to date and time are as follows:

	NIN	  Inputs integer number
	NOUT	  Outputs integer number
	FLIN	  Inputs floating-point number
	FLOUT	  Outputs floating-point number
	DFIN	  Inputs double-precision, floating-point number
	DFOUT	  Outputs double-precision, floating-point number
	IDTIM	  Inputs date and time, converting to internal format
	ODTIM	  Outputs date and time, converting from internal format
		  to text
	IDTNC	  Inputs date and time without converting to internal
		  format
	ODTNC	  Outputs date and time in internal format
	IDCNV	  Converts from day, month, year to internal date and
		  time
	ODCNV	  Converts from internal date and time to day, month,
		  year
	GTAD	  Gets current date and time in internal format

   2.10  ARCHIVE/VIRTUAL DISK SYSTEM 	   

   Before we  discuss  the  archive/virtual  disk  system,  consider  the
   following terms:

   Virtual disk 	    A storage technique in which the contents  of
 			    some files reside on disk, while the contents
 			    of other files may reside on  tape.   When	a
 			    file is "migrated" to tape, a copy of its FDB
 			    is left on disk and the file's  contents  are
 			    deleted   from  disk.   Note  that	the  term
 			    "migration" applies only to files transferred

 			    to tape by the virtual disk system.

   Archived file	    A file of unchanging data stored on  magnetic
 			    tape.   Although copies of the file may exist
 			    on disk, the original is stored  on  magnetic
 			    tape.   When  a file gains archive status, it
 			    can no  longer  be	changed.   Copies  of  an
 			    archived file cannot be changed either.  If a
 			    writeable copy is desired, the  COPY  command
 			    must be used.

 			    When a file is archived,  the  file  contents
 			    are  usually  deleted from disk, leaving only
 			    the FDB on disk.  However, it is possible  to
 			    override the deletion process.

   Offline/online	    A file is said to be offline if the file  has
 			    been moved to tape by either the virtual disk
 			    system or the archive system.  A file is said
 			    to	be online if the original or a copy of it
 			    is on disk.  A file may be	offline,  online,
 			    or	both.	A  file  that  is offline and not
 			    online will have only its FDB stored on disk.
 			    In	the  last  case,  the  FDB  will  contain
 			    pointers to the saveset and tape file number.
 			    This  provides a link between the FDB on disk
 			    and the file on tape.

   Invisible/visible	    An invisible file is one that does not appear
 			    in	a  simple  DIRECTORY  listing, and is not
 			    accessable to programs and EXEC commands.	A
 			    visible  file  appears in a DIRECTORY listing
 			    and  is  accessable  to  programs  and   EXEC
 			    commands.

 			    The concept of an invisible file is primarily
 			    designed	to    make   offline-only   files
 			    transparent  to  the  user.    However,   the
 			    invisible/visible  status  of  a  file may be
 			    changed regardless of  whether  the  file  is
 			    online,   offline,	archived,  not	archived,
 			    migrated, or not migrated.

   The virtual disk system is designed to conserve disk space  by  moving
   selected  files  from disk to tape.	Files are marked for migration to
   tape  by  the  REAPER  program.   At  the   option	of   the   system
   administrator,  REAPER  may	mark  files in any of the following three
   categories:

 	1.  Files that have not been referenced within a specified period
 	    of time.

 	2.  Online copies of migrated or archived  files  that	have  not
 	    been referenced within a specified period of time.

 	3.  Files in a directory that is over permanent disk  quota.   If
 	    the  directory  contains  a  file named MIGRATION.ORDER, then
 	    REAPER uses that file as an order  list  for  marking  files.
 	    Otherwise  REAPER  follows	the  order  given  in  the REAPER
 	    command list.  Two REAPER passes are made with the first pass
 	    using  the	order  specified in MIGRATION.ORDER or the REAPER
 	    command string.   If  the  first  pass  fails  to  bring  the
 	    directory under quota, the second pass will consider any file
 	    in the directory for migration.

   The actual migration of disk files to tape is performed by  a  special
   DUMPER  run.   The actual run will occur periodically, with the length
   of the period determined by the system administrator.

   File archiving is designed to write unalterable "permanent" copies  of
   disk  files on tape.  The user voluntarily marks a file for archiving,
   and the next archive/virtual disk DUMPER run will archive the file.

   For added security two tape copies of each archived or  migrated  file
   are made.

   The following JSYS's are used to implement  the  archive/virtual  disk
   system:

 	ARCF
 	CRDIR
 	DELDF
 	DELFN
 	GTJFN
 	GNJFN
 	JFNS
 	OPENF
 	RFTAD
 	SETJB
 	SFTAD
 	SMON
 	TMON

   2.11  PRIVILEGED MONITOR CALLS	   

   The following monitor calls are privileged and require the process  to
   have WHEEL or OPERATOR capability enabled:

	ALLOC	  Allocates a device to a particular job
	BOOT	  Performs functions required for loading
		  front-end software
	CRDIR	  Creates or modifies a directory
	GTDIR	  Returns directory information
	DSKOP	  Allows hardware address specification of disk transfers
	DIAG	  Reserves and releases hardware channels
	DSKAS	  Assigns specific disk addresses
	SJPRI	  Sets job priority
	SPRIW	  Sets process priority

	HSYS	  Specifies system shutdown times
	USRIO	  Places program in user I/O mode
	MSFRK	  Starts a process in monitor mode
	NODE	  Performs network utility functions
	PEEK	  Reads monitor data
	PLOCK	  Locks physical pages
	SNOOP	  Performs system analysis
	SYERR	  Records data in the system error file
	SMON	  Sets various monitor flags
	EFACT	  Records data in the FACT file
	MTALN	  Associates magnetic tape drive with logical unit number
	TTMSG	  Sends a message to a terminal
	PMCTL	  Controls physical memory
	USAGE	  Writes entries into the system's accounting data file
	UTEST	  Tests monitor routines

				 CHAPTER 3

			   TOPS-20 MONITOR CALLS
			     


Node: ACCESS	Next: ADBRK	Up: Top
			     ACCES     JSYS 552

   Gives a particular type of access to a given directory.  The  possible
   types of accesses are:

	1.  Connecting to a directory on a given structure.

	2.  Gaining owner and group access rights  to  directories  on	a
	    structure  without actually connecting to a directory on that
	    structure.

	3.  Relinquishing owner and group access rights to directories on
	    a  structure  without  disconnecting from a directory on that
	    structure.

   Access cannot be given to a regulated structure unless the  MSTR  JSYS
   has	been first used to increment the mount count.  All structures are
   regulated by default  except  the  primary  structure  (PS:	 on  most
   systems)  or  any  structure that has been made non-regulated with the
   MSTR JSYS.  Access rights and all JFNs on the regulated structure must
   be released before the mount count can be decremented.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
			       enabled.
   ACCEPTS IN AC1:  B0(AC%CON) connect	 the   job   to   the	specified
			       directory.  After successful completion of
			       the call, the job is connected to and  has
			       owner  access  to  the  directory, and its
			       default directory becomes this directory.

		    B1(AC%OWN) give the job owner access to the specified
			       directory  and group access to directories
			       in  the	same  groups  as  the	specified
			       directory.   The job's connected directory
			       is unchanged.   This  function  cannot  be
			       given  for another job or for a files-only
			       directory.

		    B2(AC%REM) relinquish the owner access (obtained with

   (ACCES)
   

			       the  AC%OWN  function)  to  the	specified
			       directory  and	the   group   access   to
			       directories  in the same group.	The job's
			       connected directory  is	unchanged.   This
			       function  cannot  be given for another job
			       or  for	a  files-only	directory.    The
			       settings of B0 and B1 are ignored if B2 is
			       on and the job number  given  is  for  the
			       current job.

		    B18-B35    length of the argument block

	      AC2:  address of the argument block

   RETURNS     +1:  always

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

 	0    .ACDIR	    Byte pointer to ASCIZ string  containing  the
 			    structure  and  directory  name  or  a 36-bit
 			    directory number.  The ASCIZ string  must  be
 			    of the form structure:<directory>.

 	1    .ACPSW	    Byte pointer to ASCIZ string  containing  the
 			    password  of  the  specified  directory.  The
 			    password is not required if the directory  is
 			    the  job's	logged-in directory on a domestic
 			    structure  and  if	the  directory	does  not
 			    require a password for the owner.

 	2    .ACJOB	    Number (decimal) of job or -1 for the current
			    job.  The process must have WHEEL or OPERATOR
			    capability enabled to  give  a  specific  job
			    number other than its own.

   The ACCES monitor call can be given for another job	if  the  type  of
   access  being  requested is for connecting the job (AC%CON) and if the
   process executing the call has WHEEL or OPERATOR capability enabled.

   The ACCES monitor call is used to implement the CONNECT,  ACCESS,  and
   END-ACCESS commands of the TOPS-20 Command Language.

   Generates an illegal instruction interrupt on error conditions below.

   ACCES ERROR MNEMONICS:

   ACESX1:   argument block too small

   ACESX3:   password is required

   ACESX4:   function not allowed for another job

   ACESX5:   no function specified for ACCES

   (ACCES)
   

   ACESX6:   directory is not accessed

   ACESX7:   directory is "files-only" and cannot be accessed

   CNDIX1:   invalid password

   CNDIX5:   job is not logged in

   STRX01:   structure is not mounted

   STRX02:   insufficient system resources

   STRX03:   no such directory name

   STRX04:   ambiguous directory specification

   STRX09:   prior structure mount required

   LGINX2:   directory is "files-only" and cannot be logged into

   CAPX1:    WHEEL or OPERATOR capability required

   RCDIX2:   invalid directory specification

   ARGX07:   invalid job number

   ARGX08:   no such job


Node: ADBRK	Previous: ACCESS	Next: AIC	Up: Top
			     ADBRK     JSYS 570

   Controls address breaks.  An address break  is  the	suspension  of	a
   process when a specified location is referenced in a given manner.

   RESTRICTIONS:     Not available on 2020 hardware.

   ACCEPTS IN AC1:   function code in the left half and process handle in
		     the right half

	      AC2:   arguments for the

	      AC3:   specified function

   RETURNS     +1:   always

   This JSYS is useful when debugging a program.  For  example,  consider
   the	problem  of  debugging	a  program  consisting	of a fork running
   several inferior forks mapped to the  same  address	space.	 One  (or
   more)  of  the  inferior forks is erroneously referencing a particular
   address.  To find out which fork(s) are referencing that address,  the
   user would do the following:

   (ADBRK)
   

 	1.  Set up  the  software  interrupt  system  for  interrupts  on
 	    channel 19.

 	2.  Perform the ADBRK .ABSET function for each inferior  process,
 	    using  the	handle	of  the  inferior process and the address
 	    erroneously being referenced.

 	3.  When a channel 19 interrupt occurs, perform an RFSTS JSYS for
 	    each  inferior  process.   The  interrupted  process(es) that
 	    caused the address break(s)  will  have  a	code  7  (.RFABK)
 	    returned in its (their) status word(s).

 	4.  Perform the ADBRK  .ABGAD  function  for  each  process  that
 	    caused an address break.  This will return the address of the
 	    instruction that erroneously referenced the break address.

 	5.  Perform the RFORK JSYS to restart the process(es)  halted  by
 	    address break(s).

 	6.  Continue running the program and  repeating  the  last  three
 	    steps  until  the program completes execution or it no longer
 	    generates address breaks.

   The ADBRK JSYS may also be used  to	locate	which  instruction  in	a
   process is setting a location to the wrong value.

   The available functions are as follows:

	Code	Symbol			Meaning

	 0	.ABSET	  Set address break.

	 1	.ABRED	  Read address break.

	 2	.ABCLR	  Clear address break.

	 3	.ABGAD	  Return address of break instruction.

   Each function is described in the paragraphs below.

   Setting address breaks - .ABSET
       

   This function initializes the address break facility for the specified
   process.   When  the process references the location in the manner for
   which the break has been set, it is suspended.  Its superior  receives
   a software interrupt on channel 19 (.ICIFT) if it has enabled for that
   channel.  After processing the interrupt,  the  superior  process  can
   resume the inferior by executing the RFORK monitor call.

   Only one address break can be in effect for a process at any one time,
   and	the  break  affects  only  the	process  for which it is set.  If
   another process references the location on which a break is set, it is
   in  no  way	affected by the break.	When an address break is set in a

   (ADBRK)
   

   page shared among processes and each process is to be  suspended  when
   it  references  the location, the ADBRK call must be executed for each
   process.

   Breaks cannot be specified for the accumulators.

   The .ABSET function requires the following arguments to be given:

	AC2:  address of location on which to break

	AC3:  flag word indicating the type  of  reference  on	which  to
	      break.  The following flags are currently defined:

	      B0(AB%RED)  Break on a read reference.

	      B1(AB%WRT)  Break on a write reference.

	      B2(AB%XCT)  Break  on  an   execute   (instruction   fetch)
			  reference.

   Reading address breaks - .ABRED
       

   This function returns the current address break  information  for  the
   specified   process.   It  returns  the  following  information  on	a
   successful return:

	AC2:  address of location on which a break is set

	AC3:  flag word indicating the type of	reference  on  which  the
	      break  will  occur.   The  following  flags  are	currently
	      defined:

	      B0(AB%RED)  Break will occur on a read reference.

	      B1(AB%WRT)  Break will occur on a write reference.

	      B2(AB%XCT)  Break will occur  on	an  execute  (instruction
			  fetch) reference.

   If no address break has been set for the process, the contents of  AC2
   and AC3 are zero on return.

   Clearing address breaks - .ABCLR
       

   This function removes any address break that was set for the specified
   process.   A  program  can also remove a break by executing the .ABSET
   function with AC2 and AC3 containing zero.

   Returning the address of the break instruction - .ABGAD
           

   This function returns in AC2 the address of the location on which  the
   process  encountered  a  break.   When the location on which the break

   (ADBRK)
   

   occurred is in a JSYS routine, the address returned is a  monitor  PC,
   not	the  address  of the JSYS.  The program can obtain the address of
   the JSYS by executing an RFSTS monitor call.

   Generates an illegal instruction interrupt on error conditions below.

   ADBRK ERROR MNEMONICS:

   ABRKX1:   address break not available on this system

   ARGX02:   invalid function

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX8:   illegal to manipulate an execute-only process


Node: AIC	Previous: ADBRK 	Next: ALLOC	Up: Top
			      AIC     JSYS 131

   Activates specific software interrupt  channels.   (Refer  to  Section
   2.5.)

   ACCEPTS IN AC1:  process handle

	      AC2:  36-bit word
		    Bit n on means activate channel n

   RETURNS     +1:  always

   The DIC monitor call can be	used  to  deactivate  specified  software
   interrupt channels.

   Generates an illegal instruction interrupt on error conditions below.

   AIC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX8:   illegal to manipulate an execute-only process


Node: ALLOC	Previous: AIC 	Next: ARCF	Up: Top
			     ALLOC     JSYS 520

   Allocates a device to a particular job or to the device  pool  of  the
   monitor's resource allocator.  A device under control of the monitor's
   resource allocator cannot be opened or assigned by any job other  than
   the one to which it is currently allocated.	When the allocated device
   is deassigned, it is returned to the monitor's resource allocator.

   RESTRICTIONS:    requires WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  function code (.ALCAL)

	      AC2:  device designator

	      AC3:  job number, -1, or -2

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   If AC3 contains a job number, then the designated device is	allocated
   to that job.

   If AC3 contains -1, then the device is returned to the pool of devices
   available  to  all  users of the system (i.e., the device is no longer
   allocated).	This is the initial state of all devices.

   If AC3 contains -2,	then  the  device  is  assigned  to  the  monitor
   resource allocator's pool of devices.

   When a non-allocated device (i.e., a device not under control  of  the
   resource  allocator) is assigned or opened by a job, the device cannot
   be taken by the resource allocator.	However, the  resource	allocator
   can	allocate the device to the job that currently has it.  Thus, when
   the job releases  the  device,  it  will  be  given	to  the  resource
   allocator.	The  allocator receives an IPCF packet when the device is
   returned to it.  The flag word (.IPCFL) of the packet descriptor block
   has	a  code of 1(.IPCCC) in the IP%CFC field (bits 30-32).	This code
   indicates the message was sent by the monitor.  The first word of  the
   packet data block contains the resource allocator's code .IPCSA.  Each
   following word contains the designator of the returned device.  Thus,

	     .IPCFL/<.IPCCC>B32

	     DATA/.IPCSA
	     DATA+1/device designator
	     DATA+2/device designator

   The ALLOC monitor call requires the process to have WHEEL or  OPERATOR
   capability enabled.

   ALLOC ERROR MNEMONICS:

   ALCX1:    invalid function

   (ALLOC)
   

   ALCX2:    WHEEL or OPERATOR capability required

   ALCX3:    device is not assignable

   ALCX4:    invalid job number

   ALCX5:    device already assigned to another job

   ALCX6:    device assigned to user job, but will be given to allocator
	     when released

   DEVX1:    Invalid device designator


Node: ARCF	Previous: ALLOC 	Next: ASND	Up: Top
			     ARCF     JSYS 247

   Performs all operations pertaining to the  archive  and  virtual  disk
   systems.   This includes requesting archival and migration, requesting
   retrieval, and setting archive status and tape information for a file.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
 		    enabled.
   ACCEPTS IN AC1:  JFN

 	      AC2:  Function code.  The  available  functions  and  their
 		    argument blocks are described below.

 	      AC3:  (Function dependent, normally 0)

 	Code	Symbol			     Function

 	 0	.ARRAR	  Sets/clears AR%RAR  (in  .FBBBT  of  the  FDB),
 			  activating  or  deactivating a user request for
 			  archival.  The value .ARSET  (1)  in	AC3  will
 			  request  an archive while .ARCLR (0) will clear
 			  the request.	Setting AR%NDL (in .FBBBT of  the
 			  FDB)	with  .ARSET  in  AC3  requests  that the
 			  contents of the file not be flushed  from  disk
 			  upon archival.

 	 1	.ARRIV	  Sets/clears AR%RIV  (in  .FBBBT  of  the  FDB),
 			  activating  or deactivating a system request to
 			  migrate a file from disk to  tape.   The  value
 			  .ARSET  in  AC3  will  request  migration while
 			  .ARCLR will clear the request.   This  function
 			  requires  WHEEL  or OPERATOR capabilities to be
 			  enabled.

 	 2	.AREXM	  Sets/clears AR%EXM  (in  .FBBBT  of  the  FDB),
 			  activating   or   deactivating  exemption  from
 			  involuntary  migration.   .ARCLR  (0)  in   AC3

   (ARCF)
   

 			  clears  AR%EXM  while  .ARSET  in  AC3 will set
 			  AR%EXM.   This  function  requires   WHEEL   or
 			  OPERATOR capabilities to be enabled.

 	 3	.ARRFR	  Request a file's contents  to  be  restored  to
 			  disk.  Normally, .ARRFR returns without waiting
 			  for the contents of the file to be restored  to
 			  disk.

 			  Options for AC3

 			  B1   AR%WAT	 Wait (ARCF  JSYS  blocks)  until
 					 the file is restored.

 	4	.ARDIS	  Discard tape information.   Clears  FB%ARC  (if
 			  set),   .FBTP1,  .FBTP2,  .FBTSN,  .FBTFN,  and
 			  .FBTDT.   The  file  must  be  online  for  the
 			  function to succeed.

 			  Options for AC3  (Requires  WHEEL  or  OPERATOR
 			  privileges	enabled    to	 use	functions
 			  separately.)

 			  B0   AR%CR1	 Clear information for run 1
 			  B1   AR%CR2	 Clear information for run 2

 	5	.ARSST	  Set tape  information  for  a  file.	 Requires
 			  enabled  WHEEL  or  OPERATOR	privileges.   AC3
 			  contains a pointer  to  an  argument	block  as
 			  follows:

 			  Word	 Symbol   Contents

 			   0	 .AROFL   Flags:

 					  B0(AR%01)  Set information  for
 						     run 1

 					  B1(AR%02)  Set information  for
 						     run 2

 					  B2(AR%OFL) Delete disk contents
 						     of  file  when done.
 						     Requires  both  sets
 						     of  tape information
 						     to be set.

 					  B3(AR%ARC) Set  FB%ARC  in  the
 						     FDB   (archive   the
 						     file)

 					  B4(AR%CRQ) Clear archive and/or
 						     migration	 requests
 						     (clear  AR%RAR   and
 						     AR%RIV).

   (ARCF)
   

 			   1	 .ARTP1   Tape 1 identification

 			   2	 .ARSF1   TSN 1,,TFN  1  -  Tape  saveset
 					  number  in  the  left  half and
 					  tape file number in  the  right
 					  half.

 			   3	 .ARTP2   Tape 2 identification

 			   4	 .ARSF2   TSN  2,,TFN  2  -  similar   to
 					  .ARSF1

 			   5	 .ARODT   time and date of tape write  in
 					  internal   format;   0  implies
 					  present time

 			   6	 .ARPSZ   Number of pages  in  the  file.
 					  This	word  can  be set only if
 					  AR%01 and AR%02 are set first.

 	This function is used to set information for the  first,  second,
 	or  both  tape	runs.	AR%01  and  AR%02  are used together when
 	restoring files to disk via DUMPER'S RESTORE command.

 	6	.ARRST	  Restore contents of a file to disk.  AC3  is	a
 			  JFN for a temporary file that contains the data
 			  for a currently offline archived  file.   After
 			  copying   .FBADR,   .FBBSY   and   .FBSIZ,  the
 			  temporary file is deleted.  Both files must  be
 			  on  the  same  device  or structure and enabled
 			  WHEEL or OPERATOR capabilities are required.

 	7	.ARGST	  Get tape information for file.  AC3 contains	a
 			  pointer  to an argument block that has the same
 			  format as the block for .ARSST.

       10	.ARRFL	  The restore for  this  file  has  failed.   Set
 			  AR%RFL  in  FBBBT  to  notify a waiting process
 			  that the retrieval request cannot be completed.
 			  Requires     enabled	  WHEEL    or	 OPERATOR
 			  capabilities.

       11	.ARNAR	  Resist involuntary migration.  Sets  or  clears
 			  AR%NAR  in  .FBBBT.	Using  .ARSET in AC3 will
 			  cause resist to be set, while using .ARCLR will
 			  clear resist.

   ARCF ERROR MNEMONICS:

   CAPX1:    WHEEL or OPERATOR capabilities required

   ARGX02:   Invalid function code

   ARCFX2:   File already has archive status

   (ARCF)
   

   ARCFX3:   Cannot perform  ARCF  functions  on  non-multiple	directory
   devices

   ARCFX4:   File is not online

   ARCFX5:   Files are not on the same device or structure

   ARCFX6:   File does not have archive status

   ARCFX7:   Invalid parameter for .ARSST

   ARCFX8:   Archive not complete

   ARCFX9:   File not offline

   ARCX10:   Archive prohibited

   ARCH11:   Archive requested, modification prohibited

   ARCH12:   Archive requested, delete prohibited

   ARCX13:   Archive system request not completed

   ARCX14:   Restore failed

   ARCX15:   Migration prohibited

   ARCX16:   Cannot exempt offline, archived, or archive pending files

   ARCX17:   FDB improper format for ARCF

   ARCX18:   Retrieval wait cannot be fulfilled for waiting process

   ARCX19:   Migration already pending


Node: ASND	Previous: ARCF 	Next: ASNSQ	Up: Top
			      ASND     JSYS 70

   Assigns a device to the caller.  The successful return is given if the
   device is already assigned to the caller.

   ACCEPTS IN AC1:  device designator

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The RELD call can be used to release devices assigned to the caller.

   ASND ERROR MNEMONICS:

   (ASND)
   

   DEVX1:    invalid device designator

   DEVX2:    device already assigned to another job

   ASNDX1:   device is not assignable

   ASNDX2:   illegal to assign this device

   ASNDX3:   no such device

   DSMX1:    file(s) not closed


Node: ASNSQ	Previous: ASND 	Next: ATACH	Up: Top
			     ASNSQ     JSYS 752

   Assigns a special message queue to a job.

   RESTRICTIONS:    for  ARPANET  systems  only.   Requires  NET   WIZARD
 		    capabilities enabled.

   ACCEPTS IN AC1:  mask
 	      AC2:  header value

   RETURNS     +1:  failure, error code in AC1

 	       +2:  success, special message queue assigned with  special
 		    queue handle in AC1.

   ASNSQ ERROR MNEMONICS:

   NTWZX1:   NET WIZARD capability required

   ASNSX1:   Insufficient system resources
 	     (all special queues in use)

   ASNSX2:   Link(s) assigned to another special queue


Node: ATACH	Previous: ASNSQ 	Next: ATI	Up: Top
			     ATACH     JSYS 116

   Detaches the specified job from its controlling terminal (if any)  and
   optionally	attaches   it	to   a	 new   controlling  terminal.	A
   console-attached entry is appended to the accounting data file.

   RESTRICTIONS:    some   functions   requires   WHEEL    or	 OPERATOR
			       capabilities enabled.

   (ATACH)
   

   ACCEPTS IN AC1:  B0(AT%CCJ) generate a CTRL/C interrupt to the  lowest
			       process	in  the job that is enabled for a
			       CTRL/C interrupt if the job  is	currently
			       attached to another terminal.  If this bit
			       is not set or if the job is currently  not
			       attached  to  another  terminal,  the  job
			       simply  continues  running  when   it   is
			       attached.

		    B1(AT%NAT) do  not	 attach.    Prevents   both   the
			       detaching of the job from its terminal and
			       the attaching of a remote job to the local
			       terminal.   Is  a  no-op unless the remote
			       job has a controlling terminal,	in  which
			       case   the  remote  job	is  detached  and
			       remains	detached.   This  bit  in  effect
			       makes ATACH like a remote DTACH.

		    B2(AT%TRM) attach  the  given  job	to  the  terminal
			       specified in AC4.  If this bit is not set,
			       the job is  attached  to  the  controlling
			       terminal of the caller.

 		    B18-B35    job number (decimal) of the desired job
 		    (AT%JOB)

 	      AC2:  user number (e.g., 500000,,256) under which  the  job
 		    to	be attached is logged in.  The user number can be
 		    obtained with the RCUSR monitor call.

 	      AC3:  byte pointer to  an  ASCIZ	password  string  in  the
 		    caller's address space.

 	      AC4:  number (octal) of the terminal to be attached to  the
 		    specified	job.	This   argument  is  required  if
 		    B2(AT%TRM) is set.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success.  If  there  is  a	logged-in  job	currently
		    attached  to  the  specified terminal, it is detached
		    with primary I/O not redirected.  Thus, if a  process
		    has  primary  I/O  from  the controlling terminal, it
		    will block when it	attempts  primary  I/O	and  will
		    continue  when  it	is  reattached and a character is
		    typed.  If there is a job  not  logged  in	currently
		    attached  to  the  specified  terminal,  the job goes
		    away.

   It is legal to attach to a job that has a controlling terminal if

	1.  The job is logged in under the same  user  name  as  the  job
	    executing the ATACH.

   (ATACH)
   

	2.  The job executing the ATACH supplies the correct password  of
	    the job it is attaching to.

	3.  The job executing the ATACH has WHEEL or OPERATOR  capability
	    enabled.

	4.  The job executing the ATACH has ownership of the job  because
	    it	created the job (and maintained ownership) with the CRJOB
	    call.

   If the controlling terminal is a PTY, a password is	not  required  if
   either:

	1.  The owner  of  the	PTY  has  WHEEL  or  OPERATOR  capability
	    enabled.

	2.  The specified job is logged in with  the  same  name  as  the
	    owner of the PTY.

   The DTACH monitor call can be used to detach the controlling  terminal
   from the current job.

   ATACH ERROR MNEMONICS:

   ATACX1:   invalid job number

   ATACX2:   job already attached

   ATACX3:   incorrect user number

   ATACX4:   invalid password

   ATACX5:   this job has no controlling terminal


Node: ATI	Previous: ATACH 	Next: ATNVT	Up: Top
			      ATI     JSYS 137

   Assigns a terminal code to a software interrupt  channel.   (Refer  to
   Section  2.5.)  This  call  also  sets  the	corresponding  bit in the
   process' terminal interrupt mask.  (Refer to the STIW and RTIW monitor
   calls.)

   ACCEPTS IN AC1:  terminal code (refer to Section 2.5.6)  in	the  left
		    half and channel number in the right half

   RETURNS     +1:  always

   If there is no controlling terminal (i.e., if the  job  is  detached),
   the	assignments  are remembered and will be in effect when a terminal
   becomes attached.

   (ATI)
   

   The DTI monitor call can be used to deassign a terminal code.

   Generates an illegal instruction interrupt on error conditions below.

   ATI ERROR MNEMONICS:

   TERMX1:   invalid terminal code

   ATIX1:    invalid software interrupt channel number

   ATIX2:    control-C capability required



Node: ATNVT	Previous: ATI 	Next: BIN	Up: Top
			     ATNVT     JSYS 274

   Creates the Network Virtual Terminal (NVT) connection.

   Attach two jfns to an NVT.
   For Ethernet, same calling convention as for the ARPANET.

   Local change: After successfully setting up the NVT, the port's
   data mode is set to .PM32 and its byte size to 8-bit. 

   RESTRICTIONS:    for use with ARPANET only

   ACCEPTS IN AC1:  flag bits in the left half and the JFN of the  opened
 		    receive connection in the right half

 	      AC2:  JFN of the opened send connection

   RETURNS     +1:  failure, with error code in AC1

 	       +2:  success, with terminal designator  specific  to  this
 		    NVT in AC1

   Flags for AC1:

   Bit				 Meaning

   B2	     If set, this bit indicates New TELNET protocol.
 	     If clear, this bit indicates old TELNET protocol.

   ATNVT ERROR MNEMONICS:

   ATNX1:    invalid receive JFN

   ATNX2:    receive JFN is not open for read

   ATNX3:    receive JFN is not open

   ATNX4:    receive JFN is not a network connection

   ATNX5:    receive JFN has been used

   ATNX6:    receive connection has been refused

   ATNX7:    invalid send JFN

   (ATNVT)
   

   ATNX8:    send JFN is not open for write

   ATNX9:    send JFN is not open

   ATNX10:   send JFN is not a network connection

   ATNX11:   send JFN has been used

   ATNX12:   send connection has been refused

   ATNX13:   insufficient system resources (no NVTs)


Node: BIN	Previous: ATNVT 	Next: BKJFN	Up: Top
			      BIN     JSYS 50

   Inputs the next byte from the specified source.  When the byte is read
   from  a  file, the file must first be opened, and the size of the byte
   given, with the OPENF call.	When the byte  is  read  from  memory,	a
   pointer to the byte is given.  This pointer is updated after the call.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  always, with the byte right-justified in AC2

   If the end of file is reached, AC2 contains 0  instead  of  the  byte.
   The	program  can  process  this  end-of-file condition if an ERJMP or
   ERCAL is the next instruction following the BIN call.

   The BOUT monitor call can be used to output a byte sequentially  to	a
   destination.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   BIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX1:     file is not open for reading

   IOX4:     end of file reached

   IOX5:     device or data error

   (BKJFN)
   


Node: BKJFN	Previous: BIN 	Next: BOOT	Up: Top
			     BKJFN     JSYS 42

   Backs up the source designator's pointer by one byte.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC1, if pertinent.
		    (This return actually decrements the pointer.)

   The BKJFN call, when referring to a terminal,  can  be  executed  only
   once  to back up one character (i.e., the terminal's pointer cannot be
   backed up twice).  The call, when referring to other designators,  can
   be executed more than once in succession.

   BKJFN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   BKJFX1:   illegal to back up terminal pointer twice

   SFPTX2:   illegal to reset pointer for this file

   SFPTX3:   invalid byte number

   TTYX01:   line is not active


Node: BOOT	Previous: BKJFN 	Next: BOUT	Up: Top
			     BOOT     JSYS 562

   Performs basic maintenance and utility functions required for  loading
   and dumping the communications front-end software via the DTE-20.  The
   TOPS-20 system process responsible for performing these functions uses
   a DIGITAL-supplied protocol to implement them.

   On 2040,2050, and 2060 hardware, the BOOT JSYS is  used  to	load  and
   dump  a  PDP-11 connected to a DTE20.  On 2020 hardware, the BOOT JSYS
   loads and dumps a KMC11, dumps line counters, and  stops  DDCMP  on	a
   line.

   RESTRICTIONS:    requires  WHEEL  or  OPERATOR  capabilities  enabled.
		    Some functions are specific to 2020 hardware.

   (BOOT)
   

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS     +1:  always

   The available functions and their argument blocks are described below.

	Code	Symbol			     Meaning

	 0	.BTROM	  Activate the	hardware  ROM  bootstrap  in  the
			  communications front end.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

	1	.BTLDS	  Load a secondary  bootstrap  program	into  the
			  communications   front   end.    The	secondary
			  bootstrap, with a maximum size  of  256  PDP-11
			  words,  is loaded using the ROM bootstrap.  The
			  data to be loaded must be packed as two  16-bit
			  PDP-11  words  left  justified  in  each 36-bit
			  TOPS-20 word.   The  entire  bootstrap  program
			  must	be  loaded at once, and the caller blocks
			  until the transfer is complete.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

			  2    .BTSEC	 Address of bootstrap program  to
					 be loaded

	2	.BTLOD	  Load the communications front-end memory  using
			  the  previously  loaded  secondary  or tertiary
			  bootstrap program.  The  bootstrap  program  in
			  the  front  end  must abide by the protocol for
			  DTE-20 transfers:  the first two bytes of  data
			  supplied  by	the caller must be a count of the
			  remaining number of data bytes.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

   (BOOT)
   

			  2		 Not used and must be zero.

			  3    .BTFLG	 User-supplied flag word

					 B0(BT%BEL)  Send a  doorbell  to
						     the   front  end  to
						     indicate  when   the
						     setup   is  complete
						     and the transfer can
						     begin.

			  4    .BTCNT	 Number of bytes to transfer

			  5    .BTLPT	 Pointer to data to be loaded

	3	.BTDMP	  Dump the communications front-end memory  using
			  the  ROM  bootstrap  program.   The caller must
			  activate the ROM  bootstrap  (function  .BTROM)
			  before   dumping   memory.   Subsequent  .BTDMP
			  functions  to  dump  memory  start  where   the
			  previous   dump   terminated	 unless  the  ROM
			  bootstrap  is  activated  again  by  a   .BTROM
			  function.  The caller blocks until the transfer
			  is complete.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

			  2		 Not used and must be zero.

			  3    .BTFLG	 User-supplied flag  word.   This
					 word  is  not	used  and must be
					 zero.

			  4    .BTCNT	 Number of bytes to transfer

			  5    .BTDPT	 Pointer to where the data is  to
					 be dumped in the TOPS-20

	4	.BTIPR	  Initialize the protocol to be  used  with  this
			  communications  front  end.	After  successful
			  execution of this function,  the  TOPS-20  will
			  process interrupts from the given DTE-20.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTPRV	 Version number of  the  protocol
					 to be used

   (BOOT)
   

 					 For	 multi-drop	terminals
 					 (VT62's)   on	 a   2020,   this
 					 function will generate and  link
 					 a  DDCMP Station Table.  It will
 					 startup    a	 terminal     not
 					 previously  known  to the system
 					 and must be issued once for each
 					 terminal being started up.

 					 Argument Block

 			  0    .BTPRT	 Drop,,line

 			  1    .BTPRV	 Version number of protocol to be
 					 used  (see  description  of BOOT
 					 function code 6)

	5	.BTTPR	  Stop the protocol  currently	running  on  this
			  communications  front  end.	After  successful
			  execution of this function,  the  TOPS-20  will
			  ignore interrupts from the given DTE-20.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

 	6	.BTSTS	  Return the status type of the protocol  running
 			  on this communications front end.  Also returns
 			  the name of the adjacent DECNET node	for  this
 			  front end.

 			  Argument Block

 			  0    .BTDTE	 DTE-20 number

 			  1    .BTCOD	 Returned protocol  version  type
 					 If  no protocol is running, this
 					 word contains -1.
 			  Possible protocol types are:

 			  Symbol	 Meaning

 			  .VN20F (0)	 RSX20F protocol
 			  .VNMCB (1)	 MCB DECNET protocol
 			  .VNDDC (2)	 DDCMP protocol
 			  .VNMOP (3)	 MOP (DDCMP maintenance) mode
 			  .VNCNL (4)	 Controller loopback
 			  .VNCBL (5)	 Cable loopback

	7	.BTBEL	  Block until a signal (doorbell) to the  TOPS-20
			  is  initiated  by the communications front end.
			  This function is used to synchronize the caller
			  with the bootstrap program in the front end.

   (BOOT)
   

			  Argument Block

			  0    .BTDTE	 DTE-20 number

	10	.BTRMP	  Read data from  the  communications  front  end
			  using   the	previously  loaded  secondary  or
			  tertiary  bootstrap  program.   The	bootstrap
			  program  must  abide by the protocol for DTE-20
			  transfers.  The first two bytes of data will be
			  interpreted  as a count of the remaining number
			  of bytes of data.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

			  2		 Not used and must be zero.

			  3    .BTFLG	 User-supplied flag word

					 B0(BT%BEL)  Send    a	   signal
						     (doorbell)   to  the
						     TOPS-20 to  indicate
						     the    transfer   is
						     finished.

			  4    .BTCNT	 Maximum  number  of   bytes   to
					 transfer.     After   successful
					 execution of this function, this
					 word  is  updated to reflect the
					 actual    number    of     bytes
					 transferred.

			  5    .BTMPT	 Pointer to where data is  to  be
					 placed

	11	.BTKML	  Load a KMC11 (2020 only).  This  function  will
			  optionally  load  the  CRAM, DRAM, and the four
			  UNIBUS registers.  Before the KMC11 is  loaded,
			  the  system  verifies  that  each bit in UNIBUS
			  registers can be set and cleared.   Before  the
			  DRAM	is  loaded, the system verifies that each
			  bit in the entire DRAM can be set and  cleared.
			  After the CRAM, DRAM, and registers are loaded,
			  they are verified to ensure that the	data  was
			  properly  loaded.   If the register data is not
			  supplied, the UNIBUS registers will be  cleared
			  before the KMC11 is started.

			  Argument Block

			  0    .BTKMC	 KMC11 address

   (BOOT)
   

			  1    .BTKER	 Error flags returned

					 B0 (BT%CVE)  CRAM  verify  error
						      (right half is bad)

					 B1 (BT%DVE)  DRAM  verify  error
						      (right half is bad)

					 B2 (BT%RVE)  Register	   verify
						      error  (right  half
						      is bad)

			  2    .BTKCC	 Count of CRAM data

			  3    .BTKCP	 Pointer  to  CRAM  data  (16-bit
					 data)

			  4    .BTKDC	 Count of DRAM data

			  5    .BTKDP	 Pointer  to  DRAM  data   (8-bit
					 data)

			  6    .BTKRC	 Count of register data

			  7    .BTKRP	 Pointer to register data (16-bit
					 data)

			  8    .BTKSA	 Right-halfword    is	 starting
					 address

					 B0 (BT%KSA)  Right-halfword   is
						      set;  start KMC11

	12	.BTKMS	  Dump a KMC11 (2020 only).  This  function  will
			  optionally  dump  the CRAM, DRAM, and registers
			  if space is provided.  The registers are  SEL0,
			  SEL2, SEL4, SEL6, INDATA, OUTDATA, INBA, OUTBA,
			  and MISC*400+NPR.

			  Argument Block

			  0    .BTKMC	 KMC11 address

			  1    .BTKER	 Error flags returned

					 B0 (BT%CVE)  CRAM  verify  error
						      (right half is bad)

					 B1 (BT%DVE)  DRAM  verify  error
						      (right half is bad)

					 B2 (BT%RVE)  Register	   verify
						      error  (right  half
						      is bad)
			  2    .BTKCC	 Count of CRAM data

   (BOOT)
   

			  3    .BTKCP	 Pointer  to  CRAM  data  (16-bit
					 data)

			  4    .BTKDC	 Count of DRAM data

			  5    .BTKDP	 Pointer  to  DRAM  data   (8-bit
					 data)

			  6    .BTKRC	 Count of register data

			  7    .BTKRP	 Pointer to register data (16-bit
					 data)

	13	.BTRLC	  Return  line	counters.    All   counters   are
			  positive numbers.

			  Argument Block

			  0    .BTPRT	 Port number

			  1    .BTSCC	 Status count counter

			  2    .BTSCP	 Status count pointer

			  3    .BTRCC	 Receive count counter

			  4    .BTRCP	 Receive count pointer

			  5    .BTTCC	 Transmit count counter

			  6    .BTTCP	 Transmit count pointer

	14	.BTCLI	  Convert line id to port number

 			  Argument Block

 			  0    .BTPRT	 Port number
 			  1    .BTLID	 Pointer to ASCIZ line id

 	15	.BTCPN	  Convert NSP port number to line id

 			  Argument Block

 			  0    .BTPRT	 Port number
 			  1    .BTLID	 Pointer to ASCIZ line id

 	16	.BTSTA	  Set the stations polling  state  to  ACTIVE  to
 			  cause  the  terminal to be polled, or set it to
 			  IDLE to prevent the terminal from being polled.
 			  (VT62 on 2020 only)

 			  Argument Block

 			  0    .BTPRT	 Drop,,Line
 			  1    .BTCOD	 Returned protocol  version  type

   (BOOT)
   

 					 (see	 description	of   Boot
 					 function code 6)

 					 0     .BTACT	  Set line active

 					 1     .BTIDL	  Set line idle

 	17	.BTSSP	  Set the startup  priority  value.   This  value
 			  will	specify  the  relative frequency at which
 			  startups are attempted.  That is, for  a  value
 			  of N each active station will be polled N times
 			  for each DDCMP start.  This is used to  prevent
 			  unresponsive	  stations   from   deteriorating
			  performance of a  multi-drop	line.	(VT62  on
			  2020 only)

			  Argument Block

			  0    .BTPRT	 Line
			  1    .BTSPR	 Start priority count

	20	.BTSTP	  Set the polling priority.   This  parameter  is
			  maintained  in the Station Table to specify the
			  realtive polling priority  of  a  station.   If
			  this	feature  is not used, all priority values
			  will default to 1 and polling will proceed in a
			  round robin manner.  (VT62 on 2020 only)

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTPRI	 priority value

					 Typical  range  1  (high)  to	5
					 (low)

	21	.BTSDD	  Send a DDCMP message.  A DDCMP message  wil  be
			  queued  for transmission on the specified line.
			  (VT62 on 2020 only)

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTMSG	 Address of message
			  2    .BTLEN	 Byte count of message

	22	.BTRDD	  Receive a DDCMP  message.   An  item	from  the
			  DDCMP  input	queue  will be returned or .BTLEN
			  will be set to zero  if  the	queue  is  empty.
			  Items  on  the  queue  will  be  data segments,
			  completion   postings,   or	status	 postings
			  (station  going  up  or  down).   (VT62 on 2020
			  only)
   (BOOT)
   

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTMSG	 Address of buffer
			  2    .BTLEN	 Size of user buffer

					 For  data  messages,  the   byte
					 count of the message is returned
					 in .BTLEN.  If the buffer is too
					 small,  the JSYS will fail.  For
					 completion	postings,     the
					 following  will  be  returned in
					 .BTLEN:

					 BT%CTL  (1B0)	+  .BTSUP  (1)	-
					 station came up

					 BT%CTL  (1B0)	+  .BTSDW  (2)	-
					 station went down

					 BT%CTL  (1B0)	+  .BTCMP  (3)	-
					 transmit complete

					 BT%CTL (1B0) + .BTSSF	(4)  -	a
					 startup failed

					 .BTPRT will contain the drop  of
					 the	station    this   message
					 pertains to.

	23	.BTCHN	  Set the  interrupt  channel  so  that  software
			  interrupts will be generated when input data is
			  available.  (VT62 on 2020 only)

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTSIC	 Software interrupt channel

	24	.BTSLS	  Set type of  line  service  to  be  done  on	a
			  synchronous communications line.

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTCOD	 Define protocol

					 Protocol values may be:

					 0     .BTNSP	  NSP protocol	B
					 1     .BTDCP	  DDCMP protocol

   The error status flag returned in word .BTERR on  failure  of  a  BOOT
   call  are  front-end  reload  status bits recorded in the SYSERR error
   (BOOT)
   

   file.  (Refer to the TOPS-20 Error Detection, Recovery, and	Reporting
   Reference Manual for an explanation of these status bits.)

   Generates an illegal instruction interrupt on error conditions below.

   BOOT ERROR MNEMONICS:

   BOTX01:   invalid DTE-20 number

   BOTX02:   invalid byte size

   BOTX03:   invalid protocol version number

   BOTX04:   byte count is not positive

   BOTX05:   protocol initialization failed

   CAPX1:    WHEEL or OPERATOR capability required

   ARGX02:   invalid function


Node: BOUT	Previous: BOOT		Next: CACCT	Up: Top
			      BOUT     JSYS 51

   Outputs a byte sequentially to the specified  destination.	When  the
   byte is written to a file, the file must first be opened, and the size
   of the byte given, with the OPENF call.  When the byte is  written  to
   memory,  a pointer to the location in which to write the byte is given
   in AC1.  This pointer is updated after the call.

   ACCEPTS IN AC1:  destination designator

	      AC2:  the byte to be output, right-justified

   RETURNS     +1:  always

   The BIN monitor call can be used to input a byte sequentially  from	a
   source.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   BOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned
   (BOUT)
   

   DESX5:    file is not open

   IOX2:     file is not open for writing

   IOX5:     device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX11:    quota exceeded or disk full


Node: CACCT	Previous: BOUT	Next: CFIBF	Up: Top
			      CACCT     JSYS 4

   Changes the account for the current job.

  ACCEPTS IN AC1:  account number (decimal) in bits 3-35 if bits 0-2 are
		    5.	 Otherwise  contains  a  byte  pointer to the new
		    account string in the address space of caller.  If	a
		    null byte is not seen, the string is terminated after
		    39 characters are processed.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC1

   The CACCT call sets the current account for the job to  the	specified
   account.   Subsequent  session  charges  will  be to this new account.
   This call also validates the account given if the  account  validation
   facility  is  enabled.  (Refer to the .SFAVR function of the SMON/TMON
   monitor call.)

   The GACCT monitor call can be used  to  return  the	account  for  the
   current job.

   CACCT ERROR MNEMONICS:

   CACTX1:   invalid account identifier

   CACTX2:   job is not logged in

   VACCX0:   Invalid account

   VACCX1:   Account string exceeds 39 characters


Node: CFIBF	Previous: CACCT	Next: CFOBF	Up: Top
			     CFIBF     JSYS 100
   (CFIBF)
   

   Clears the designated file input buffer.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  always

   Is a no-op if the source designator is not associated with a terminal.

   The CFOBF monitor call can be used to clear a designated  file  output
   buffer.

   Generates an illegal instruction interrupt on error conditions below.

   CFIBF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: CFOBF	Previous: CFIBF	Next: CFORK	Up: Top
			     CFOBF     JSYS 101

   Clears the designated file output buffer.

   ACCEPTS IN AC1:  destination designator

   RETURNS     +1:  always

   Is a no-op if the destination designator  is  not  associated  with	a
   terminal.

   The CFIBF call can be used to clear a designated file input buffer.

   Generates an illegal instruction interrupt on error conditions below.

   CFOBF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job
   (CFOBF)
   

   TTYX01:   line is not active


Node: CFORK	Previous: CFOBF	Next: CHFDB	Up: Top
			     CFORK     JSYS 152

   Creates a process inferior to this process. (Refer to Section 2.6.2.)

   ACCEPTS IN AC1:  B0(CR%MAP) make the inferior process' map the same as
			       the  current  process'  map  by	means  of
			       indirect pointers.  If this bit is not on,
			       the inferior process will have no pages in
			       its map.  If desired, the creating process
			       may  then  use PMAP or GET to add pages to
			       the inferior's map.

		    B1(CR%CAP) make the  inferior  process'  capabilities
			       the same as the current process'.  If this
			       bit is not on, the inferior process has no
			       special capabilities.

		    B3(CR%ACS) set the inferior  process'  ACs	from  the
			       block  whose  address  is in AC2.  If this
			       bit is not on, the inferior  process'  ACs
			       are set to 0.

		    B4(CR%ST)  set the PC of the inferior process to  the
			       value  in  the right half of AC1 and start
			       the process.  If this bit is not  on,  the
			       inferior  process  is not started, and the
			       right half of AC1 is ignored.

		    B18-B35    PC value for the inferior process if CR%ST
		    (CR%PCV)   is on.

	      AC2:  address of 20 (octal) word	block  (optional).   This
		    block   contains  the  AC  values  for  the  inferior
		    process.  (Refer to bit CR%ACS above.)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, relative process handle in AC1

   The inferior process receives the same primary input and output  JFN's
   as  the  current  process.	However,  the primary input and/or output
   files may be changed with the SPJFN monitor call.

   The CR%MAP argument in AC1 allows the inferior to see the same address
   space  as  that  of the superior.  The inferior process will have read
   and write access to the  superior's	address  space.   The  pages  are
   shared, and changes made by one process will be seen by the other.
   (CFORK)
   

  CFORK creates a virgin process if CR%ST and CR%MAP are not set.   Note
  that  loading parameters in the AC's using CR%ACS does not make this a
  non-virgin process.	Setting CR%ST and either CR%ACS or CR%MAP creates
  a non-virgin process.

  CFORK creates an execute-only process if bit CR%MAP	is  set  and  the
  creating  process  is an execute-only process.  This is the only other
  way to create an execute-only process besides using the GET JSYS.

   The KFORK monitor call can be used to kill one or more processes.

   CFORK ERROR MNEMONICS:

   FRKHX6:   all relative process handles in use

  FRKHX8:   illegal to manipulate an execute-only process

   CFRKX3:   insufficient system resources


Node: CHFDB	Previous: CFORK	Next: CHKAC	Up: Top
			     CHFDB     JSYS 64

   Changes certain words in the  file  descriptor  block  (FDB)  for  the
   specified  file.   (Refer  to  Section  2.2.8  for  the format of this
   block.)

   ACCEPTS IN AC1:  B0(CF%NUD) do not wait  for  the  disk  copy  of  the
			       directory  to  be  updated.  The specified
			       changes	are  made  to  the  directory  in
			       memory  and  are  written to the disk as a
			       part of the normal monitor  disk  updating
			       procedure.     (See    below    for   more
			       information.)

		    B9-B17     index  into  FDB  indicating  word  to  be
		    (CF%DSP)   changed

		    B18-B35    JFN
		    (CF%JFN)

	      AC2:  mask indicating bits to be changed.   If  changing	a
		    count value (in AC3), use -1 as a mask.

	      AC3:  new values for changed bits.  These  values  must  be
		    given  in the bit positions corresponding to the mask
		    given in AC2.

   RETURNS     +1:  always

  The following table lists the JSYS's that are used to  set  the  words
  and bits of the FDB:
   (CHFDB)
   

   Word	  Bits	    JSYS

  .FBHDR	  none	    unchangeable

  .FBCTL	  B0-B1     CHFDB

		  FB%NEX    unchangeable

		  FB%DEL    CHFDB

		  B4-B5     unchangeable

		  B6	    reserved

		  FB%DIR    unchangeable

		  FB%NOD    CHFDB (owner/write access)

		  B9-B10    unchangeable

		  FB%ARC    ARCF

		  FB%INV    CHFDB

		  FB%OFF    ARCF

		  FB%CTL    CHFDB (owner)

  .FBEXL	  none	    unchangeable

  .FBADR	  none	    unchangeable

  .FBPRT	  B18-B35   CHFDB (owner)

  .FBCRE	  all	    CHFDB (WHEEL/OPERATOR)

  .FBAUT	  all	    SFUST

  .FBGEN	  none	    unchangeable

  .FBACT	  all	    SACTF

  .FBBYV	  FB%RET    CHFDB (owner)

		  FB%BSZ    CHFDB (owner/write access)

		  FB%MOD    CHFDB (owner/write access)

		  FB%PGC    CHFDB (WHEEL/OPERATOR)

  .FBSIZ	  all	    CHFDB (owner/write access)

  .FBCRV	  all	    CHFDB (owner/write access)

  .FBWRT	  all	    CHFDB (owner/write access)
   (CHFDB)
   

  .FBREF	  all	    CHFDB (owner/write access)

  .FBCNT	  all	    CHFDB (WHEEL/OPERATOR)

  .FBBK0	  none	    unchangeable

  .FBBK1	  none	    unchangeable

  .FBBK2	  none	    unchangeable

  .FBBBT	  B0-B5     ARCF

		  AR%1ST    CHFDB (WHEEL/OPERATOR)

		  AR%RFL    ARCF

		  AR%PSZ    DELF

  .FBNET	  all	    SFTAD

  .FBUSW	  all	    CHFDB (owner)

  .FBGNL	  none	    unchangeable

  .FBNAM	  none	    unchangeable

  .FBEXT	  none	    unchangeable

  .FBLWR	  all	    SFUST

  .FBTDT	  all	    ARCF

  .FBFET	  all	    SFTAD

  .FBTP1	  all	    ARCF

  .FBSS1	  all	    ARCF

  .FBTP2	  all	    ARCF

  .FBSS2	  all	    ARCF

   Because each CHFDB call changes only one  word  in  the  FDB,  several
   calls must be executed to change several words.  Each call causes disk
   I/O, and to keep this I/O to a minimum, the	program  should  set  bit
   CF%NUD on each call.  The setting of this bit on each call permits the
   program to run faster by allowing several changes to be  made  to  the
   FDB	with  minimum disk I/O.  To ensure that all the changes have been
   written to the disk, the program can issue the last	CHFDB  call  with
   bit	CF%NUD off.  Also, if the program requires the FDB on the disk to
   be updated after each call, it should execute each CHFDB call with bit
   CF%NUD off.
   (CHFDB)
   

   The GTFDB monitor call can be used to return the file descriptor block
   for	a  specified  file.  The GFUST monitor call can be used to return
   the name strings of the author of the file and the user who last wrote
   the file.  The GACTF call can be used to obtain the account designator
   of the file.

   Generates an illegal instruction interrupt on error conditions below.

   CHFDB ERROR MNEMONICS:

   CFDBX1:   invalid displacement

   CFDBX2:   illegal to change specified bits

   CFDBX3:   write or owner access required

   CFDBX4:   invalid value for specified bits

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators
   (CHKAC)
   


Node: CHKAC	Previous: CHFDB	Next: CIS	Up: Top
			     CHKAC     JSYS 521

   Checks if a user is allowed access to  files  in  a	given  directory.
   This  monitor  call	is  used to determine if the user will be able to
   access files having a given protection code if the user is  logged  in
   with the given capabilities and connected to the directory.

   ACCEPTS IN AC1:  length of the argument block in the right  half.   If
		    B0(CK%JFN)	is  on, word .CKAUD of the argument block
		    contains a JFN.

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success,  access  check  is   completed,   with   AC1
		    containing	-1 if access is allowed or 0 if access is
		    not allowed.

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

	0    .CKAAC	    Code of desired access to files.

	1    .CKALD	    Byte pointer to user name string,  or  36-bit
			    user  number  of  user  whose access is being
			    checked.

	2    .CKACD	    Byte pointer to directory name  string  (with
			    punctuation),  or  36-bit directory number to
			    which user whose access is being  checked  is
			    connected.

	3    .CKAEC	    Enabled capabilities of user whose access  is
			    being checked.  (Refer to Section 2.6.1.)

	4    .CKAUD	    Byte pointer to directory name  string  (with
			    punctuation),  or  36-bit directory number of
			    the  directory  containing	the  files  being
			    accessed.	If  B0(CK%JFN) of AC1 is on, this
			    word  contains  a  JFN  for  the  file  being
			    accessed.

	5    .CKAPR	    Protection	of  the  files	being	accessed.
			    (Refer  to	Section  2.2.6.) This word is not
			    required if a JFN is supplied in word .CKAUD.

   Access codes are as follows:

	0    .CKARD    read existing files
	1    .CKAWR    write existing files
	2    .CKAEX    execute existing files
	3    .CKAAP    append to existing files
   (CHKAC)
   

	4    .CKADL    obtain directory listing of existing files
	6    .CKADR    read the directory
	10   .CKACN    connect to the directory
	11   .CKACF    create files in the directory

   CHKAC ERROR MNEMONICS:

   CKAX1:    argument block too small

   CKAX2:    invalid directory number

   CKAX3:    invalid access code

   CKAX4:    file is not on disk


Node: CIS	Previous: CHKAC	Next: CLOSF	Up: Top
			      CIS     JSYS 141

   Clears the software interrupt system for the current process.   Clears
   all interrupts in progress and all waiting interrupts.

   RETURNS     +1:  always


Node: CLOSF	Previous: CIS	Next: CLZFF	Up: Top
			     CLOSF     JSYS 22

   Closes a specific file or all files.

   ACCEPTS IN AC1:  B0(CO%NRJ) do not release the JFN

		    B6(CZ%ABT) abort  any  output  operations	currently
			       being  done.   Close  the  file but do not
			       perform any  cleanup  operations  normally
			       associated  with  closing a file (e.g., do
			       not output remaining buffers or write tape
			       marks  if  output  to  a  magnetic tape is
			       aborted).  If output to a  new  disk  file
			       that   has   not  been  closed  (i.e.,  is
			       nonexistent)  is  aborted,  the	file   is
			       closed and then expunged.

		    B7(CZ%NUD) do not update the copy of the directory on
			       the  disk.   (Refer to CF%NUD of the CHFDB
			       call description for further information.)

		    B18-B35    JFN of the file being closed
		    (CO%JFN)
   (CLOSF)
   

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   If AC1 contains -1, all files (and all JFN's) at or below this process
   (with  the exception of the primary I/O files and files that cannot be
   closed by this process) are closed.	This action is identical to  that
   taken  on  a  CLZFF call with AC1 containing the process handle .FHSLF
   (400000).

   The OPENF monitor call can be used to open a specific file.

   CLOSF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   CLSX1:    file is not open

   CLSX2:    file cannot be closed by this process

   CLSX3:    file still mapped

   CLSX4:    device still active

   ENQX20:   locked JFN cannot be closed

   IOX11:    quota exceeded or disk full

   All output errors may occur.


Node: CLZFF	Previous: CLOSF	Next: COMND	Up: Top
			     CLZFF     JSYS 34

   Closes process' files.  Closes all files and/or releases all JFN's  at
   and/or below a specified process.

   ACCEPTS IN AC1:  B0(CZ%NIF) do not close files of inferior processes

		    B1(CZ%NSF) do not close files of this process

		    B2(CZ%NRJ) do not release JFNs

		    B3(CZ%NCL) do not  close  any  files;   only  release
			       non-open JFNs
   (CLZFF)
   

		    B4(CZ%UNR) unrestrict files  opened  with  restricted
			       access	for   specified   process.    The
			       specified process must be the same  as  or
			       inferior  to  the  process  executing  the
			       call.

		    B5(CZ%ARJ) wait until file can be closed, then  close
			       it, and release JFNs

		    B6(CZ%ABT) abort  any  output  operations	currently
			       being  done.   Close  the  file but do not
			       perform any  cleanup  operations  normally
			       associated  with  closing a file (e.g., do
			       not output remaining buffers or write tape
			       marks  if  output  to  a  magnetic tape is
			       aborted).  If output to a  new  disk  file
			       that   has   not  been  closed  (i.e.,  is
			       nonexistent)  is  aborted,  the	file   is
			       closed and then expunged.

		    B7(CZ%NUD) do not update the copy of the directory on
			       the  disk.   (Refer to CF%NUD of the CHFDB
			       call description for further information.)

		    B18-B35    process handle
		    (CZ%PRH)

   RETURNS     +1:  always.  No action is taken if the call is in any way
		    illegal.

   If AC1  contains  only  the	process  handle  .FHSLF,  the  action  is
   identical to that taken on a CLOSF call with AC1 containing -1.

   Generates an illegal instruction interrupt on error conditions below.

   CLZFF ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of  multiple process handle

   IOX11:    quota exceeded or disk full


Node: COMND	Previous: CLZFF	Next: CRDIR	Up: Top
			     COMND     JSYS 544

   Parses one field of a command that  is  either  typed  by  a  user  or
   contained in a file.  When this monitor call is used to read a command
   from a terminal, it provides the following features:
   (COMND)
   

	1.  Allows the input of a command (including the guide words)  to
	    be given in abbreviated, recognition (ESC and CTRL/F), and/or
	    full input mode.

	2.  Allows the user to edit his input with  the  DELETE,  CTRL/U,
	    CTRL/W, and CTRL/R editing keys.

	3.  Allows fields of the command to be defaulted  if  an  ESC  or
	    CTRL/F  is	typed at the beginning of any field or if a field
	    is omitted entirely.

	4.  Allows a help message to be given if a question mark  (?)  is
	    typed at the beginning of any field.

	5.  Allows input of an indirect file (@file)  that  contains  the
	    fields for all or the remainder of the command.

	6.  Allows a recall of the correct portion of  the  last  command
	    (i.e.,  up	to  the beginning of the field where an error was
	    detected) if the next command line begins with  CTRL/H.   The
	    correct  portion  of the command is retyped, and the user can
	    then continue typing from that point.

	7.  Allows input of a line to be continued onto the next line  if
	    the  user types a hyphen (-) immediately preceding a carriage
	    return.  (The carriage return is  invisible  to  the  program
	    executing  the  COMND call, although it is stored in the text
	    buffer.) The hyphen can be typed by  the  user  while  he  is
	    typing  a  comment.   The  comment is then continued onto the
	    next line.

   The COMND call allows the command line that	is  input  to  contain	a
   comment if the comment is preceded by either an exclamation point or a
   semicolon and the previous field has been terminated.  When the  COMND
   call  inputs  an  exclamation  point  after	a  field  that	has  been
   terminated, it ignores all text on the remainder of the line or up  to
   the	next  exclamation  point.  When the COMND call inputs a semicolon
   after a field that has been terminated, it ignores  all  text  on  the
   remainder of the line.

   When an indirect file is given on the command line, it can be given at
   the	beginning  of any field.  However, it must be the last item typed
   on the line, and its contents must complete the current command.   The
   user  must  terminate  his  input  of  the  indirect  file  (after any
   recognition is performed) with a carriage  return.	If  he	does  not
   terminate  his  input,  the	message  ?INDIRECT  FILE NOT CONFIRMED is
   output.  Also, if the user types a question mark (instead of the  file
   specification  of  the  indirect file) after he types the @ character,
   the message FILESPEC OF INDIRECT FILE is output.   The  indirect  file
   itself  should  not	contain  an  ESC  or  carriage	return;  if these
   characters are included, they will be treated as spaces.  The contents
   of  the  indirect file are placed in the text buffer but are not typed
   on the user's terminal.

   As the user types his command, the characters are placed in a  command
								  
   (COMND)
   

   text buffer.  This buffer can also include the command line prompt, if
    
   any.  Several byte pointers and counts reflect the  current	state  of
   the parsing of the command.	These pointers and counts are as follows:

	1.  Byte pointer to the beginning of  the  prompting-text  buffer
	    (.CMRTY).  This pointer is also called the CTRL/R buffer byte
	    pointer since it indicates the initial part of the text  that
	    will  be  output  on  a  CTRL/R.   (The remainder of the text
	    output on a CTRL/R is what the user had typed before he typed
	    CTRL/R.)  The  buffer  containing  the  prompt  need  not  be
	    contiguous with the buffer containing the  remainder  of  the
	    command  line.   Typically this pointer is to a string in the
	    literals area.

	2.  Byte pointer to the beginning of the user's  input	(.CMBFP).
	    This is the limit back to which the user can edit.

	3.  Byte pointer to the beginning of the next field to be  parsed
	    (.CMPTR).

	4.  Count of  the  space  remaining  in  the  text  input  buffer
	    (.CMCNT).

	5.  Count of the number of characters in the buffer that have not
	    yet been parsed (.CMINC).

   The illustration below is a logical arrangement of the  byte  pointers
   and	counts.  Remember that the prompting-text buffer does not have to
   be adjacent to the text buffer.

						       .CMCNT

		!=======================================================!
		!	 !		!		  !		!
		!	 !		!		  !		!
		!=======================================================!
		^	 ^		^
		!	 !		!
		!	 !		!	 .CMINC
		!	 !		!
		!	 !		!
		!	 .CMBFP 	.CMPTR
		.CMRTY

   These byte pointers and other information are contained in  a  command
								  
   state  block,  whose  address  is  given  as  an argument to the COMND
     
   monitor call.  The .CMINI function initializes these pointers.

   Parsing of a command is performed field by field and by default begins
   when  the user types a carriage return, ESC, CTRL/F, or question mark.
   These characters are called action characters because they  cause  the
   (COMND)
   

   system  to  act  on	the command as typed so far.  A field can also be
   terminated  with  a	space,	tab,   slash,	comma,	 or   any   other
   nonalphanumeric  character.	Normally, the parsing does not begin, and
   the COMND call does not return control to the program, until an action
   character  is typed.  However, if B8(CM%WKF) is on in word .CMFLG when
   the COMND call  is  executed,  parsing  begins  after  each	field  is
   terminated.

   The command is parsed by repeated COMND calls.   Each  call	specifies
   the	type  of  field expected to be parsed by supplying an appropriate
   function code and any data needed for the function.	This  information
   is  given in a function descriptor block.  On successful completion of
		    
   each call, the current byte pointers and the counts are updated in the
   command state block, and any data obtained for the field is returned.

   The program executing  the  COMND  call  should  not  reset	the  byte
   pointers  in the command state block after it completes the parsing of
   each command.  It should set up the state block once at the	beginning
   and then use the .CMINI function when it begins parsing each line of a
   command.  This is true because  the	.CMINI	function  implements  the
   CTRL/H  error  recovery  feature  in addition to initializing the byte
   pointers in the state block and printing the prompt for the line.   If
   the	program  resets  the pointers, the CTRL/H feature is not possible
   because the pointers from the  previous  command  are  not  available.
   When a CTRL/H is input, the .CMINI function allows error recovery from
   the last command only if both (1) the pointer to the beginning of  the
   user's  input (.CMBFP) is not equal to the pointer to the beginning of
   the next field to be parsed (.CMPTR) and (2) the last character parsed
   in the previous command was not an end-of-line character.

   The design of the COMND call allows the user to delete his typed input
   with  the  DELETE,  CTRL/W,	and  CTRL/U  keys without regard to field
   boundaries.	When the user deletes into a field that has already  been
   parsed,  the  COMND call returns to the program with B3(CM%RPT) set in
   word .CMFLG.  This return informs the program to  forget  the  current
   state  of  the  command and to reparse from the beginning of the line.
   Because the complete line as typed and corrected by the user is in the
   text  buffer, the parse can be repeated and will yield the same result
   up to the point of the change.

   The calling sequence to the COMND call is as follows:

   ACCEPTS IN AC1:  address of the command state block

	      AC2:  address of the first alternative function  descriptor
		    block

   RETURNS     +1:  always (unless a reparse is needed and the right half
		    of .CMFLG is nonzero), with
		    AC1 containing  flags  in  the  left  half,  and  the
			address  of  the command state block in the right
			half.  The flags are copied from word  .CMFLG  in
			the command state block.
		    AC2 containing either the data obtained for the field
			or an error code if the field could not be parsed
   (COMND)
   

			(CM%NOP is on).
		    AC3 containing in the left half the  address  of  the
			function  descriptor block given in the call, and
			in the right half the  address	of  the  function
			descriptor  block  actually  used  (i.e., the one
			that matched the input).

   The format of the command state block is shown below.

	   0			    17 18			35
	  !=======================================================!
   .CMFLG !	    Flag Bits	      ! Reparse Dispatch Address  !
	  !-------------------------------------------------------!
   .CMIOJ !	    Input JFN	      !        Output JFN	  !
	  !-------------------------------------------------------!
   .CMRTY !		 Byte Pointer to CTRL/R Text		  !
	  !-------------------------------------------------------!
   .CMBFP !	     Byte Pointer to Start of Text Buffer	  !
	  !-------------------------------------------------------!
   .CMPTR !	   Byte Pointer to Next Input To Be Parsed	  !
	  !-------------------------------------------------------!
   .CMCNT !		Count of Space Left in Buffer		  !
	  !-------------------------------------------------------!
   .CMINC !	     Count of Characters Left in Buffer 	  !
	  !-------------------------------------------------------!
   .CMABP !		 Byte Pointer to Atom Buffer		  !
	  !-------------------------------------------------------!
   .CMABC !		     Size of Atom Buffer		  !
	  !-------------------------------------------------------!
   .CMGJB !	       Address of GTJFN Argument Block		  !
	  !=======================================================!

			    Command State Block
			      

   Word      Symbol		      Meaning

     0	     .CMFLG    Flag bits  in  the  left  half,	and  the  reparse
		       dispatch  address  in  the  right half.	Some flag
		       bits can be set by the program executing the COMND
		       call;   others  can be set by the COMND call after
		       its execution.  The bits that can be  set  by  the
		       program	are described following the Command State
		       Block description.  The bits that can  be  set  by
		       COMND   are   described	 following  the  Function
		       Descriptor Block description.

		       The reparse dispatch address is	the  location  to
		       which  control is automatically transferred when a
		       reparse of the command is needed because the  user
		       edited  past  the  current pointer (i.e., the user
		       edited characters that were already  parsed).   If
		       this field is zero, the COMND call sets B3(CM%RPT)
		       in the left half of this word  and  gives  the  +1
   (COMND)
   

		       return when a reparse is needed.  The program must
		       then test CM%RPT and, if on, must reenter the code
		       that  parses the first field of the command.  When
		       the reparse dispatch address is given, control  is
		       transferred automatically to that address.

		       The code at the reparse	dispatch  address  should
		       initialize  the	program's  state  to  what it was
		       after   the   last    .CMINI    function.     This
		       initialization  should include resetting the stack
		       pointer, closing and releasing any  JFNs  acquired
		       since  the  last .CMINI function, and transferring
		       control to the code immediately following the last
		       .CMINI function call.

     1	     .CMIOJ    Input JFN in the left half, and output JFN in  the
		       right half.  These designators identify the source
		       for the input of the command and  the  destination
		       for   the   output   of	 the  typescript.   These
		       designators are usually	.PRIIN	(for  input)  and
		       .PRIOU (for output).

     2	     .CMRTY    Byte   pointer	to   the   beginning	of    the
		       prompting-text.

     3	     .CMBFP    Byte pointer to the beginning of the user's input.
		       The user cannot edit back past this pointer.

     4	     .CMPTR    Byte pointer to the beginning of the next field to
		       be parsed.

     5	     .CMCNT    Count of the space remaining in the  buffer  after
		       the .CMPTR pointer.

     6	     .CMINC    Count of the number of unparsed characters in  the
		       buffer after the .CMPTR pointer.

     7	     .CMABP    Byte pointer  to  the  atom  buffer,  a	temporary
		       storage buffer that contains the last field parsed
		       by the COMND call.  The terminator of the field is
		       not  placed  in	this  buffer.  The atom buffer is
		       terminated with a null.

     10      .CMABC    Count of the number  of	characters  in	the  atom
		       buffer.	This count should be at least as large as
		       the largest field expected to be parsed.

     11      .CMGJB    Address of a GTJFN  argument  block.   This  block
		       must  be at least 16(octal) words long and must be
		       writable.   If  a  longer  GTJFN  block	is  being
		       reserved,  the  count  in  the  right half of word
		       .GJF2 of the GTJFN argument block must be  greater
		       than four.  This block is usually filled in by the
		       COMND call with arguments for the  GTJFN  call  if
		       the  specified function is requesting a JFN (i.e.,
   (COMND)
   

		       functions .CMIFI, .CMOFI, and .CMFIL).	The  user
		       should  store  data  in	this  block on the .CMFIL
		       function only.

  The flag bits that can be set by the user in the  left  half  of  word
  .CMFLG  in  the  Command  State Block are described below.  These bits
  apply to the parsing of the entire command and are preserved by  COMND
  after  execution.   See  the  end of the COMND JSYS discussion for the
  bits that are returned by COMND in the left half of word .CMFLG.

		 Bits Supplied in State Block on COMND Call
		        

      Bit    Symbol		      Meaning

       6     CM%RAI	    Convert lowercase input to uppercase.

       7     CM%XIF	    Do	not  recognize	 the   @   character   as
			    designating   an   indirect   file;   instead
			    consider   the    character    as	 ordinary
			    punctuation.   A  program  sets  this  bit to
			    prevent the input of an indirect file.

       8     CM%WKF	    Begin parsing after each field is  terminated
			    instead  of  only  after  an action character
			    (carriage return, ESC, CTRL/F, question mark)
			    is	typed.	 For example, a program sets this
			    bit    if	 it    must    change	 terminal
			    characteristics   (e.g.,  it  must	turn  off
			    echoing because a password may be  input)  in
			    the  middle  of  a	command.  However, use of
			    this bit is not recommended because  terminal
			    wakeup occurs after each field is terminated,
			    thereby  increasing  system  overhead.    The
			    recommended   method   of  changing  terminal
			    characteristics within a command is to  input
			    the     field     requiring    the	  special
			    characteristic on the next line with its  own
			    prompt.    For   example,  if  a  program  is
			    accepting a  password,  it	should	turn  off
			    echoing after the .CMCFM function of the main
			    command and perform the  .CMINI  function  to
			    type  the prompt requesting a password on the
			    next line.

   The format of the function descriptor block is shown below.

	  0	      8 9	   17 18		       35
	 !=======================================================!
	 !  function   !  function   ! address of next function  !
   .CMFNP!    code     !    flags    !	   descriptor block	 !
	 !-------------------------------------------------------!
   .CMDAT!		Data for specific function		 !
	 !-------------------------------------------------------!
   (COMND)
   

   .CMHLP!	    Byte pointer to help text for field 	 !
	 !-------------------------------------------------------!
   .CMDEF!	  Byte pointer to default string for field	 !
	 !-------------------------------------------------------!
  .CMBRK!	       Pointer to 4-word break mask		 !
	 !=======================================================!

			 Function Descriptor Block
			   

   Word      Symbol		      Meaning

     0	     .CMFNP    Function  code  and  pointer  to   next	 function
		       descriptor block.
		       B0-B8(CM%FNC)   Function code
		       B9-B17(CM%FFL)  Function-specific flags
		       B18-B35(CM%LST) Address	of  the   next	 function
				       descriptor block

     1	     .CMDAT    Data for the specific function, if any.

     2	     .CMHLP    Byte pointer to the  help  text	for  this  field.
		       This  word  can	be  zero  if  the  program is not
		       supplying its own help text.  CM%HPP must  be  set
		       (in word 0) in order for this pointer to be used.

     3	     .CMDEF    Byte pointer to the default string for this field.
		       This  word  can	be  zero  if  the  program is not
		       supplying its own default string.

    4	     .CMBRK    Pointer to a  4-word  break  mask  that	specifies
		       which  characters  constitute  end of field.  Word
		       .CMBRK is ignored unless CM%BRK (B13) is on.

   The individual words in the function descriptor block are described in
   the following paragraphs.

   Words .CMFNP and .CMDAT of the function descriptor block
           

   Word .CMFNP contains the function code for the expected  field  to  be
   parsed,  and  word .CMDAT contains any additional data needed for that
   function.  The function codes, along with any required  data  for  the
   functions, are described below.

   Code      Symbol		      Meaning

    0	     .CMKEY    Parse a keyword, such as  a  command  name.   Word
		       .CMDAT  contains  the  address of a keyword symbol
		       table in the format described in the TBLUK monitor
		       call  description  (i.e., alphabetical).  The data
		       bits that can be defined in the right half of  the
		       first word of the argument pointed to by the table
		       entries (when B0-B6 of the first word are off  and
		       B7(CM%FW) is on) are as follows:
   (COMND)
   

		       B35(CM%INV)    Suppress this keyword in	the  list
				      output on a ?.  The program can set
				      this bit to include entries in  the
				      table   that  should  be	invisible
				      because  they  are  not	preferred
				      keywords.   For  example,  this bit
				      can be set  to  allow  the  keyword
				      LIST  to	be valid, even though the
				      preferred  keyword  may  be  PRINT.
				      The   LIST  keyword  would  not  be
				      listed in the output given on a  ?.
				      This    bit   is	 also	used   in
				      conjunction with the CM%ABR bit  to
				      suppress	an  abbreviation  in  the
				      output given on a ?.

		       B34(CM%NOR)    Do not recognize this keyword  even
				      if  an  exact match is typed by the
				      user and suppress  its  listing  in
				      the  list output on a ?.	(Refer to
				      the TBLUK call description for more
				      information on using this bit.)

		       B33(CM%ABR)    Consider	this  keyword	a   valid
				      abbreviation  for  another entry in
				      the table.  The right half of  this
				      table  entry  points to the keyword
				      for which this is an  abbreviation.
				      The  program  can  set  this bit to
				      include entries in the  table  that
				      are  less  than  the minimum unique
				      abbreviation.   For  example,  this
				      bit can be set to include the entry
				      ST (for START) in  the  table.   If
				      the   user   then  types	ST  as	a
				      keyword, it will be accepted  as	a
				      valid   abbreviation   even  though
				      there   may   be	 other	 keywords
				      beginning with ST.  To suppress the
				      output of this abbreviation in  the
				      list typed on a ?, the program must
				      also set the CM%INV bit.

		       On a successful return, AC2 contains  the  address
		       of the table entry where the keyword was found.

    1	     .CMNUM    Parse a number.	Word .CMDAT  contains  the  radix
		       (from  2  to  10)  of the number.  On a successful
		       return, AC2 contains the number.

    2	     .CMNOI    Parse a guide word string, but do  not  return  an
		       error  if  no  guide  word  is input.  An error is
		       returned only if a guide word is input  that  does
		       not  match  the one expected by the COMND call.	A
		       guide word field must be delimited by parentheses.
   (COMND)
   

		       Word  .CMDAT  contains  a byte pointer to an ASCIZ
		       string.	 This  string  does   not   contain   the
		       parentheses  of	the  guide word.  Guide words are
		       output if the user terminated the  previous  field
		       with  ESC.   Guide  words  are not output, nor can
		       they be input, if the user has caused parsing into
		       the next field.

    3	     .CMSWI    Parse a switch.	A switch field must begin with	a
		       slash  and  can	be  terminated	with  a  colon in
		       addition to any of the  legal  terminators.   Word
		       .CMDAT  contains  the  address of a switch keyword
		       symbol table.  (Refer to the  TBLUK  monitor  call
		       description  for  the  format  of  the table.) The
		       entries in the table do not contain the	slash  of
		       the  switch  keywords;	however,  they should end
		       with a colon if the switch requires a value.   The
		       data  bits  CM%INV, CM%NOR, and CM%ABR defined for
		       the .CMKEY  function  can  also	be  set  on  this
		       function.   On  a  successful return, AC2 contains
		       the address of the table entry  where  the  switch
		       keyword was found.

    4	     .CMIFI    Parse an input file specification.  This  function
		       causes  the  COMND call to execute a GTJFN call to
		       attempt to parse the specification for an existing
		       file, using no default fields.  The .CMGJB address
		       (word 11 in  the  command  state  block)  must  be
		       supplied,  but  the  GTJFN  block should be empty.
		       (Data stored in the block will be  overwritten  by
		       the  COMND  JSYS.   Also,  certain GTJFN flags are
		       set.) On a successful return, AC2 contains the JFN
		       assigned.   Hyphens  are  treated  as alphanumeric
		       characters for this function

		       See note following .CMFIL function.

    5	     .CMOFI    Parse an output file specification.  This function
		       causes  the  COMND call to execute a GTJFN call to
		       attempt to parse the specification  for	either	a
		       new  or	an existing file.  The default generation
		       number is the generation number	of  the  existing
		       file plus 1.  The .CMGJB address must be supplied,
		       but the GTJFN block should be empty.  (Data stored
		       in  the	block  will  be  overwritten by the COMND
		       JSYS.  Also, certain GTJFN flags are  set.)  On	a
		       successful  return, AC2 contains the JFN assigned.
		       Hyphens are treated as alphanumeric characters for
		       this function.

		       See note following .CMFIL function.

    6	     .CMFIL    Parse a general	(arbitrary)  file  specification.
		       This  function  causes the COMND call to execute a
   (COMND)
   

		       GTJFN to attempt to parse  the  specification  for
		       the  file.   The  .CMGJB address must be supplied,
		       but data stored in  certain  words  of  the  GTJFN
		       block  will  be	overwritten by the COMND JSYS and
		       certain GTJFN flags will be set (see note  below).
		       On  a  successful  return,  AC2	contains  the JFN
		       assigned.  Hyphens  are	treated  as  alphanumeric
		       characters for this function.

		       Note that portions of  the  GTJFN  block  used  by
		       functions   .CMOFI,   .CMIFI,   and   .CMFIL   are
		       controlled by COMND.   The  following  list  shows
		       which  words  are  under  the control of COMND and
		       which words are under the control of the user:

		       GTJFN	  Controlled	Characteristics
		       Word(s)	  by

		       .GJGEN	  COMND

						1.  .CMOFI   sets   flags
						    GJ%FOU,  GJ%MSG,  and
						    GJ%XTN and clears all
						    other flags.

						2.  .CMIFI   sets    flag
						    GJ%OLD,   and  GJ%XTN
						    and clears all  other
						    flags.

						3.  .CMOFI   and   .CMIFI
						    zero  the  right half
						    of word .GJGEN

						4.  .CMFIL   sets    flag
						    GJ%XTN   and   clears
						    GJ%FCM

		       .GJSRC	  COMND 	None

		       .GJDEV -
		       .GJJFN	  COMND/
				  USER		Functions   .CMIFI    AND
						.CMOFI give COMND control
						of these  words.   .CMFIL
						gives the user control of
						these words.
		       .GJF2 -
		       .GJATR	  COMND 	None

    7	     .CMFLD    Parse an arbitrary field.  This function is useful
		       for fields not normally handled by the COMND call.
		       The   input,   as   delimited   by    the    first
		       nonalphanumeric character, is copied into the atom
		       buffer;	the delimiter is not  copied.	Note  the
   (COMND)
   

		       following:

		       1.  This function will parse a null field

		       2.  Hyphens are treated as alphanumeric characters
			   for this function

		       3.  No validation is performed (such  as  filename
			   validation)

		       4.  No standard help  message  is  available  (see
			   below)

		       5.  The FLDBK. and BRMSK. macros may be	used  for
			   including  other characters in the field (like
			   "*").

    10	     .CMCFM    Confirm.  This function	waits  for  the  user  to
		       confirm	the  command  with  a carriage return and
		       should be used at the end  of  parsing  a  command
		       line.

    11	     .CMDIR    Parse a	directory  name.   Login  and  files-only
		       directories  are  allowed.   Word  .CMDAT contains
		       data  bits  for	this  function.   The	currently
		       defined bit is as follows:

		       B0(CM%DWC)     Allow  wildcard  characters  to  be
				      typed in a directory name.

		       On a successful return, AC2  contains  the  36-bit
		       directory number.

    12	     .CMUSR    Parse a user name.   Only  login  directories  are
		       allowed.  On a successful return, AC2 contains the
		       36-bit user number.

    13	     .CMCMA    Comma.  Sets B1(CM%NOP-no parse) in word .CMFLG of
		       the  command state block and returns if a comma is
		       not the next item in the input.	Blanks can appear
		       on  either  side  of  the comma.  This function is
		       useful for parsing a list of arguments.

   14	     .CMINI    Initialize the command line (e.g., set up internal
		       monitor	pointers,  type the prompt, and check for
		       CTRL/H).  This function	should	be  used  at  the
		       beginning  of  parsing a command line but not when
		       reparsing a line.  Otherwise, the  CTRL/H  feature
		       will not work.

		       To use this function, the  user	first  moves  the
		       appropriate  data into the command state block and
		       then issues .CMINI.  If, at any	time  during  the
   (COMND)
   

		       parsing	of  a  line,  an  error occurs, .CMINI is
		       issued again to reinitialize the  line.	 However,
		       for  the 2'nd thru N'th invocation of .CMINI for a
		       given line, the user should  not  alter	the  byte
		       pointers and character counts in the command state
		       block.  To do so would disable the CTRL/H feature.
		       This feature allows the user program, on parsing a
		       bad atom, to print an error message,  reissue  the
		       prompt,	and  parse the command line again without
		       forcing the user to retype the entire line.

		       If .CMINI reads a CTRL/H  character,  .CMINI  will
		       reset  all  byte  pointers  and	character  counts
		       except the .CMINC count to their  original  state.
		       .CMINI  will set the .CMINC count to the number of
		       characters in the  buffer  up  to  the  bad  atom.
		       These  characters  are  output to the terminal and
		       parsed again.  Control then passes to the  reparse
		       address	(if provided) and normal parsing resumes.
		       The effect on the program is as if  the	bad  atom
		       had never been typed.

    15	     .CMFLT    Parse a floating-point number.	On  a  successful
		       return, AC2 contains the floating-point number.

    16	     .CMDEV    Parse a device name.  On a successful return,  AC2
		       contains the device designator.

    17	     .CMTXT    Parse the input	text  up  to  the  next  carriage
		       return,	place  the  text  in the atom buffer, and
		       return.	If an ESC or CTRL/F is typed,  it  causes
		       the  terminal bell to ring (because recognition is
		       not available with this function) and is otherwise
		       ignored.    If  a  ?   is  typed,  an  appropriate
		       response is given, and the ? is	not  included  in
		       the  atom  buffer.   (A	? can  be included in the
		       input text if it is preceded by a CTRL/V.)

    20	     .CMTAD    Parse a date and/or time field  according  to  the
		       setting	of bits CM%IDA and CM%ITM.  The user must
		       input the field as  requested.	Any  date  format
		       allowed by the IDTIM call can be input.	If a date
		       is not input, it is  assumed  to  be  the  current
		       date.  If a time is not input, it is assumed to be
		       00:00:01.  When both the date and time fields  are
		       input,  they  must  be  separated  by  one or more
		       spaces.	If the fields are input separately,  they
		       must  be  terminated  with  a  space  or  carriage
		       return.	Word .CMDAT contains  bits  in	the  left
		       half  and an address in the right half as data for
		       the function.  The bits are:

		       B0(CM%IDA) Parse a date
		       B1(CM%ITM) Parse a time
		       B2(CM%NCI) Do not convert the date and/or time  to
   (COMND)
   

				  internal  format.   (Refer  to  Section
				  2.8.2.)

		       The address in the right half is the beginning  of
		       a  3-word block in the caller's address space.  On
		       a successful  return,  this  block  contains  data
		       returned  from the IDTNC call executed by COMND if
		       B2(CM%NCI) was on in the COMND call (i.e., if  the
		       input  date  and/or  time  field  was  not  to  be
		       converted to internal format).  If B2(CM%NCI)  was
		       off in the COMND call, on a successful return, AC2
		       contains the internal date and time format.

    21	     .CMQST    Parse a quoted string up to the terminating quote.
		       The  delimiters	for  the  string  must	be double
		       quotation marks and are not  copied  to	the  atom
		       buffer.	 A double quotation mark is input as part
		       of the string if two double quotation marks appear
		       together.   This  function  is useful if the legal
		       field terminators and the action characters are to
		       be  included  as part of a string.  The characters
		       ?, ESC, and  CTRL/F  are  not  treated  as  action
		       characters  and	are included in the string stored
		       in the atom buffer.  Carriage return is an invalid
		       character in a quoted string and causes B1(CM%NOP)
		       to be set on return.

    22	     .CMUQS    Parse  an  unquoted  string  up	to  one  of   the
		       specified  break characters.  Word .CMDAT contains
		       the  address  of  a  4-word  block  of  128  break
		       character mask bits.  (Refer to word .RDBRK of the
		       TEXTI call description for an explanation  of  the
		       mask.)  The  characters	scanned are not placed in
		       the atom buffer.  On return, .CMPTR is pointing to
		       the  break character.  This function is useful for
		       parsing a string with an arbitrary delimiter.  The
		       characters  ?,  ESC, and CTRL/F are not treated as
		       action characters (unless they  are  specified  in
		       the  mask)  and	can  be  included  in the string.
		       Carriage return can also be included if it is  not
		       one of the specified break characters.

    23	     .CMTOK    Parse the  input  and  compare  it  with  a  given
		       string.	 Word .CMDAT contains the byte pointer to
		       the given string.  This function  sets  B1(CM%NOP)
		       in  word  .CMFLG  of  the  command state block and
		       returns if the next input characters do not  match
		       the given string.  Leading blanks in the input are
		       ignored.  This  function  is  useful  for  parsing
		       single or multiple character operators (e.g., + or
		       **).

    24	     .CMNUX    Parse  a  number  and  terminate  on   the   first
		       non-numeric  character.	 Word .CMDAT contains the
		       radix  (from  2	to  10)  of  the  number.   On	a
   (COMND)
   

		       successful  return, AC2 contains the number.  This
		       function is useful for parsing a number	that  may
		       not  be	terminated with a nonalphabetic character
		       (e.g., 100PRINT FILEA).

		       Note that non-numeric identifiers can begin with a
		       digit  (e.g.,  1SMITH  as  a  user  name).  When a
		       non-numeric identifier  and  a  number  appear  as
		       alternates  for a field, the order of the function
		       descriptor  blocks  is  important.    The   .CMNUX
		       function,  if  given first, would accept the digit
		       in the non-numeric identifier as  a  valid  number
		       instead	 of  as  the  beginning  character  of	a
		       non-numeric identifier.

    25	     .CMACT    Parse an account string.  The input, as	delimited
		       by  the first nonalphanumeric character, is copied
		       into  the  atom	buffer;   the  delimiter  is  not
		       copied.	 No  verification is performed nor is any
		       standard help message available.

   26	     .CMNOD    Parse a network node name.  A node  name  consists
		       of up to six alphanumeric characters followed by 2
		       colons ("::").  Lowercase characters are converted
		       to  uppercase characters.  The node name is copied
		       into the atom buffer  without  the  colons.   Note
		       that  this  function does not verify the existence
		       of the node.

   In addition to the  .CMFNP  word  of  the  function	descriptor  block
   containing  the  function  code  in	bits 0-8 (CM%FNC), this word also
   contains function-specific flag bits in bits  9-17  (CM%FFL)  and  the
   address of another function descriptor block in bits 18-35 (CM%LST).

   The flag bits that can be set in bits 9-17 (CM%FFL) are as follows:

   Bit	     Symbol		      Meaning

    14	     CM%PO     The field is to be parsed  only	and  the  field's
		       existence   is  not  to	be  verified.	This  bit
		       currently  applies  to  the  .CMDIR   and   .CMUSR
		       functions   and	 is  ignored  for  the	remaining
		       functions.  On  return,	COMND  sets  B1(CM%NOP-no
		       parse)  only  if  the  field  typed  is not in the
		       correct syntax.	Also, data returned  in  AC2  may
		       not be correct.

    15	     CM%HPP    A byte pointer to a program-supplied help  message
		       for this field is given in word 2 (.CMHLP) of this
		       function descriptor block.

    16	     CM%DPP    A  byte	pointer  to  a	program-supplied  default
		       string  for this field is given in word 3 (.CMDEF)
		       of this function descriptor block.
   (COMND)
   

    17	     CM%SDH    The output of the default help message  is  to  be
		       suppressed  if  the  user  types  a question mark.
		       (See below for the default messages.)

   The address of another function descriptor block can be given in  bits
   18-35  (CM%LST) of the .CMFNP word.	The use of this second descriptor
   block is described below.

   Usually one COMND call is executed for  each  field	in  the  command.
   However,  for some fields, more than one type of input may be possible
   (e.g., after a keyword field, the next field could be a  switch  or	a
   filename  field).   In  these cases, all the possibilities for a field
   must be tried in an order selected to test unambiguous cases first.

   When the COMND call	cannot	parse  the  field  as  indicated  by  the
   function code, it does one of two things:

	1.  It sets the current pointer and counts  such  that	the  next
	    call  will	attempt  to  parse the same input over again.  It
	    then returns with B1(CM%NOP) set in  the  left  half  of  the
	    .CMFLG  word in the command state block.  The caller can then
	    issue another COMND call  with  a  function  code  indicating
	    another  of the possible fields.  After the execution of each
	    call, the caller should test the CM%NOP flag to  see  if  the
	    field was parsed successfully.

	2.  If an address of another function descriptor block	is  given
	    in	CM%LST,  the  COMND  call  moves to this descriptor block
	    automatically and attempts to parse the field as indicated by
	    the  function  code contained in B0-B8(CM%FNC) in word .CMFNP
	    of that block.  If the COMND call fails to	parse  the  field
	    using  this new function code, it moves to a third descriptor
	    block if one is given.  This sequence continues until  either
	    the  field	is successfully parsed or the end of the chain of
	    function blocks is reached.  Upon  completion  of  the  COMND
	    call,  AC3	contains  the  addresses  of  the  first and last
	    function blocks used.

   By specifying a chained list of function blocks, the program can  have
   the	COMND  call  automatically  check all possible alternatives for a
   field and not have  to  issue  a  separate  call  for  each	one.   In
   addition,  if  the user types a question mark, a list is output of all
   the alternatives for the field as indicated by the  list  of  function
   descriptor blocks.

   Word .CMHLP of the function descriptor block
         

   This word contains a byte pointer to a program-supplied help  text  to
   be output if the user types a question mark when entering his command.
   The	default  help  message	is  appended  to  the	output	 of   the
   program-supplied message if B17(CM%SDH) is not set.	If B17(CM%SDH) is
   set, only the program-supplied message is output.  If this word in the
   descriptor  block is zero, only the default message is output when the
   user types a question mark.	Bit 15(CM%HPP) must  be  set  in  word	0
   (.CMFNP) of the function descriptor block for this pointer to be used.
   (COMND)
   

   The default help message depends on the particular function being used
   to  parse  the  current field.  The table below lists the default help
   message for each function available in the COMND call.

			   Default Help Messages
			     

   Function		    Message

   .CMKEY (keyword)	    ONE OF THE FOLLOWING
			    followed by the alphabetical  list	of  valid
			    keywords.	If the user types a question mark
			    in the middle of the field, only the keywords
			    that   can	 possibly   match  the	field  as
			    currently typed are output.   If  no  keyword
			    can possibly match the currently typed field,
			    the message
			    KEYWORD  (NO  DEFINED  KEYWORDS  MATCH   THIS
			    INPUT)
			    is output.

   .CMNUM (number)	    The help message output depends on the  radix
			    specified  in .CMDAT in the descriptor block.
			    If the radix is octal, the help message is
				 OCTAL NUMBER
			    If the radix is decimal, the help message is
				 DECIMAL NUMBER
			    If the radix is any  other	radix,	the  help
			    message is
				 A NUMBER IN BASE nn
			    where nn is the radix.

   .CMNOI (guide word)	    None

   .CMSWI (switch)	    ONE OF THE FOLLOWING
			    followed by the alphabetical  list	of  valid
			    switch keywords.  The same rules apply as for
			    .CMKEY function.  (See above.)

   .CMIFI (input file)	    The help  message	output	 depends  on  the
   .CMOFI (output file)     settings of certain bits in the  GTJFN  call.
   .CMFIL (any file)	    If bit GJ%OLD is off and bit  GJ%FOU  is  on,
			    the help message is
				 OUTPUT FILESPEC
			    Otherwise, the help message is
				 INPUT FILESPEC

   .CMFLD (any field)	    None

   .CMCFM (confirm)	    CONFIRM WITH CARRIAGE RETURN

   .CMDIR (directory)	    DIRECTORY NAME

   .CMUSR (user)	    USER NAME

   .CMCMA (comma)	    COMMA
   (COMND)
   

   .CMINI (initialize)	    None

   .CMFLT (floating point)  NUMBER

   .CMDEV (device)	    DEVICE NAME

   .CMTXT (text)	    TEXT STRING

   .CMTAD (date)	    The help message depends on the bits  set  in
			    .CMDAT in the descriptor block.  If CM%IDA is
			    set, the help message is
				 DATE
			    If CM%ITM is set, the help message is
				 TIME
			    If both are set, the help message is
				 DATE AND TIME

   .CMQST (quoted)	    QUOTED STRING

   .CMUQS (unquoted)	    None

   .CMTOK (token)	    None

   .CMNUX (number)	    Same as .CMNUM

   .CMACT (account)	    None

   .CMNOD (node)	    NODE NAME

   Word .CMDEF of the function descriptor block
         

   This word contains a byte pointer to the ASCIZ string to  be  used  as
   the	default  for  this  field.   For  this pointer to be used, bit 16
   (CM%DPP) must be set in word 0 (.CMFNP) of the descriptor block.   The
   string  is  output  to  the destination, as well as copied to the text
   buffer, if the user types an ESC or	CTRL/F	as  the  first	non-blank
   character  in  the  field.	If  the user types a carriage return, the
   string is copied  to  the  atom  buffer  but  is  not  output  to  the
   destination.

   When the caller supplies a list of  function  descriptor  blocks,  the
   byte  pointer  for  the  default  string must be included in the first
   block.  The CM%DPP bit and the pointer  for	the  default  string  are
   ignored  when  they appear in subsequent blocks.  However, the default
   string can be worded so that it will apply to any of  the  alternative
   fields.   The  effect  is  the same as if the user had typed the given
   string.

   Defaults for fields of a file specification can also be supplied  with
   the	.CMFIL	function.  If both the byte pointer to the default string
   and the GTJFN defaults have been provided, the COMND default  will  be
   used first and then, if necessary, the GTJFN defaults.
		  The  function  descriptor  block,  whose
		  address  is  given in AC2, can be set up
		  by the FLDDB. and FLDBK. macros  defined
		  in  MACSYM.	(See  end of COMND section
		  for a description of these macros.)

  Word .CMBRK of the function descriptor block
        

  This word contains a pointer to  a  4-word  user-specified  mask  that
  determines  which characters constitute end of field.  The leftmost 32
  bits of each word correspond to a character	in  the  ASCII	collating
  sequence  (in  ascending  order).   If  the	bit  is  on  for  a given
  character, typing that character will cause the COMND  JSYS	to  treat
  the characters typed so far as a separate field and parse it according
  to the function being used.	CM%BRK (B13) must be on in the first word
  of the function descriptor block or COMND will ignore word .CMBRK.

  Ordinarily, the user would rely  on	COMND's  default  masks  (varying
  according to function) to specify which characters signal end of field
  and thus would not be concerned  with  word	.CMBRK	of  the  function
  block.   However,  for special purposes such as allowing "*" or "%" to
  be part of a field rather  than  a  field  delimiter,  the  user  must
  specify  his  own  mask.   (In  this example, the bits for "*" and "%"
  would be off in the mask word.) The user may inspect  COMND's  default
  masks (defined in MONSYM) for help in designing a custom mask.

  The following is a list of the COMND functions that use masks:

  Mask 	     COMND	 Changeable
  Symbols	     Function	 by User

  KEYB0. - KEYB3.   .CMKEY	 Yes
  DEVB0. - DEVB3.   .CMDEV	 Yes (only if parse-only)
  FLDB0. - FLDB3.   .CMFLD	 Yes
  EOLB0. - EOLB3.   .CMTXT	 Yes
  KEYB0. - KEYB3.   .CMSWI	 Yes
  User specified    .CMDAT	 Yes
  USRB0. - USRB3.   .CMUSR	 No
  FILB0. - FILB3.   .CMFIL	 No
  FILB0. - FILB3.   .CMIFI	 No
  FILB0. - FILB3.   .CMOFI	 No
  internal	     .CMNUM	 No
  FILB0. - FILB3.   .CMDIR	 No
  internal	     .CMFLT	 No
  ACTB0. - ACTB3.   .CMACT	 No

  COMND will ignore any break masks that  are	specified  for	functions
  that do not allow user-modified masks.

  Note that specifying a zero mask with CM%BRK set will  cause  the  TTY
  line buffer to fill up and generate an error.

   On a successful return, the COMND call returns flag bits in	the  left
   half  of  AC1  and preserves the address of the command state block in
   the right half of AC1.  These flag bits are copied from word .CMFLG in
   the command state block and are described as follows.
   (COMND)
   

			Bits Returned on COMND Call
			    

   Bit	     Symbol		      Meaning

    0	     CM%ESC    An ESC was typed by the user as the terminator for
		       this field.

    1	     CM%NOP    The field could not be parsed because it  did  not
		       conform	to  the  specified function(s).  An error
		       code is returned in AC2.

    2	     CM%EOC    The field was terminated with a carriage return.

    3	     CM%RPT    Characters already  parsed  need  to  be  reparsed
		       because	the  user edited them.	This bit does not
		       need to be examined if the program has supplied	a
		       reparse	dispatch  address  in  the  right half of
		       .CMFLG in the command state block.

    4	     CM%SWT    A switch field was terminated with a colon.   This
		       bit is on if the user either used recognition on a
		       switch that ends with a colon or typed a colon  at
		       the end of the switch.

    5	     CM%PFE    The previous field was terminated with an ESC.

   When a field cannot be parsed, B1(CM%NOP) is set in AC1,  and  one  of
   the	following error codes is returned in AC2.  Note that if a list of
   function descriptor blocks is given and an error code is returned, the
   error  is  associated  with	the last function descriptor block in the
   list.

   NPXAMB:   ambiguous

   NPXNSW:   not a switch - does not begin with slash

   NPXNOM:   does not match switch or keyword

   NPXNUL:   null switch or keyword given

   NPXINW:   invalid guide word

   NPXNC:    not confirmed

   NPXICN:   invalid character in number

   NPXIDT:   invalid device terminator

   NPXNQS:   not a quoted string - does not begin with double quote

   NPXNMT:   does not match token

   NPXNMD:   does not match directory or user name

   NPXCMA:   comma not given
   (COMND)
   

   COMX18:   invalid character in node name

   COMX19:   too many characters in node name

  Macros
  

  Several macros (defined in MACSYM) are available  to  make  using  the
  COMND JSYS more convenient.	These macros are as follows:

  FLDDB.(TYP,FLGS,DATA,HLPM,DEFM,LST)

	  where:

	  TYP  = function type
	  FLGS = function flags
	  DATA = function-specific data
	  HLPM = help message
	  DEFM = default text
	  LST  = additional invocations of the FLDDB. macro (used only if
		 multiple function blocks are required)

	  This macro generates function descriptor blocks for COMND.  For
	  example, the following code would perform a .CMINI function:

	  MOVEI T1,STEBLK	     ;Get address of COMND state block
	  MOVEI T2,[FLDDB.(.CMINI)]  ;Get address of function block
	  COMND

	  The following code would perform a  .CMKEY  function	(assuming
	  that the keyword table started at address CMDTAB:

	  MOVEI T1,STEBLK	     ;Get address of COMND state block
	  MOVEI T2,[FLDDB(.CMKEY,<CM%DPP+CM%+CM%HPP>,CMDTAB,
		   <help text>,<default text>)]
	  COMND

  FLDBK.(TYP,FLGS,DATA,HLPM,DEFM,BRKADR,LST)

	  This is exactly the same as FLDDB. except that a provision  has
	  been	made  for  the	address  of  the  first  word of a 4-word
	  character mask (BRKADR).   This  version  is	for  use  when	a
	  user-specified character mask is required.

  BRMSK.(INI0,INI1,INI2,INI3,ALLOW,DISALLOW)

	  where:

	  INI0 =     first word of character mask
	  INI1 =     second word of character mask
	  INI2 =     third word of character mask
	  INI3 =     fourth word of character mask
	  ALLOW =    characters to allow in the mask
	  DISALLOW = characters to disallow in the mask

	  This macro generates 4-word character masks for use with  those
   (COMND)
   

	  COMND  functions  that  allow the user to specify his own mask.
	  For example, executing the following code would  allow  "*"  in
	  the predefined mask for the .CMFLD function (FLDB0 thru BLDB3):

	  BRMSK.(FLDB0.,FLDB1.,FLDB2.,FLDB3.,<*>,)

	  Also, the BRMSK. macro may be invoked within the FLDBK. macro:

	  FLDBK.(TYP,FLGS,DATA,HLPM,DEFM,[
		 BRMSK.(INI0,INI1,INI2,INI3,ALLOW,DISALLOW)],LST)

   The COMND call causes other monitor calls to be executed, depending on
   the	particular  function  that  is requested.  Failure of these calls
   usually results in the failure to parse the requested field.  In these
   cases, the relevant error code can be obtained via the GETER and ERSTR
   monitor calls.

	Any TBLUK error can occur on the keyword and switch functions.

	Any NIN/NOUT  and  FLIN/FLOUT  error  can  occur  on  the  number
	functions.

	Any  GTJFN  error  except  for	GJFX37	can  occur  on	the  file
	specification functions.

	Any IDTNC error can occur on the date/time function.

	Any RCDIR or RCUSR error can occur  on	the  directory	and  user
	functions.

	Any STDEV error can occur on the device function.

   Generates an illegal instruction interrupt on error conditions below.

   COMND ERROR MNEMONICS:

   COMNX1:   invalid COMND function code

   COMNX2:   field too long for internal buffer

   COMNX3:   command too long for internal buffer

   COMNX5:   invalid string pointer argument

   COMNX8:   number base out of range 2-10

   COMNX9:   end of input file reached

   COMX10:   invalid default string

   COMX11:   invalid CMRTY pointer

   COMX12:   invalid CMBFP pointer
   (COMND)
   

   COMX13:   invalid CMPTR pointer

   COMX14:   invalid CMABP pointer

   COMX15:   invalid default string pointer

   COMX16:   invalid help message pointer

   COMX17:   invalid byte pointer in function block


Node: CRDIR	Previous: COMND	Next: CRJOB	Up: Top
			     CRDIR     JSYS 240

   Creates, changes, or deletes a directory entry.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
  ACCEPTS IN AC1:  byte pointer to ASCIZ string containing the structure
		    and  directory name.  The string must be of the form:
		    structure:<directory>.

	      AC2:  B0(CD%LEN)	set length of the argument block  to  the
				value  given in word .CDLEN.  This bit is
				not used in  TOPS-20  version  3  and  is
				provided for future releases.

		    B1(CD%PSW)	set password from argument block

		    B2(CD%LIQ)	set  working  disk  storage  limit   from
				argument block

		    B3(CD%PRV)	set capability bits from argument block

		    B4(CD%MOD)	set mode bits from argument block

		    B5(CD%LOQ)	set permanent  disk  storage  limit  from
				argument block

		    B6(CD%NUM)	set directory number from argument  block
				(valid only when creating a directory)

		    B7(CD%FPT)	set default file protection from argument
				block

		    B8(CD%DPT)	set directory  protection  from  argument
				block

		    B9(CD%RET)	set default retention count from argument
				block

		    B10(CD%LLD) set last LOGIN date from argument block
   (CRDIR)
   

		    B11(CD%UGP) set user groups from argument block

		    B12(CD%DGP) set directory groups from argument block

		    B13(CD%SDQ) set  subdirectory  quota  from	 argument
				block

		    B14(CD%CUG) set  user  groups  assignable	by   this
				directory from argument block

		    B15(CD%DAC) set default account from argument block

		    B17(CD%DEL) delete this directory entry

		    B18-B35	address of the argument block
		    (CD%APB)

	      AC3:  byte pointer to ASCIZ string containing the  password
		    of	the  directory.   This pointer is required when a
		    nonprivileged user is  changing  parameters  for  his
		    directory.

   RETURNS     +1:  always, with directory number in AC1

   This monitor call requires the  process  to	have  WHEEL  or  OPERATOR
   capability enabled unless one of the following conditions is true:

	1.  The specified directory is one to which the caller has  owner
	    access  and  the  caller is changing any one of the following
	    parameters:

		 password (.CDPSW)
		 default file protection (.CDFPT)
		 directory protection (.CDDPT)
		 default retention count (.CDRET)
		 default account (.CDDAC)

	    This feature is installation  dependent  and  is  enabled  by
	    issuing function .SFCRD of the SMON monitor call.

	2.  The specified directory is inferior to the one to  which  the
	    caller is currently connected and the caller has owner access
	    to this inferior directory.

   Refer to Section 2.2.6 for the description of owner access.

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

	0    .CDLEN	    flag bits in the left half, and length of the
			    argument   block  in  the  right  half.   The
			    following bits are defined:
   (CRDIR)
   

			    B0(CD%NSQ)	When restoring this directory, do
					not	update	  its	 superior
					directory's  quotas   (permanent,
					working, and subdirectory quotas)
					to account  for  this  directory.
					If  this bit is off, the superior
					directory's quotas  are  updated.
					This  bit is set by the DLUSER or
					DUMPER	program  to  retain   the
					superior  directory's quotas when
					restoring   its   subdirectories.
					The  process  must  have WHEEL or
					OPERATOR  capability  enabled  to
					set this bit.

			    B1(CD%NCE)	When restoring or  reconstructing
					this directory, do not change any
					directory   parameters	 if   the
					directory   currently  exists  on
					disk;  set the parameters only if
					the directory does not exist.  If
					this bit is  off,  the	directory
					parameters  as saved are restored
					for the directory.  This  bit  is
					set   by  the  DLUSER  or  DUMPER
					program to restore or reconstruct
					directories    from   out-of-date
					files  without	causing  existing
					directories  to  revert  to older
					parameters.   The  process   must
					have WHEEL or OPERATOR capability
					enabled to set this bit.

	1    .CDPSW	    pointer to password string, which is a string
			    from 1 to 39 alphanumeric characters.

	2    .CDLIQ	    maximum number of pages that can be used  for
			    working disk storage (also known as logged-in
			    quota).

	3    .CDPRV	    capabilities  for  this  user.    (Refer   to
			    Section 2.6.1 for the capability bits.)

	4    .CDMOD	    mode word.

			    B0(CD%DIR)	directory name can only  be  used
					for   connecting  to  (i.e.,  the
					directory   is	  a    files-only
					directory).   If this bit is off,
					the directory name  can  be  used
					for logging in and connecting to.

			    B1(CD%ANA)	accounts are alphanumeric.   This
					bit  is  not used and is provided
					for  compatibility  with  systems
   (CRDIR)
   

					earlier than TOPS-20 version 3.

			    B2(CD%RLM)	all the messages  from	the  file
					<SYSTEM>MAIL.TXT   are	 repeated
					each time the user logs  in.   If
					this   bit   is   off,	only  the
					messages not  previously  printed
					are output when the user logs in.

			    B7(CD%DAR)	If on, this  bit  indicates  that
					when  the  online expiration date
					has  been  reached,   the   files
					concerned   should   be  archived
					rather than migrated  to  virtual
					disk.	 This  bit  is	currently
					reserved and is not implemented.

	5    .CDLOQ	    maximum number of pages that can be used  for
			    permanent	disk   storage	 (also	known  as
			    logged-out quota).

	6    .CDNUM	    directory number, valid only when creating	a
			    directory.	An error code is returned if user
			    changes the number of an  existing	directory
			    (CRDIX2)   or   gives   a  non-unique  number
			    (CRDIX8).

	7    .CDFPT	    default    file    protection    (18    bits,
			    right-justified).

	10   .CDDPT	    directory	   protection	   (18	    bits,
			    right-justified).

	11   .CDRET	    default number of generations of a file to be
			    retained  in the directory (retention count).
			    Valid numbers are 0 to 63, with  0	being  an
			    infinite number.

	12   .CDLLD	    date of last login.

	13   .CDUGP	    pointer to user group list.

	14   .CDDGP	    pointer to directory group list.

	15   .CDSDQ	    maximum number of  directories  that  can  be
			    created  inferior  to  this  directory.  This
			    parameter allows a user to create directories
			    with the BUILD command.

	16   .CDCUG	    pointer  to  user  group  list.   This   list
			    contains  the group numbers that can be given
			    to directories inferior to this one.

	17   .CDDAC	    pointer to default account for this user.
   (CRDIR)
   

	20   .CDDNE	    default online expiration date and time.  May
			    be	 an  explicit  date  and  time	(internal
			    format) or an interval (in days).  In  either
			    case,  the	specified  date/interval  may not
			    exceed the system maximum.	This parameter is
			    read  if  CD%NED  (1B2)  or  CD%FED  (1B3) in
			    .CDLEN  are  set.	If  a  new  directory  is
			    created  and this parameter is not specified,
			    the system default is used.

			    An unprivileged user may modify his defaults,
			    but  only  to  a  value less than or equal to
			    those which are currently  specified  or  the
			    system maximum, whichever is greater.

			    This word is currently reserved  and  is  not
			    implemented.

	21   .CDDFE	    default  offline  expunge  date   and   time.
			    Otherwise similar to .CDDNE (above).

			    This word is currently reserved  and  is  not
			    implemented.

  The format of  each	group  list  is  a  table  with  the  first  word
  containing  a  count of the number of words (including the count word)
  in the table and each subsequent word containing a group number.

  When CRDIR is being executed to create a directory, bits 0-17  of  AC2
  may	optionally be on or off.  If a particular bit is on, it indicates
  that the corresponding  argument  in  the  argument	block  should  be
  examined.  If the bit is off, it indicates that the argument should be
  defaulted.  The following table lists the bits and  the  corresponding
  argument defaults:

	Bits		     Argument Defaults
	B2(CD%LIQ)  maximum working disk file storage to 250 pages
	B3(CD%PRV)  no special capabilities
	B4(CD%MOD)  directory name that can be used for  logging  in  and
		    that  lists  the  messages from <SYSTEM>MAIL.TXT only
		    once
	B5(CD%LOQ)  maximum permanent disk file storage to 250 pages
	B6(CD%NUM)  the  first	unused	directory  number.    B6   should
		    normally be off.
	B7(CD%FPT)  default file protection to 777700
	B8(CD%DPT)  directory protection to 777700
	B9(CD%RET)  default file retention count to 1
	B10(CD%LLD) never logged in
	B11(CD%UGP) no user groups
	B12(CD%DGP) no directory groups
	B13(CD%SDQ) no ability to create inferior directories
	B14(CD%CUG) no assignable user groups for inferior directories
	B15(CD%DAC) no default account

   When CRDIR is being executed to change a directory and any  of  B0-B17
   (CRDIR)
   

   of AC2 is off, the corresponding parameter is not affected.

   When CRDIR is being executed to delete a directory,	the  settings  of
   B0-B17  of  AC2 are ignored.  A CRDIR call cannot be given to delete a
   directory that has directories inferior to it.

   The GTDIR call can be used to obtain the directory information.

   Generates an illegal instruction interrupt on error conditions below.

   CRDIR ERROR MNEMONICS:

   CRDIX1:   WHEEL or OPERATOR capability required

   CRDIX2:   illegal to change number of old directory

   CRDIX3:   insufficient system resources (Job Storage Block full)

   CRDIX4:   superior directory full

   CRDIX5:   directory name not given

   CRDIX6:   directory file is mapped

   CRDIX7:   file(s) open in directory

   CRDIX8:   invalid directory number

   CRDIX9:   internal format of directory is incorrect

   CRDI10:   maximum directory number exceeded; index table needs
	     expanding

   CRDI11:   invalid terminating bracket on directory

   CRDI12:   structure is not mounted

   CRDI13:   request exceeds superior directory working quota

   CRDI14:   request exceeds superior directory permanent quota

   CRDI15:   request exceeds superior directory subdirectory quota

   CRDI16:   invalid user group

   CRDI17:   illegal to create non-files-only subdirectory under
	     files only directory

   CRDI18:   illegal to delete logged-in directory

   CRDI19:   illegal to delete connected directory

   CRDI20:   WHEEL, OPERATOR, or requested capability required

   CRDI21:   working space insufficient for current allocation
   (CRDIR)
   

   CRDI22:   subdirectory quota insufficient for existing subdirectories

   CRDI23:   superior directory does not exist

   CRDI24:   invalid subdirectory quota


Node: CRJOB	Previous: CRDIR	Next: CRLNM	Up: Top
			      CRJOB     JSYS 2

   Creates a new job and optionally logs it in.  This monitor call causes
   the functions that are normally performed when a job is created (e.g.,
   assignment of  a  JSB,  the	primary  I/O  designators,  and  the  job
   controlling terminal) to be performed for the new job.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  flag bits

	      AC2:  address of argument block

	      AC3:  (optional) If CRJOB is to be used to release  control
		    over  a  job previously created with CRJOB (bit 17 in
		    AC1 must be on), then AC3 contains the job number  of
		    the previously created job.

   RETURNS     +1:  failure, with error code in AC1

	       +2:  success, with the number of the new job in AC1

   The flag bits defined in the left half of AC1 are as follows:

   Bit	   Symbol			    Meaning

   0	   CJ%LOG      Log in the new job.  If this bit is off,  the  new
		       job is created but not logged in.

   1	   CJ%NAM      Set the user name and password from  the  argument
		       block.	If  this bit is off, the user name of the
		       caller is given to the new job.

   2-3	   CJ%ACT      Set the account of the new job to the following:

		       Code    Symbol		     Meaning

		       0       .CJUCA	 Use current account of caller.

		       1       .CJUAA	 Use account  from  the  argument
					 block.

		       2       .CJUDA	 Use  default  account	of   user
					 whose job is being created.
   (CRJOB)
   

  4	   CJ%ETF      If set, place the TOPS-20 command processor in the
		       top-level  process  of  the  new job.  The command
		       processor will read  its  program  argument  block
		       (see below) at the time it is started.

		       CJ%FIL and CJ%ETF interact in the following ways:

		       1.  If CJ%FIL is on and CJ%ETF is on, then  a  job
			   is  created	with  a top process consisting of
			   the TOPS-20 command processor and an  inferior
			   process  consisting	of the file pointed to by
			   word .CJFIL.

		       2.  IF CJ%FIL is off and CJ%ETF is on, then a  job
			   is  created	with  a top process consisting of
			   the TOPS-20 command	processor.   No  inferior
			   process is created.

		       3.  If CJ%FIL is on and CJ%ETF is off, then a  job
			   is  created	with  a top process consisting of
			   the	file  pointed  to  by  word  .CJFIL.   No
			   inferior process is created.

		       The format of the program  argument  block  is  as
		       follows:

		       Word		Contents

			0	 Count of words in block,  not	including
				 this word.

			1	 1B0+3B6+2B12+CR%PRA - indicates this  is
				 a  program argument block created by the
				 CRJOB JSYS

			2	 1B0 + offset1 - offset1 is the offset in
				 this  block  of the first argument being
				 passed.

			3	 1B0 + offset2 - offset2 is the offset in
				 this  block of the second argument being
				 passed.

			n	 (offset1) This argument is a copy of the
				 flag  bits  from  word .CJEXF (word 10 -
				 flags	 for   the    command	 language
				 processor) of the CRJOB argument block.

			n+1	 (offset2)   This    argument	 contains
				 information   about  the  process  being
				 started - process  handle,,entry  vector
				 offset.  The entry vector offset is from
				 word  .CJSVF  (word  4)  of  the   CRJOB
				 argument block.
   (CRJOB)
   

		       The program argument block is created by the CRJOB
		       monitor	call  and  is  passed to the process by a
		       PRARG  monitor  call  (performed   internally   by
		       CRJOB).	 The  user  does  not  specify any of the
		       information in the program  argument  block.   The
		       user  can,  by  invoking  the  PRARG monitor call,
		       return the block and examine its contents.

   5	   CJ%FIL      Move (via a GET call) the file pointed to  in  the
		       argument  block into a process in the new job.  If
		       B4(CJ%ETF) is off,  the	file  is  placed  in  the
		       top-level  process  of the new job.  If B4(CJ%ETF)
		       is  on,	the  file  is  placed  in   the   process
		       designated  in  the  Command  Language Processor's
		       PRARG argument block.  (See below.)  If B5(CJ%FIL)
		       is off, no file is moved into a process of the new
		       job, and the top-level process of the new  job  is
		       the Command Language Processor.

   6	   CJ%ACS      Load the ACs from the value in the argument block.
		       The  ACs  are  loaded only if a program other than
		       the Command Language Processor is being run.

   7	   CJ%OWN      Maintain ownership of the  new  job.   This  means
		       that  the  new  job cannot be logged out until the
		       caller releases ownership of it.  If this  bit  is
		       off, control of the new job is released.

   8	   CJ%WTA      Do not start the new  job  until  it  is  attached
		       (using  ATACH JSYS) to a terminal.  If this bit is
		       off, the new job is started.

   9	   CJ%NPW      Do not check the password given when the  new  job
		       is logged in.  If this bit is off, the password is
		       checked unless the new job is being logged in with
		       the  same user name as the caller or with WHEEL or
		       OPERATOR capability enabled.

   10	   CJ%NUD      Do not update the date of LOGIN for  user  logging
		       in  to  the new job.  If this bit is off, the date
		       of LOGIN is updated unless the user is logging  in
		       with  the  same	user  name  as the caller or with
		       WHEEL or OPERATOR capability enabled.

   11	   CJ%SPJ      Set (via a  SPJFN  call)  the  primary  input  and
		       output  designators from the argument block before
		       starting the job.  The primary I/O designators are
		       not  changed  for  a Command Language Processor in
		       the top-level process of the new  job;	they  are
		       changed	only for inferior processes.  If this bit
		       is off, the primary I/O designators of the new job
		       are the job's controlling terminal.

   12	   CJ%CAP      Set the new job's allowed user capabilities (right
		       half)  to  be  the  same as the caller's currently
   (CRJOB)
   

		       enabled capabilities, until the new job is  logged
		       in.   If this bit is off, the new job has the user
		       capabilities associated with the user whose job is
		       being created.

   13	   CJ%CAM      Set the new job's allowed capabilities to  be  the
		       combination  of (AND function) the capability mask
		       in the argument	block  and  the  new  job's  user
		       capabilities.  If this bit is off, the new job has
		       the capabilities associated with  the  user  whose
		       job is being created.

   14	   CJ%SLO      Send  a	IPCF  message  to  the	PID  supplied  in
		       argument block when the new job is logged out.  If
		       this bit is off, no message is sent when  the  new
		       job is logged out.

		       The IPCF logout message has the following format:

		       Word		   Contents

			0	 0,,.IPCLO
			1	 N,,# of job logged out.  N is the  count
				 of  the  remaining words in this message
				 (currently 10 octal).
			2	 flags,,reserved
				 Bits	Symbol	 Meaning
				  B0	SP%BAT	 job  is  controlled   by
						 batch
				  B1	SP%DFS	 spooling is deferred.
				  B2	SP%ELO	 the job executed LGOUT
				  B3	SP%FLO	 the job  was  forced  to
						 logout.   If this bit is
						 on, check Word 8 of  the
						 IPCF message (gives code
						 of most  recent  monitor
						 call error).  B3 will be
						 on only if  job  has  an
						 interrupt  to be handled
						 by MEXEC(Mini-EXEC).
				  B4	SP%OLO	 the job was  logged  out
						 by  another job.  Word 6
						 of  the   IPCF   message
						 contains  the job number
						 of the job that did  the
						 logout.

			3	 job connect time
			4	 job CPU time
			5	 TTY number  of  job  at  logout  (-1  if
				 detached)
			6	 job number  of  the  job  that  did  the
				 logout
			7	 reserved
			10	 code of the  most  recent  monitor  call
   (CRJOB)
   

				 error

   17	   CJ%DSN      Release ownership of the  previously  created  job
		       whose  number  is  in  AC3.  If this bit is on, it
		       overrides the setting of all other  bits  in  AC1,
		       and  no	change	is made to the job's status other
		       than the change in ownership.

   The format of the argument block (whose address is given in AC2) is as
   follows:

   Word 	Symbol			     Meaning

    0		.CJNAM	  Byte pointer to the user name string.

    1		.CJPSW	  Byte pointer to the password string.

    2		.CJACT	  5B2 + numeric account number or byte pointer to
			  account string.

    3		.CJFIL	  Byte pointer to the name  of	the  file  to  be
			  moved  (via  a  GET call) into a process of the
			  new job.  The new job must have read access  to
			  the  file.   The process into which the file is
			  placed depends on the setting of B4(CJ%ETF).

    4		.CJSFV	  Offset in the entry vector to use as the  start
			  address  of the file pointed to by word .CJFIL.
			  This offset is the argument to the  SFRKV  call
			  used to start the process.

    5		.CJTTY	  Terminal   designator   of   the   new    job's
			  controlling  terminal.   This  terminal must be
			  assigned by the caller.  The terminal  is  then
			  released  and  assigned to the new job.  If the
			  new  job  is	to  be	 detached,   the   .NULIO
			  designator (377777) is given.

   6		.CJTIM	  connect-time for new	job  before  a	LGOUT  is
			  forced  on  it;   0  indicates  no limit.  This
			  function is currently not implemented.

   7		.CJACS	  Address of a 16-word block whose  contents  are
			  to  be loaded in the new job's ACs if a program
			  other than the Command  Language  Processor  is
			  being run.

   10		.CJEXF	  Flag bits to be passed to the Command  Language
			  Processor  in  the top-level process of the new
			  job.	The bits are:

			  B0	 Suppress  the	herald	printed  by   the
				 Command Language Processor.

			  B1	 Move the file pointed to by word  .CJFIL
   (CRJOB)
   

				 into  the process whose handle is in the
				 PRARG block.  (See below.)

			  B2	 Start the process at the offset  in  the
				 entry vector given in word .CJSFV.  This
				 process is  started  after  the  Command
				 Language Processor is initialized.

			  B3	 Output the text  printed  when  a  LOGIN
				 command is given (e.g., system messages,
				 job number, terminal number).

			  This word is copied  into  the  PRARG  argument
			  block passed to the Command Language Processor.
			  (See Below.)

   11		.CJPRI	  Primary input and output  designators  for  the
			  inferior  processes  of  the	new  job.   These
			  designators must refer to  device  designators.
			  The Command Language Processor in the top-level
			  process of the new job executes a SPJFN call to
			  set these designators.

   12		.CFCPU	  Runtime limit for the new job.  When this limit
			  is  reached,	an  interrupt is generated (via a
			  TIMER call), and the Command Language Processor
			  will	execute  a LGOUT call for the new job.	A
			  zero in this word means  there  is  no  runtime
			  limit on the job.

   13		.CJCAM	  Capability mask for the new job.  This mask  is
			  used only if CJ%CAM is set.

    14		.CJSLO	  PID to which an IPCF message is to be sent when
			  the new job is logged out.

  When CRJOB creates a new job, it also creates the  top-level  process,
  and	this  process  is always a virgin process.  Thus, an execute-only
  program can be RUN as the top-level fork.

   The CRJOB call causes other monitor calls to be executed, depending on
   the particular function that is performed.

	Any GTJFN and OPENF errors can occur when obtaining the specified
	file.

	Any SFRKV error can  occur  when  starting  the  program  in  the
	specified file.

	Any LOGIN and account validation errors can occur when logging in
	the job.

   CRJOB ERROR MNEMONICS:

   CRJBX1:   invalid parameter or function bit combination
   (CRJOB)
   

   CRJBX2:   illegal for created job to enter MINI-EXEC

   CRJBX4:   terminal is not available

   CRJBX5:   unknown name for LOGIN

   CRJBX6:   insufficient system resources


Node: CRLNM	Previous: CRJOB	Next: CVHST	Up: Top
			     CRLNM     JSYS 502

   Defines or deletes a logical name assignment.  Logical names are  used
   to specify a set of default values for each field requested by a GTJFN
   monitor call.  When a logical name is passed to the	GTJFN  call,  any
   fields  not specified by the user are supplied from the fields defined
   in the logical name definition.  (Refer to Section 2.2.2  and  to  the
   INLNM  and  LNMST  monitor  call  descriptions for more information on
   logical names.)

   ACCEPTS IN AC1:  function code

	      AC2:  byte pointer to the logical name

	      AC3:  byte pointer to the logical name definition string

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC3

   The codes for the functions are as follows:

	0    .CLNJ1  delete one logical name from the job

	1    .CLNS1  delete one logical name from the system

	2    .CLNJA  delete all logical names from the job

	3    .CLNSA  delete all logical names from the system

	4    .CLNJB  create a logical name for the job

	5    .CLNSY  create a logical name for the system

   CRLNM ERROR MNEMONICS:

   CRLNX1:   logical name is not defined

   CRLNX2:   WHEEL or OPERATOR capability required

   CRLNX3:   invalid function
   (CRLNM)
   

   GJFX4:    invalid character in filename

   GJFX5:    field cannot be longer than 39 characters

   GJFX6:    device field not in a valid position

   GJFX7:    directory field not in a valid position

   GJFX8:    directory terminating delimiter is not preceded by a  valid
	     beginning delimiter

   GJFX9:    more than one name field is not allowed

   GJFX10:   generation number is not numeric

   GJFX11:   more than one generation number field is not allowed

   GJFX12:   more than one account field is not allowed

   GJFX13:   more than one protection field is not allowed

   GJFX14:   invalid protection

   GJFX15:   invalid confirmation character

   GJFX22:   insufficient system resources (Job Storage Block full)

   GJFX31:   invalid wildcard designator



Node: CVHST	Previous: CRLNM	Next: CVSKT	Up: Top
			     CVHST     JSYS 276

  Converts a host number to a primary name.

  RESTRICTIONS:    for use with ARPANET only

	      ACCEPTS IN AC1: destination designator for the ASCIZ string

	      AC2:  host number

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, host name string returned to area designated
		    by AC1

  CVHST ERROR MNEMONICS:

  CVHST1:   no string for that host number
   (CVSKT)
   


Node: CVSKT	Previous: CVHST	Next: DEBRK	Up: Top
			     CVSKT     JSYS 275

  Converts a local socket number to absolute form.

  RESTRICTIONS:    for use with ARPANET only

	      ACCEPTS IN AC1: JFN

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, absolute socket number in AC2

  CVSKT ERROR MNEMONICS:

  CVHST1:   no string for that host number
  CVSKX1:   invalid JFN

  CVSKX2:   local socket invalid in this context


Node: DEBRK	Previous: CVSKT	Next: DELDF	Up: Top
			     DEBRK     JSYS 136

   Dismisses the current  software  interrupt  routine	in  progress  and
   resumes  the process at the location specified by the PC stored in the
   priority level table.  (Refer to Section 2.5.7.)

   RETURNS     +1:  if no software interrupt is currently in progress and
		    if an ERJMP or ERCAL instruction follows the DEBRK

   Generates an illegal instruction interrupt on error conditions below.

   DEBRK ERROR MNEMONICS:

   DBRKX1:    no interrupts in progress


Node: DELDF	Previous: DEBRK	Next: DELF	Up: Top
			     DELDF     JSYS 67

   Reclaims space by expunging disk  files  that  have	been  marked  for
   deletion  with  DELF.  This call first checks the user's access to the
   directory, verifying that the user is allowed to  expunge  files  from
   it.

  When a file with archive status is deleted and expunged,  DELDF  sends
  an  IPCF  message to GALAXY.  This message contains all archive status
   (DELDF)
   

  informatiion which includes tape information as well  as  the  present
  file  name,	user  who  expunged the file and the time at which it was
  expunged.

   RESTRICTIONS:	       some functions require WHEEL  or  OPERATOR
			       capabilities enabled.
   ACCEPTS IN AC1:  B0(DD%DTF) delete temporary files (;T) also

		    B1(DD%DNF) delete nonexistent files that are not  now
			       opened

		    B2(DD%RST) rebuild the symbol table

		    B3(DD%CHK) check internal consistency  of  directory.
			       If  an  error  occurs,  the  symbol  table
			       should be rebuilt.  If B2(DD%RST) is  also
			       set,  it  is  ignored,  and the DELDF call
			       must be executed again with B2(DD%RST)  on
			       to rebuild the symbol table.

	      AC2:  directory number

   RETURNS     +1:  always

   The directory number given must be that of  the  user's  connected  or
   logged-in   directory   unless  the	process  has  WHEEL  or  OPERATOR
   capability enabled.

   If errors still occur after the symbol table is rebuilt,  the  process
   should  restore  the  directory  from magnetic tape or the user should
   request help from the operator.

   Generates an illegal instruction interrupt on error conditions below.

   DELDF ERROR MNEMONICS:

   DELDX1:   WHEEL or OPERATOR capability required

   DELDX2:   invalid directory number

   DELFX2:   file cannot be expunged because it is currently open

   DELFX4:   directory symbol table could not be rebuilt

   DELFX5:   directory symbol table needs rebuilding

   DELFX6:   internal format of directory is incorrect

   DELFX7:   FDB formatted incorrectly; file not deleted

   DELFX8:   FDB not found; file not deleted
   (DELF)
   


Node: DELF	Previous: DELDF	Next: DELNF	Up: Top
			      DELF     JSYS 26

   Deletes the specified disk file and (if the file is	closed)  releases
   the JFN.  The file is not expunged immediately but is marked for later
   expunging by the system or with the DELDF or LGOUT monitor call.

   RESTRICTIONS:	       some functions require WHEEL  or  OPERATOR
			       capabilities enabled.
   ACCEPTS IN AC1:  B0(DF%NRJ) do not release the JFN

		    B1(DF%EXP) expunge the contents of	the  file.   This
			       also   deletes	the   FDB  entry  in  the
			       directory.   B0(DF%NRJ)	 and   B1(DF%EXP)
			       cannot be set simultaneously.

		    B2(DF%FGT) expunge the file but do not  deassign  its
			       addresses.  The process must have WHEEL or
			       OPERATOR capability enabled  to	set  this
			       bit.   This  bit  should be set only by an
			       operator or system specialist to delete	a
			       file  that  has	a damaged or inconsistent
			       index block.

		    B3(DF%DIR) delete and expunge a directory file.   The
			       process	 must	have  WHEEL  or  OPERATOR
			       capability enabled to set this bit.   This
			       bit  should  be set only by an operator or
			       specialist to delete a bad directory.

		   B4(DF%ARC)  allow a file with  archive  status  to  be
			       deleted.

		   B5(DF%CNO)  delete and expunge  the	contents  of  the
			       file  but preserve the file's name and FDB
			       as they were (with the  exception  of  the
			       page  count  and  the page table address).
			       Setting this bit will cause  the  DELF  to
			       fail  if  bit AR%NDL is set in word .FBBBT
			       of the FDB or if a complete  set  of  tape
			       backup information is not in the FDB.

		    B18-B35    JFN of the file being deleted
		    (DF%JFN)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, JFN is released unless B0(DF%NRJ) is  on  or
		    the file is opened.

   By setting B0(DF%NRJ), the user can delete multiple files by giving	a
   JFN to GNJFN that represents a group of files and processing each file
   in the group.

   The DELF call takes the  +1	return	if  the  JFN  is  assigned  to	a
   (DELF)
   

   non-directory device.

   DELF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DESX9:    invalid operation for this device

   DELFX1:   delete access required

   DELFX2:   file cannot be expunged because it is currently opened

   DELFX3:   system scratch area depleted; file not deleted

   DELFX4:   directory symbol table could not be rebuilt

   DELFX5:   directory symbol table needs rebuilding

   DELFX6:   internal format of directory is incorrect

   DELFX7:   FDB formatted incorrectly; file not deleted

   DELFX8:   FDB not found; file not deleted

   DELFX9:   file is not a directory file

   DELF10:   directory still contains subdirectory

   DLFX10:   cannot delete directory; file still mapped

   DLFX11:   cannot delete directory file in this manner

   WHELX1:   WHEEL or OPERATOR capability required


Node: DELNF	Previous: DELF	Next: DEQ	Up: Top
			     DELNF     JSYS 317

   Deletes all but the specified number of generations of  a  disk  file.
   The	files  are  marked  for deletion and are expunged at a later time
   either automatically by the system or explicitly  with  the	DELDF  or
   LGOUT call.

   ACCEPTS IN AC1:	       B0(DF%NRJ) do not release the JFN

		    B4(DF%ARC) allow a file with  archive  status  to  be
   (DELNF)
   

			       deleted.

		    B5(DF%CNO) delete and expunge  the	contents  of  the
			       file  but preserve the file's name and FDB
			       as they were (with the  exception  of  the
			       page  count  and  the page table address).
			       Setting this bit will cause  the  DELF  to
			       fail  if  bit AR%NDL is set in word .FBBBT
			       of the FDB or if a complete  set  of  tape
			       backup information is not in the FDB.

		     B18-B35   JFN of the file being deleted

   AC2: 		       the number of generations to retain

	      RETURNS	  +1:  failure, error code in AC1

			  +2:  success, with the number of files  deleted
			       in AC2

   Starting at the file specified by the JFN, the DELNF  call  decrements
   the	generation  number,  first  retaining  the  specified  number  of
   generations before deleting the remaining generations.

   DELNF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DELFX1:   delete access required


Node: DEQ	Previous: DELNF	Next: DEVST	Up: Top
			      DEQ     JSYS 514

   Removes a request for a specific resource from  the	queue  associated
   with that resource.	The request is removed whether or not the process
   has a lock for the resource or is only waiting in the  queue  for  the
   resource.

   This call can be used to remove any number of requests.  If one of the
   requests  cannot be dequeued, the dequeueing procedure continues until
   all requests that can be have been dequeued.  An error return is given
   for	the  last  request found that could not be dequeued.  The process
   can then execute the ENQC call to determine the current status of each
   request.   However,	if  the  process  attempts to dequeue more pooled
   resources than it originally allocated, the error return is taken  and
   (DEQ)
   

   none of the pooled resources are dequeued.

   Refer to the TOPS-20 Monitor Calls User's Guide for	an  overview  and
   description of the Enqueue/Dequeue facility.

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument  block	(required  only  for  the
		    .DEQDR function)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

      Code   Symbol			   Meaning

	0    .DEQDR	    Remove the specified requests from the queue.
			    This  function  is	the only one requiring an
			    argument block.

	1    .DEQDA	    Remove all requests for this process from the
			    queues.   This  action is taken on a RESET or
			    LGOUT call.  The error return is taken if the
			    process has not given an ENQ call.

	2    .DEQID	    Remove all requests that  correspond  to  the
			    specified	request   identifier(ID).    This
			    function allows  the  process  to  release	a
			    class  of locks in one call without itemizing
			    each lock in an argument block.  It is useful
			    when  dequeueing  in  one call the same locks
			    that were enqueued in one call.  To use  this
			    function,	the  process  places  the  18-bit
			    request ID in AC2.

   The format of the argument block for function .DEQDR is  identical  to
   that  given	on  the  ENQ  call.   (Refer  to  the  ENQ  monitor  call
   description.) However, the .ENQID word of the argument  block  is  not
   used on a DEQ call and must be zero.

   DEQ ERROR MNEMONICS:

   ENQX1:    invalid function

   ENQX2:    level number too small

   ENQX3:    request and lock level numbers do not match

   ENQX4:    number of pool and lock resources do not match

   ENQX6:    requested locks are not all locked

   ENQX7:    no ENQ on this lock
   (DEQ)
   

   ENQX9:    invalid number of blocks specified

   ENQX10:   invalid argument block length

   ENQX11:   invalid software interrupt channel number

   ENQX13:   indirect or indexed byte pointer not allowed

   ENQX14:   invalid byte size

   ENQX15:   ENQ/DEQ capability required

   ENQX16:   WHEEL or OPERATOR capability required

   ENQX17:   invalid JFN

   ENQX18:   quota exceeded

   ENQX19:   string too long

   ENQX20:   locked JFN cannot be closed

   ENQX21:   job is not logged in

   DESX8:    file is not on disk


Node: DEVST	Previous: DEQ	Next: DFIN	Up: Top
			     DEVST     JSYS 121

  Translates the given device	designator  to	its  corresponding  ASCIZ
  device   name   string.    The   string  returned  contains	only  the
  alphanumeric device name;  it does not contain a colon.

   ACCEPTS IN AC1:  destination designator

	      AC2:  device designator

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC1, if pertinent

   The STDEV monitor call can be  used	to  translate  a  string  to  its
   corresponding device designator.

   DEVST ERROR MNEMONICS:

   DEVX1:    invalid device designator

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job
   (DEVST)
   

   DESX3:    JFN is not assigned

   IOX11:    quota exceeded or disk full


Node: DFIN	Previous: DEVST	Next: DFOUT	Up: Top
			     DFIN     JSYS 234

  Inputs  a  double-precision,  floating-point   number,   rounding   if
  necessary.	 Currently   this   call   stores   the  number  in  KA10
  double-precision floating-point format.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  failure, error code in AC4 and updated string pointer
		    in AC1, if pertinent.

	       +2:  success,  double-precision,   floating-point   number
		    (extended  format where necessary) in AC2 and AC3 and
		    updated string pointer in AC1, if pertinent.

   DFIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   FLINX1:   first character is not blank or numeric

   FLINX2:   number too small

   FLINX3:   number too large

   FLINX4:   invalid format


Node: DFOUT	Previous: DFIN	Next: DIAG	Up: Top
			     DFOUT     JSYS 235

  Outputs a double-precision,	floating-point	number.   Currently  this
  call  outputs a number stored in KA10 double-precision, floating-point
  format.

   ACCEPTS IN AC1:  destination designator
   (DFOUT)
   

	      AC2:  a normalized double-precision

	      AC3:  floating-point   number   in   either   extended   or
		    non-extended range.

	      AC4:  format control word.  (Refer to Section 2.8.1.2.)

   RETURNS     +1:  failure, error code in AC4 and updated string pointer
		    in AC1, if pertinent.

	       +2:  success, updated string pointer in AC1, if pertinent.

   DFOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   FLOTX1:   column overflow in field 1 or 2

   FLOTX2:   column overflow in field 3

   FLOTX3:   invalid format specified

   IOX11:    quota exceeded or disk full


Node: DIAG	Previous: DFOUT	Next: DIBE	Up: Top
			     DIAG     JSYS 530

   Reserves a channel and either a single device or all devices  attached
   to  that  channel.	This call is also used to release the channel and
   its devices.  When the request is made, no new activity  is	initiated
   on  the  requested channel, and the monitor waits for current activity
   on all devices connected to the channel to complete.  When the channel
   becomes idle, the process requesting the channel continues running.

   The DIAG JSYS can also be used to get and  release  memory.	 The  get
   memory  function is used by the system program TGHA for performing its
   spare bit substitution.

   Reserving or Releasing a Channel and Device(s).

   RESTRICTIONS:    requires WHEEL, OPERATOR, or MAINTENANCE capabilities
		    enabled.

  ACCEPTS IN AC1:  negative length of the argument  block  in	the  left
		    half,  and address of the argument block in the right
   (DIAG)
   

		    half.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

   Function  Symbol    Meaning

       1     .DGACU    Assign the channel and a single device.	Force the
		       device	to  be	released  after  the  time  limit
		       specified.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address
		       2       time limit in milliseconds

       2     .DGACH    Assign the channel and all devices.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address

       3     .DGRCH    Release the channel and all assigned devices.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address

       4     .DGSCP    Set up the channel  program.   The  data  transfer
		       must  be in one page.  The user page pointed to by
		       the channel control word is locked in memory.  The
		       Exec  Process  Table location corresponding to the
		       channel is updated with the  appropriate  physical
		       address channel control word.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address
		       2       channel control word
   (DIAG)
   

       5     .DGRCP    Release the channel program.  The page pointed  to
		       by  the	channel  control  word	for the specified
		       channel	is  unlocked.	This  function	 is   not
		       required before specifying a new channel program.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address

       6     .DGGCS    Return the status of the  channel.   The  argument
		       block contains the logout area for the channel.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address
		       2-5     4-word channel logout area

       100   .DGGEM    Get memory (for TGHA).

		       Argument block:

		       Word    Contents

		       0       function code
		       1       first page in user address space
		       2       first physical memory page
		       3       number of pages
		       4       user  address  of   AR/ARX   parity   trap
			       routines

       Upon successful return, this function accomplishes the following:

		       1.  TOPS-20 has requested that all  of  the  front
			   ends refrain from accessing common memory.

		       2.  The hardware PI system has  been  turned  off;
			   no scheduling can occur.

		       3.  The time base and  interval	timer  have  been
			   turned off.

		       4.  All DTE byte transfers have completed.

   (DIAG)
   

		       5.  All RH20 activity has ceased.

		       6.  The designated pages of the	process'  address
			   space   have   been	set  up  to  address  the
			   designated physical memory.	Note that this is
			   not	the  same  as  your  having requested the
			   pages  with	PLOCK.	 With  the   get   memory
			   function,  the  data  in  the  physical memory
			   pages have been retained, and the ownership of
			   the pages is unchanged.

		       7.  The CST0 entries for each  of  the  designated
			   physical  pages  have  been	saved  and set as
			   follows:

		       8.  The age is set  to  the  present  age  of  the
			   requesting process.

		       9.  The process use field is set to all ones.

		      10.  The modified bit is set to one.

		      11.  The entire address  space  of  the  requesting
			   process has been locked in memory.  (Actually,
			   only the pages that existed at the time of the
			   DIAG  call are locked.  Therefore, the process
			   must ensure that all of  the  pages	it  needs
			   exist and are private when DIAG is executed.)

		      12.  The monitor has set up proper dispatch if TGHA
			   specified an AR/ARX trap address.

       101   .DGREM    Release memory (for TGHA)

		       Argument block:

		       Word    Contents

		       0       function code

      102   .DGPDL    Inform  the  monitor  that  a  device   previously
		       unknown	to  it	is  now available for use (is now
		       online).  For devices interfaced through the  DX20
		       (TX01, TX03, TX05, TU70, TU72).

		       Argument block:
   (DIAG)
   

		       Word    Contents

		       0       function code
		       1       channel number
		       2       unit number
		       3       controller number (-1 if no controller)
		       4       alternate path channel number
		       5       alternate path unit number (should be same
			       as primary path unit number)
		       6       alternate path controller number (-1 if no
			       controller)

   The device  address	given  in  some  of  the  argument  blocks  is	a
   machine-dependent  specification  for  the  channel	and  device to be
   assigned.  The devices that can be assigned must be	attached  to  the
   RH20  controller  and  must	be  mounted  by a process with the WHEEL,
   OPERATOR, or MAINTENANCE capability enabled.  The format of the device
   address word is

	  0	    2 3       9 10     23 24	 29 30		35
	 !=======================================================!
	 !  address  ! device  !    0	 !  unit   !   subunit	 !
	 !   type    !	code   !	 !	   !		 !
	 !=======================================================!

   DIAG ERROR MNEMONICS:

   DIAGX1:   invalid function

   DIAGX2:   device is not assigned

   DIAGX3:   argument block too small

   DIAGX4:   invalid device type

   DIAGX5:   WHEEL, OPERATOR, or MAINTENANCE capability required

   DIAGX6:   invalid channel command list

   DIAGX7:   illegal to do I/O across page boundary

   DIAGX8:   no such device

   DIAGX9:   unit does not exist

   DIAG10:   subunit does not exist

   DIAG11:   Device is already on-line
   (DIBE)
   


Node: DIBE	Previous: DIAG	Next: DIC	Up: Top
			     DIBE     JSYS 212

   Dismisses the process until the designated file input buffer is empty.

   ACCEPTS IN AC1:  file designator

   RETURNS     +1:  always

   Returns immediately	if  the  designator  is  not  associated  with	a
   terminal.

   The DOBE monitor call can be used to dismiss  the  process  until  the
   designated file output buffer is empty.

   Generates an illegal instruction interrupt on error conditions below.

   DIBE ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: DIC	Previous: DIBE	Next: DIR	Up: Top
			      DIC     JSYS 133

   Deactivates the specified  software	interrupt  channels.   (Refer  to
   Section 2.5.1.)

   ACCEPTS IN AC1:  process handle

	      AC2:  36-bit word
		    Bit n means deactivate channel n

   RETURNS     +1:  always

   Software interrupt requests to deactivated channels are ignored except
   for	interrupts generated on panic channels.  Panic channel interrupts
   are passed to the closest  superior	process  that  has  the  specific
   channel enabled.

   The AIC monitor call is used to activate specified software	interrupt
   channels.

   Generates an illegal instruction interrupt on error conditions below.
   (DIC)
   

   DIC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: DIR	Previous: DIC	Next: DIRST	Up: Top
			      DIR     JSYS 130

   Disables the software interrupt system for a process.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   If software interrupt  requests  are  generated  while  the	interrupt
   system  is  disabled, the requests are remembered and take effect when
   the interrupt system is reenabled unless an intervening  CIS  call  is
   executed.   However,  interrupts  on  panic	channels  will	still  be
   generated even though the system is disabled.   In  addition,  if  the
   CTRL/C  terminal code is assigned to a channel, it will still generate
   an interrupt  that  cannot  be  disabled  with  a  DIR  call.   CTRL/C
   interrupts  can  be	disabled by deactivating the channel to which the
   code is assigned or by the monitor.

   The EIR monitor call can be used  to  enable  the  software	interrupt
   system for a process.

   Generates an illegal instruction interrupt on error conditions below.

   DIR ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: DIRST	Previous: DIR	Next: DISMS	Up: Top
			     DIRST     JSYS 41
   (DIRST)
   

   Translates the specified  36-bit  user  or  directory  number  to  its
   corresponding  string  and writes it to the given destination.  When a
   user number is given, the string returned is  the  corresponding  user
   name  without  any punctuation.  When a directory number is given, the
   string returned is the  corresponding  structure  and  directory  name
   including punctuation (i.e., structure:<directory>).

   ACCEPTS IN AC1:  destination designator

	      AC2:  user or directory number

   RETURNS     +1:  failure, with error code in AC1.

	       +2:  success,  string  written  to  destination,   updated
		    string pointer, if pertinent, in AC1

   The RCDIR monitor call can be used to translate a directory string  to
   its	corresponding  directory  number.   The RCUSR monitor call can be
   used to translate a user name string to its corresponding user number.

   DIRST ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DELFX6:   internal format of directory is incorrect

   DIRX1:    invalid directory number

   DIRX2:    insufficient system resources

   DIRX3:    internal format of directory is incorrect

   STRX01:   structure is not mounted

   IOX11:    quota exceeded or disk full


Node: DISMS	Previous: DIRST	Next: DOBE	Up: Top
			     DISMS     JSYS 167

   Dismisses this process for the specified amount of time.

   ACCEPTS IN AC1:  number of milliseconds for which the process is to be
		    dismissed

   RETURNS     +1:  when the elapsed time is up
   (DISMS)
   

   The maximum number of milliseconds that a process can be dismissed  is
   2^26  milliseconds.	 If  a	number	is given that is greater than the
   maximum, it is ignored and the maximum dismiss  time  is  given.   The
   time  resolution  is  limited  to  the  scheduling frequency (about 20
   milliseconds).


Node: DOBE	Previous: DISMS	Next: DSKAS	Up: Top
			     DOBE     JSYS 104

   Dismisses the process until	the  designated  file  output  buffer  is
   empty.

   ACCEPTS IN AC1:  destination designator

   RETURNS     +1:  always

   Returns immediately if designator is not associated with a terminal.

   The DIBE monitor call can be used to dismiss  the  process  until  the
   designated file input buffer is empty.

   Generates an illegal instruction interrupt on error conditions below.

   DOBE ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: DSKAS	Previous: DOBE	Next: DSKOP	Up: Top
			     DSKAS     JSYS 244

   Assigns or deassigns specific disk addresses.

   RESTRICTIONS:	       requires WHEEL  or  OPERATOR  capabilities
			       enabled.
   ACCEPTS IN AC1:  B0(DA%DEA) deassign the specified  address.   If  the
			       address	is  currently  assigned,  control
			       returns to the next instruction	following
			       the  call (+1 return).  If the address was
			       not previously assigned, a BUGCHK occurs.
   (DSKAS)
   

		    B1(DA%ASF) assign a  free  page  near  the	specified
			       address.    Assignment	is  on	the  same
			       cylinder  as  the  specified  address,  if
			       possible, or on a nearby cylinder.  If the
			       specified address is 0, a page is assigned
			       on  a  cylinder	that is at least one-half
			       free.  If the assignment is  not  possible
			       because	the disk is full, control returns
			       to  the	next  instruction  following  the
			       call.

		    B2(DA%CNV) convert the specified address according to
			       the setting of B3(DA%HWA).

		    B3(DA%HWA) the  specified  address	is   a	 hardware
			       address.    If	this   bit  if	off,  the
			       specified address is a software address.

		    B4(DA%INI) initialize  a  private  copy  of  the  bit
			       table.

		    B5(DA%WRT) write the private copy of the bit table to
			       a new bit table file.

		    B18-B35    disk address
		    (DA%ADR)

	      AC2:  device designator of structure.  If DA%CNV is  on  in
		    AC1, this argument is not required.

   RETURNS     +1:  failure,  address  already	assigned  or  cannot   be
		    assigned

	       +2:  success, address assigned in AC1

   Generates an illegal instruction interrupt on error conditions below.

   DSKAS ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required


Node: DSKOP	Previous: DSKAS	Next: DTACH	Up: Top
			     DSKOP     JSYS 242

   Allows  the	process  to  reference	physical  disk	 addresses   when
   performing  disk transfers.	This monitor call requires the process to
   have WHEEL, OPERATOR, or MAINTENANCE capability enabled  to	read  and
   write  data.   However,  a  process	with  only MAINTENANCE capability
   enabled can write data only if it is using physical addresses (.DOPPU)
   and writing to a unit that is not part of a mounted structure.
   (DSKOP)
   

   RESTRICTIONS:		   requires	WHEEL	  or	 OPERATOR
				   capabilities  enabled.  Some functions
				   can	be  performed  with   MAINTENANCE
				   capabilities enabled.

   ACCEPTS IN AC1:  B0-B1(DOP%AT)  field  indicating  the  address  type.
				   For	  physical   channel   and   unit
				   addresses, the value of the	field  is
				   1(.DOPPU) and the remainder of AC1 is
				      B2-B6(DOP%CN) channel number
				      B7-B12(DOP%UN) unit number
				      B13-B35(DOP%UA) unit address
				   For	a  structure   and   a	 relative
				   address,  the  value  of  the field is
				   2(.DOPSR) and the remainder of AC1 is
				      B2-B10(DOP%SN) structure designator
				       flag  (0  is  structure	 PS:).	A
				       value of -1 means the structure is
				       indicated    by	  the	structure
				       designator  (refer to Section 2.4)
				       in AC4.
				      B11-B35(DOP%RA) relative address

				   Any other values for  this  field  are
				   illegal.

	      AC2:  control flags in the left half and	a  count  of  the
		    number  of	words to transfer in the right half.  The
		    control flags are

		    B11(DOP%IL)  inhibit error logging
		    B12(DOP%IR)  inhibit error recovery
		    B14(DOP%WR)  write data to the disk.  If this bit  is
				 off, read data from the disk.
		    B18-B35	 word count.  Since the  transfer  cannot
		    (DOP%CT)	 cross a page boundary, the count must be
				 less  than  or  equal	to  1000  (octal)
				 words.

	      AC3:  address in caller's address space from which data  is
		    written or into which data is read.

	      AC4:  device designator of the  structure.   This  word  is
		    used if the value given for DOP%SN is -1.

   RETURNS     +1:  always, AC1 is nonzero if an error occurred  or  zero
		    if no error occurred.

   If an error occurs and DOP%IL is on in the call, no error  logging  is
   performed.	If  DOP%IL  is	off, the standard system error logging is
   performed.

   If an error occurs and DOP%IR is on in the call,  no  retries  or  ECC
   corrections,  if  applicable,  are  attempted.   If DOP%IR is off, the
   standard system error recovery procedure is followed.
   (DSKOP)
   

   Generates an illegal instruction interrupt on error conditions below.

   DSKOP ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required

   DSKOX1:   channel number too large

   DSKOX2:   unit number too large

   DSKOX3:   invalid structure number

   DSKOX4:   invalid address type specified


Node: DTACH	Previous: DSKOP	Next: DTI	Up: Top
			     DTACH     JSYS 115

   Detaches the controlling terminal from the current  job.   (The  ATACH
   call  with bit 1 (AT%NAT) of AC2 set can be used to detach a job other
   than the current job.) A console-detached entry  is	appended  to  the
   accounting data file.

   RETURNS     +1:  always

   The DTACH call is a no-op if the job is already detached.

   The ATACH monitor call is used to attach the controlling terminal to a
   specified job.


Node: DTI	Previous: DTACH	Next: DUMPI	Up: Top
			      DTI     JSYS 140

   Deassigns a terminal code.

   ACCEPTS IN AC1:  terminal code; refer to Section 2.5.6

   RETURNS     +1:  always

   The DTI call is a  no-op  if  the  specified  terminal  code  was  not
   assigned by the current process.

   The ATI monitor call is used to assign a terminal code.

   Generates an illegal instuction interrupt on error conditions below.

   DTI ERROR MNEMONICS:
   (DTI)
   

   TERMX1:   invalid terminal code


Node: DUMPI	Previous: DTI	Next: DUMPO	Up: Top
			     DUMPI     JSYS 65

   Reads data words into memory in unbuffered data mode.  The  file  must
   be  open  for data mode 17.	(Refer to Section 2.4.2.2 for information
   about unbuffered magnetic tape I/O.)

   ACCEPTS IN AC1:  JFN

	      AC2:  B0(DM%NWT)	do not wait for completion  of	requested
				operation

		    B18-B35	address of command list in memory
		    (DM%PTR)

   RETURNS     +1:  failure, error code  in  AC1,  pointer  to	offending
		    command in AC2

	       +2:  success, pointer in AC2 updated to last command

   The use of B0(DM%NWT) allows data operations  to  be  double  buffered
   with  a resulting increase in speed.  When this bit is on, DUMPI/DUMPO
   returns immediately after the request  is  queued.	This  allows  the
   program  to	overlap  computations  with I/O transfers.  If the second
   request is then made, the program is blocked until the  first  request
   is  completed.   Generally,	for  a sequence of overlapped DUMPI/DUMPO
   calls, return from the Nth call indicates that the Nth-1  request  has
   completed  and  that  the Nth request is now in progress.  This bit is
   implemented only for magnetic tape.

   The GDSTS call  can	be  used  after  the  transfer	is  completed  to
   determine the number of words read.

   If an error occurs on the Nth request, the failure return is given  on
   the Nth+1 call, and the Nth+1 request is ignored.  This means that the
   program will discover an error on a request only after making the next
   request.   The  next  request is ignored to prevent improper operation
   and must be reissued after the error has been  processed.   The  GDSTS
   call can be executed to determine the cause for the error.

   COMMAND LIST FORMAT

   Three types of entries may occur in the command list.

	1.  IOWD n, loc - Causes n words to be transferred from the  file
	    to	locations  loc	through  loc+n-1  of  the process address
	    space.  The  next  command	is  obtained  from  the  location
	    following  the  IOWD.   For  mag-tape files, 1 IOWD word will
	    read 1 physical tape record.  For labeled mag-tape files, the
   (DUMPI)
   

	    data format must be "U".

	    The IOWD pseudo-op generates XWD -n,loc-1.

	2.  XWD 0, y - Causes the next command to be taken from  location
	    y.	Referred to as a GOTO word.

	3.  0 - Terminates the command list.

   DUMPI ERROR MNEMONICS:

   DUMPX1:   command list error

   DUMPX2:   JFN is not open in dump mode

   DUMPX3:   address error (too big or crosses end of memory)

   DUMPX4:   access error (cannot read or write data in memory)

   DUMPX5:   no-wait dump mode not supported for this device

   DUMPX6:   dump mode not supported for this device

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   IOX1:     file is not opened for reading

   IOX4:     end of file reached

   IOX5:     device or data error


Node: DUMPO	Previous: DUMPI	Next: DVCHR	Up: Top
			     DUMPO     JSYS 66

   Writes data words from memory in unbuffered data mode.  The file  must
   be  open  for data mode 17.	(Refer to Section 2.4.2.2 for information
   about unbuffered magnetic tape I/O.)

   ACCEPTS IN AC1:  JFN

	      AC2:  B0(DM%NWT)	do not wait for completion  of	requested
				operation
   (DUMPO)
   

		    B18-B35	address of command list in memory
		    (DM%PTR)

   RETURNS     +1:  failure, error code  in  AC1,  pointer  to	offending
		    command in AC2

	       +2:  success, pointer in AC2 updated to last command

   The use of B0(DM%NWT) allows data operations  to  be  double  buffered
   with  a resulting increase in speed.  When this bit is on, DUMPI/DUMPO
   returns immediately after the request  is  queued.	This  allows  the
   program  to	overlap  computations  with I/O transfers.  If the second
   request is then made, the program is blocked until the  first  request
   is  completed.   Generally,	for  a sequence of overlapped DUMPI/DUMPO
   calls, return from the Nth call indicates that the Nth-1  request  has
   completed  and  that  the Nth request is now in progress.  This bit is
   implemented only for magnetic tape.

   COMMAND LIST FORMAT

   Three types of entries may occur in the command list.

	1.  IOWD n, loc - Causes n words from loc through loc+n-1  to  be
	    transferred  from the process address space to the file.  The
	    next command is obtained  from  the  location  following  the
	    IOWD.   For mag-tape files, 1 IOWD word will write 1 physical
	    tape record.  For labeled mag-tape	files,	the  data  format
	    must be "U".

					NOTE

		Dump mode output to a labeled tape can	override  the
		block-size  limit  specified  in  the  GTJFN.  If any
		write produces a block in  excess  of  the  specified
		block-size  parameter, then the file can only be read
		in dump mode.

	    The IOWD pseudo-op generates XWD -n,loc-1.

	2.  XWD 0, y - Causes the next command to be taken from  location
	    y.	Referred to as a GOTO word.

	3.  0 - Terminates the command list.

   The GDSTS call  can	be  used  after  the  transfer	is  completed  to
   determine the number of words written.

   DUMPO ERROR MNEMONICS:
   (DUMPO)
   

   DUMPX1:   command list error

   DUMPX2:   JFN is not open in dump mode

   DUMPX3:   address error (too big or crosses end of memory)

   DUMPX4:   access error (cannot read or write data in memory)

   DUMPX5:   no-wait dump mode not supported for this device

   DUMPX6:   dump mode not supported for this device

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   IOX2:     file is not opened for writing

   IOX5:     device or data error

   IOX11:    quota exceeded or disk full


Node: DVCHR	Previous: DUMPO	Next: EFACT	Up: Top
			     DVCHR     JSYS 117

   Returns the device characteristics of the specified device.

   ACCEPTS IN AC1:  JFN or device designator

   RETURNS     +1:  always, with

		    AC1 containing the device designator (even if  a  JFN
		    was given).
		    AC2 containing the device characteristics word.
		    AC3 containing the job number to which the device  is
		    assigned  in the left half and the unit number in the
		    right half.  If the device is a structure or does not
		    have units, the right half is -1.

  The left half of AC3 contains -1 if the device is not assigned to  any
  job or -2 if the device allocator has ownership of the device.

			Device Characteristics Word
			  

   Bit		  Symbol	      Meaning
   (DVCHR)
   

   0		  DV%OUT	 device can do output
   1		  DV%IN 	 device can do input
   2		  DV%DIR	 device has a directory
   3		  DV%AS 	 device is assignable with ASND
   4		  DV%MDD	 device has multiple directories
		    Device Characteristics Word (Cont.)
		       

   5		  DV%AV 	 device is available or assigned to this
				 job
   6		  DV%ASN	 device is assigned by ASND
   8		  DV%MNT	 device is mounted
   9-17 	  DV%TYP	 device type
				   0	   .DVDSK	  disk
				   2	   .DVMTA	  magnetic tape
				   7	   .DVLPT	  line printer
				   10	   .DVCDR	  card reader
				   11	   .DVFE	  front-end
							  pseudo-device
				   12	   .DVTTY	  terminal
				   13	   .DVPTY	  pseudo-terminal
				   15	   .DVNUL	  null device
				   16	   .DVNET	  ARPA network
   20-35	  DV%MOD	 data mode in which device can be opened
				   B20	    DV%M17	  dump mode
				   B27	    DV%M10	  image mode
				   B35	    DV%M0	  normal mode

   Generates an illegal instruction interrupt on error conditions below.

   DVCHR ERROR MNEMONICS:

   DEVX1:    invalid device designator

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer


Node: EFACT	Previous: DVCHR	Next: EIR	Up: Top
			      EFACT     JSYS 5

   Makes an entry in the FACT file.  The EFACT monitor call  is  obsolete
   and	provided only for existing programs that make entries in the FACT
   file.  New programs should use the USAGE monitor call to make  entries
   in the new USAGE file.

   RESTRICTIONS:    requires WHEEL or OPERATOR capabilities enabled.
   ACCEPTS IN AC1:  LH:  negative size of entry
		    RH:  pointer to beginning  of  entry  (size  bits  of
			 entry	will  be  updated  by the system from the
   (EFACT)
   

			 negative size specified)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The EFACT call returns successfully without making  an  entry  in  the
   FACT file if the monitor flag SF%FAC (refer to SMON and TMON calls) is
   not set.

   The EFACT monitor call can be executed only by the  monitor	or  by	a
   process that has WHEEL or OPERATOR capability enabled.

   EFACT ERROR MNEMONICS:

   EFCTX1:   WHEEL or OPERATOR capability required

   EFCTX2:   entry cannot be longer than 64 words

   EFCTX3:   fatal error when accessing FACT file


Node: EIR	Previous: EFACT	Next: ENQ	Up: Top
			      EIR     JSYS 126

   Enables the software  interrupt  system  for  a  process.   (Refer  to
   Section 2.5.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   The DIR monitor call can be used to	disable  the  software	interrupt
   system for a process.

   Generates an illegal instruction interrupt on error conditions below.

   EIR ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: ENQ	Previous: EIR	Next: ENQC	Up: Top
			      ENQ     JSYS 513
   (ENQ)
   

   Requests access to a specific resource by placing  a  request  in  the
   queue  for that resource.  This call can be used to request any number
   of resources.

   Refer to the TOPS-20 Monitor Calls User's Guide for	an  overview  and
   description of the Enqueue/Dequeue facility.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

      Code   Symbol			   Meaning

	0    .ENQBL	    Queue the  requests  and  block  the  process
			    until  all requested locks are acquired.  The
			    error return is taken only if the call is not
			    correctly specified.

	1    .ENQAA	    Queue the requests and acquire the locks only
			    if	all  requested	resources are immediately
			    available.	No requests are  queued  and  the
			    error  return  is  taken  if  any  one of the
			    resources is not available.

	2    .ENQSI	    Queue  the	requests.    If   all	requested
			    resources  are  immediately  available,  this
			    function is identical to the .ENQBL function.
			    If	 all   resources   are	 not  immediately
			    available, the  request  is  queued  and  the
			    error  return  (ENQX6:) is taken.  A software
			    interrupt  will  occur  when  all	requested
			    resources have been given to the process.

	3    .ENQMA	    Modify the	access	of  a  previously  queued
			    request.  (Refer to EN%SHR below.) The access
			    of each lock in this request is compared with
			    the  access  of  each  lock in the previously
			    queued request.  If the two accesses are  the
			    same,  no  action is taken.  If the access in
			    this request is shared and the access in  the
			    previous request is exclusive, the successful
			    return is  taken.	If  the  access  in  this
			    request  is  exclusive  and the access in the
			    previous request is shared, the error  return
			    is taken unless this process is the only user
			    of the lock.  In this  case,  the  successful
			    return  is	taken.	 The error return is also
   (ENQ)
   

			    taken if

			    1.	Any one of the specified locks	does  not
				have a pending request.

			    2.	Any one  of  the  specified  locks  is	a
				pooled resource.

			    Each  lock	specified  is  checked,  and  the
			    access  is	changed  for  all locks that were
			    given correctly.   If  the	error  return  is
			    taken, the user must execute the ENQC call to
			    determine the current state of each lock.

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .ENQLN	    length  of	the  header  and  the  number  of
			    requested  locks in the left half, and length
			    of argument block in the right half.

	1    .ENQID	    software interrupt channel number in the left
			    half, and the request ID in the right half.

	2    .ENQLV	    flags and level number in the left half,  and
			    JFN,  -1,  -2, or -3 in the right half.  (See
			    below.)

	3    .ENQUC	    pointer to a  string  or  a  5B2+33-bit  user
			    code.

	4    .ENQRS	    number of resources in pool in the left  half
			    and  number  of  resources	requested  in the
			    right half, or 0 in the left half and a group
			    number in the right half.

	5    .ENQMS	    address of a resource mask block.
		.
		.
		.

      n-4		    flags and level number in the left half,  and
			    JFN, -1, -2, or -3 in the right half.

      n-3		    pointer to a  string  or  a  5B2+33-bit  user
			    code.

      n-2		    number of resources in pool in the left  half
			    and  number  of  resources	requested  in the
			    right half, or 0 in the left half and a group
			    number in the right half.

      n-1		    address of a resource mask block.
   (ENQ)
   

   The argument block is divided into two logical sections:  a header and
   individual  requests  for  each desired lock.  Words .ENQLN and .ENQID
   form the header.  Word .ENQLV through word .ENQMS form the  individual
   request  and are repeated for each lock being requested.  The words in
   the argument block are described in the following paragraphs.

   .ENQLN

   The length of the header (.ENHLN) is contained in bits  0  through  5.
   Currently,  the length of the header is two words.  (Note that a given
   length of zero or one is assumed to be equal to a length of two.)  The
   number  of  locks  being  requested	(.ENNLK)  is  contained in bits 6
   through 17, and the length of the argument block (.ENALN) is contained
   in bits 18 through 35.

   .ENQID

   The software interrupt channel specifies the number of the channel  on
   which  to generate an interrupt with the .ENQSI function.  The request
   ID is an 18-bit user-generated value used to identify  the  particular
   resource.   This  ID currently is not used by the system but is stored
   for future expansion of the facility.

   .ENQLV

   The following flags are defined:

      B0(EN%SHR)  Access to this resource is to be shared.  If	this  bit
		  is not set, access to the resource is to be exclusive.

      B1(EN%BLN)  Ignore the level number associated with this	resource.
		  Sequencing   errors	in  level  numbers  will  not  be
		  considered  fatal,  and  execution  of  the  call  will
		  continue.  If a sequencing error occurs, the successful
		  return will be taken, and AC1  will  contain	an  error
		  code indicating the sequencing error that occurred.

      B2(EN%NST)  Allow ownership of this lock to be nested to any  level
		  within  a  process.	This  means  that  a  process can
		  request this resource again even though it already owns
		  it.	If  the  process  has a request in the resource's
		  queue or if the process  already  owns  the  lock,  the
		  ownership  of the lock is nested to a depth one greater
		  than the current depth.  If the process does not have a
		  request  in  the  resource's queue, the setting of this
		  bit has no effect, and the execution of  the	ENQ  call
		  continues.   When  a process has a nested lock, it must
		  DEQ the resource as many times as it	ENQed  it  before
		  the resource becomes available to other processes.

      B3(EN%LTL)  Allow a long-term lock on this resource.  This notifies
		  the  system  that  this  resource  will  be  locked and
		  unlocked many times in a short period of time.  Setting
		  this bit permits a program to run faster if it is doing
		  multiple locks and unlocks on the same resource because
   (ENQ)
   

		  the argument block data is not deleted immediately from
		  the ENQ/DEQ data base when  a  DEQ  call  is	executed.
		  Thus,  the  time  required  to  re-create  the  data is
		  reduced.

      B9-B17	  Level number associated with this resource.
      (EN%LVL)

   The request is not queued and the error return is taken if  EN%BLN  is
   not set and

	1.  A resource with a level number less  than  or  equal  to  the
	    highest numbered resource requested so far is specified.

	2.  The level number of the current request does  not  match  the
	    level number supplied on previous requests for this resource.

   The right half of .ENQLV specifies the type of access desired for  the
   resource.   If  a  JFN  is  given, the file associated with the JFN is
   subject to the standard access protection of the  system.   If  -1  is
   given,  the resource can be accessed only by processes of the job.  If
   -2 is given, the resource can be accessed by any job  on  the  system.
   (The process must have ENQ capability enabled to specify -2.) If -3 is
   given, the resource can be accessed only by processes that have  WHEEL
   or OPERATOR capability enabled.

   .ENQUC

   This word is either a byte pointer to a string or a 33-bit user  code,
   either of which serves to uniquely identify the resource to all users.
   This quantity is the second part of the resource name.  (JFN, -1,  -2,
   or  -3  is  the  first part of the resource name.) The system makes no
   association between these identifiers and any physical resource.

   The string can be comprised of bytes of any size from 1 to 36 bits  in
   length  and	is  terminated	by a null byte.  The byte size desired is
   specified by the pointer to the string.  The  maximum  length  of  the
   string (including the terminating null byte) is 50 words long.

   .ENQRS

   This word is used to  allocate  multiple  resources	from  a  pool  of
   identical  resources.   The total number of resources in the pool is a
   parameter agreed upon by all users.	All requests for the same  pooled
   resource  must  agree  with	the original count or the error return is
   taken.  The number of resources being requested from the pool must  be
   greater  than  zero if a pool exists and must be smaller than or equal
   to the number in the pool.  If the left half of this word is zero, the
   system assumes only one resource of the specific type exists.  In this
   case, if the right half of this word is positive, it is interpreted as
   the	number	of  the  group of users who can simultaneously access the
   resource.

   .ENQMS
   (ENQ)
   

   Obtains a single  lock  representing  many  specific  resources.   For
   example,  a	lock  can  be obtained on a particular data base, and the
   specific resources requested can be individual records  in  that  data
   base.

  This word contains an address of a mask block, consisting of  a  count
  word  and  a  group	of  mask words.  The first word of the mask block
  contains a count (in the right half-word) of the number  of	words  in
  the block, including the count word.  The remaining words each contain
  36 mask bits, where each bit represents a  specific	resource  of  the
  lock.  The maximum length of the mask block is 16 words.  All requests
  for the resources associated with the mask block must specify the same
  length  for	the block or an error return is taken.	Also, when a mask
  block is specified, the ENQ call must request exclusive access to  the
  resource  and the left half of word .ENQRS of the lock request must be
  zero.

   The set of resources comprising the lock is a parameter agreed upon by
   all users.

   A process can obtain exclusive access to all or some of  the  specific
   resources  comprising  the  lock.   When  a process requires exclusive
   access to all of the resources, it executes an ENQ call (for exclusive
   access)  and  does not specify a mask block.  A successful return will
   be given if there are no other processes that have issued an ENQ  call
   for	that  lock.   Otherwise,  the  process blocks until the requested
   resources are available.

   When a process requires exclusive  access  to  some	of  the  specific
   resources  comprising the lock, it sets up the mask block and sets the
   bits corresponding to the specific resources it wants  to  lock.   The
   process then executes an ENQ call for exclusive access.  On successful
   execution of the ENQ call, the process has an exclusive lock  for  the
   resources  represented by the bits on in the mask.  The process blocks
   if another process owns an exclusive lock on  the  resource	and  that
   process' ENQ call did not specify a mask block.

   Once a mask block has been set up for a  set  of  specific  resources,
   subsequent  requests for a different set of resources will be honored.
   The set of resources being requested is considered  different  if  the
   bits  on in one process' mask block are not any of the same bits on in
   another process' mask block.  When a subsequent request is  given  for
   resources that are currently locked by a process, the process with the
   request blocked until the last of the currently  locked  resources  is
   dequeued by the owner of the lock.

   A process can dequeue all or part of the original  ENQ  call  request.
   When  a DEQ call is executed, the bits on in the mask block of the DEQ
   call are compared with the bits on in  the  original  ENQ  call.   The
   resources  not  being dequeued remain locked and must be dequeued by a
   subsequent DEQ call.  This action allows a process to lock a number of
   resources  all  at once and then to release individual resources as it
   finishes with them.	However, a process cannot execute subsequent  ENQ
   calls  to  request  additional  resources  from those requested in its
   original ENQ call.
   (ENQ)
   

   ENQ ERROR MNEMONICS:

   ENQX1:    invalid function

   ENQX2:    level number too small

   ENQX3:    request and lock level numbers do not match

   ENQX4:    number of pool and lock resources do not match

   ENQX5:    lock already requested

   ENQX6:    requested locks are not all locked

   ENQX8:    invalid access change requested

   ENQX9:    invalid number of blocks specified

   ENQX10:   invalid argument block length

   ENQX11:   invalid software interrupt channel number

   ENQX12:   invalid number of resources requested

   ENQX13:   indirect or indexed byte pointer not allowed

   ENQX14:   invalid byte size

   ENQX15:   ENQ/DEQ capability required

   ENQX16:   WHEEL or OPERATOR capability required

   ENQX17:   invalid JFN

   ENQX18:   quota exceeded

   ENQX19:   string too long

   ENQX20:   locked JFN cannot be closed

   ENQX22:   invalid mask block length

   ENQX23:   mismatched mask block lengths

   DESX8:    file is not on disk


Node: ENQC	Previous: ENQ	Next: EPCAP	Up: Top
			     ENQC     JSYS 515

   Returns  the  current  status  of  the  given  resource  and   obtains
   information	about  the  state  of the queues.  This monitor call also
   (ENQC)
   

   allows privileged processes to manipulate access rights to the  queues
   and to perform other utility functions on the queue structure.

   Refer to the TOPS-20 Monitor Calls User's Guide for	an  overview  and
   description of the Enqueue/Dequeue facility.

   The ENQC monitor call has two calling sequences, depending on  whether
   the	process is obtaining status information or is modifying the queue
   structure.

   Obtaining Status Information
     

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  function code (.ENQCS)

	      AC2:  address of argument block

	      AC3:  address of block in which to place status

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The function .ENQCS returns the status of the specified resources.

   The argument block is identical in format to the ENQ and DEQ  argument
   blocks.  (Refer to the ENQ monitor call description.)

   The status block has a 3-word entry for each resource specified in the
   argument  block.   This  entry  reflects  the  current  status  of the
   resource and has the following format:

	  0			   17 18		       35
	 !=======================================================!
	 !	  flag bits indicating status of resource	 !
	 !=======================================================!
	 !		     36-bit time stamp			 !
	 !=======================================================!
	 ! # of processes with lock  !	      request ID	 !
	 !=======================================================!

   The following flag bits are currently defined.

	B0(EN%QCE) An error has occurred in  the  corresponding  resource
		   request  and  bits  18-35 contain an appropriate error
		   code.

	B1(EN%QCO) This process owns the lock.

	B2(EN%QCQ) This  process  is  in  the  queue  waiting  for   this
		   resource.   This  bit  is  set  if  B1(EN%QCO)  is set
		   because a request remains in the  queue  until  a  DEQ
   (ENQC)
   

		   call is given.

	B3(EN%QCX) The lock has been allocated for exclusive access.

	B4(EN%QCB) This process is in the  queue  waiting  for	exclusive
		   access to the resource.  This bit is off if B2(EN%QCQ)
		   is off.

	B9-B17	   The level number of the resource.
	(EN%LVL)

	B18-B35    Job	number	of  the  owner	of  the lock.  For  locks
	(EN%JOB)   with shared access, this value will be the job  number
		   of  one  of	the sharers.  However, this value will be
		   the current job's number if the current job is one  of
		   the	sharers.   If the lock is not owned, the value is
		   -1.	If B0(EN%QCE) is  on,  this  field  contains  the
		   appropriate error code.

   The time stamp indicates the last time a process was given  access  to
   the resource.  The time is in the universal date-time standard.  If no
   process currently has access to the resource, the word is zero.

   The number returned in the left half of the third word  indicates  the
   number of processes that currently have the resource locked for either
   exclusive access or shared access.

   The request ID is either the request ID of the current process if that
   process is in the queue or the request ID of the owner of the lock.

   Modifying the Queue Structure
      

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions, along with their argument block formats,  are
   as follows:

	Function  Argument Block		     Meaning

	.ENQCG	  One word containing	   Return the ENQ/DEQ quota for
		  a job number in the	   the specified job. The quota
		  right half. The left	   is returned in AC1.
		  half is ignored.

	.ENQCC	  One word containing	   Change the ENQ/DEQ quota for
		  the new quota in the	   the specified job. The process
		  left half and a job	   executing the call must have
		  number in the right	   WHEEL capability enabled or an
		  half. 		   error code is returned.
   (ENQC)
   

	.ENQCD	  A block of n words.	   Dump the ENQ/DEQ locks and
		  The first word is the    queue entries into the
		  length of the block (n). argument block. The process
		  Remaining words contain  executing the call must have
		  the returned		   WHEEL capability enabled or an
		  data. (See below.)	   error code is returned.

   The data returned in the argument block is data  concerning	both  the
   ENQ/DEQ  locks  and the queues.  The data concerning the locks is in a
   4-word block of the following format:

	       0	   8 9		17 18			    35
	      !=======================================================!
      .ENQDF  !    flags    !level number ! OFN, 40000+job#, -2, or -3!
	      !=======================================================!
      .ENQDR  !  total resources in pool  ! # of resources remaining  !
	      !=======================================================!
      .ENQDT  ! 	  time stamp of last request locked	      !
	      !=======================================================!
      .ENQDC  !       user code of lock or beginning of string	      !
	      !=======================================================!

   If there are no pooled resources, word .ENQDR has the format:

	       0			17 18			    35
	      !=======================================================!
      .ENQDR  ! 	    0		  !	  group number	      !
	      !=======================================================!

   The data concerning the queues is in a 2-word block of  the	following
   format:

	       0	   8 9		17 18			    35
	      !=======================================================!
      .ENQDF  !    flags    !software chan! job # creator queue entry !
	      !=======================================================!
      .ENQDI  !group # or number requested!	   request ID	      !
	      !=======================================================!

   The flags returned in the first word of each block are as follows:

      B0(EN%QCL) This block concerns data about the locks.  If	this  bit
		 is off, the block concerns data about the queues.

      B1(EN%QCO) This process owns the lock.

      B2(EN%QCT) This lock contains a text string.

      B3(EN%QCX) This lock is for exclusive access.
   (ENQC)
   

      B4(EN%QCB) This  process	is  blocked  until  exclusive  access  is
		 available.

   ENQC ERROR MNEMONICS:

   ENQX1:    invalid function

   ENQX2:    level number too small

   ENQX3:    request and lock level numbers do not match

   ENQX4:    number of pool and lock resources do not match

   ENQX5:    lock already requested

   ENQX6:    requested locks are not all locked

   ENQX7:    no ENQ on this lock

   ENQX8:    invalid access change requested

   ENQX9:    invalid number of blocks specified

   ENQX10:   invalid argument block length

   ENQX11:   invalid software interrupt channel number

   ENQX12:   invalid number of resources requested

   ENQX13:   indirect or indexed byte pointer not allowed

   ENQX14:   invalid byte size

   ENQX15:   ENQ/DEQ capability required

   ENQX16:   WHEEL or OPERATOR capability required

   ENQX17:   invalid JFN

   ENQX18:   quota exceeded

   ENQX19:   string too long

   ENQX20:   locked JFN cannot be closed

   ENQX21:   job is not logged in

   DESX8:    file is not on disk


Node: EPCAP	Previous: ENQC	Next: ERSTR	Up: Top
			     EPCAP     JSYS 151
   (EPCAP)
   

   Enables the capabilities for the specified process.	(Refer to Section
   2.6.1 for a description of the capability word.)

   ACCEPTS IN AC1:  process handle

	      AC2:  capabilities possible for the specified process

	      AC3:  capabilities to enable for the specified process

   RETURNS     +1:  always

   The capabilities in bits 0-8 and bits 18-35 of AC2  are  matched  with
   the	corresponding capabilities of the process executing the call.  If
   the executing process does  not  have  the  capability  available,  it
   cannot be enabled for the specified process (i.e., an AND operation is
   performed).

   The contents of AC2 are ignored if the process handle in  AC1  is  for
   the current process.

   The RPCAP monitor call can be used to obtain  the  capabilities  of	a
   process.

   Generates an illegal instruction interrupt on error conditions below.

   EPCAP ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process


Node: ERSTR	Previous: EPCAP	Next: ESOUT	Up: Top
			     ERSTR     JSYS 11

   Translates a TOPS-20 error number to its corresponding text string and
   writes  the string to the specified destination.  This error number is
   the one returned in an AC (usually in AC1) on  a  JSYS  error  and  is
   associated  with  a	unique error mnemonic and text string.	The error
   numbers begin at 600010 and are defined in the system file MONSYM.MAC.
   (Refer  to  Appendix  A  for the list of error numbers, mnemonics, and
   text strings.)

   ACCEPTS IN AC1:  destination designator

	      AC2:  LH:  process handle
		    RH:  error number, or -1 for the most recent error
			 in the specified process.  If an error number is
			 specified, .FHSLF should be specified in AC1.

	      AC3:  LH:  a negative  count of the maximum number of bytes
			 in the string to be transferred,  or  0  for  no
   (ERSTR)
   

			 limit
		    RH:  0

   RETURNS     +1:  failure, undefined error number

	       +2:  failure,  string  size  out  of  bounds  or   invalid
		    destination designator

	       +3:  success

  Note that if an error code (i.e.  not -1) is given in the  right  half
  of  AC2,  then  the	fork  handle  in  the  left  half  of  AC2 has no
  significance to the JSYS.  (It will return an error, however,  if  the
  fork handle is not a legitimate handle.)

   Generates an illegal instruction interrupt on error conditions below.

   ERSTR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   FRKHX1:   invalid process handle

   IOX11:    quota exceeded or disk full


Node: ESOUT	Previous: ERSTR	Next: FFFFP	Up: Top
			     ESOUT     JSYS 313

   Outputs an error string.  This monitor call is used for  reporting  an
   error  in  the  input  from the primary input stream in order to cause
   re-synchronization  of  the	input  transaction.   This  mechanism  is
   convenient  for  communication with a user who made a typing error and
   may have continued to type ahead.  It also standardizes the format  of
   error messages.

   ACCEPTS IN AC1:  byte pointer to a  string  in  the	caller's  address
		    space.    The   string  is	terminated  with  a  null
		    character.

   RETURNS     +1:  always, updated string pointer in AC1

   The ESOUT call waits for the primary output buffer to empty	and  then
   outputs a carriage return, line feed, and question mark to the primary
   output designator.  Next  it  clears  the  primary  input  buffer  and
   outputs the error string to the primary output designator.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)
   (FFFFP)
   


Node: FFFFP	Previous: ESOUT	Next: FFORK	Up: Top
			     FFFFP     JSYS 31

   Finds the first free page in the specified file.  A free page  is  one
   that  is  marked  as  not  being in use.  The FFFFP call is useful for
   finding a nonused page in a file before a PMAP call is  executed  that
   writes into that page.

  ACCEPTS IN AC1:  starting page number in left half, JFN in right half.

   RETURNS     +1:  always, with the JFN in the left half of AC1 and  the
		    page  number  in the right half of AC1, or a fullword
		    -1 in AC1 if there is no free page.

   Generates an illegal instruction interrupt on error conditions below.

   FFFFP ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    illegal use of terminal designator or string pointer

   DESX5:    file is not open


Node: FFORK	Previous: FFFFP	Next: FFUFP	Up: Top
			     FFORK     JSYS 154

   Freezes one or more processes.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   This suspends the processes (as soon as they are  stoppable	from  the
   monitor's  point  of view) in such a way that they can be continued at
   the place they were suspended.   However,  they  do	not  have  to  be
   continued;  they could be killed.

   The FFORK call is a no-op if the referenced process is already frozen.

   The RFORK monitor call can be used to resume one or more processes.

   Generates an illegal instruction interrupt on error conditions below.

   FFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process
   (FFORK)
   

   FRKHX3:   invalid use of multiple process handle


Node: FFUFP	Previous: FFORK	Next: FLHST	Up: Top
			     FFUFP     JSYS 211

   Finds the first used page of the file at or beyond the specified  page
   number.

   ACCEPTS IN AC1:  JFN in the left half, and the starting page number in
		    the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, page number in the right half of  AC1.   The
		    left half of AC1 is unchanged.

   FFUFP ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    illegal use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   FFUFX1:   file is not open

   FFUFX2:   file is not on multiple-directory device

   FFUFX3:   no used page found


Node: FLHST	Previous: FFUFP	Next: FLIN	Up: Top
			     FLHST     JSYS 277

  "Flushes" an ARPANET host.  Causes  the  NCP  tables  containing  that
  host's  status  information	to be purged of all information regarding
  previous or partially terminated connections between the  sending  and
  receiving  hosts  of  the  connection.  All connections to the flushed
  host are closed.

  RESTRICTIONS:    for ARPANET systems only.  Requires OPERATOR,  WHEEL,
		    or NET WIZARD capabilities enabled.

  ACCEPTS IN AC1:  number of host to be flushed

  RETURNS     +1:  always
   (FLIN)
   


Node: FLIN	Previous: FLHST	Next: FLOUT	Up: Top
			     FLIN     JSYS 232

   Inputs a floating-point number from the specified source.   This  call
   ignores  leading  spaces  and  terminates  on the first character that
   cannot be part of a floating point number.  If  that  character  is	a
   carriage return followed by a line feed, the line feed is also input.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  failure, error code in AC3 and updated string pointer
		    in AC1, if pertinent

	       +2:  success, single-precision, floating-point  number  in
		    AC2 and updated string pointer in AC1, if pertinent

   FLIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   FLINX1:   first character is not blank or numeric

   FLINX2:   number too small

   FLINX3:   number too large

   FLINX4:   invalid format


Node: FLOUT	Previous: FLIN	Next: GACCT	Up: Top
			     FLOUT     JSYS 233

   Outputs a floating-point number to the specified destination.

   ACCEPTS IN AC1:  destination designator

	      AC2:  normalized, single-precision, floating-point number

	      AC3:  format control word.  (Refer to Section 2.8.1.2.)

   RETURNS     +1:  failure, error code in AC3 and updated string pointer
		    in AC1, if pertinent

	       +2:  success, updated string pointer in AC1, if pertinent

   FLOUT ERROR MNEMONICS:
   (FLOUT)
   

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    file is not open

   FLOTX1:   column overflow in field 1 or 2

   FLOTX2:   column overflow in field 3

   FLOTX3:   invalid format specified

   IOX11:    quota exceeded or disk full


Node: GACCT	Previous: FLOUT	Next: GACTF	Up: Top
			     GACCT     JSYS 546

   Returns the current account for the specified job.

   RESTRICTIONS:    some  functions  require   Confidential   Information
		    Access, WHEEL, or OPERATOR capabilities enabled.
   ACCEPTS IN AC1:  job number, or -1 for current job

	      AC2:  byte pointer to  string  where  alphanumeric  account
		    designator (if any) is to be stored

   RETURNS     +1:  always, with updated pointer to account string in AC2

   The GACCT monitor call  requires  the  process  to  have  Confidential
   Information	Access,  WHEEL,  or  OPERATOR  capability  enabled if the
   specified job number is not for the current job.

   The CACCT monitor call can be used  to  change  the	account  for  the
   current job.

   Generates an illegal instruction interrupt on error conditions below.

   GACCT ERROR MNEMONICS:

   GACCX1:   invalid job number

   GACCX2:   no such job

   GACCX3:   Confidential Information Access capability required
   (GACTF)
   


Node: GACTF	Previous: GACCT	Next: GCVEC	Up: Top
			     GACTF     JSYS 37

   Returns the account designator to which the specified  file	is  being
   charged.

   ACCEPTS IN AC1:  JFN

	      AC2:  byte pointer to  string  in  caller's  address  space
		    where account string (if any) is to be stored

   RETURNS     +1:  failure, error code in AC1

	       +2:  success,  account  string  returned,  updated  string
		    pointer in AC2

	       +3:  success, 5B2+account number returned in AC2

   The SACTF monitor call can be used to set the  account  designator  to
   which the file is to be charged.

   GACTF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   GACTX1:   file is not on multiple-directory device

   GACTX2:   file expunged

   GACTX3:   internal format of directory is incorrect


Node: GCVEC	Previous: GACTF	Next: GDSKC	Up: Top
			     GCVEC     JSYS 300

   Returns the entry vector and the UUO locations for  the  compatibility
   package.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, entry vector length  in  the  left	half  and
		    entry  vector  address  in the right half of AC2, and
		    UUO location in the left half and PC location in  the
		    right half of AC3.
   (GCVEC)
   

   If use of the compatibility package has been disabled, AC2 contains -1
   on return.  If the compatibility package is not available, AC2 and AC3
   contain 0 on return.

   The SCVEC monitor call can be used to set the  entry  vector  for  the
   compatibility package.

   GCVEC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: GDSKC	Previous: GCVEC	Next: GDSTS	Up: Top
			     GDSKC     JSYS 214

   Returns  information  on  the  given  structure's   disk   usage   and
   availability.  This call is useful in determining storage usage.

   ACCEPTS IN AC1:  device  designator,  must  be  a  designator  for	a
		    structure.	If the generic designator DSK:	is given,
		    the connected structure is assumed.

   RETURNS     +1:  always, number of pages in use in AC1, and number  of
		    pages not in use in AC2.

   GDSKC ERROR MNEMONICS:

   DEVX1:    invalid device designator


Node: GDSTS	Previous: GDSKC	Next: GDVEC	Up: Top
			     GDSTS     JSYS 145

  Returns the status of a device for user I/O.  (Refer  to  Section  2.4
  for	the descriptions of the status bits.) This call requires that the
  device be opened.

  Also, this call will not return the status of  a  device  for  monitor
  I/O.   For  example, if GDSTS is executed after a tape mark is written
  (a monitor I/O operation) the GDSTS call will return the status of the
  last user record written.

   ACCEPTS IN AC1:  JFN

   RETURNS     +1:  always, device-dependent  status  bits  in	AC2,  and
   (GDSTS)
   

		    device-dependent  information  in  AC3.  For magnetic
		    tape, AC3 contains the positive count  of  number  of
		    hardware  bytes actually transferred in the left half
		    and zero in the right half.  For  the  line  printer,
		    AC3  contains  the	last  value  of  the page counter
		    register, or -1 if there is no page counter register.

  For ARPANET, the call/return sequence is:

  ACCEPTS IN AC1:  JFN

  RETURNS     +1:  always,  for  network  connection-files,  the  values
		    returned are:

	      AC2:  connection state (octal values 01 thru 16) in bits	0
		    thru 3

	      AC3:  foreign host number (octal)

	      AC4:  foreign socket number (octal)

   The GDSTS call is a no-op for devices without device-dependent  status
   bits.

   The SDSTS monitor call can be used  to  set	the  status  bits  for	a
   particular device.

   Generates an illegal instruction interrupt on error conditions below.

   GDSTS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open


Node: GDVEC	Previous: GDSTS	Next: GET	Up: Top
			     GDVEC     JSYS 542

   Returns the entry vector for the Record Management System (RMS).

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, entry vector length in the left half and  the
		    entry vector address in the right half of AC2.
   (GDVEC)
   

   The SDVEC monitor call can be used to set the entry vector for RMS.

   Generates an illegal instruction interrupt on error conditions below.

   GDVEC ERROR MNEMONICS:

   ILINS5:   RMS facility is not available


Node: GET	Previous: GDVEC	Next: GETAB	Up: Top
			      GET     JSYS 200

   Gets  a  save  file,  copying  or  mapping  it  into  the  process  as
   appropriate,  and  updates  the  process'  entry vector from the file.
   This call can be executed for  either  sharable  or	nonsharable  save
   files  that	were  created  with  the  SSAVE  or  SAVE  monitor  call,
   respectively.  The file must not be open.

   ACCEPTS IN AC1:  process handle in left half, and flag bits and a  JFN
		    in right half.

	      AC2:  lowest process page number in left half, and  highest
		    process page number in right half.	This controls the
		    parts of memory that are loaded when GT%ADR is on.

   RETURNS     +1:  always

   The defined flag bits in AC1 are as follows:

      Bit    Symbol		      Meaning

      19     GT%ADR	    Use the memory address limits given  in  AC2.
			    If this bit is off, all existing pages of the
			    file (according to its directory) are mapped.

      20     GT%PRL	    Preload the pages being  mapped  (i.e.,  move
			    the  pages	immediately.) If this bit is off,
			    the pages are read in from the disk when they
			    are referenced.

      21     GT%NOV	    Do not overlay existing pages and  do  return
			    an error.  If this bit is off, existing pages
			    will be overlaid.

      22     GT%FL2	    Read additional flag bits  specified  in  AC3
			    (reserved for future development).

   The JFN is given in bits 24 through 35 of AC1.

  The following table demonstrates how  mapping  occurs  when	different
  page  numbers  are supplied in AC2.	A dash indicates that a particlar
   (GET)
   

  save file page was not mapped into the process.  Also, note that  page
  0 of the save file (the directory page) is never mapped.

	     AC2	 File	 Process
	     Contents	 Page	 Page

	     0,,4	 0	 -

			 1	 0

			 2	 1

			 3	 2

			 4	 3

			 5	 4

	     2,,4	 0	 -

			 1	 -

			 2	 -

			 3	 2

			 4	 3

			 5	 4

   When the GET call is executed for a sharable save file, pages from the
   file  are  mapped into pages in the process, and the previous contents
   of the process' page are overwritten.  If the file contains	data  for
   only  a  portion  of  the  process' page, the remainder of the page is
   zeroed.  Pages of the process not used by the file are unchanged.

   When the GET call is executed for a nonsharable save file,  individual
   words  of  the  file  are written into the process.	Since these files
   usually do not have words containing all zeros, a  GET  call  executed
   for a nonsharable file never clears memory.

   The GET call never loads the accumulators.

   Can cause several  software	interrupts  or	process  terminations  on
   certain file conditions.

  A GET call performed on an execute-only process is illegal unless  the
  process  is	.FHSLF.  If the JFN specified in the GET call refers to a
  file for which the user only has execute-only access, then the process
  specified must be a virgin process.
   (GET)
   

  Generates an illegal instruction interrupt on error conditions below.

   GET ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process

   GETX1:    invalid save file format

   GETX2:    system Special Pages Table full

   GETX3:    illegal to overlay existing pages

   SSAVX1:   illegal to save files on this device

   OPNX2:    file does not exist

   All file errors can occur.


Node: GETAB	Previous: GET	Next: GETER	Up: Top
			     GETAB     JSYS 10

   Returns a word from the specified system  table.   (Refer  to  Section
   2.3.2.)

   ACCEPTS IN AC1:  index into table in the left half, and  table  number
		    in the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, 36-bit word from the specified table in AC1

   If -1 is given as the index, this call returns  the	negative  of  the
   length of the specified table.

   The table number can be obtained with the SYSGT  call.   However,  the
   recommended	procedure is to use the symbol definition from the MONSYM
   file for the table number.  (Refer to Appendix A for the system  table
   definitions.)

   The GETAB monitor call requires the process to have	GETAB  capability
   available, but not enabled (SC%GTB in the process capability word).

   Note: The  following tables  are  not a  complete  list of  all  GETAB
   tables.  These are ones  used for the Ethernet  and are not  otherwise
   readily available

     .PUPPA==:62		; PUP PARAMETER TABLE
     .PUPRO==:63		; HOST NUMBER AND ROUTING TABLE
     .PUPLS==:64		; LOCAL SOCKET NUMBERS,
     .PUPLN==:65		; LOCAL NET/HOST NUMBERS, BSP LINKAGE
     .PUPFP==:66		; FOREIGN PORTS
     .PUPSW==:67		; PUP STATUS WORD
     .PUPBU==:70		; STORAGE REGION FOR PUP DATA
     .PUSTA==:71		; STATISTCS
     .PUPBG==:72		; PUP BUG COUNT HASH TABLE
     .NVTPU==:73		; PUP NVT INFO (TTYPUP WORD IN DYNAMIC DATA)

   GETAB ERROR MNEMONICS:

   GTABX1:   invalid table number

   GTABX2:   invalid table index

   GTABX3:   GETAB privileges required


Node: GETER	Previous: GETAB	Next: GETJI	Up: Top
			     GETER     JSYS 12
   (GETER)
   

   Returns the most recent error condition encountered in a process.  The
   most recent error is always saved in the Process Storage Block.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, process handle in left half of AC2	and  most
		    recent error condition in right half of AC2.

   The SETER monitor call can be used to set  the  last  error	condition
   encountered in a process.

   GETER ERROR MNEMONICS:

   LSTRX1:  process has not encountered any errors


Node: GETJI	Previous: GETER	Next: GETNM	Up: Top
			     GETJI     JSYS 507

   Returns information for the specified job.

   ACCEPTS IN AC1:  job number, or -1  for  current  job,  or  400000+TTY
		    number

	      AC2:  negative of the length of the block in which to store
		    the  information  in the left half, and the beginning
		    address of the block in the right half

	      AC3:  word number (offset) of first entry desired from  job
		    information table

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, with updated pointer in  AC2  and	requested
		    entries stored in specified block

   When a terminal designator is given in AC1, the  information  returned
   is for the job running on that terminal.

   The system begins copying the entries from the job information  table,
   starting  with  the offset given in AC3, into the address specified in
   the right half of AC2.  The number of  entries  copied  is  minus  the
   number given in the left half of AC2 or is the number remaining in the
   table, whichever is smaller.  Because AC2 is updated on  a  successful
   return, it cannot be used for the returned data.

   The format of the job information table is as follows:

	Word	  Symbol	 Meaning

	 0	  .JIJNO    Job number
	 1	  .JITNO    Job's terminal number (-1 means  the  job  is
   (GETJI)
   

			    detached)
	 2	  .JIUNO    Job's user number
	 3	  .JIDNO    Job's connected directory number
	 4	  .JISNM    Subsystem name (SIXBIT)
	 5	  .JIPNM    Program name (SIXBIT)
	 6	  .JIRT     Run time
	 7	  .JICPJ    Controlling PTY job number (-1 means the  job
			    is not controlled by a PTY)
	 10	  .JIRTL    Run time limit (as set by the TIMER call)
			    A zero means no time limit is in effect.
	 11	  .JIBAT    Job is controlled by Batch, if -1 (as set  by
			    the MTOPR call)
	 12	  .JIDEN    Default for magnetic tape density (as set  by
			    the SETJB call)
	 13	  .JIPAR    Default for magnetic tape parity (as  set  by
			    the SETJB call)
	 14	  .JIDM     Default for magnetic tape data mode  (as  set
			    by the SETJB call)
	 15	  .JIRS     Default number for magnetic tape record  size
			    in bytes (as set by the SETJB call)
	 16	  .JIDFS    Deferred spooling in effect, if 1 (as set  by
			    the SETJB call)
	 17	  .JILNO    Job's logged-in directory number
	 20	  .JISRM    Byte pointer to area to receive job's session
			    remark.  This pointer is supplied by the user
			    before issuing the GETJI call.
	 21	  .JILLN    Job's last login date and time
	 22	  .JISRT    Job CPU time at start of  last  session.   To
			    compute  CPU  time for this session, subtract
			    .JISRT  value  from  current  job  CPU   time
			    (.JIRT).
	 23	  .JISCT    Console time at start of  last  session.   To
			    compute  the  console  time for this session,
			    subtract .JISCT value  from  current  console
			    time (obtainable with RUNTM monitor call).
	 24	  .JIT20    Indicates if job is at EXEC level or  program
			    level.  (-1 = EXEC, 0 = program)
	 25	  .JISTM    Returns  time  when  job  was  created  (when
			    CTRL/C was performed).  -1 is returned if the
			    system time and date were not  set	when  the
			    job started.

   GETJI ERROR MNEMONICS:

   GTJIX1:   invalid index

   GTJIX2:   invalid terminal line number

   GTJIX3:   invalid job number

   GTJIX4:   no such job
   (GETNM)
   


Node: GETNM	Previous: GETJI	Next: GETOK%	Up: Top
			     GETNM     JSYS 177

   Returns the name of the program currently being used by the job.  This
   name  will  have  been  declared  previously  with  the SETNM or SETSN
   monitor call.

   RETURNS     +1:  always, SIXBIT name of program in AC1


Node: GETOK%	Previous: GETNM	Next: GEVEC	Up: Top
			    GETOK%     JSYS 574

  Requests  approval  for  the  specified  system  resource   from   the
  installation's access-control program.

  ACCEPTS IN AC1:  function code

	      AC2:  address of argument block (if required)

	      AC3:  length of the argument block (the maximum permissable
		    length is specified by symbol .GOKMC)

	      AC4:  requested for job

  RETURNS     +1:  always, 0 or 1B18 set to zero in first word of status
		    block if access granted

		    1B18 set to one +  error  number  in  first  word  of
		    status block if request denied

		    Function Codes:

	Code	  Symbol		       Meaning
   (GETOK%)
   

	 1	  .GOASD    Assign a device

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Error block address
			     1	   .GEADD   Device  designator	(returned
					    by STDEV JSYS)

	 2	  .GOCAP    Enable capabilities  (right  half  privileges
			    only)

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GENCP   New capability word

	 3	  .GOCJB    Allow CRJOB JSYS to be executed

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address

	 4	  .GOLOG    Allow LOGIN

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GELUN   User number

	 5	  .GOCFK    Allow CFORK (only done after Nth fork)

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GEFCT   Number of  forks  already  in
					    use by job

	 6	  .GOTBR    Set terminal baud rate

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GELIN   Line number
   (GETOK%)
   

			     2	   .GESPD   Line speed

	 7	  .GOLGO    Allow logout when the directory is over quota

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GEUSD   Number of pages used
			     2	   .GEQUO   Quota
			     3	   .GERLG   Job requesting logout  or  -1
					    for this job

	 10	  .GOENQ    Allow setting of ENQ quota

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GEEQU   Desired quota
			     2	   .GEEUN   Job number request is for  or
					    -1 for this job

	 11	  .GOCRD    Allow directory creation

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address

	 12	  .GOSMT    Allow MOUNT of structure

			    Must be given once	to  increment  the  mount
			    count and once to decrement the mount count.

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GESDE   Device  designator	(returned
					    by STDEV JSYS)

	 13	  .GOMDD    Allow entry to MDDT

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address

	 14	  .GOCLS    Verify scheduler class assignment for a job
   (GETOK%)
   

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GEJOB   Job number
			     2	   .GECLS   Class desired

	 15	  .GLCL0    Set scheduler class at login

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GEJOB   Job
			     2	   .GECLS   Class desired

	 16	  .GOMTA    MT:  access request

			    Argument block (user specified):

			    Word   Symbol   Contents

			     0	   .GEERB   Status block address
			     1	   .GEACC   Access code from HDR1 label
			     2	   .GEUSN   User number
			     3	   .GEUNT   MT:  unit number
			     4	   .GEACD   Desired access bits
			     5	   .GELTP   Label type

	 400000+n Customer reserved functions

  Status block format (returned):

	Word 0: 	    1B18 + Error number if access denied
			    or zero if access granted

			    Note that some  access-control  programs  may
			    return  a  value  in word 0 even if access is
			    granted.  In that  case,  1B18  set  to  zero
			    indicates access was granted.

	Word 1: 	    Byte  pointer  (optional,  depending  on  the
			    particular access-control program)

	Word 2: 	    Byte  count  (optional,  depending	 on   the
			    particular access-control program)

  The format of the status block for user-defined functions will  depend
  on the design of the particular access-control program.

  Generates an illegal instruction interrupt on error conditions below.
   (GETOK%)
   

  GETOK% ERROR MNEMONICS:

  ARGX04:   Argument block too small

  ARGX05:   Argument block too long

  MONX01:   Insufficient system resources

  GOKER1:   Illegal function

  GOKER2:   Request denied by Access Control Facility

  GOKER3:   Access control job already running


Node: GEVEC	Previous: GETOK%	Next: GFRKH	Up: Top
			     GEVEC     JSYS 205

   Returns the entry vector of the specified process.  (Refer to  Section
   2.7.3.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, specified process' entry vector word in AC2

   The SEVEC monitor call can be used to set the process' entry vector.

   Generates an illegal instruction interrupt on error conditions below.

   GEVEC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: GFRKH	Previous: GEVEC	Next: GFRKS	Up: Top
			     GFRKH     JSYS 164

   Gets a handle on a process that currently is not known to  the  caller
   but is known to another process.  The handle returned can then be used
   by the caller to refer to the desired process.

   ACCEPTS IN AC1:  process handle of the process that	knows  about  the
		    desired  process  and  that currently has a handle on
		    it.

	      AC2:  process handle used by the process in AC1 to refer to
		    the  desired process.  This handle must be a relative
		    handle (i.e., in the range 400000 to 400777) and must
		    refer to an existing process.
   (GFRKH)
   

   RETURNS     +1:  failure, with error code in AC1.

	       +2:  success, with a handle in AC1 that is usable  by  the
		    caller  to refer to the desired process.  This handle
		    is not the same as the one given  in  AC2  (i.e.,  is
		    different  from the one used by the process in AC1 to
		    refer to the desired process).

   Generates an illegal instruction interrupt on error conditions below.

   GFRKH ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX6:   all relative process handles in use

   GFRKX1:   invalid process handle


Node: GFRKS	Previous: GFRKH	Next: GFUST	Up: Top
			     GFRKS     JSYS 166

   Returns the process structure of the current job from a given  process
   downward.

   ACCEPTS IN AC1:  process handle of the starting point

	      AC2:  B0(GF%GFH) return relative process handles	for  each
			       process

		    B1(GF%GFS) return status for each process

	      AC3:  negative of the word count of the block in	which  to
		    store the structure in the left half, and the address
		    of the first word of the block in the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, all process handles are returned

   The handle of  the  current	process  is  always  returned  as  .FHSLF
   regardless  of  the setting of GF%GFH.  Any user can specify a process
   handle of .FHTOP (i.e., start with the top level  process).	 However,
   the	user  must  have  WHEEL or OPERATOR capability enabled to specify
   .FHTOP and set GF%GFH;  otherwise, the setting of GF%GFH is ignored.

				Table format
   (GFRKS)
   

		 **********************************************
		 *		      * 		      *
   3 words	 *	parallel      *      inferior	      *
   per entry	 *	pointer       *      pointer	      *
		 *		      * 		      *
		 **********************************************
		 *		      * 		      *
		 *	superior      * process handle	      *
		 *	pointer       * or 0 if GF%GFH	      *
		 *		      * was off, or when no   *
		 *		      * more process handles  *
		 *		      * are left for the      *
		 *		      * process 	      *
		 *		      * 		      *
		 **********************************************
		 *					      *
   This word is  *		 status word		      *
   -1 if GF%GFS  *					      *
   is off.	 *					      *
		 **********************************************

				    NOTE

		  Pointers in table are  memory  addresses
		  of  other table entries, or 0 if no such
		  structure.

   The execution of the GFRKS call will be terminated before  the  entire
   structure  has  been  returned if either all handles are in use or the
   block in which to store the structure is too small.	If this  happens,
   as  much of the structure as possible is returned before an error code
   is generated.

   Generates an illegal instruction interrupt on error conditions below.

   GFRKS ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX6:   all relative process handles in use

   GFKSX1:   area too small to hold process structure


Node: GFUST	Previous: GFRKS	Next: GIVOK%	Up: Top
			     GFUST     JSYS 550
   (GFUST)
   

   Returns the name of either the author of the file or the user who last
   wrote to the file.

   ACCEPTS IN AC1:  function code in the left half, and JFN of	the  file
		    in the right half

	      AC2:  pointer to the string in which to store the name

   RETURNS     +1:  always, with an updated string pointer in AC2

   The defined functions are as follows:

   Code      Symbol		      Meaning

     0	     .GFAUT    Return the name of the author of the file.

     1	     .GFLWR    Return the name of the user who last wrote to  the
		       file.

   The SFUST monitor call can be used to  set  the  name  of  either  the
   author of the file or the user who last wrote to the file.

   Generates an illegal instruction interrupt on error conditions below.

   GFUST ERROR MNEMONICS:

   GFUSX1:   invalid function

   GFUSX2:   insufficient system resources

   GFUSX3:   file expunged

   GFUSX4:   internal format of directory is incorrect

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   DESX7:    JFN cannot refer to output wildcard designators

   DESX8:    file is not on disk

   DESX10:   structure is dismounted

   DELFX6:   internal format of directory is incorrect

   DIRX2:    insufficient system resources

   DIRX3:    internal format of directory is incorrect
   (GIVOK%)
   


Node: GIVOK%	Previous: GFUST	Next: GJINF	Up: Top
			    GIVOK%     JSYS 576

  Allows  a  privileged   access-control   program   (written	 by   the
  installation)  to  allow  or  disallow  a  user  program's access to a
  specified system resource.

  RESTRICTIONS:    Requires enabled WHEEL or OPERATOR capability.

  ACCEPTS IN AC1:  Request number (from RCVOK% message)

	      AC2:  0 or 1B18 set to zero = request allowed
		    1B18 + error number = request denied

	      AC3:  pointer to ASCIZ string (maximum of 80 characters) or
		    0.	 This  string  is an error message or information
		    message to be returned to the user.

  RETURNS     +1:  always

  Returns an illegal instruction interrupt on error conditions below.

  GIVOK% ERROR MNEMONICS:

  CAPX1:    wheel or operator capability required

	     GOKER3:  Access control job already running


Node: GJINF	Previous: GIVOK%	Next: GNJFN	Up: Top
			     GJINF     JSYS 13

	     Returns information pertaining to the current job.

   RETURNS     +1:  always, with

		    AC1 containing the user number under which the job is
		    running.

		    AC2 containing the directory number to which the  job
		    is connected.

		    AC3 containing the job number.

		    AC4 containing the terminal number	attached  to  the
		    job, or -1 if no terminal is attached to job.


Node: GNJFN	Previous: GJINF	Next: GPJFN	Up: Top
			     GNJFN     JSYS 17
   (GNJFN)
   

   Assigns the JFN to the next file in a group of files  that  have  been
   specified  with  wildcard  characters.   The next file in the group is
   determined by searching  the  directory  in	the  order  described  in
   Section  2.2.3  (i.e.,  in  the  internal directory order).	The flags
   returned from the GTJFN call  are  given  to  the  GNJFN  call  as  an
   argument to indicate the fields of the file specification that contain
   wildcard characters.

   ACCEPTS IN AC1:  indexable file handle returned by GTJFN (i.e.,  flags
		    returned by GTJFN in the left half and the JFN in the
		    right half)

   RETURNS     +1:  failure, including no more files in the  group.   JFN
		    is	released if there are no more files in the group.
		    This return occurs on the first call to GNJFN  if  no
		    flags  indicating  wildcard fields are on in the left
		    half of AC1.

	       +2:  success, same JFN is assigned to the next file in the
		    group.   The following flags are set (if appropriate)
		    in the left half of AC1:

		      B13   GN%STR   structure changed
		      B14   GN%DIR   directory changed
		      B15   GN%NAM   name changed
		      B16   GN%EXT   file type changed

   The GNJFN call uses the flags returned in the left half of  AC1  on	a
   GTJFN  call	to  determine  the  fields  containing	wildcards and the
   default generation  number.	 Note  that  the  GNJFN  call  returns	a
   different  set  of  flags  in the left half of AC1 than the GTJFN call
   returns.  Because all calls to GNJFN should use the	flags  originally
   returned by GTJFN, programs must save the returned GTJFN flags for use
   in the GNJFN call.

   The file currently associated with the JFN must  be	closed	when  the
   GNJFN call is executed.

  A JFN will not be returned for a file on a regulated structure  unless
  the	MSTR  JSYS has been first used to increment the mount count.  All
  structures are regulated by default except the primary structure  (PS:
  on  most  systems)  or  any structure that has been made non-regulated
  with the MSTR JSYS.	A job must release all its JFNs for  a	regulated
  structure before it can decrement the mount count.

   GNJFN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned
   (GNJFN)
   

   DESX4:    invalid use of terminal designator or string pointer

   GNJFX1:   no more files in this specification

   OPNX1:    file is already open

  STRX09:   prior structure mount required


Node: GPJFN	Previous: GNJFN	Next: GTAD	Up: Top
			     GPJFN     JSYS 206

   Returns the primary JFNs of the specified process.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, primary input JFN in the left  half  of  AC2,
		    and the primary output JFN in the right half of AC2.

   The SPJFN monitor call can be used to set the primary JFNs.	 If  this
   call has not been given, the GPJFN call returns -1 in AC2.

   Generates an illegal instruction interrupt on error conditions below.

   GPJFN ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: GTAD	Previous: GPJFN	Next: GTDAL	Up: Top
			     GTAD     JSYS 227

   Returns the current date in the internal  system  format.   (Refer  to
   Section 2.8.2.)

   RETURNS     +1:  always, day in the left half of AC1, and fraction  of
		    day in right half of AC1

   If the system does not have the current date set, AC1 contains -1.

   The STAD monitor call can be used to set the system's date.
   (GTDAL)
   


Node: GTDAL	Previous: GTAD	Next: GTDIR	Up: Top
			     GTDAL     JSYS 305

   Returns the disk allocation for the specified directory.

   ACCEPTS IN AC1:  directory  number	(-1   indicates   the	connected
		    directory)

   RETURNS     +1:  always, with

		    AC1  containing  the  working  disk   storage   limit
		    (logged-in quota) for the directory.

		    AC2 containing the number of pages being used.

		    AC3  containing  the  permanent  disk  storage  limit
		    (logged-out quota) for the directory.

   Generates an illegal instruction interrupt on error conditions below.

   GTDAL ERROR MNEMONICS:

   DIRX1:   invalid directory number

   DELFX6:  internal format of directory is incorrect


Node: GTDIR	Previous: GTDAL	Next: GTFDB	Up: Top
			     GTDIR     JSYS 241

   Returns information about the given directory.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  directory number

	      AC2:  address of argument block in caller's  address  space
		    in which to store the directory information

	      AC3:  byte pointer to string in which to store the password

   RETURNS     +1:  always, updated byte pointer in AC3

   The argument block returned to the caller is compatible with  the  one
   given  on  the  CRDIR call.	Word 0(.CDLEN) contains the length of the
   argument block in which  to	store  the  directory  information  being
   returned.   If  this word is zero, the length of the argument block is
   assumed to be 15 octal words long.  The password of the  directory  is
   placed  in  the  string  indicated  by  AC3, and word 1(.CDPSW) of the
   returned argument block points to this string.  Because the group list
   format  includes  a	count  word, the number of groups returned is one
   less than the count.  The group list is terminated by a zero word.
   (GTDIR)
   

   If the given directory number is zero, the GTDIR monitor call  returns
   the system default settings for the following directory parameters:

	working disk storage quota (.CDLIQ)
	permanent disk storage quota (.CDLOQ)
	default file protection (.CDFPT)
	default directory protection (.CDDPT)
	default file retention count (.CDRET)
	maximum number of subdirectories allowed (.CDSDQ)
	online expiration period (.CDDNE)
	offline expiration period (.CDDFE)

   Either one of the following	conditions  must  be  satisfied  for  the
   caller  to  obtain  all information (including the password) about the
   given directory.

	1.  The caller has WHEEL or OPERATOR capability enabled.

	2.  The caller is connected to the directory that is  immediately
	    superior to the given directory.

   To obtain all  information  other  than  the  password  of  the  given
   directory,  the  caller  must  have	at  least  owner  access  to  the
   directory.  (Refer  to  Section  2.2.6  for	a  description	of  owner
   access.)

   Generates an illegal instruction interrupt on error conditions below.

   GTDIR ERROR MNEMONICS:

   GTDIX1:   WHEEL or OPERATOR capability required

   GTDIX2:   invalid directory number


Node: GTFDB	Previous: GTDIR	Next: GTHST	Up: Top
			     GTFDB     JSYS 63

   Returns some or all of the file descriptor  block  for  the	specified
   file.  (Refer to Section 2.2.8 for the format of this block.)

   The GFUST monitor call must be used to obtain the name strings of  the
   author  of  the  file (.FBAUT) and of the user who last wrote the file
   (.FBLWR).  The GACTF monitor  call  is  used  to  obtain  the  account
   designator of the file (.FBACT).

   ACCEPTS IN AC1:  JFN

	      AC2:  number of words to be read in the left half  and  the
		    word  number (offset) of the first entry desired from
		    the file descriptor block in  the  right  half.   The
		    following instruction will set up AC2 for reading the
   (GTFDB)
   

		    entire FDB:

			 HRLZI AC2,.FBLEN

	      AC3:  address in caller's address  space	for  storing  the
		    data returned

   RETURNS     +1:  always

   The program receives an error (GFDBX2) if it requests more words  than
   there are words remaining in the FDB.

   The CHFDB monitor call can be used to change most words  in	the  file
   descriptor  block for a specified file.  Section 2.2.8 lists the words
   that can be changed with CHFDB.  The SFUST monitor  call  is  used  to
   change  the	name  strings  of the author (.FBAUT) and the last writer
   (.FBLWR).  The SACTF call is used to change the account designator  of
   the file (.FBACT).

   Generates an illegal instruction interrupt on error conditions below.

   GTFDB ERROR MNEMONICS:

   GFDBX1:   invalid displacement

   GFDBX2:   invalid number of words

   GFDBX3:   list access required

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators


Node: GTHST	Previous: GTFDB	Next: GTJFN	Up: Top
			     GTHST     JSYS 273

  Obtains information about ARPANET hosts.

  RESTRICTIONS:    for ARPANET systems only

  ACCEPTS IN AC1:  function code

	      AC2:  function-specific argument

	      AC3:  function-specific argument
   (GTHST%)
   

	      AC4:  function-specific argument

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, function-specific data returned in AC's

  Code     Symbol    Function

    0	    .GTHSZ    returns negative number of host names and  negative
		      length of HSTSTS table.

		      User supplied arguments:

		      None

		      Returned data:

		      AC2:   -number host names,,0
		      AC3:   -length of HSTSTS table,,0
		      AC4:   local  host  number  (in	32-bit	 Internet
			     format)

    1	    .GTHIX    Returns the name string associated with  the  host.
		      If the name returned is a nickname, HS%NCK is on in
		      the status word.

		      User supplied arguments:

		      AC2:   destination byte pointer
		      AC3:   index into name table (returned by GETAB)

		      Returned data:

		      AC2:   updated byte pointer
		      AC3:   host number
		      AC4:   host status

    2	    .GTHNS    Returns the primary name for the given host number

		      User supplied arguments:

		      AC2:   destination byte pointer
		      AC3:   host number

		      Returned data:

		      AC2:   updated byte pointer
		      AC3:   host number
		      AC4:   host status

    3	    .GTHSN    Translates the specified host name  string  to  its
		      host  number.  If the name specified is a nickname,
		      then HS%NCK will be on in the status word.

		      User supplied arguments:
   (GTHST%)
   

		      AC2:   source byte pointer

		      Returned data:

		      AC2:   updated byte pointer
		      AC3:   host number
		      AC4:   host status

    4	    .GTHHN    Return the current status of the given host

		      User supplied arguments:

		      AC3:   host number

		      Returned data:

		      AC3:   host number
		      AC4:   host status

    5	    .GTHHI    Return the host  number  and  status  of	the  host
		      having  the  specified  index  into the host status
		      table.

		      User supplied arguments:

		      AC3:   index into HSTSTS (returned by GETAB)

		      Returned data:

		      AC3:   host number
		      AC4:   host status

  Flags in host status word:

  Bits      Symbol    Meaning
  1B0	     HS%UP     Host is up
  1B1	     HS%VAL    Valid status
  7B4	     HS%DAY    Day when up if currently down
  37B9      HS%HR     Hour
  17B13     HS%MIN    5 minute interval
  17B17     HS%RSN    Reason
  1B18      HS%SRV    Host is server
  1B19      HS%USR    Host is user
  1B20      HS%NCK    Nickname
  77B26     HS%STY    System tape mask
  1B27      HS%NEW    RAS, RAR, RAP, etc

  1B26      .HS10X    TENEX
  2B26      .HSITS    ITS
  3B26      .HSDEC    TOPS-10
  4B26      .HSTIP    TIP
  5B26      .HSMTP    MTIP
  6B26      .HSELF    ELF
  7B26      .HSANT    ANTS
  10B26     .HSMLT    MULTICS
   (GTHST%)
   

  11B26     .HST20    TOPS-20
  12B26     .HSUNX    UNIX

  GTHST% ERROR MNEMONICS:

  ARGX02:   Invalid function

  GTHSX1:   Unknown host number

  GTHSX2:   No number for that host name

  GTHSX3:   No string for that host number

  GTJIX1:   Invalid index


Node: GTJFN-LONG	Previous: GTHST	Next: GTJFN-SHORT	Up: Top
			     GTJFN-L     JSYS 20
				 LONG FORM

   Returns a JFN for the specified file.  Accepts the  specification  for
   the	file  from  both a string in memory and from a file.  If both are
   given as arguments, the string is used first, and  then  the  file  is
   (GTJFN)
   

   used  if  more  fields are needed to complete the specification.  This
   form also allows the program to specify nonstandard values to be  used
   for omitted fields and to request the assignment of a specific JFN.

  A JFN will not be returned for a file on a regulated structure  unless
  the	MSTR  JSYS has been first used to increment the mount count.  All
  structures are regulated by default except the primary structure  (PS:
  on  most  systems)  or  any structure that has been made non-regulated
  with the MSTR JSYS.	A job must release all its JFNs for  a	regulated
  structure before it can decrement the mount count.

   ACCEPTS IN AC1:  0 in the left half, and address of the  beginning  of
		    the  argument  table in the caller's address space in
		    the right half

	      AC2:  byte pointer to ASCIZ file	specification  string  in
		    the caller's address space, or 0 if none

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, flags in the left half of AC1, and  the  JFN
		    assigned  in  the  right  half of AC1.  (This word is
		    called an indexable file handle and is given  to  the
		    GNJFN call as an argument.) Updated string pointer in
		    AC2, if pertinent.

   All I/O errors can occur.  These errors cause software  interrupts  or
   process terminations, and only a single return (+1) is given.

   The format of the argument table specified by the right half of AC1 is
   described  below.  Words 0 through 10 (.GJGEN-.GJJFN) must be supplied
   in the long form of the GTJFN call.	The remaining words are optional,
   and if they are supplied, B15(GJ%XTN) of word .GJGEN must be on.

   Word      Symbol		      Meaning

     0	     .GJGEN    Flag bits in the left half and  generation  number
		       in the right half.  (See below.)

     1	     .GJSRC    Input JFN in the left half and output JFN  in  the
		       right  half.   To  omit either JFN, specify .NULIO
		       (377777).

     2	     .GJDEV    Byte pointer to ASCIZ string  that  specifies  the
		       default	device to be used when none is given.  If
		       this word is 0,	the  user's  connected	structure
		       will be used.

     3	     .GJDIR    Byte pointer to ASCIZ string  that  specifies  the
		       default	directory  to be used when none is given.
		       If this word is 0, the user's connected	directory
		       will be used.
   (GTJFN)
   

     4	     .GJNAM    Byte pointer to ASCIZ string  that  specifies  the
		       default	filename  to  be used when none is given.
		       If this word is 0, either the string or the  input
		       JFN must supply the filename.

     5	     .GJEXT    Byte pointer to ASCIZ string  that  specifies  the
		       default	file  type to be used when none is given.
		       If this word is 0, the  null  file  type  will  be
		       used.

     6	     .GJPRO    Byte pointer to ASCIZ string  that  specifies  the
		       default	protection to be used when none is given.
		       If this word  is  0,  the  default  protection  as
		       specified  in  the  directory or the protection of
		       the next lower generation will be used.

     7	     .GJACT    Byte pointer to ASCIZ string  that  specifies  the
		       default account to be used when none is given.  If
		       this word is 0, the user's LOGIN  account  (unless
		       changed) will be used.

     10      .GJJFN    The JFN to associate with the  file  specification
		       if  flag  GJ%JFN  is set in word 0 (.GJGEN) of the
		       argument block.

     11      .GJF2     Extended argument block if B15(GJ%XTN)  is  on  in
		       the  left  half	of  .GJGEN.  This word contains a
		       second group of flags in the  left  half  and  the
		       count  of  the number of words following this word
		       in the argument block  in  the  right  half.   The
		       flags  in the left half specify additional control
		       over the GTJFN process.	The following  flags  are
		       defined:

		       B0(G1%RND) Return to the caller	if  the  filename
				  buffer  becomes  empty,  and	the  user
				  attempts to delete a	character.   This
				  can  occur if the user, when giving the
				  filename, types a  CTRL/U  or  types	a
				  DELETE  or CTRL/W and there are no more
				  characters in the buffer.

		       B2(G1%NLN) Filenames  cannot  be  longer  than	6
				  characters  and  file  types	cannot be
				  longer than 3 characters.  In addition,
				  the	 generation   number,	temporary
				  status, protection, and account  fields
				  cannot  be  specified  in the string or
				  the input data.

		       B3(G1%RCM) Return the confirmation message to  the
				  caller by placing it in the destination
				  buffer.

		       B4(G1%RIE) Return  to  the  caller  if  the  input
   (GTJFN)
   

				  buffer  becomes  empty,  and	the  user
				  attempts to delete a character.

		       B5(G1%IIN) Ignore  the  invisible  status  of  the
				  file.   If G1%IIN is not set, the GTJFN
				  will	ignore	files	that   have   the
				  invisible  bit  set (FB%INV in the FDB)
				  for subsequent JFN's.

     12      .GJCPP    Byte pointer to string where GTJFN is to store the
		       exact  copy  of the user's typescript (destination
		       string pointer).  This string will contain logical
		       names,  if  they  were typed by the user, and will
		       not contain the default fields  unless  they  were
		       generated through recognition.  This string allows
		       the caller to obtain a true  copy  of  the  user's
		       typescript.

     13      .GJCPC    Number  of  bytes  available  in  the  destination
		       string  pointed	to  by	.GTCPP	(word  12).  If a
		       pointer has been specified but this word is 0, the
		       monitor assumes the string contains 130 bytes.

     14      .GJRTY    Byte pointer to the text to  be	output	when  the
		       user  types  a CTRL/R (i.e., pointer to the CTRL/R
		       buffer).  This pointer  cannot  be  equal  to  the
		       pointer	given  in  AC2.  (Refer to the TEXTI call
		       for the definition of CTRL/R text.)

    15      .GJBFP    Byte pointer to the beginning of  the  destination
		       buffer.	(obsolete)

    16      .GJATR    Pointer to the file specification attribute block.

		       The attribute block has the following format:

		       Word    Contents

			0      Count  of   words   in	attribute   block
			       (including this word).
			1      Byte pointer to argument string.
			1+n    Byte pointer to argument string.

		       The ASCIZ argument strings are specified as:

		       keyword:attribute

		       The possible keywords and attribute values are  as
		       follows:

		       Keyword		  Attribute Value

		       A:		  Installation-defined	  account
					  string
		       BDATA:		  DECnet binary password
   (GTJFN)
   

		       BLOCK-LENGTH:	  Magnetic-tape block length
		       CHARGE:		  DECnet account string
		       DATA:		  DECnet optional data
		       EXPIRATION-DATE:   Magnetic-tape expiration date
		       FORMAT:		  Magnetic-tape  record   format.
					  The  argument may be one of the
					  following:

					  Argument   Meaning

					     F	     Fixed-length records
					     D	     Variable-length
						     records
					     S	     Spanned
					     U	     Binary  files   with
						     36-bits per word

		       OFF-LINE 	  NONE	-  display-only  keyword.
					  The attribute is set by setting
					  bit FB%OFF in  word  .FBCTL  of
					  the FDB block.
		       P:		  Octal file protection value
		       PASSWORD:	  DECnet password string
		       POSITION:	  File	 sequence    number    to
					  position magnetic-tape to.
		       RECORD-LENGTH:	  Magnetic-tape record length
		       T		  NONE	-  display-only  keyword.
					  The attribute is set by setting
					  bit GJ%TMP in  word  .GJGEN  of
					  the GTJFN block.
		       USERID:		  DECnet user ID string

   The flag bits accepted in the left half of  .GJGEN  (word  0)  of  the
   argument  block  are basically the same as those accepted in the short
   form of the GTJFN call.  The entire	set  of  bits  is  listed  below.
   (Refer  to  GTJFN - SHORT FORM for more detailed explanations of these
   bits.) The flags that are different	in  the  two  forms  are  GJ%JFN,
   GJ%XTN, GJ%FNS, and GJ%SHT.

      Bit    Symbol		      Meaning

       0     GJ%FOU    Create a new version of the file.

       1     GJ%NEW    The file must not exist.

       2     GJ%OLD    The file must exist.

       3     GJ%MSG    Type  a	message  if  the  user	presses  ESC   to
		       terminate input.

       4     GJ%CFM    Confirmation from the user is required.

       5     GJ%TMP    The file is temporary.

       6     GJ%NS     Search only the first specification in a  multiple
   (GTJFN)
   

		       logical name definition.

       7     GJ%ACC    The JFN cannot be accessed by inferior processes.

       8     GJ%DEL    Ignore the file deleted bit in the FDB.

      9-10   GJ%JFN    Associate the JFN supplied in .GJJFN (word 10)  of
		       the  argument  block  with the file specification.
		       The value of this field is interpreted as follows:

		       Value		   Meaning

		       0(.GJDNU) Ignore the JFN supplied.
		       2(.GJERR) Attempt to assign the JFN  supplied  and
				 return an error if it is not available.
		       3(.GJALT) Attempt to assign the JFN supplied  and,
				 if   it  is  not  available,  assign  an
				 alternate.

      11     GJ%IFG    The  file  specification  can   contain	 wildcard
		       characters.

      12     GJ%OFG    Associate the  JFN  with  the  file  specification
		       string and not the file itself.

      13     GJ%FLG    Return flags in AC1 on  successful  completion  of
		       the call.

      14     GJ%PHY    The physical device is to be used.

      15     GJ%XTN    The argument block contains more than  10  (octal)
		       words.

      16     GJ%FNS    This bit is ignored for the long form of the GTJFN
		       call.

      17     GJ%SHT    This bit must be off for  the  long  form  of  the
		       GTJFN call.

   The generation number given in the right half of .GJGEN  (word  0)  of
   the argument block can be one of the following:

      0(.GJDEF)  to indicate that the next higher generation number is to
		 be used if GJ%FOU is on, or to indicate that the highest
		 existing generation number is to be used  if  GJ%FOU  is
		 off.

      -1(.GJNHG) to indicate that the next higher generation number is to
		 be used if no generation number is supplied.

      -2(.GJLEG) to indicate that the lowest existing  generation  number
		 is to be used if no generation number is supplied.

      -3(.GJALL) to indicate that all generation numbers are to  be  used
		 and  that the JFN is to be assigned to the first file in
   (GTJFN)
   

		 the group, if no generation number  is  supplied.   (Bit
		 GJ%IFG must be on.)

      1-377777	 to indicate that the specified number is to be  used  as
		 the generation if no generation number is supplied.

   On a successful return, flags are returned in the left half of AC1  if
   flag  bit  GJ%IFG,  GJ%OFG,	or  GJ%FLG was on in the call.	The flags
   returned are the same as those returned in  the  short  form  call  of
   GTJFN.

   Refer to the short form of the  GTJFN  call	for  the  possible  error
   mnemonics.


Node: GTJFN-SHORT	Previous: GTJFN-LONG	Next: GTRPI	Up: Top
			     GTJFN-S     JSYS 20
				 SHORT FORM

   Returns a JFN for the specified file.  Accepts the  specification  for
   the	file  from  a string in memory or from a file, but not from both.
   The string can represent the complete specification for the file:

	dev:<directory>name.typ.gen;attributes

   One or more fields of the specification can be defined  by  a  logical
   name.   (Refer  to  Section 2.2.2.) If any fields are omitted from the
   specification, the system will provide the values shown below.

	device	     connected structure
		     See note below.

	directory    connected directory

					     NOTE

			 If   neither	device	 nor   directory   is
			 specified,  the  default  is  DSK:,  not the
			 user's  connected  directory.	  If   either
			 device  or directory is specified, the other
			 is   taken   from   the   user's   connected
			 directory.

	name	     no default;  this field must be specified
	type	     null
	generation   highest existing number if  the  file  is	an  input
		     file.   Next  higher number if the file is an output
   (GTJFN)
   

		     file.
	protection   protection of the next lower generation or  for  new
		     files, protection as specified in the directory.
	account      account  specified  when  user  logged  in,   unless
		     changed by the CACCT or SACTF call.

  A JFN will not be returned for a file on a regulated structure  unless
  the	MSTR  JSYS has been first used to increment the mount count.  All
  structures are regulated by default except the primary structure  (PS:
  on  most  systems)  or  any structure that has been made non-regulated
  with the MSTR JSYS.	A job must release all its JFNs for  a	regulated
  structure before it can decrement the mount count.

   The JFNS monitor call can be used to  obtain  the  file  specification
   string associated with a given JFN.

   ACCEPTS IN AC1:  flag bits in the left half,  and  default  generation
		    number in the right half

	      AC2:  source designator  from  which  to	obtain	the  file
		    specification.    (Refer   to  flag  bit  GJ%FNS  for
		    specific values.)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, flags in the left half of AC1, and  the  JFN
		    assigned  in  the  right  half of AC1.  (This word is
		    called an indexable file handle and is given  to  the
		    GNJFN call as an argument.) Updated string pointer in
		    AC2, if pertinent.

   All I/O errors can occur.  These errors cause software  interrupts  or
   process terminations, and only a single return (+1) is given.

   The flag bits that can be specified in AC1 are described as follows.

			      GTJFN Flag Bits
			        

     Bit     Symbol			   Meaning

      0      GJ%FOU		 The file given is to be  assigned  the
				 next  higher  generation number.  This
				 bit indicates that a new version of  a
				 file  is to be created and is normally
				 set if the file is for output use.

      1      GJ%NEW		 The file specification given must  not
				 refer	to  an existing file (i.e., the
				 file must be a new file).
   (GTJFN)
   

      2      GJ%OLD		 The  file  specification  given   must
				 refer	to  an existing file (i.e., the
				 file must be an old file).

      3      GJ%MSG		 One of the appropriate messages is  to
				 be	printed    after    the    file
				 specification	is  obtained,  if   the
				 system  is  performing  recognition on
				 the file specification  and  the  user
				 ends his input by typing an ESC.

				 !NEW FILE!
				 !NEW GENERATION!
				 !OLD GENERATION!
				 !OK! if GJ%CFM (bit 4) is off
				 !CONFIRM! if GJ%CFM (bit 4) is on

      4      GJ%CFM		 Confirmation from  the  user  will  be
				 required  (if	GJ%FNS is on) to verify
				 that the file	specification  obtained
				 is  correct.  (See below for the valid
				 confirmation characters.)

      5      GJ%TMP		 The  file  specified  is   to	 be   a
				 temporary file.

      6      GJ%NS		 Only  the  first  specification  in  a
				 multiple logical name assignment is to
				 be searched for the file (i.e., do not
				 search  beyond  the  first  name  in a
				 multiple logical name assignment).

      7      GJ%ACC		 The  JFN  specified  is  not	to   be
				 accessed by inferior processes in this
				 job.	However,  another  process  can
				 access   the	file   by  acquiring  a
				 different JFN.  To  prevent  the  file
				 from	 being	  accessed   by   other
				 processes, the user's	program  should
				 set OF%RTD(B29) in the OPENF call.

      8      GJ%DEL		 Files marked  as  deleted  are  to  be
				 considered  by  the  system when it is
				 searching for a file to assign to  the
				 JFN.

     9-10    GJ%JFN		 These bits are off in the  short  form
				 of the GTJFN call.

     11      GJ%IFG		 The  file   specification   given   is
				 allowed  to  have  one  or more of its
				 fields  specified  with   a   wildcard
				 character  (* or %).  This bit is used
				 to process a group  of  files	and  is
				 generally  used  for input files.  The
   (GTJFN)
   

				 monitor verifies  that  at  least  one
				 value	 exists  for  each  field  that
				 contains a wildcard  and  assigns  the
				 JFN  to  the  first file in the group.
				 The monitor also verifies that  fields
				 not  containing  wildcards represent a
				 new  or  old  file  according	to  the
				 setting  of  GJ%NEW  and  GJ%OLD.  The
				 GNJFN call can then be used to  obtain
				 the next file in the group.  (Refer to
				 Section 2.2.3 for more information  on
				 wildcard     characters     in    file
				 specifications.)

     12      GJ%OFG		 The JFN is to be associated  with  the
				 given	file  specification string only
				 and  not  to  the  actual  file.   The
				 string may contain wildcard characters
				 (* or %) in one or more of its fields.
				 It  is checked for correct punctuation
				 between fields, but is not checked for
				 the  validity	of any field.  This bit
				 allows a JFN to be associated	with  a
				 file  specification  even  if the file
				 specification does  not  refer  to  an
				 actual  file.	The JFN returned cannot
				 be used to refer  to  an  actual  file
				 (e.g.,  cannot  be  used  in  an OPENF
				 call) but can be used	to  obtain  the
				 original input string (via JFNS).  The
				 fields in this string can then be used
				 in  a	GTJFN-long form call as program
				 defaults.  However,  if  the  original
				 string  contains  the	temporary  file
				 attribute (;T), this attribute is  not
				 "remembered"  and thus is not returned
				 on the JFNS call even though  the  bit
				 indicating  temporary	status (JS%TMP)
				 is set.  All other  fields  (including
				 the protection and account fields) can
				 be returned by JFNS.

     12      GJ%OFG		 When both B11(GJ%IFG) and  B12(GJ%OFG)
	     (Cont.)		 are on,  the  GTJFN  call  parses  the
				 specification	 given,  verifying  the
				 existence  of	each  field.   When   a
				 wildcard character appears in a field,
				 the GTJFN call  checks  the  remaining
				 fields  for  correct  punctuation  and
				 returns   a   JFN   for    the    file
				 specification	string	only.  That is,
				 once a wildcard character is seen, the
				 action  taken	is  identical  to  that
				 taken when only  B12(GJ%OFG)  is  set.
				 If  no  wildcard  character appears in
   (GTJFN)
   

				 the string, the action is the same  as
				 if both bits were off.

     13      GJ%FLG		 Flags are to be returned in  the  left
				 half of AC1 on a successful return.

    14      GJ%PHY		 Job-wide logical names (those	defined
				 by  the user) are to be ignored by the
				 monitor for this call.

     15      GJ%XTN		 This bit is off in the short  form  of
				 the GTJFN call.

     16      GJ%FNS		 The  contents	of  AC2   are	to   be
				 interpreted as follows:

				 1.  If this bit is on, AC2 contains an
				     input  JFN in the left half and an
				     output JFN in the right half.  The
				     input  JFN  is  used to obtain the
				     file    specification    to     be
				     associated   with	the  JFN.   The
				     output JFN is used to indicate the
				     destination for printing the names
				     of any  fields  being  recognized.
				     To omit either JFN, specify .NULIO
				     (377777).

				 2.  If this bit is off, AC2 contains a
				     byte pointer to an ASCIZ string in
				     memory that specifies the file  to
				     be associated with the JFN.

				 0(.GJDEF)    to indicate that the next
					      higher  generation number
					      of the file is to be used
					      if  GJ%FOU (bit 0) is on,
					      or to indicate  that  the
					      highest	       existing
					      generation number of  the
					      file  is	to  be	used if
					      GJ%FOU is off.

     18-35			 -1(.GJNHG)   to indicate that the next
     (Cont.)				      higher generation  number
					      of the file is to be used
					      if no  generation  number
					      is supplied.

				 -2(.GJLEG)   to  indicate   that   the
					      lowest	       existing
					      generation number of  the
					      file  is to be used if no
					      generation   number    is
					      supplied.
   (GTJFN)
   

				 -3(.GJALL)   to  indicate   that   all
					      generation numbers (*) of
					      the file are to  be  used
					      and that the JFN is to be
					      assigned	to  the   first
					      file  in the group, if no
					      generation   number    is
					      supplied.    (Bit  GJ%IFG
					      must be set.)

				 1-377777     to  indicate   that   the
					      specified      generation
					      number of the file is  to
					      be  used if no generation
					      number is supplied.

   The GTJFN monitor call always reads the  terminating  character  after
   the	file  specification  string.   (This character can be obtained by
   executing  the  BKJFN  call	followed  by  a  BIN  call.)  The   valid
   terminating characters are:

	line feed		      left parenthesis
	CTRL/L			      right parenthesis
	CTRL/Z			      plus sign
	carriage return 	      comma
	exclamation point	      slash
	double quotation marks	      equals sign
	number sign		      at sign (@)
	ampersand		      space
	single quotation mark	      ESC

   All	of  these  characters  except  for  ESC  are  also   confirmation
   characters  (refer  to  bit	GJ%CFM	above)	and are called confirming
   terminators.  If a confirming terminator is typed after the string,	a
   confirmation  message  will not be typed to the user nor will the user
   be required to confirm the string obtained, regardless of the  setting
   of GJ%MSG and GJ%CFM.

   On a successful return, the following flags are returned in	the  left
   half of AC1 if flag bit GJ%IFG, GJ%OFG, or GJ%FLG was on in the call.

		   Bits Returned on Successful GTJFN Call
		        

     Bit     Symbol			   Meaning

      0      GJ%DEV		 The   device	field	of   the   file
				 specification	  contained    wildcard
				 characters.

      1      GJ%UNT		 The   unit   field   of    the    file
				 specification	  contained    wildcard
				 characters.  This bit	will  never  be
   (GTJFN)
   

				 set  because  wildcard  characters are
				 not allowed in unit fields.

      2      GJ%DIR		 The  directory  field	of   the   file
				 specification	  contained    wildcard
				 characters.

      3      GJ%NAM		 The  filename	field	of   the   file
				 specification	  contained    wildcard
				 characters.

      4      GJ%EXT		 The  file  type  field  of  the   file
				 specification	  contained    wildcard
				 characters.

      5      GJ%VER		 The generation  number  field	of  the
				 file  specification contained wildcard
				 characters.

      6      GJ%UHV		 The  file   used   has   the	highest
				 generation number because a generation
				 number of 0 was given in the call.

      7      GJ%NHV		 The file  used  has  the  next  higher
				 generation number because a generation
				 number of 0 or -1  was  given	in  the
				 call.

      8      GJ%ULV		 The   file   used   has   the	 lowest
				 generation number because a generation
				 number of -2 was given in the call.

      9      GJ%PRO		 The  protection  field  of  the   file
				 specification was given.

     10      GJ%ACT		 The  account	field	of   the   file
				 specification was given.

     11      GJ%TFS		 The  file  specification  is	for   a
				 temporary file.

     12      GJ%GND		 Files marked for deletion will not  be
				 considered   when  assigning  JFNs  in
				 subsequent calls.  This bit is set  if
				 GJ%DEL was not set in the call.

    17      GJ%INV		 Invisible files will not be  considerd
				 when	assigning  JFNs  in  subsequent
				 calls.  This bit is set if  G1%IIN  is
				 not set (see long form GTJFN).

   GTJFN ERROR MNEMONICS:

   GJFX1:    desired JFN invalid
   (GTJFN)
   

   GJFX2:    desired JFN not available

   GJFX3:    no JFNs available

   GJFX4:    invalid character in filename

   GJFX5:    field cannot be longer than 39 characters

   GJFX6:    device field not in a valid position

   GJFX7:    directory field not in a valid position

   GJFX8:    directory terminating delimiter is not preceded by
	     a valid beginning delimiter

   GJFX9:    more than one name field is not allowed

   GJFX10:   generation number is not numeric

   GJFX11:   more than one generation number field is not allowed

   GJFX12:   more than one account field is not allowed

   GJFX13:   more than one protection field is not allowed

   GJFX14:   invalid protection

   GJFX15:   invalid confirmation character

   GJFX16:   no such device

   GJFX17:   no such directory name

   GJFX18:   no such filename

   GJFX19:   no such file type

   GJFX20:   no such generation number

   GJFX21:   file was expunged

   GJFX22:   insufficient system resources (Job Storage Block full)

   GJFX23:   exceeded maximum number of files per directory

   GJFX24:   file not found

   GJFX27:   file already exists (new file required)

   GJFX28:   device is not on-line

   GJFX30:   account is not numeric

   GJFX31:   invalid wildcard designator
   (GTJFN)
   

   GJFX32:   no files match this specification

   GJFX33:   filename was not specified
   GJFX34:   invalid character "?" in file specification

   GJFX35:   directory access privileges required

   GJFX36:   internal format of directory is incorrect

   GJFX37:   input deleted

   GJFX38:   file not found because output-only device was specified

   GJFX39:   logical name loop detected

   GJFX40:   undefined attribute in file specification

   GJFX41:   file name must not exceed 6 characters

   GJFX42:   file type must not exceed 3 characters

   GJFX43:   more than one ;T specification is not allowed

   GJFX44:   account string does not match

   GJFX45:   illegal to request multiple specifications for the same
	     attribute

   GJFX46:   attribute value is required

   GJFX47:   attribute does not take a value

   GJFX48:   GTJFN input buffer is empty

   GJFX49:   invalid attribute for this device

   GJFX51:   byte count too small

   IOX11:    quota exceeded or disk full

   DESX9:    invalid operation for this device

  STRX09:   prior structure mount required


Node: GTRPI	Previous: GTJFN	Next: GTNCP	Up: Top
			     GTRPI     JSYS 172

   Returns the paging trap information for the specified process.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, with
		    AC1 containing  number  of	pager  traps  (i.e.,  the
			number of times a trap has occurred to the pager)
			for designated	process  since	the  process  was
			started
		    AC2 containing  number  of	page  faults  (i.e.,  the
			number	of  times  a  trap has resulted in a page
			being swapped in) for  designated  process  since
			the process was started
		    AC3 containing time spent (in milliseconds)  in  page
			routines  by designated process since the process
			was started

   The number of pager traps will be greater than or equal to the  number
   of page faults.

   Generates an illegal instruction interrupt on error conditions below.

   GTRPI ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle
   (GTNCP)
   


Node: GTNCP%	Previous: GTRPI	Next: GTRPW	Up: Top
			    GTNCP%     JSYS 272

  Obtains information about the NCP.

  RESTRICTIONS:    for ARPANET systems only

  ACCEPTS IN AC1:  function code

	      AC2:	       function-specific argument

	      AC3:	       function-specific argument

	      AC4:	       function-specific argument

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, function-specific data returned in AC's

  Code     Symbol    Function

    0	    .GTNSZ    returns negative number of NCP connections

		      User supplied arguments:

		      None

		      Returned data:

		      AC2:   -number NCP connections,,0
		      AC3:   -number NVTs ,, line number of first NVT

    1	    .GTNIX    Return connection number status

		      User supplied arguments:

		      AC2:   connection number
		      AC3:   30 bit address of storage block
		      AC4:   -length of  block	,,  first  data  item  to
			     return

			     Returned data:

			     (See format of block below)

    2	    .GTNNI    Return status of NVT line number (input connection)

		      User supplied arguments:

		      AC2:   NVT line number (input)
		      AC3:   30 bit address of storage block
		      AC4:   -length of  block	,,  first  data  item  to
			     return

			     Returned data:
   (GTNCP)
   

			     (See format of block below)

    3	    .GTNNO    Return status of NVT connection (output connection)

		      User supplied arguments:

		      AC2:   NVT line number (output)
		      AC3:   30 bit address of storage block
		      AC4:   -length of  block	,,  first  data  item  to
			     return

			     Returned data:

			     (See format of block below)

    4	    .GTNJF    Return status of JFN

		      User supplied arguments:

		      AC2:   JFN
		      AC3:   30 bit address of storage block
		      AC4:   -length of  block	,,  first  data  item  to
			     return

  Returned data:

  (See format of block below)

  Format of returned data block:

  Word      Symbol	       Contents

    0	     .NCIDX    NCP connection index
    1	     .NCFHS    Foreign host
    2	     .NCLSK    Local socket
    3	     .NCFSK    Foreign socket
    4	     .NCFSM    State of connection
    5	     .NCLNK    Link
    6	     .NCNVT    NVT, -1 if none
    7	     .NCSIZ    Byte size of connection
   10	     .NCMSG    MSG allocation
   11	     .NCBAL    Bit allocation
   12	     .NCDAL    Desired allocation
   13	     .NCBTC    Bits transferred
   14	     .NCBPB    Bytes per buffer
   15	     .NCCLK    Time-out countdown
   16	     .NCSTS    Connection status

  GTNCP ERROR MNEMONICS:

  ARGX02:   Invalid function

  GTJIX1:   Invalid index
   (GTNCP)
   

  GTNCX1:   Invalid network JFN

  GTNCX2:   Invalid or inactive NVT



Node: GTRPW	Previous: GTNCP%	Next: GTSTS	Up: Top
			     GTRPW     JSYS 171

   Returns the trap  words.   This  monitor  call  allows  a  program  to
   retrieve information about a previous read, write, or execute trap.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, trap status word from  last  memory  trap  in
		    AC1, and last monitor call that had an error in AC2.

   The following bits are defined in the status word:

      B0(PF%USR)  page failure-user mode reference
      B5(PF%WRT)  page failure-write reference
      B14(TSW%RD) trap status-read (always on)
      B15(TSW%WT) trap status-write (same setting as B5)
      B16(TSW%EX) trap status-execute (always on)
      B17(TSW%MN) trap status-monitor mode reference (complement of B0)
      B18-B35	  address of reference that caused the trap

   This information allows a program to determine the exact  cause  of	a
   memory trap and/or the effective virtual address that caused the trap.
   This information is sufficient to enable the program to  continue,  if
   desired, when the cause of the trap has been removed.

   The contents of AC1 is 0 if there have been no memory traps.

   Generates an illegal instruction interrupt on error conditions below.

   GTRPW ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: GTSTS	Previous: GTRPW	Next: GTTYP	Up: Top
			     GTSTS     JSYS 24

   Returns the status of a file associated with a JFN.
   (GTSTS)
   

   ACCEPTS IN AC1:  JFN in the right half

   RETURNS     +1:  always, status in AC2.  If JFN is illegal in any way,
		    B10 of AC2 will be 0.

			      JFN STATUS WORD
			        

      B0(GS%OPN)  file is open
      B1(GS%RDF)  if file is open (i.e., bit 0 is on),	it  is	open  for
		  read access
      B2(GS%WRF)  if file is open, it is open for write access
      B3(GS%XCF)  if file is open, it is open for execute access
      B4(GS%RND)  if file is open, it is open for non-append access
      B7(GS%LNG)  file is longer than 512 pages
      B8(GS%EOF)  last read was past end of file
      B9(GS%ERR)  file may be in error (i.e.,  a  device  or  data  error
		  occurred)
      B10(GS%NAM) file specification is associated with this JFN
      B11(GS%AST) one or more fields of the  file  specification  contain
		  wildcard characters
      B12(GS%ASG) JFN is currently being assigned
      B13(GS%HLT) I/O errors are considered terminating conditions
      B17(GS%FRK) if file is open, it is open for restricted access
      B32-B35	  data mode of the file.  Refer to the OPENF monitor
      (GS%MOD)	  call description.

		       .GSNRM  normal data mode
		       .GSIMG  image mode
		       .GSDMP  dump mode

   If B0(GS%OPN) is not set on return, the file is not	opened,  and  the
   settings of bits 1 through 4 are indeterminate.

   The STSTS call can be used to set the status of a particular file.


Node: GTTYP	Previous: GTSTS	Next: GTWAA%		Up: Top
			     GTTYP     JSYS 303

   Returns the terminal type number  for  the  specified  terminal  line.
   (Refer to Section 2.4.3.4 for the terminal type numbers.)

   ACCEPTS IN AC1:  file designator (only terminal designators are legal)

   RETURNS     +1:  always,  terminal  type  number  in  AC2  and  buffer
		    allocation	 numbers   (#  of  input  buffers  to  be
		    allocated in left half, and # of output buffers to be
		    allocated in right half) in AC3.  AC1 is unchanged.

   The STTYP monitor call can be used to set the terminal type number for
   (GTTYP)
   

   a specified line.

   Generates an illegal instruction interrupt on error conditions below.

   GTTYP ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   TTYX01:   line is not active


Node: GTWAA%	Previous: GTTYP	Next: HALTF	Up: Top
			GTWAA%  JSYS 702

Get weekly account allocation information.  NOTE:  this is a temporary
jsys, and may not be defined in future releases.

ACCEPTS IN AC1:  directory or user number.

	   AC2:  function bits in left half,length of argument block
		 in the right.

		  B0	(wa%rd)  Get allocation information and store in
				 data block.  Note: if both wa%rd and wa%in
				 are set, the new information is returned in
				 the argument block.

		  B1	(wa%wr)  Update allocation information from data block.
	
		  B2	(wa%in)  Increment allocation information from data
				 block.  Note: if both wa%wr and wa%in are
				 set, wa%in is ignored.

	   AC3:   address of argument block

RETURNS:   +1:   Always, with B17 (wa%ft) of AC2 set if current time is in the
		 "free time" block.

This is a temporary jsys, and may not be defined in future releases.
The argument block may be up to eighteen words in length. Its format
is given below.

	.WALW==:0		weekly console (login) allocation
	.WACW==:1		weekly cpu allocation
	.WAPW==:2		weekly pages-printed allocation
	.WALA==:3		this week's console (login) allocation
	.WACA==:4		this week's cpu allocation
	.WAPA==:5		this week's pages-printed allocation
	.WALC==:6		console time charged this week
	.WACC==:7		cpu time charged
	.WAPC==:10		pages charged
	.WALU==:11		console time used (cumulative this week)
	.WACU==:12		cpu time used (cumulative this week)
	.WAPU==:13		pages used (cumulative this week)
	.WALQ==:14		console time chargeable (cumul. this quarter)
	.WACQ==:15		cpu time chargeable (cumulative this quarter)
	.WAPQ==:16		pages chargeable (cumulative this quarter)
	.WALT==:17		console time used (cum. this quarter)
	.WACT==:20		cpu time used (cum. this quarter)
	.WAPT==:21		pages printed (cum. this quarter)

GTWAA% ERROR MNEMONICS:

ILINS2: Undefined JSYS

CAPX1:  WHEEL or OPERATOR capability required

GTWAX1: Invalid function code

GTWAX2: Invalid argument block length

STRX02: Insufficient system resources

DELFX6:	Internal format of directory is incorrect

DATEX6: System date and time are not set


Node: HALTF	Previous: GTWAA%	Next: HANDS%	Up: Top
			     HALTF     JSYS 170

   Halts the current process and any inferior processes  of  the  current
   process.   Sets the process' PC to the next instruction after the call
   and saves it in the Process Storage Block (PSB) in case the process is
   continued.	The  user can continue the process by typing the CONTINUE
   command, which causes the process to start at the next instruction.

   Sets bits  1-17(RF%STS)  in	the  status  word  for	this  process  to
   2(.RFVPT).	Refer  to  the	RFSTS  monitor call for the format of the
   status word.

   If the top level process executes a HALTF call and does not have WHEEL
  or  OPERATOR  capability  enabled,  the job is logged out.  If the top
  level process executes a HALTF call and does have  WHEEL  or  OPERATOR
  capability enabled, control passes to mini-exec (MEXEC) level.


Node: HANDS%	Previous: HALTF		Next: HFORK	Up: Top
			HANDS%  JSYS 700

Used to access system tables efficiently.  Accepts a list of monitor
tables to be returned in their entirety to the user.

ACCEPTS IN AC1:	 Negative length of table in left half, address of table
		 in right half

RETURNS:    +1:	 Always, with the entirety of the specified system tables
		 transferred to the user's area.

The table entries are of the form <table number>,,<destination address>.

HANDS% ERROR MNEMONICS:

ARGX17:	Invalid argument block length

GTABX1:	Invalid table number

GTABX3:	GETAB capability required


Node: HFORK	Previous: HANDS%	Next: HPTIM	Up: Top
			     HFORK     JSYS 162

   Halts one or more inferior processes.  (Refer  to  the  HALTF  monitor
   call description to halt the current process.)

   ACCEPTS IN AC1:  process handle (inferior processes only)

   RETURNS     +1:  always

   Sets bits 1-17(RF%STS) in the status word(s) for addressed  process(s)
   to  2(.RFVPT).   Refer to the RFSTS monitor call for the format of the
   status word.

   Generates an illegal instruction interrupt on error conditions below.

   HFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle
   (HFORK)
   

   FRKHX2:   illegal to manipulate a superior process

   HFRHX1:   illegal to halt self with HFORK


Node: HPTIM	Previous: HFORK	Next: HSYS	Up: Top
			     HPTIM     JSYS 501

   Returns the	value  of  one	of  the  high  precision  system  clocks.
   Although  the main time base from interrupts generated by the internal
   system clock is in units of 1 millisecond, the clock provides  a  time
   base  in  units  of	10 microseconds.  The HPTIM monitor call provides
   access to the variables kept in these high precision units.

   ACCEPTS IN AC1:  number of the clock to read (see below)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success,  with  AC1  containing  the  value  of   the
		    specified clock

   The numbers for currently-defined clocks are:

	0    .HPELP    Elapsed time since system startup.  (Refer to  the
		       TIME call for obtaining the time in milliseconds.)

	1    .HPRNT    CPU runtime for this process.  (Refer to the RUNTM
		       call for obtaining the time in milliseconds.)

   HPTIM ERROR MNEMONICS:

   HPTX1:    undefined clock number


Node: HSYS	Previous: HPTIM	Next: IDCNV	Up: Top
			     HSYS     JSYS 307

   Initiates an orderly shutdown of  the  timesharing  operation  of  the
   system.   This  call causes periodic notices of the impending shutdown
   to be issued to all terminals.  It also causes any jobs  still  logged
   in at the designated shutdown to be logged out.

   RESTRICTIONS:    requires WHEEL, OPERATOR, or MAINTENANCE capabilities
		    enabled
   ACCEPTS IN AC1:  shutdown time with the date and time in the  internal
		    format.  (Refer to Section 2.8.2.)

	      AC2:  date  and  time  in  internal  format   when   system
		    operation  will  resume  (or 0 if unknown).  Used for
   (HSYS)
   

		    advisory messages only.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, shutdown procedure initiated

   The shutdown notice is issued immediately  to  all  terminals  if  the
   shutdown time is within two hours.  The notice is also sent two hours,
   one hour, 30 minutes, 10 minutes, 5 minutes, and one minute before the
   shutdown.

   The time when the system is expected to be placed back into	operation
   is not used directly by the monitor.  It is entered into a GTTAB table
   where it may be examined with the GETAB monitor call.

   HSYS ERROR MNEMONICS:

   CAPX2:    WHEEL, OPERATOR, or MAINTENANCE capability required

   TIMEX1:   time cannot be greater than 24 hours

   TIMEX2:   downtime cannot be more than 7 days in the future


Node: IDCNV	Previous: HSYS	Next: IDLE%	Up: Top
			     IDCNV     JSYS 223

   Converts separate numbers for the local year,  month,  day,	and  time
   into  the  internal date and time format.  (Refer to Section 2.8.2 for
   more information on the internal format.)

   ACCEPTS IN AC2:  year  in  the  left   half,   and	numerical   month
		    (0=January) in the right half

	      AC3:  day of the month (0=first day) in the left half,  and
		    0 in the right half

	      AC4:  B0(IC%DSA) apply daylight savings  according  to  the
			       setting	of  B1(IC%ADS).   If  B0  is off,
			       daylight  savings  is  applied	only   if
			       appropriate for the date.

		    B1(IC%ADS) apply daylight savings  if  B0(IC%DSA)  is
			       on.

		    B2(IC%UTZ) use time zone in B12-B17.  If this bit  is
			       off, the local time zone is used.

		    B3(IC%JUD) interpret the number in the right half  of
			       AC2  as	being in Julian day format (Jan 1
			       is day 1).
   (IDCNV)
   

		    B12-B17    time zone  to  use  if  B2(IC%UTZ)  is on.
		    (IC%TMZ)   (Refer  to  Section  2.8.2  for	the  time
			       zones.)

		    B18-B35    local time in seconds since midnight.
		    (IC%TIM)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, AC2 contains the internal date and time, and
		    AC3 contains

		    B0 and B2	on for compatibility with the ODCNV call

		    B1(IC%ADS)	on if daylight savings was applied

		    B12-B17	time zone used
		    (IC%TMZ)

   IDCNV ERROR MNEMONICS:

   DATEX1:   year out of range

   DATEX2:   month is not less than 12

   DATEX3:   day of month too large

   DATEX5:   date out of range

   TIMEX1:   time cannot be greater than 24 hours

   ZONEX1:   time zone out of range


Node: IDLE%	Previous: IDCNV		Next: IDTIM	Up: Top
			IDLE%  JSYS 701

Determines the idle time of a job.

ACCEPTS IN AC1:	 job number

RETURNS:   +1:	 always, with the number of milliseconds since any fork
		 of the job was last in the run queue in AC1.

IDLE% ERROR MNEMONICS:

ARGX08:	No such job


Node: IDTIM	Previous: IDLE%		Next: IDTNC	Up: Top
			     IDTIM     JSYS 221

   Inputs the date and time and converts them to the  internal	date  and
   time  format.   (Refer  to Section 2.8.2.) The IDTIM monitor call does
   not permit either the date or the time to be  entered  separately  and
   does  not  perform conversions for time zones other than the local one
   (unless the time zone is specified in the input string).  Refer to the
   IDTNC and IDCNV monitor calls descriptions for these functions.

   ACCEPTS IN AC1:  source designator

	      AC2:  format option flags (see below), 0 is the normal case

   RETURNS     +1:  failure, error code in AC2, updated string pointer in
		    AC1, if pertinent

	       +2:  success, updated string  pointer,  if  pertinent,  in
   (IDTIM)
   

		    AC1, and the internal format date and time in AC2

   The format option flags in AC2 specify the interpretation to  be  used
   when a date or time specification is ambiguous.

			     IDTIM Option Flags
			       

      B1(IT%NNM)  do not allow the month to be numeric and ignore B2-B3.

      B2(IT%SNM)  interpret the second number in the date  as  the  month
		  (e.g.,  6/2/76  is  interpreted  as Feb.  6, 1976).  If
		  this bit is off, the first number is interpreted as the
		  month (e.g., 2/6/76 is interpreted as Feb.  6, 1976).

      B3(IT%ERR)  return an error if the order of the day and month  does
		  not  agree  with  the setting of B2(IT%SNM) even though
		  the date can be successfully interpreted.  If this  bit
		  is off, a date which can be interpreted by assuming the
		  day and month are  in  the  opposite	order  than  that
		  specified   by   the	setting  of  B2(IT%SNM)  will  be
		  considered valid.   For  example,  if  B2-B3	are  off,
		  30/5/76 will be considered as a valid date.

      B7(IT%NIS)  seconds cannot be included in a time specification.

      B8(IT%AIS)  seconds must be included in a  time  specification  and
		  must be preceded by a colon.

		  If B7-B8 are both off, seconds are optional in  a  time
		  specification.   If specified, seconds must be preceded
		  by a colon.

      B9(IT%NAC)  colon cannot be used to separate hours and minutes.

      B10(IT%AAC) colon must be used to separate hours and minutes.

		  If B9-B10 are both off, a  colon  is	optional  between
		  hours and minutes.

      B11(IT%AMS) when	B7-B10	are  off,   always   interpret	 a   time
		  specification containing one colon as hhmm:ss.

      B12(IT%AHM) when	B7-B10	are  off,   always   interpret	 a   time
		  specification  containing one colon as hh:mm and return
		  an error if the first field is too large.  This differs
		  from	B7(IT%NIS)  in	that  seconds  can be included if
		  preceded by a second colon.

		  If B7-B12 are all off, a time specification  containing
		  one colon is interpreted as hh:mm if the first field is
		  small enough.  Otherwise it is interpreted as hhmm:ss.

      B14(IT%N24) do not allow the time to be specified in 24-hour format
		  (e.g.,  1520	for 3:20 in the afternoon) and make AM or
   (IDTIM)
   

		  PM specification mandatory.

      B15(IT%NTM) do  not  allow  the  time  specification   to   include
		  AM,PM,NOON, or MIDNIGHT.

      B16(IT%NTZ) do not allow a time zone to be specified.

   If AC2 is 0, the IDTIM call	accepts  any  reasonable  date	and  time
   formats.

   IDTIM ERROR MNEMONICS:

   DILFX1:   invalid date format

   TILFX1:   invalid time format

   DATEX1:   year out of range

   DATEX3:   day of month too large

   DATEX5:   date out of range

   All I/O  errors  are  also  possible.   These  errors  cause  software
   interrupts or process terminations as described under the BIN call.


Node: IDTNC	Previous: IDTIM	Next: IIC	Up: Top
			     IDTNC     JSYS 231

   Inputs the date and/or the time and converts it into separate  numbers
   for	the  local  year, month, day, or time.	The IDTNC call allows the
   date or time to be entered separately, which is not possible with  the
   IDTIM JSYS because neither one can be converted to the internal format
   without converting the other.  (Refer to Section 2.8.2.)

   ACCEPTS IN AC1:  source designator

	      AC2:  format option flags
		    In addition to the flags described in the IDTIM call,
		    the flags below can also be specified:

		    B0(IT%NDA) do not input the date  and  ignore  B1-B3.
			       If IT%NDA is off, the date must be input.

		    B6(IT%NTI) do not input the time and  ignore  B7-B16.
			       If IT%NTI is off, the time must be input.

   RETURNS     +1:  failure, error code in AC2, updated  string  pointer,
		    if pertinent, in AC1

	       +2:  success, updated string pointer, if pertinent, in AC1
   (IDTNC)
   

		    If the date was input,
		    AC2 contains the year in the left half, and the month
			(0=January) in the right half.
		    AC3 contains the day of the month  (0=first  day)  in
			the left half, and the day of the week (0=Monday)
			in the right half.

		    If the time was input,
		    AC4 contains
			B0(IC%DAS)  on if a  time  zone  was  input  (for
				    compatibility with the ODCNV call).
			B1(IC%ADS)  on if a daylight  savings  time  zone
				    was input.
			B2(IC%UTZ)  on if a time zone was input.
			B3(IC%JUD)  on if a number in Julian  day  format
				    was input.
			B12-B17     the  time  zone if one  was input, or
			(IC%TMZ)    the  local	time  zone  if	none  was
				    input.   (Refer  to Section 2.8.2 for
				    the time zones.)
			B18-B35     time as seconds since midnight.
			(IC%TIM)

   IDTNC ERROR MNEMONICS:

   DILFX1:   invalid date format

   TILFX1:   invalid time format

   All I/O  errors  are  also  possible.   These  errors  cause  software
   interrupts  or  process  terminations  as described under the BIN call
   description.

   The IDTNC call does not detect certain errors in date input,  such  as
   day	31  of	a  30-day  month.  These errors are detected by the IDCNV
   call.


Node: IIC	Previous: IDTNC	Next: INLNM	Up: Top
			      IIC     JSYS 132

   Initiates software interrupts on the specified channels in a  process.
   (Refer to Section 2.5.)

   ACCEPTS IN AC1:  process handle

	      AC2:  36-bit word
		    Bit n on  means  initiate  a  software  interrupt  on
		    channel n.

   RETURNS     +1:  always
   (IIC)
   

   Generates an illegal instruction interrupt on error conditions below.

   IIC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

  FRKHX3:   invalid use of multiple process handle

  FRKHX8:   Illegal to manipulate an execute-only process


Node: INLNM	Previous: IIC	Next: JFNS	Up: Top
			     INLNM     JSYS 503

   Returns a logical name that is defined either for this job or for  the
   system.  (Refer to Section 2.2.2 and CRLNM and LNMST monitor calls.)

   ACCEPTS IN AC1:  function code in the left half, and  index	into  the
		    table of defined logical names in the right half

	      AC2:  byte pointer to the string for  storing  the  logical
		    name

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC2

   The available functions are:

	Code	  Symbol	 Meaning

	  0	  .INLJB    List the logical names defined for this job

	  1	  .INLSY    List the logical names defined for the system

   INLNM ERROR MNEMONICS:

   INLNX1:   index is beyond end of logical name table

   INLNX2:   invalid function


Node: JFNS	Previous: INLNM	Next: KFORK	Up: Top
			      JFNS     JSYS 30

   Returns the file specification currently associated with the JFN.
   (JFNS)
   

   ACCEPTS IN AC1:  destination designator where the ASCIZ string  is  to
		    be written

	      AC2:  indexable file handle (refer to GTJFN), or pointer to
		    string

	      AC3:  format control bits to be  used  when  returning  the
		    string, or 0

	      AC4:  byte pointer to  string  containing  prefix  of  file
		    specification attribute

   RETURNS     +1:  always, updated string pointer, if pertinent, in AC1
   AC2 can have one of two formats, depending on B26(JS%PTR) in AC3.  The
   first  format  is  a word with either 0 or the flag bits returned from
   GTJFN in the left half and the JFN in the right half.  When	the  left
   half  is  0, the string returned is the exact specification associated
   with the JFN.  If the  given  JFN  is  associated  only  with  a  file
   specification  (i.e., it was obtained with B12(GJ%OFG) on in the GTJFN
   call), the string returned contains null fields for nonexistent fields
   or fields containing wildcards, and actual values for existent fields.
   When the left half is nonzero, the string returned  contains  wildcard
   characters  for  appropriate  fields  and 0, -1, or -2 as a generation
   number if the corresponding bit is on in the call.

   The second format (allowed only if B26(JS%PTR) of  AC3  is  on)  is	a
   pointer  to	the string to be returned.  This string is one field of a
   file specification.	The field is  determined  by  the  first  nonzero
   3-bit  field in AC3 or by the setting of B27(JS%ATR) or B28(JS%AT1) in
   AC3.  For example, if bits 6-8 (JS%NAM) of AC3 are nonzero,	then  the
   string  is interpreted as a filename field.	If B27(JS%ATR) is on, the
   string  is  interpreted  as	a  file  specification	 attribute.    If
   B28(JS%AT1) is on, the string is concatenated to the string pointed to
   by AC4, and a colon is inserted  between  the  two  strings.   In  all
   cases,  the	string	is  output to the destination designator, and the
   appropriate punctuation is added.

   AC3 contains control bits for formatting the  string  being	returned.
   B0-B20 are divided into 3-bit bytes, each byte representing a field in
   the file specification.  The value of the byte  indicates  the  output
   for that field.  The values are:

	0    (.JSNOF)  do not output this field
	1    (.JSAOF)  always output this field
	2    (.JSSSD)  suppress this field if it is the system default

   The bits that can be set in AC3 are as follows:

	B0-B2(JS%DEV)	output for device field
	B3-B5(JS%DIR)	output for directory field
	B6-B8(JS%NAM)	output for filename field (2 is illegal)
	B9-B11(JS%TYP)	output for file type field (2 is illegal)
	B12-B14(JS%GEN) output for generation number field
	B15-B17(JS%PRO) output for protection field
	B18-B20(JS%ACT) output for account field
   (JFNS)
   

	B21(JS%TMP)	return ;T if appropriate
	B22(JS%SIZ)	return size of file in pages
	B23(JS%CDR)	return creation date
	B24(JS%LWR)	return date of last write
	B25(JS%LRD)	return date of last read
	B26(JS%PTR)	AC2 contains pointer to the string being returned
	B27(JS%ATR)	return	 file	specification	 attributes    if
			appropriate
	B28(JS%AT1)	return the specific specification attribute whose
			prefix	is  indicated by the string pointed to in
			AC4.   This  bit  is  used  when  a  program   is
			processing  attributes	one at a time.	If JS%ATR
			is also set, all attributes will be returned.
	B29(JS%OFL)	return the "OFFLINE" attribute
	B32(JS%PSD)	punctuate the size and date fields
	B33(JS%TBR)	tab before all fields returned, except for  first
			field
	B34(JS%TBP)	tab before all fields that may be returned (i.e.,
			fields	whose  value  is given as 1 or 2), except
			for first field
	B35(JS%PAF)	punctuate all fields from device through ;T

   If B32-B35 are 0, punctuation between fields is not used.

   If AC3 is 0, the string is output in the format

	dev:<directory>name.typ.gen;T

   with  fields  the  same  as	system	defaults  not  returned  and  the
   protection (;P) and account (;A) attributes returned if B9(GJ%PRO) and
   B10(GJ%ACT) in AC2 are  on.	 The  temporary  attribute  (;T)  is  not
   returned  if the JFN is not associated with a file (refer to GJ%OFG in
   the GTJFN description) or the file is not temporary.

   The punctuation used on each field is shown below.

	dev:<directory>name.typ.gen;attribute
	,size,creation date,write date,read date

   The GTJFN or GNJFN monitor call is used to  associate  a  JFN  with	a
   given file specification string.

   Generates an illegal instruction interrupt on error conditions below.

   JFNS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   IOX11:    quota exceeded or disk full
   (KFORK)
   


Node: KFORK	Previous: JFNS	Next: LGOUT	Up: Top
			     KFORK     JSYS 153

   Kills one or more processes.  When a process is  killed,  all  private
   memory  acquired  by  the  process  and  its Process Storage Block are
   released.  Also, any JFNs the process has created  are  released,  and
   any	terminal  interrupt  assignments  that were acquired from another
   process are passed back.  (Note that because the  process  is  deleted
   asynchronously,  a  page of a file mapped into a lower process may not
   be unmapped before the KFORK call returns.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, unless the current process attempts  to  kill
		    itself

   The KFORK call will not release a process  handle  that  identifies	a
   process  already  killed  by another process.  In this case, the RFRKH
   call must be used to release the handle.

   The CFORK monitor call can be used to create an inferior process.

   Generates an illegal instruction interrupt on error conditions below.

   KFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   KFRKX1:   illegal to kill top level process

   KFRKX2:   illegal to kill self


Node: LGOUT	Previous: KFORK	Next: LNMST	Up: Top
			      LGOUT     JSYS 3

   Kills the specified	job  and  appends  an  accounting  entry  to  the
   accounting  data  file.   However, no entry is appended if the job was
   never logged in (i.e., a CTRL/C was typed, but no login occurred).

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled

   ACCEPTS IN AC1:  number of the job to be logged out,  or  -1  for  the
		    current job

   RETURNS     +1:  failure, error code in AC1
   (LGOUT)
   

	       +2:  success

   When a specific job number is given in AC1, it must refer to either	a
   PTY	job  controlled  by  the current job or a job logged in under the
   same user name as the current job.  Otherwise, to give a specific  job
   number,  the  process  must have WHEEL or OPERATOR capability enabled.
   An argument of -1 must be given if the  current  job  wishes  to  kill
   itself  (i.e.,  the job number given cannot be the same as the current
   job).  Note that this monitor call does not return if the argument  in
   AC1 is -1.

   The LGOUT monitor call outputs the time used (both CPU  and	console),
   the	job  number,  and the current date and time.  This information is
   output on the terminal to which the job being logged out is attached.

   LGOUT ERROR MNEMONICS:

   LOUTX1:   illegal to specify job number when logging out own job

   LOUTX2:   invalid job number

   LOUTX3:   WHEEL or OPERATOR capability required

   LOUTX4:   LOG capability required

   LOUTX5:   illegal to log out job 0


Node: LNMST	Previous: LGOUT	Next: LOGIN	Up: Top
			     LNMST     JSYS 504

   Translates a logical name to its original definition  string.   (Refer
   to Section 2.2.2 and the CRLNM and INLNM monitor calls descriptions.)

   ACCEPTS IN AC1:  function code

	      AC2:  pointer to the logical name

	      AC3:  pointer to the string where the original logical name
		    definition is to be written

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC3

   The codes for the functions are as follows:

   0	.LNSJB	  Obtain the job-wide definition of the logical name.
   1	.LNSSY	  Obtain the system definition of the logical name.

   LNMST ERROR MNEMONICS:
   (LNMST)
   

   GJFX22:   insufficient system resources (Job Storage Block full)

   LNSTX1:   no such logical name

   LNSTX2:   invalid function


Node: LOGIN	Previous: LNMST	Next: LPINI	Up: Top
			      LOGIN     JSYS 1

   Logs a job into the system.	 Useful  for  logging  in  from  an  idle
   terminal on which a CTRL/C has been typed.

   ACCEPTS IN AC1:  36-bit user number under which user will log in

	      AC2:  pointer to beginning of password string

	      AC3:  account number in  bits  3-35  if  bits  0-2  are  5.
		    Otherwise  contains  a  pointer to an account string.
		    If a null byte is not seen, the string is  terminated
		    after 39 characters are processed.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, date and time of  last  login  (in  internal
		    system  format;   refer to Section 2.8.2) in AC1, and
		    updated string pointers, if  pertinent,  in  AC2  and
		    AC3.

   The LOGIN monitor call does not require a password if the  controlling
   terminal  is  a pseudo-terminal and the controlling job either has the
   WHEEL or OPERATOR capability enabled or is logged in as the same  user
   being logged in for this job.

   If the call is successful, an accounting  entry  is	appended  to  the
   accounting  data file.  If the account validation facility is enabled,
   the LOGIN call verifies  either  the  account  given  or  the  default
   account of the user being logged in.

   LOGIN ERROR MNEMONICS:

   LGINX1:   invalid account identifier

   LGINX2:   directory is "files-only" and cannot be logged in to

   LGINX3:   internal format of directory is incorrect

   LGINX4:   invalid password

   LGINX5:   job is already logged in

   LGINX6:   no more job slots available for logging in
   (LPINI)
   


Node: LPINI	Previous: LOGIN	Next: MDDT%	Up: Top
			     LPINI     JSYS 547

   Loads the direct access Vertical Formatting Unit (VFU) or  translation
   Random  Access  Memory  (RAM)  for  the  line  printer.   This call is
   executed at system startup by the program that configures the system.

   RESTRICTIONS:    requires WHEEL or OPERATOR capabilities enabled

   ACCEPTS IN AC1:  JFN of file containing VFU or RAM

	      AC2:  status bits in the left half, and  function  code  in
		    the right half

	      AC3:  unit number of line printer

   RETURNS     +1:  always

   The following status bit is currently defined.

       B0(MO%LCP)   Line printer is a lowercase printer.

   The available functions are as follows:

   Code      Symbol		 Meaning

    32	     .MOLVF    Load the VFU from the file indicated by the  given
		       JFN.

    34	     .MOLTR    Load the translation RAM from the  file	indicated
		       by the given JFN.

   The line printer must not be opened by any process when this  call  is
   executed.   If  a  condition  occurs that prevents the VFU or RAM from
   being loaded (e.g., the line printer is off line),  the  name  of  the
   file will be stored.  The VFU or RAM will then be loaded automatically
   the next time a process performs output to the line printer.

   Generates an illegal instruction interrupt on error conditions below.

   LPINI ERROR MNEMONICS:

   LPINX1:  invalid unit number

   LPINX2:  WHEEL or OPERATOR capability required

   LPINX3:  illegal to load RAM or VFU while device is OPEN


Node: MDDT%	Previous: LPINI	Next: METER%	Up: Top
			     MDDT%    JSYS 777
   (MDDT%)
   

  Transfers control to the MDDT program while preserving the context  of
  the	process  that  issued  the  MDDT% JSYS.  The terminal keyboard is
  activated and the user may enter commands to the MDDT program  or  may
  return to TOPS-20 command level by typing CTRL/C or CTRL/Z.

  RESTRICTIONS:  requires WHEEL or OPERATOR capabilities enabled

  The MDDT% JSYS accepts no arguments and does not return control to the
  issuing process (unless the user types MRETN$G).

  MDDT ERROR MNEMONICS:

  WHELX1:  WHEEL or OPERATOR capability required


Node: METER%	Previous: MDDT%		Next: MONRD%	Up: Top
			    METER%     JSYS 766

  Returns the value of the execution  accounting  meter  or  the  memory
  reference  accounting meter.  These values do not represent time as in
  "clock time";  rather, they represent the amount of time that the EBOX
  was busy and how many times the MBOX was referenced by the EBOX.

  RESTRICTIONS:    available only on KL10 hardware

  ACCEPTS IN AC1:  function code

  RETURNS     +1:  always, with 59-bit value in AC2 and AC3

  Function Codes:

  Code      Symbol		       Meaning

   1	     .MEREA	Read   process	 execution    accounting    meter
			doubleword.   Value  returned  is  EBOX busy time
			(number of EBOX ticks).

   2	     .MERMA	Read process  memory-reference	accounting  meter
			doubleword.   Value  returned  is  count  of MBOX
			references (number of MBOX ticks).

  The accounting meters have bits which allow executive PI overhead  and
  executive  non-PI  overhead	to  be	included in the doubleword count.
  These are turned off by default (the monitor must be  rebuilt  to  set
  them),  so  (by  default)  the EBOX count does not include the monitor
  overhead of paging, scheduling,  or	swapping.   The  count	primarily
  includes  only  the	EBOX  time  spent  executing the instructions and
  JSYS's in the user's  program.   However,  interrupts  caused  by  IO,
  paging,  swapping, etc can cause instruction restarts or require pager
  refills and these are included in the count.  Because these interrupts
  are dependent on a variety of system variables (such as load average),
   (METER%)
   

  subsequent timings of the same event will return varying count values.
  These  fluctuations	can  be "smoothed" by timing the event repeatedly
  and taking the average of the values returned.

  The MBOX reference count has  the  same  specifications  as	the  EBOX
  count,  and is subject to the same kind of fluctuations.  Cache hit/no
  hit introduces an additional source of  fluctuations.   Again,  timing
  the	event  repeatedly  and	taking the average of the values returned
  will "smooth" the counts.

  An event can be timed by an initial	execution  of  METER%,	a  DMOVEM
  instruction	to  save  the start value, and (after the event) a second
  execution of METER% followed by a DSUB instruction to find the elapsed
  number  of  ticks.	For  added accuracy, the average overhead for the
  timing sequence can be determined  and  subtracted  from  the  average
  count value for the timed interval.

  The following diagram illustrates the format of the value returned:

  !		  AC2		  !		AC3		 !
  !=============================================================!
  !	    High Order Part	  !0!  Low Order Part ! Reserved !
  !=============================================================!
  !0				35!0!1		    23!24      35!

  To form a  right-justified  doubleword  value  in  AC2  and	AC3,  the
  following instruction may be executed:

	ASHC AC2,-D12

  METER% ERROR MNEMONICS:

  ARGX02:  Invalid function code

  METRX1:  METER not implemented for this processor.


Node: MONRD%	Previous: METER%	Next: MRECV	Up: Top
                       MONRD%     JSYS 717


The MONRD% is used by non-privileged program to obtain  information  from
the JSB, PSB, a monitor symbol (restricted set of), and fork status.

ACCEPTS IN AC1:  function code

     AC2 through AC4:  dependent on the function (see description below)

RETURNS     +1:  always

Code  Symbol                         Meaning

  0   .RDTST     The test function is used in order to see if the  MONRD%
                 JSYS  is  implemented.   If  implemented, the JSYS will
                 return a value of .TSTNM (123456 octal).  (AC2 must  be
                 zero.)

  1   .RDSYM     The read symbol function will get the  definition  (the
                 address  in  the  monitor) of the SIXBIT symbol in AC1.
                 If successful AC2 will contain the  definition  of  the
                 symbol.

  2   .RDJSB     The read JSB function allows you to read the contents a
                 word  in  the  JSB  (Job  Storage  Block).  The word is
                 referenced by an  offset  (contained  in  AC3)  from  a
                 symbol  (the  SIXBIT  value  of  which is in AC2).  AC4
                 contains the  job  number.   (Symbols  implemented  are
                 listed  below.)  On  successful return AC2 will contain
                 the contents of that word.

  3   .RDPSB     The read  PSB  function  is  the  same  as  the  .RDJSB
                 function except that it allows you to read from the PSB
                 (Proccess Storage Block) and not the JSB.  AC4 contains
                 the system fork number.

  4   .RDSTS     The read fork status function  returns  the  same  fork
                 information  as  the RFSTS JSYS in AC2 (if successful).
                 AC2 (on entry) contains the absolute fork  number  (not
                 relative fork handle) of the fork in question.

Function: Test   Read symbol    Read JSB    Read PSB    Read fork status
AC1:     .RDTST   .RDSYM         .RDJSB      .RDPSB          .RDSTS
AC2:        0     sym-name      sym-name    sym-name       sys-fork-#
AC3:       --       --           offset      offset           --
AC4:       --       --           job-#     sys-fork-#         --

Where:   sym-name is the  SIXBIT  value  of  the  symbol  to  look  for;
         sys-fork-#  is  an  absolute fork number;  offset is the offset
         (from the symbol name);  job-# is the job number of  the  whose
         JSB or PSB to look at

                       Table of Symbols for MONRD%

	CAPENB	CAPMSK	DSKDTB	FILBYN	FILBYT	FILDDN	FILDNM	FILNEN
	FILSTS	FILVER	FILOFN	FILDEV	FKCNT	FKPTRS	FKRT	INTDF
	JOBNO	JSVAR	JSVARZ	KIMUU1	LSTERR	MAXJFN	MLJFN	NUFKS
	PPC	PSVAR	PSVARZ	RESQTL	RSCNBP	SYSFK	TRAPPC	TTFLG1
	TTFLGS	TTICT	TTLINK	TTOCT	UPDL	UTRPCT

Generates illegal instruction interrupt if not implemented.


Node: MRECV	Previous: MONRD%	Next: MSEND	Up: Top
			     MRECV     JSYS 511

   Retrieves an IPCF (Inter-Process Communication Facility) message  from
   the	process'  input queue.	Refer to the TOPS-20 Monitor Calls User's
   Guide  for  an  overview  and   description	 of   the   Inter-Process
   Communication Facility.

   RESTRICTIONS:    Requires WHEEL or IPCF capability enabled

   ACCEPTS IN AC1:  length of packet descriptor block
   (MRECV)
   

	      AC2:  address of packet descriptor block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success.  The packet is retrieved and placed into the
		    block   indicated	by  word  .IPCFP  of  the  packet
		    descriptor block.  AC1 contains  the  length  of  the
		    next  entry  in  the  queue  in the left half and the
		    flags from the next packet in the right  half.   This
		    returned  word  is	called the associated variable of
		    the next entry in the queue.  If the queue is  empty,
		    AC1 contains 0.

   The format of the packet descriptor block is as follows:

	Word	  Symbol	      Meaning

	  0	  .IPCFL    Flags.    (Refer   to    the    MSEND    call
			    description.)

	  1	  .IPCFS    PID of sender.  The caller	does  not  supply
			    this  PID;	 the  system fills it in when the
			    packet is retrieved.

	  2	  .IPCFR    PID of receiver.  This  PID  can  be  one  of
			    three values:  a specific PID, -1 to retrieve
			    messages  for  any	PID  belonging	to   this
			    process,  or  -2 to retrieve messages for any
			    PID belonging to this job.	When -1 or -2  is
			    supplied,  messages  are not retrieved in any
			    particular order except that messages from	a
			    specific  PID  are	returned  in the order in
			    which they were received.

	  3	  .IPCFP    Pointer to	block  where  message  is  to  be
			    placed  (length  of  message in the left half
			    and address where message is to be placed  in
			    the right half).

	  4	  .IPCFD    User number of sender.

	  5	  .IPCFC    Enabled capabilities of sender.

	  6	  .IPCSD    Directory  number	of   sender's	connected
			    directory.

	  7	  .IPCAS    Account  string  of   sender.    The   caller
			    supplies  a  pointer  to  the block where the
			    account is to be placed.

   The caller (i.e., receiver) does not supply the information in words 4
   through  7;	 the  system  fills  in  the  words  when  the	packet is
   retrieved.  These words describe the sender at the  time  the  message
   was sent and permit the receiver to validate messages.
   (MRECV)
   

   Refer to the MSEND call description for the flags that can be  set  in
   word .IPCFL of the packet descriptor block.

   MRECV ERROR MNEMONICS:

   IPCFX1:   length of packet descriptor block cannot be less than 4

   IPCFX2:   no message for this PID

   IPCFX3:   data too long for user's buffer

   IPCFX4:   receiver's PID invalid

   IPCFX5:   receiver's PID disabled

   IPCF11:   WHEEL or IPCF capability required

   IPCF14:   no PID's available to this job

   IPCF15:   no PID's available to this process

   IPCF16:   receive and message data modes do not match

   IPCF24:   invalid message size

   IPCF25:   PID does not belong to this job

   IPCF26:   PID does not belong to this process

   IPCF27:   PID is not defined

   IPCF28:   PID not accessible by this process

   IPCF29:   PID already being used by another process

   IPCF31:   invalid page number

   IPCF32:   page is not private

   IPCF34:   cannot receive into an existing page


Node: MSEND	Previous: MRECV	Next: MSFRK	Up: Top
			     MSEND     JSYS 510

   Sends an IPCF (Inter-Process  Communication	Facility)  message.   The
   message  is	in  the  form  of  a packet and can be sent to either the
   specified PID or  the  system  process  <SYSTEM>INFO.   Refer  to  the
   TOPS-20  Monitor Calls User's Guide for an overview and description of
   the Inter-Process Communication Facility.

   RESTRICTIONS:    requires IPCF  capability  enabled.   Some	functions
   (MSEND)
   

		    require WHEEL capability enabled.

   ACCEPTS IN AC1:  length of packet descriptor block

	      AC2:  address of packet descriptor block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success.  The packet is sent to the receiver's  input
		    queue.  Word .IPCFS of the packet descriptor block is
		    updated with the sender's PID.  This updating is done
		    in	case  the  PID	was being defaulted or created by
		    this call.

   The format of the packet descriptor block is as follows:

	Word	  Symbol		   Meaning

	  0	  .IPCFL    Flags.  (See below.)

	  1	  .IPCFS    PID of sender, or 0  if  no  PID  exists  for
			    sender.   This  word will be filled in by the
			    monitor if	the  caller  is  creating  a  PID
			    (i.e., flag bit IP%CPD is on).

	  2	  .IPCFR    PID  of  receiver,	or  0  if   receiver   is
			    <SYSTEM>INFO.

	  3	  .IPCFP    Pointer to message block (length  of  message
			    in	the  left  half  and  starting address of
			    message in the right half).  When a packet is
			    sent   to  <SYSTEM>INFO,  the  message  block
			    contains  the  request  being   made.    (See
			    below.)

   The	following  flags  are  defined	in  word  .IPCFL  of  the  packet
   descriptor  block.  These flags can be set on both the MSEND and MRECV
   calls.

   Flags Set By Caller
      

      B0(IP%CFB)  Do not block process if there are no	messages  in  the
		  queue.   If this bit is set, an error is given if there
		  are no messages.

     B1(IP%CFS)  Use, as the sender's PID, the  PID  obtained	from  the
		  address  specified  in word .IPCFS.  Setting bit IP%CFS
		  notifies the	monitor  that  word  .IPCFS  contains  an
		  address,  and  the  sender's	PID  is  located  in that
		  address.

      B2(IP%CFR)  Use, as the receiver's PID, the PID obtained	from  the
		  address  specified  in word .IPCFR.  Setting bit IP%CFR
		  notifies the	monitor  that  word  .IPCFR  contains  an
		  address,  and  the  receiver's  PID  is located in that
   (MSEND)
   

		  address.

      B3(IP%CFO)  Allow one send request above the quota.   (The  default
		  send quota is 2.)

      B4(IP%TTL)  Truncate the message, if it is larger  than  the  space
		  reserved.  If this bit is not set, an error is given if
		  the message is too large.

      B5(IP%CPD)  Create a PID to use as the sender's PID and  return  it
		  in word .IPCFS of the packet descriptor block.

      B6(IP%JWP)  Make the created PID be job wide (i.e., permanent until
		  the  job logs out).  If this bit is not set, the PID is
		  temporary until the process executes the RESET  monitor
		  call.  If B5(IP%CPD) is not set, B6 is ignored.

      B7(IP%NOA)  Do not allow other processes to use  the  created  PID.
		  If B5(IP%CPD) is not set, B7 is ignored.

      B18(IP%CFP) The packet is privileged.  (This bit can be set only by
		  a  process  with  WHEEL  capability  enabled.)  When	a
		  privileged sender sets this bit, the	MRECV  and  MUTIL
		  calls  return  it set for any reply.	An error is given
		  if this bit is set by the sender and	the  receiver  is
		  not privileged.

      B19(IP%CFV) The packet is a page	of  data.   Word  .IPCFP  of  the
		  packet  descriptor block contains 1000 in the left half
		  and the page number in the right half.   The	page  the
		  packet  is  being  sent  to, or is being received into,
		  must be private.

					   NOTE

		      When a process sends a page of data with MSEND,
		      that page is removed from the process' map.

   Flags Returned After Call
      

      B20(IP%CFZ) A zero-length message was sent, and the packet consists
		  of only the packet descriptor block.

      B24-B29	  Error code field for errors encountered by <SYSTEM>INFO
      (IP%CFE)	  during a send or receive request.

		  Code Symbol		   Meaning

		  15   .IPCPI	 insufficient privileges
		  16   .IPCUF	 invalid function
		  67   .IPCSN	 <SYSTEM>INFO needs name
		  72   .IPCFF	 <SYSTEM>INFO free space exhausted
   (MSEND)
   

		  74   .IPCBP	 PID has no name or is invalid
		  75   .IPCDN	 duplicate name has been specified
		  76   .IPCNN	 unknown name has been specified
		  77   .IPCEN	 invalid name has been specified

      B30-B32	  System and sender code.  This code can be set only by a
      (IP%CFC)	  process with	WHEEL  capability  enabled.   The  system
		  returns  the	code  so  that	a  nonprivileged user can
		  examine it.

		  Code Symbol		   Meaning

		  1    .IPCCC	 sent by <SYSTEM>IPCF
		  2    .IPCCF	 sent by system-wide <SYSTEM>INFO
		  3    .IPCCP	 sent by receiver's <SYSTEM>INFO

      B33-B35	  Field for  return of	special messages.  This field can
      (IP%CFM)	  be set only by a process with WHEEL capability enabled.
		  The	system	 returns   the	 information  so  that	a
		  nonprivileged user can examine it.

		  Code Symbol		   Meaning

		  1    .IPCFN	 Process' input queue contains	a  packet
				 that  could not be delivered to intended
				 PID.

   When the MSEND call is used to send	a  packet  to  <SYSTEM>INFO,  the
   message  portion  of the packet (i.e., the first three words) contains
   the request.  This request has the following format:

	Word	  Symbol		   Meaning

	  0	  .IPCI0    user-defined code in the left  half  and  the
			    function   (see  below)  <SYSTEM>INFO  is  to
			    perform in the right half.	The  user-defined
			    code  is  used to associate the response from
			    <SYSTEM>INFO with the appropriate request.

	  1	  .IPCI1    PID that is to receive  a  duplicate  of  the
			    response  from <SYSTEM>INFO.  If this word is
			    0,	the  response  is  sent   only	 to   the
			    originator of the request.

	  2	  .IPCI2    argument for the  requested  function.   (See
			    below.)

   The functions that can be requested of <SYSTEM>INFO, along with  their
   arguments, are as follows:

      Function	  Argument		   Meaning

      .IPCIW	  name		 Return  the  PID  associated  with   the
				 specified  name.  The PID is returned in
				 word .IPCI1.
   (MSEND)
   

      .IPCIG	  PID		 Return  the  name  associated	with  the
				 specified  PID.  The name is returned in
				 word .IPCI1.

      .IPCII	  name in	 Assign  the  specified  name  to the PID
		   ASCIZ	 belonging  to	the  process  making  the
				 request.   The  temporary  or	permanent
				 status of the PID is specified  by  flag
				 bit   IP%JWP(B6)   when   the	 PID  was
				 originally created.

      .IPCIJ	  name in	 Identical to the .IPCII function.
		   ASCIZ

      .IPCIS			 Disassociates all PIDs with names.  Used
				 by  the  monitor  on  a  RESET  or LGOUT
				 monitor  call.   This	function  is  not
				 available to user programs.

   MSEND ERROR MNEMONICS:

   IPCFX1:   length of packet descriptor block cannot be less than 4

   IPCFX4:   receiver's PID invalid

   IPCFX5:   receiver's PID disabled

   IPCFX6:   send quota exceeded

   IPCFX7:   receiver quota exceeded

   IPCFX8:   IPCF free space exhausted

   IPCFX9:   sender's PID invalid

   IPCF11:   WHEEL or IPCF capability required

   IPCF12:   no free PID's available

   IPCF13:   PID quota exceeded

   IPCF14:   no PID's available to this job

   IPCF15:   no PID's available to this process

   IPCF19:   no PID for [SYSTEM]INFO

   IPCF24:   invalid message size

   IPCF25:   PID does not belong to this job

   IPCF26:   PID does not belong to this process

   IPCF27:   PID is not defined
   (MSEND)
   

   IPCF28:   PID not accessible by this process

   IPCF29:   PID already being used by another process

   IPCF31:   invalid page number

   IPCF32:   page is not private


Node: MSFRK	Previous: MSEND	Next: MSTR	Up: Top
			     MSFRK     JSYS 312

   Starts a process in monitor mode.  The MSFRK call is legal only if  it
   is  called  from  monitor mode or if the process has WHEEL or OPERATOR
   capability enabled.	 This  call  allows  job  0  to  create  multiple
   processes for handling various asynchronous monitor tasks.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  process handle

	      AC2:  36-bit PC word, with user mode and other flags in the
		    left half and the virtual address in the right half

   RETURNS     +1:  always

   Because the starting context of the process is undefined, the  process
   being started should execute the following sequence of instructions at
   its starting address:

	FBGN:	MOVSI 1,UMODF	 ;fake user PC
		MOVEM 1,FPC	 ;simulate the JSYS call
		MCENTR		 ;establish usual top-level JSYS context

   Generates an illegal instruction interrupt on error conditions below.

   MSFRK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   CAPX1:    WHEEL or OPERATOR capability required


Node: MSTR	Previous: MSFRK	Next: MTALN	Up: Top
			     MSTR     JSYS 555
   (MSTR)
   

   Performs  various  structure-dependent  functions.	These	functions
   include   mounting	and   dismounting  structures,	incrementing  and
   decrementing mount counts for structures, and  setting  and	obtaining
   the status of structures.

  For regulated structures, the mount count must be  incremented  before
  access  rights  or JFNs can be given.  All structures are regulated by
  default except the primary structure (PS:  on  most	systems)  or  any
  structure declared non-regulated with the .MSSSS function of MSTR.

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled.	A  process  with  MAINTENANCE  capability
		    enabled  can  obtain  the  status  of  a  disk   unit
		    (functions .MSRNU and .MSRUS).

   ACCEPTS IN AC1:  length of the argument block in  the  left	half  and
		    function code in the right half

	      AC2:  address of the argument block

   RETURNS     +1:  always, with some functions  returning  data  in  the
		    argument   block.	 (Refer  to  individual  function
		    descriptions below.)

   Generates an illegal instruction interrupt on all error conditions.

   The available functions are summarized below.

   Function	  Symbol    Privileged		     Meaning
     Code

	0	  .MSRNU       Yes	   Return the status of the  next
					   disk unit.

	1	  .MSRUS       Yes	   Return the status of the given
					   disk unit.

	2	  .MSMNT       Yes	   Mount the given structure.

	3	  .MSDIS       Yes	   Dismount the given structure.

	4	  .MSGSS       No	   Return the status of the given
					   structure.

	5	  .MSSSS       Yes	   Change the status of the given
					   structure.

	6	  .MSINI       Yes	   Initialize	   the	    given
					   structure.

	7	  .MSIMC       No	   Increment the mount count  for
					   the	given  structure  for the
   (MSTR)
   

					   job.

	10	  .MSDMC       No	   Decrement the mount count  for
					   the	given  structure  for the
					   job.

	11	  .MSGSU       No	   Return the job numbers of  the
					   users of the given structure.

	13	  .MSICF       No	   Increment the mount count  for
					   the	given  structure  for the
					   given fork.

	14	  .MSDCF       No	   Decrement the mount count  for
					   the	given  structure  for the
					   given fork.

	15	  .MSOFL       Yes	   Receive  interrupt  when  disk
					   comes on-line.

	16	  .MSIIC       Yes	   Ignore  increment  check   for
					   structure use

   Obtaining the Status of the Next Disk Unit - .MSRNU
            

   This function returns the status of the next disk unit on the  system.
   The	next disk unit is determined by searching the current channel and
   looking for the next physical unit on that channel.

   The .MSRNU function accepts the channel, controller, and unit  numbers
   in  the  first three words of the argument block.  The first time this
   function is executed, the value for	each  of  these  numbers  is  -1.
   After successful completion of this function, the channel, controller,
   and unit numbers are updated, and the software information  about  the
   disk  drive	is  returned in the argument block.  To locate all drives
   available for mounting structures, the channel, controller,	and  unit
   numbers  returned  from  one  .MSRNU function call are supplied on the
   next one until all units on all channels have been searched.  When all
   units have been searched, the MSTR monitor call returns error MSTX18.

   The format of the argument  block,  whose  length  is  .MSRLN,  is  as
   follows:

   Word      Symbol			   Meaning

     0	     .MSRCH	    Channel number (0-7)

     1	     .MSRCT	    Controller number (reserved for  future  use,
			    must be -1)

     2	     .MSRUN	    Unit number (0-7)

     3	     .MSRST	    Returned  software	status	of   unit.    The
			    following status bits are defined:
   (MSTR)
   

			    B0(MS%MNT)	Unit  is  part	 of   a   mounted
					structure
			    B2(MS%DIA)	Unit is being used by an  on-line
					diagnostic program
			    B3(MS%OFL)	Unit is off line
			    B4(MS%ERR)	Unit  has  an  error   that   was
					detected during reading
			    B5(MS%BBB)	Unit has a  bad  BAT  block.   If
					this bit is on, the data returned
					in word .MSRSN (word  4)  and  in
					words	.MSRNS	 through   .MSRFI
					(words	 6   through	20)    is
					indeterminate.
			    B6(MS%HBB)	Unit has a bad HOME block
			    B7(MS%WLK)	Unit is write locked

			    B9-B17	Type of disk unit
			    (MS%TYP)
					1  .MSRP4   RP04
					5  .MSRP5   RP05
					6  .MSRP6   RP06
					7  .MSRP7   RPO7
					11 .MSRM3   RMO3

     4	     .MSRSN	    Byte pointer to  ASCIZ  string  in	which  to
			    store  the	structure  name.  This pointer is
			    updated on return.

     5	     .MSRSA	    Byte pointer to  ASCIZ  string  in	which  to
			    store  the	structure  alias.   The  alias is
			    usually the same as the structure name.   The
			    alias  is  returned, and the pointer updated,
			    only if the structure is on line.

     6	     .MSRNS	    Logical unit number within the  structure  of
			    this  unit	in  the  left half, and number of
			    units in the structure in the right half.

     7	     .MSRSW	    Number  of	pages  for   swapping	on   this
			    structure.

    10-12    .MSRUI	    Unit ID (3 words of ASCII)

    13-15    .MSROI	    Owner ID (3 words of ASCII)

    16-20    .MSRFI	    File system ID (3 words of ASCII)

    21	     .MSRSP	    Number of sectors per page

    22	     .MSRSC	    Number of sectors per cylinder

    23	     .MSRPC	    Number of pages per cylinder

    24	     .MSRCU	    Number of cylinders per unit
   (MSTR)
   

    25	     .MSRSU	    Number of sectors per unit

    26	     .MSRBT	    Number of bit words in bit table per cylinder

   The length of the argument block in words is given  by  symbol  .MSRLN
   (27).

   The following errors are possible on the failure of this function.

   MSTRX2:   WHEEL or OPERATOR capability required

   MSTRX3:   argument block too small

   MSTX14:   invalid channel number

   MSTX15:   invalid unit number

   MSTX16:   invalid controller number

   MSTX18:   no more units in system

   MSTX27:   specified unit is not a disk

   CAPX2:    WHEEL, OPERATOR, or MAINTENANCE capability required

   Obtaining the Status of a Given Disk Unit - .MSRUS
            

   This function returns the status of the given disk unit.   It  accepts
   the	channel, controller, and unit numbers in the first three words of
   the argument block.	After successful completion of this function, the
   channel,  controller, and unit numbers are unchanged, and the software
   information about the given disk unit  is  returned	in  the  argument
   block.

   The difference between this function and the .MSRNU function  is  that
   .MSRUS  does  not search for the next disk unit but rather returns the
   status for the given unit.  The .MSRNU function searches for the  next
   disk unit and returns the status for that unit.

   The format of the argument  block  and  the	errors	possible  on  the
   failure  of	this  function	are  the same as described for the .MSRNU
   function.

   Mounting a Given Structure - .MSMNT
        

   This function brings the given structure on line and normally makes it
   available  for  general  use.   Any	structure  other  than the public
   structure PS:  must be brought  on  line  with  this  function.   (The
   public  structure  PS:   is	brought on line during the system startup
   procedure.)

   It is recommended that the .MSRNU (Read Next Unit) function	be  given
   first  to  locate  all units in the structure.  Then the .MSMNT (Mount
   (MSTR)
   

   Structure) function can be given to read and verify the HOME blocks of
   each  unit  and  to	mount the structure.  If one or more units of the
   structure are write-locked, the structure cannot  be  mounted  and  an
   error is given.

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

	0    .MSTNM	    Pointer to the ASCIZ  string  containing  the
			    name of the structure.

	1    .MSTAL	    Pointer to the ASCIZ  string  containing  the
			    alias of the structure.

	2    .MSTFL	    Flag bits in the left half, and the number of
			    units  in the structure (.MSTNU) in the right
			    half.  The bits that can be set in	the  left
			    half are:

			    B0(MS%NFH)	If one	of  the  HOME  blocks  is
					incorrect,  do	not fix it and do
					return an error.  If this bit  is
					off and one of the HOME blocks is
					incorrect, the correct	block  is
					copied	into  the  bad HOME block
					and   the   mounting	procedure
					continues.

			    B1(MS%NFB)	If one of the BAT (Bad Allocation
					Table)	blocks	is  incorrect, do
					not  fix  it  and  do  return  an
					error.	 If  this  bit is off and
					one  of   the	BAT   blocks   is
					incorrect,  the  correct block is
					copied into the bad BAT block and
					the mounting procedure continues.

			    B2(MS%XCL)	Mount the structure for exclusive
					use by this job.  This bit is set
					by  a  system  program	when   it
					initializes   or  reconstructs	a
					structure.  If this bit  if  off,
					the   structure  is  mounted  for
					general use.

			    B3(MS%IGN)	Ignore correctable errors in  the
					bit   table   and   in	the  root
					directory  on	this   structure.
					This  bit  is  set  by	a  system
					program when it reconstructs  the
					root  directory on a structure or
					rebuilds the bit table.  If  this
					bit   is  off  and  an	error  is
					detected, this	function  returns
   (MSTR)
   

					an error.

	3    .MSTUI	    Beginning of unit information for  each  unit
			    in the structure.  The information is 3 words
			    long per unit, and the symbol for this length
			    is	.MSTNO.   The  first  3-word block is for
			    logical unit 0, and the last 3-word block  is
			    for  the  last  logical unit (.MSTNU-1).  The
			    offsets into the 3-word block are:

			    0	  .MSTCH   Channel number of unit

			    1	  .MSTCT   Controller  number	of   unit
					   (currently must be -1)

			    2	  .MSTUN   Unit number of unit

			    The number of  argument  words  per  unit  is
			    given by symbol .MSTNO (3).

   After successful completion of this function, the given  structure  is
   mounted  and  available  for  general use (unless bit MS%XCL was on in
   word .MSTFL of the argument block).

   The following errors are possible on the failure of this function.

   MSTRX2:   WHEEL or OPERATOR capability required

   MSTRX3:   argument block too small

   MSTRX4:   insufficient system resources

   MSTRX5:   drive is not on line

   MSTRX6:   home blocks are bad

   MSTRX7:   invalid structure name

   MSTRX8:   could not get OFN for ROOT-DIRECTORY

   MSTRX9:   could not MAP ROOT-DIRECTORY

   MSTX10:   ROOT-DIRECTORY bad

   MSTX11:   could not initialize Index Table

   MSTX12:   could not OPEN Bit Table File

   MSTX13:   backup copy of ROOT-DIRECTORY is bad

   MSTX14:   invalid channel number

   MSTX15:   invalid unit number

   MSTX16:   invalid controller number
   (MSTR)
   

   MSTX17:   all units in a structure must be of the same type

   MSTX19:   unit is already part of a mounted structure

   MSTX20:   data error reading HOME blocks

   MSTX23:   could not write HOME blocks

   MSTX25:   invalid number of swapping pages

   MSTX27:   specified unit is not a disk

   MSTX30:   incorrect Bit Table counts on structure

   MSTX34:   unit is write-locked

   MSTX35:   too many units in structure

   MONX01:   insufficient system resources

   Dismounting a Given Structure - .MSDIS
        

   This function indicates that the given structure can be  removed  from
   the system.	Any mounted structure other than the public structure PS:
   can be dismounted with this function.  (The public structure  PS:   is
   dismounted at system shutdown.)

   Files that are open at the  time  this  function  is  executed  become
   inaccessible, and the jobs that had the files open receive an error if
   they reference them.  Jobs that have mounted  the  structure  or  have
   connected  to  or  accessed	a  directory  on the structure receive an
   informational message on the terminal.  This message is

	[STRUCTURE name:  HAS BEEN DISMOUNTED]

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .MSDNM	    Pointer to ASCIZ string containing the  alias
			    of the structure, or device designator of the
			    structure.

   After successful completion of this function, the given  structure  is
   dismounted and can be physically removed from the system.

   The following errors are possible on the failure of this function.

   MSTRX2:   WHEEL or OPERATOR capability required

   MSTRX3:   argument block too small

   MSTX21:   structure is not mounted
   (MSTR)
   

   MSTX24:   illegal to dismount the Public Structure

   Obtaining the Status of a Given Structure - .MSGSS
           

   This function returns the status of a mounted structure.   The  caller
   supplies  the designators for the structure and for the storage of the
   structure's physical ID.  After successful  completion  of  the  call,
   data is returned in the appropriate words in the argument block.

   The format of the argument  block,  whose  length  is  .MSGLN,  is  as
   follows:

      Word   Symbol			   Meaning

	0    .MSGSN	    Byte pointer to ASCIZ string  containing  the
			    alias  of the structure, or device designator
			    of the structure.

	1    .MSGST	    Returned status word.  The status bits are:

			    B0(MS%PS)	This  structure   is   a   public
					structure.

			    B1(MS%DIS)	This	structure    is     being
					dismounted  and  no further mount
					count increments are allowed.

			    B2(MS%DOM)	This  structure  is  a	 domestic
					structure.

			    B3(MS%PPS)	This  structure  is  the   public
					structure.

			    B4(MS%INI)	This	structure    is     being
					initialized.

			    B6(MS%NRS)	Structure is non-regulated

	2    .MSGNU	    Number of units in structure.

	3    .MSGMC	    Mount count for this structure.   This  value
			    is	 determined   by  the  number  of  .MSIMC
			    (Increment Mount Count) functions  given  for
			    this   structure   by  all	users  since  the
			    structure was mounted.

	4    .MSGFC	    Open file count (i.e., number of open  files)
			    for this structure.

	5    .MSGSI	    Pointer to ASCIZ string in which to store the
			    structure's physical ID.

   The length of the argument block is given by symbol .MSGLN (6).
   (MSTR)
   

   After successful completion of this function, the status of the  given
   structure  is returned in the appropriate words of the argument block,
   and the pointer to the physical ID is updated to reflect the  returned
   string.

   The following errors are possible on the failure of this function.

   MSTRX3:   argument block too small

   MSTX21:   structure is not mounted

   Changing the Status of a Given Structure - .MSSSS
           

   This function changes the status of a mounted structure.   The  caller
   can change only two of the status bits in the structure's status word:
   status of being dismounted and status of being domestic.

   The format of the argument block, whose length is .MSSLN is:

      Word   Symbol			   Meaning

	0    .MSSSN	    Byte pointer to ASCIZ string  containing  the
			    alias  of the structure, or device designator
			    of the structure.

	1    .MSSST	    Word containing the new values for	the  bits
			    being changed.

	2    .MSSMW	    Mask containing the bits being changed.   The
			    bits that can be changed are

			    B1(MS%DIS)	Structure is being dismounted.

			    B2(MS%DOM)	Structure is domestic.

			    B6(MS%NRS)	Structure is non-regulated

   After successful completion of this function, the status of the  given
   structure  is  changed  according to the data supplied in the argument
   block.

   The following errors are possible on the failure of this function.

   MSTRX2:   WHEEL or OPERATOR capability required

   MSTRX3:   argument block too small

   MSTX21:   structure is not mounted

   MSTX22:   illegal to change specified bits

   Initializing a Given Structure - .MSINI
        
   (MSTR)
   

   This function creates a new structure or repairs an existing structure
   during normal system operation.  The caller has the option of creating
   a new file system, reconstructing the root directory,  writing  a  new
   set of HOME blocks on the structure, or rebuilding the index block.

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .MSINM	    Byte pointer to ASCIZ string  containing  the
			    name of the structure.

	1    .MSIAL	    Byte pointer to ASCIZ string  containing  the
			    alias of the structure.

	2    .MSIFL	    Flag bits in B0-B11, function value  (MS%FCN)
			    in	B12-B17, and number of units in structure
			    (.MSINU) in B18-B35.  The flag bits are:

			    B0(MS%NFH)	Do not fix HOME block if  one  is
					incorrect and do return an error.
					This bit  can  be  on  only  with
					function .MSRRD.  (See below.)

			    B1(MS%NFB)	Do not fix BAT block  if  one  is
					incorrect and do return an error.

			    B2(MS%XCL)	Mount	 this	 structure    for
					exclusive  use	by  this job.  If
					this bit is off, the structure is
					mounted for general use.

			    B3(MS%IGN)	Ignore errors in  the  bit  table
					and in the root directory on this
					structure.  If this  bit  is  on,
					B2(MS%XCL) must also be on.

			    The function values that can be given are:

			    1	.MSCRE	Create a new file system

			    2	.MSRRD	Reconstruct the root directory

			    3	.MSWHB	Write a new set of HOME blocks

			    4	.MSRIX	Rebuild the index table

      3-5    .MSISU	    Beginning of unit information for  each  unit
			    in the structure.  The information is 3 words
			    long per unit, and the symbol for this length
			    is	.MSINO.   The  first  3-word block is for
			    logical unit 0, and the last 3-word block  is
			    for  the  last  logical unit (.MSINU-1).  The
			    offsets into the 3-word block are:
   (MSTR)
   

			    0	.MSICH	Channel number of unit

			    1	.MSICT	Controller   number    of    unit
					(currently must be -1)

			    2	.MSIUN	Unit number of unit

			    The number of arguments per unit is given  by
			    symbol .MSINO (3).

	6    .MSIST	    Status word (reserved for future use).

	7    .MSISW	    Number  of	pages  for   swapping	on   this
			    structure.

       10    .MSIFE	    Number  of	pages  for  the  front-end   file
			    system.

      11-13  .MSIUI	    Unit ID (3 words of ASCII)

      14-16  .MSIOI	    Owner ID (3 words of ASCII)

      17-21  .MSIFI	    File system ID (3 words of	ASCII)	(reserved
			    for future use)

       22    .MSIFB	    Number of pages for the file BOOTSTRAP.BIN.

   Words 6 through 16 (.MSIST through .MSIOI) of the argument block  must
   be  supplied when the MSTR call is being executed to create a new file
   system or to write  a  new  set  of	HOME  blocks.	After  successful
   completion  of  the	.MSCRE function, the structure is initialized and
   the following directories are created:

	<ROOT-DIRECTORY>
	<SYSTEM>
	<SUBSYS>
	<ACCOUNTS>
	<SPOOL>
	<OPERATOR>

   The following errors are possible on the failure of this function.

   MSTRX2:   WHEEL or OPERATOR capability required

   MSTRX3:   argument block too small

   MSTRX4:   insufficient system resources

   MSTRX5:   drive is not on line

   MSTRX6:   home blocks are bad

   MSTRX7:   invalid structure name

   MSTRX8:   could not get OFN for ROOT-DIRECTORY
   (MSTR)
   

   MSTRX9:   could not MAP ROOT-DIRECTORY

   MSTX10:   ROOT-DIRECTORY bad

   MSTX11:   could not initialize Index Table

   MSTX12:   could not OPEN Bit Table File

   MSTX13:   backup copy of ROOT-DIRECTORY is bad

   MSTX14:   invalid channel number

   MSTX15:   invalid unit number

   MSTX16:   invalid controller number

   MSTX17:   all units in a structure must be of the same type

   MSTX19:   unit is already part of a mounted structure

   MSTX20:   data error reading HOME blocks

   MSTX23:   could not write HOME blocks

   MSTX25:   invalid number of swapping pages

   MSTX26:   invalid number of Front-End-Filesystem pages

   MSTX27:   specified unit is not a disk

   MSTX28:   could not initialize Bit Table for structure

   MSTX29:   could not reconstruct ROOT-DIRECTORY

   MSTX30:   incorrect Bit Table counts on structure

   MONX01:   insufficient system resources

   Incrementing the Mount Count - .MSIMC
        

   Users  indicate  that  they	are  actively  using   a   structure   by
   incrementing  the  structure's  mount  count.   A  nonzero mount count
  informs the operator that the  structure  should  not  be  dismounted.
  Also,  an  IPCF  message  is sent to the Mountable Device Allocator to
  indicate that a user is using the structure.  The .MSIMC  function  is
   used to increment a structure's mount count.

  Note that incrementing the mount count is a requirement for	accessing
  files and directories on regulated structures.

   The job receives an error if the given structure is in the process  of
   being  dismounted  (i.e., a job has given the .MSSSS function with the
   MS%DIS bit on).
   (MSTR)
   

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .MSDEV	    Byte pointer to ASCIZ string  containing  the
			    alias  of the structure, or device designator
			    of the structure.
	1    .MSJOB	    Number of job whose  mount	count  is  to  be
			    incremented.  This requires WHEEL or OPERATOR
			    capability to be enabled.

   After successful completion of this function, the mount count  of  the
   given structure has been incremented.

   The following errors are possible on the failure of this function.

   MSTRX3:   argument block too small

   MSTX21:   structure is not mounted

   MSTX33:   structure is unavailable for mounting

   ARGX18:   invalid structure name

   MONX01:   insufficient system resources

   STDVX1:   no such device

   STRX01:   structure is not mounted

   STRX02:   insufficient system resources

   Decrementing the Mount Count - .MSDMC
        

   This function indicates that the given structure is	no  longer  being
   used by the job executing the call.	If the job executing the call has
   previously incremented the mount count  for	this  structure  via  the
   .MSIMC   (Increment	 Mount	 Count)  function,  the  mount	count  is
   decremented.  If the job has not incremented the mount count, the  job
  receives  an  error.   If the structure is regulated, and the user has
  any assigned JFNs on the structure, is accessing the structure  or  is
  connected to the structure, an error is returned.

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .MSDEV	    Byte pointer to ASCIZ string  containing  the
			    alias  of the structure, or device designator
			    of the structure.
	1    .MSJOB	    Number of job whose  mount	count  is  to  be
			    deccremented.    This   requires   WHEEL   or
			    OPERATOR capability to be enabled.
   (MSTR)
   

   The resource allocator receives an IPCF packet when	the  mount  count
   for	a structure is decremented.  The flag word (.IPCFL) of the packet
   descriptor block has a code of 1(.IPCCC) in	the  IP%CFC  field  (bits
   30-32).  This code indicates the message was sent by the monitor.  The
   first word of the packet data block contains  the  structure  dismount
   code  .IPCDS.  The second word contains the number of header words and
   the number of the job decrementing the mount count.	 The  third  word
   contains the device designator of the structure.  Thus,

	.IPCFL/<.IPCCC>B32

	DATA/.IPCDS
	DATA+1/number of header words (2),, job number
	DATA+2/device designator of structure

   After successful completion of this function, the mount count  of  the
   structure has been decremented and the IPCF message has been sent.

   The following errors are possible on the failure of this function.

   MSTRX3:   argument block too small

   MSTX21:   structure is not mounted

   MSTX32:   structure was not mounted

  MSTX36:   illegal while JFNs assigned

  MSTX37:   illegal while accessing or connected to a directory

   ARGX18:   invalid structure name

   MONX01:   insufficient system resources

   STDVX1:   no such device

   STRX01:   structure is not mounted

   STRX02:   insufficient system resources

   Obtaining the Users on a Given Structure - .MSGSU
           

   This function returns the job  numbers  of  the  users  of  the  given
   structure.	Users  of  a  structure  are  divided into three classes:
   users who have incremented the mount count (SMOUNT command), users who
   are	connected  to the structure (CONNECT command), and users who have
   accessed the structure (ACCESS command).   The  caller  specifies  the
   classes  of	users  for which information is to be returned by setting
   the appropriate bits in the argument block.

   The format of the argument block is as follows:

      Word   Symbol			   Meaning
   (MSTR)
   

	0    .MSUAL	    Byte pointer to ASCIZ string  containing  the
			    alias  of the structure, or device designator
			    of the structure.

	1    .MSUFL	    Flag bits in the left half and 0 in the right
			    half.  The bits that can be set are:

			    B0(MS%GTA)	Return users  who  have  accessed
					the structure.

			    B1(MS%GTM)	Return users who have incremented
					the mount count.

			    B2(MS%GTC)	Return users who are connected to
					the structure.

   After successful execution of this function, word 1 through	word  n+1
   (where  n  is  the  number  of  items  returned)  are updated with the
   following information.

      Word   Symbol			   Meaning

	1    .MSUFL	    Right half contains the number of  items  (n)
			    being returned.  Left half is unchanged.

	2    .MSUJ1	    Flag bits for the job in the left  half,  and
			    number of job in the right half.

	.		    .
	.		    .
	.		    .

      n + 1		    Flag bits for the job in the left  half,  and
			    number of job in the right half.

			    The bits returned for each	job  are  defined
			    as:

			    B0(MS%GTA)	Job has accessed structure.

			    B1(MS%GTM)	Job  has  incremented  the  mount
					count for structure.

			    B2(MS%GTC)	Job has connected to structure.

   The following errors are possible on the failure of this function.

   MSTRX1:   invalid function

   MSTRX3:   argument block too small

   STRX01:   structure is not mounted

   STDVX1:   no such device
   (MSTR)
   

   ARGX18:   invalid structure name

   MONX01:   insufficient system resources
   Specifying word and bits to be modified - .MSHOM

   This function allows enabled WHEEL or OPERATOR program to specify word
   of homeblock of mounted structure to be modified, which bits should be
   modified, and what the new values should be.

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .MSHNM	    Handle on alias such as pointer to string, or
			    device designator.

	1    .MSHOF	    Offset  specifying	which  word   should   be
			    changed.

	2    .MSHVL	    Value for new bits.

	3    .MSHMK	    Mask showing which bits should be changed.

   The following errors are possible on the failure of this function:

   MSTRX2:   insufficient privileges

   MSTRX3:   argument block too small

   MSTX21:   structure not mounted

	     any errors "MODHOM" routine returns

  Incrementing the Mount Count for the Fork - .MSICF
          

  This  function  and	the  next  one	(.MSDCF)  allow  job   forks   to
  independently  mount  and  dismount structures without contending with
  one another for control of the structure.  Note that when either a job
  mount  or  fork  mount  is  possible, the job mount is preferred as it
  incurs less overhead.

  This function indicates that a fork is actively using a structure.  If
  the	structure  is  being  dismounted, the job receives an error.  The
  format of the argument block is:

     Word   Symbol			   Meaning

	0    .MSDEV	    Pointer to ASCIZ string containing the  alias
			    of the structure, or device designator of the
			    structure.

  The following errors are possible on the failure of this function.

  MSTRX3:   argument block too small
   (MSTR)
   

  MSTX21:   structure is not mounted

  MSTX33:   structure is unavailable for mounting

  ARGX18:   invalid structure name

  MONX01:   insufficient system resources

  STDVX1:   no such device

  STRX01:   structure is not mounted

  STRX02:   insufficient system resources

  Decrementing the Mount Count for the Fork - .MSDCF
          

  This function and  the  previous  one  (.MSICF)  allow  job	forks  to
  independently  mount  and  dismount structures without contending with
  one another for control of the structure.  Note that when either a job
  mount  or  fork  mount  is  possible, the job mount is preferred as it
  incurs less overhead.

  This function indicates that a fork is no longer  using  a  structure.
  Note  that  if  a job-wide increment has been done, the fork may still
  access the structure.  The format of the argument block is:

     Word   Symbol			   Meaning

	0    .MSDEV	    Pointer to ASCIZ string containing the  alias
			    of the structure, or device designator of the
			    structure.

  The following errors are possible on the failure of this function.

  MSTRX3:   argument block too small

  MSTX21:   structure is not mounted

  MSTX32:   structure was not mounted

  MSTX36:   illegal while JFNs assigned

  MSTX37:   illegal while accessing or connected to a directory

   ARGX18:   invalid structure name

   MONX01:   insufficient system resources

   STDVX1:   no such device

   STRX01:   structure is not mounted

   STRX02:   insufficient system resources
   (MSTR)
   

  Receive Interrupt when Disk Comes On-line - .MSOFL
         

  This function specifies who is to receive an interrupt when
  a disk comes on-line.  It is provided for the Mountable
  Device Allocator in order to control the disks and inform the operator
  of structure status.  Only one process on the system will receive
  the interrupts.  The process using this JSYS must have WHEEL or
  OPERATOR
  capability enabled.	The argument block has the following format:

     Word   Symbol			   Meaning

	0    .MSCHN	    Place this process on a software interrupt
			    channel.
			    An interrupt is then generated when a disk
			    comes on-line.  If the channel
			    number is given as -1, a previously assigned
			    interrupt channel will be
			    deassigned.

  Ignore Increment Check for Structure Use - .MSIIC
         

  Allows a process to use a regulated structure without previously
  incrementing the mount count.  Entries are made to the accounting file
  only on structure decrements, so this function will enable bypassing
  of accounting.

  There is no argument block.

  The following errors are possible:

  MSTRX2:   WHEEL or OPERATOR capability required



Node: MTALN	Previous: MSTR	Next: MTOPR	Up: Top
			     MTALN     JSYS 774

   Associates a  given	serial-numbered  magnetic  tape  drive	with  the
   specified logical unit number.  The MTALN call is a temporary call and
   may not be defined in future releases.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  slave type in left	half;	logical  unit  number  of
		    magtape in right half

	      AC2:  decimal serial number of magnetic tape drive
   (MTALN)
   

   RETURNS     +1:  always

   All units are searched for the specified serial number and slave type.
   When  they  are  found, the drive is associated with the given logical
   unit number.  The original unit is now  associated  with  the  logical
   unit number that the specified serial-numbered drive had before it was
   reassigned.

   The slaves recognized are

	.MTT45	  TU45 (The system default)
	.MTT70	  TU70
	.MTT71	  TU71
	.MTT72	  TU72

   Generates an illegal instruction interrupt on error conditions below.

   MTALN ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required

   DEVX1:    invalid device designator

   OPNX7:    device already assigned to another job


Node: MTOPR	Previous: MTALN	Next: MTU%	Up: Top
			     MTOPR     JSYS 77

   Performs various device-dependent  control  functions.   This  monitor
   call  requires  that the device either be opened or be assigned to the
   caller if the device is an assignable device.

   Because of the device dependencies of the MTOPR call, programs written
   with  device-independent  code  should  not	use this call unless they
   first check for the type of device.

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled
   ACCEPTS IN AC1:  JFN of the device

	      AC2:  function code (see below)

	      AC3:  function arguments or address of argument block  (see
		    descriptions of individual devices)

   RETURNS     +1:  always

   The functions listed for each device apply only to that device.  If	a
   function  applies to more than one device, its description is repeated
   for each applicable device.
   (MTOPR)
   

   ARPANET Functions
    

  ARPANET  MTOPR  functions  are  described  below.   For   a	 complete
  description of their application, refer to the TOPS-20AN Monitor Calls
  User's Guide.

  Code      Symbol		      Meaning

   20	     .MOACP    If a connection is in the RFCR state, use of  this
		       function  will  cause  an RFC to be sent to accept
		       the connection.

   21	     .MOSND    If a connection	is  operating  in  buffered  send
		       mode,  use  of  this function causes all currently
		       buffered bytes to be sent.

   22	     .MOSIN    Causes the INS/INR command to be sent.

   24	     .MOAIN    Assigns	interrupt  channels  through  which   the
		       program is interrupted on either a change of state
		       (of the connection F.S.M) or receipt of an INS  or
		       INR message.  The INS/INR PSI channel is stored in
		       field MOS%NIN (B0-5) of AC3 and the  state  change
		       PSI  channel is stored in field MO%FSM (B12-17) of
		       AC3.  A value of 77 (octal)  in	either	of  these
		       fields prevents assignment of a PSI channel.

   ETHERNET Functions


  ETHERNET  MTOPR  functions  are  described  below.   For   a	 complete
  description of their application, refer to documentation in the monitor
  sources for the Ethernet. If updating is necessary, please do so.

    Code     Symbol    Meaning

    20       .MOPEF    Send Mark, or write end of file.  Takes Mark byte in
		       AC3.

    21       .MOPFC    Force transmission of partial pup.

    22       .MOPIS    Send interrupt.  AC3 contains the interrupt code and,
		       if non-zero, AC4 contains a string pointer to an
		       interrupt text.

    23       .MOPRM    Return most recent Mark byte in AC3.

    24       .MOPIN    Assign interrupt channels according to AC3.

		       B0-B5	  "Interrupt" PSI channel
		       B6-B11	  "Received pup" PSI channel
		       B12-B17	  "State change" PSI channel

    25       .MOPAB    Abort connection.  AC3 contains the Abort code and if
		       AC4 is non-zero it contains a pointer to the Abort text

    26       .MOPRA    Return Abort data.  Takes an optional string pointer in
		       AC4 to return the Abort text.  Returns Abort code in
		       AC3 and an appropriately updated string pointer in AC4.

    27       .MOPSM    Set hardware data mode of the connection from the
		       contents of AC3. This allows the programmer to specify
		       how the data (physically a stream of 8-bit frames) is
		       to be laid out in 36-bit words.  The default mode is
		       .PM32, 32 bits (4 8-bit frames) left justified in a
		       36-bit word.  It is advised that special care be taken 
		       to open the connection in a byte size compatible with
		       the hardware data mode.  The data modes are:

		       0   .PM16	16-bit bytes right justified in half
					words.  Suggested byte sizes: 18, 36.

		       1   .PM32	A 32-bit byte left justified in a full
					word.  This is the default mode.
					Byte sizes: 8,16,32.

		       2   .PM36	A full 36 bit word.

		       3   .PMASC	Five 7-bit bytes left justified in a
					full word.  On input, the high-order
					bits of the frames are discarded; on
					output, they are set to zero.  Byte
					size: 7.

		       4   .PM16S	16-bit bytes right justified in half
					words with the high and low order bytes
					swapped.  Byte size: 18, 36.

    30 	     .MOPRM    Read hardware data mode of connection into AC3.

   DECnet Functions
    

   DECnet-20  MTOPR  functions	are  described	below.	 For  a  complete
   description	of  their  application,  refer	to  the TOPS-20 DECnet-20
   Programmer's Guide and Operations Manual.

   Code      Symbol		      Meaning

    24	     .MOACN    Allow a network task to enable software	interrupt
		       channels for any combination of the following work
		       types:

			    o  connect event pending
			    o  interrupt message available
			    o  data available

		       This function  requires	that  AC3  contain  three
		       9-bit   fields	specifying  the  changes  in  the
		       interrupt assignments for this link.  These fields
		       are

		       Field	 Symbol    Used to Signal

		       B0-B8	 MO%CDN    Connect event pending
		       B9-B17	 MO%INA    Interrupt message available
		       B18-B26	 MO%DAV    Data available

		       The contents of the fields are
   (MTOPR)
   

		       Value	 Meaning

		       nnn	 The number of the channel to be enabled;
				 0-5 and 23-35 decimal
		       .MOCIA	 Clear the interrupt
		       .MONCI	 No change

    25	     .MORLS    Read the link status and return a 36-bit  word  of
		       information  regarding  the  status of the logical
		       link.  AC3 contains flag bits in the left half and
		       a  disconnect  code  in	the right half.  The flag
		       bits are

		       Symbol	 Bit	   Meaning

		       MO%CON	 B0	   Link is connected
		       MO%SRV	 B1	   Link is a server
		       MO%WFC	 B2	   Link is waiting for a connect
		       MO%WCC	 B3	   Link is waiting for a  connect
					   confirm
		       MO%EOM	 B4	   Link has an entire message  to
					   be read
		       MO%ABT	 B5	   Link has been aborted
		       MO%SYN	 B6	   Link has been closed normally
		       MO%INT	 B7	   Link has an interrupt  message
					   available
		       MO%LWC	 B8	   Link   has	been   previously
					   connected

		       The disconnect/reject codes are as follows:

		       Symbol	 Value	   Meaning

		       .DCX0	   0	   No special error
		       .DCX1	   1	   Resource allocation failure
		       .DCX2	   2	   Destination	node   does   not
					   exist
		       .DCX3	   3	   Node shutting down
		       .DCX4	   4	   Destination process	does  not
					   exist
		       .DCX5	   5	   Invalid name field
		       .DCX11	  11	   User    abort    (asynchronous
					   disconnect)
		       .DCX32	  32	   Too many connections to node
		       .DCX33	  33	   Too	 many	connections    to
					   destination process
		       .DCX34	  34	   Access not permitted
		       .DCX35	  35	   Logical link services mismatch
		       .DCX36	  36	   Invalid account
		       .DCX37	  37	   Segment size too small
		       .DCX38	  38	   Process aborted
		       .DCX39	  39	   No path to destination node
		       .DCX40	  40	   Link aborted due to data loss
		       .DCX41	  41	   Destination process	does  not
					   exist
   (MTOPR)
   

		       .DCX42	  42	   Confirmation   of   DISCONNECT
					   INITIATE
		       .DCX43	  43	   Image data field too long

		       If a disconnect code does not apply to the current
		       status  of the link, the right half of AC3 will be
		       zeros.

    26	     .MORHN    Return the ASCII name of  the  host  node  at  the
		       other  end  of  the  logical  link.  This function
		       requires that AC3 contain a string pointer to  the
		       location where the host name is to be stored.  (If
		       the  byte  size	exceeds  eight	bits,  bytes  are
		       truncated to eight bits.)

		       The monitor call returns with an  updated  pointer
		       in AC3, and the host name stored as specified.

    27	     .MORTN    Return the unique task  name  that  is  associated
		       with  your  end	of  the logical link.  If you had
		       defaulted  the  task  name  in  the  network  file
		       specification,	  the	  call	   returns    the
		       monitor-supplied task  name.   In  DECnet-20,  the
		       default task name is actually a unique number.

		       This function requires that AC3 contain	a  string
		       pointer	to the location where the task name is to
		       be stored.  (If the byte size exceeds eight  bits,
		       bytes are truncated to eight bits.)

		       The monitor call returns with an  updated  pointer
		       is AC3 and the task name stored as specified.

    30	     .MORUS    Return  the  source   task   user   identification
		       supplied  in  the  connect initiate message.  This
		       function  requires  that  AC3  contain  a   string
		       pointer	 to   the   location   where   the   user
		       identification is to be stored.	(If the byte size
		       exceeds	eight  bits, bytes are truncated to eight
		       bits.

		       The monitor call returns with an  updated  pointer
		       in  AC3	and  the  user	identification	stored as
		       specified.  If no user identification was supplied
		       by  the source task, AC3 continues to point to the
		       beginning of the string, and a null is returned as
		       the only character.

    31	     .MORPW    Return the source task's password as  supplied  in
		       the   connect  initiate	message.   This  function
		       requires that AC3 contain a string pointer to  the
		       location  where	the  password  is  to  be stored.
		       (Passwords  are	binary,  therefore   the   string
		       pointer should accomodate 8-bit bytes.)
   (MTOPR)
   

		       The monitor call returns with an  updated  pointer
		       in  AC3	and  the source task's password stored as
		       specified.  AC4 contains the number  of	bytes  in
		       the  string;   a  zero  value  indicates  that  no
		       password was supplied by the source task.

    32	     .MORAC    Return the account string supplied by  the  source
		       task   in  the  connect	initiate  message.   This
		       function  requires  that  AC3  contain  a   string
		       pointer	to  the location where the account string
		       is to be stored.  (If the byte size exceeds  eight
		       bits, bytes are truncated to eight bits.)

		       The monitor call return with an updated pointer in
		       AC3 and the source task's account number stored as
		       specified.  If no account string was  supplied  by
		       the  source  task,  AC3	continues to point to the
		       beginning of the string, and a null is returned as
		       the only character.

    33	     .MORDA    Return the optional data supplied in  any  of  the
		       connect	or  disconnect	messages.   This function
		       requires that AC3 contain a string pointer to  the
		       location  where	the  optional  user data is to be
		       stored.	(This file is binary;  the string pointer
		       should specify 8-bit bytes.)

		       The monitor call returns with an  updated  pointer
		       in  AC3 and the optional data stored as specified.
		       AC4 contains the  number  of  bytes  in	the  data
		       string;	 a  zero value indicates that no optional
		       data was supplied.

    34	     .MORCN    Return the object type that was used by the source
		       task  to  address  this	connection.   The  result
		       indicates whether the local task was addressed  by
		       its generic type or its unique network task name.

		       The monitor call returns with the object  type  is
		       AC3.  A zero object type indicates that the target
		       task was addressed  by  its  unique  network  task
		       name;   a  nonzero  value  indicates  that  it was
		       addressed by its generic object type.

    35	     .MORIM    Read interrupt message.	 This  function  requires
		       that  AC3  contain a byte pointer to the receiving
		       buffer.	(If the byte  size  exceeds  eight  bits,
		       bytes  are  truncated to eight bits.)  The maximum
		       message length is 16 bytes, and	the  buffer  size
		       should be at least 8 bits.

		       The monitor call returns with an  updated  pointer
		       in  AC3, the message stored in the buffer, and the
		       count of bytes received in AC4.
   (MTOPR)
   

    36	     .MOSIM    Send an interrupt message.  This function requires
		       that  AC3  contain  a  byte pointer to the message
		       (eight bytes maximum) and the AC4 contain a  count
		       of  the	bytes  in  the interrupt message (sixteen
		       bytes maximum).

    37	     .MOROD    Return the unique  identification  of  the  source
		       task.   This  identification  is  in the format of
		       object-descriptor, and the contents depend on  the
		       DECnet  implementation  on  the	remote	host.  In
		       addition, if the  source  task  is  running  on	a
		       system  that  provides  for  group and user codes,
		       this information is also returned.  If the  source
		       task  name  is  on  a  DECnet-20  host,	the  data
		       returned is TASK-taskname.  This function requires
		       that  AC3 contain a string pointer to the location
		       where the object-descriptor of the source task  is
		       to  be  stored.	 (If  the byte size exceeds eight
		       bits, bytes are truncated to eight bits.)

		       The monitor call returns with an  updated  pointer
		       in   AC3   and  the  object-descriptor  stored  as
		       specified.  In addition, if the source host system
		       uses  group  and user codes (sometimes referred to
		       as project and programmer  number  or  p,pn),  AC4
		       contains  the  group code in the left half and the
		       user code in the right half.  If the  source  host
		       system  does  not provide for group or user codes,
		       AC4 contains zeros.

    40	     .MOCLZ    Reject	a   connection	 either   implicitly   or
		       explicitly.   If  the  target  task closes its JFN
		       (via the CLOSF monitor call) before accepting  the
		       connection  either  implicitly  or explicitly, the
		       local NSM assumes that the connection is  rejected
		       and  sends  a  connect  reject message back to the
		       source task.  The reason given is process  aborted
		       (reject code 38).  The target task must the reopen
		       its JFN in order  to  receive  subsequent  connect
		       initiate messages.

		       In order to explicitly reject a connect and at the
		       same  time return a specific reject reason and set
		       up 16 bytes of user data, the target task must use
		       the  .MOCLZ  function  of  the MTOPR monitor call.
		       The .MOLCZ function does not close the JFN.

		       This function requires that

			    AC2 contain a reject code in  the  left  half
			    and  .MOCLZ  in  the  right half.  The reject
			    code is a 2-byte, NSP-defined decimal  number
			    indicating	the  reason that a target task is
			    rejecting  a  connection.	 Refer	 to   the
			    description of code 25, .MORLS, for a list of
   (MTOPR)
   

			    disconnect/reject codes.

			    AC3 contain a string pointer to any  data  to
			    be returned.  (If the byte size exceeds eight
			    bits, bytes are truncated to eight bits.)

			    AC4 contain the count of bytes  in	the  data
			    string  (maximum=16).   A  zero  indicates no
			    data

    41	     .MOCC     Accept	a   connection	 either   implicitly   or
		       explicitly.   Under  certain conditions, the local
		       NSP assumes that the connection	is  accepted  and
		       sends a connect confirm message back to the source
		       task.  These implicit conditions are

			    The target task attempts  to  output  to  the
			    logical  link (issues a SOUT or SOUTR monitor
			    call to the network).

			    The target task submits a read request to the
			    logical  link  (issues  a SIN or SINR monitor
			    call to the network).

			    The target task is in input wait  state  (has
			    enabled   itself   for   a	"data  available"
			    software interrupt).

		       In order to explicitly accept a connect	and  also
		       return  a  limited amount of data, the target task
		       must use the .MOCC function of the  MTOPR  monitor
		       call.   This  function requires that AC3 contain a
		       string pointer to any data to  be  returned.   (If
		       byte  size exceeds eight bits, bytes are truncated
		       to eight bits.)	AC4 must  contain  the	count  of
		       bytes in the data string to a maximum of 16 bytes.
		       A zero indicates no data.

    42	     .MORSS    Returns the maximum segment size that can be  sent
		       over  this  link.  This value is the lesser of the
		       maximum segment sizes supported by the remote  NSP
		       task  and the remote network task.  The local task
		       can use this value to optimize the format of  data
		       being transmitted over the link.

		       The monitor call returns the maximum segment size,
		       in bytes, in AC3.

   FE Functions
    

   Code      Symbol		      Meaning

    3	     .MOEOF    Send an end of file to the program  using  the  FE
		       device  on  the	front end.  This function is used
		       for synchronization between a program  running  on
   (MTOPR)
   

		       the  TOPS-20  and  a  program running on the front
		       end.

    4	     .MODTE    Assign the specified device to the DTE  controller
		       on  the	front  end.  This function, which must be
		       performed before I/O is	allowed  to  the  device,
		       requires  AC3  to  contain  the	device type.  The
		       process must have  WHEEL  or  OPERATOR  capability
		       enabled.

   MTA/MT Functions
    

   The functions available for physical magnetic tape  drives  (MTA)  and
   logical  magnetic tape drives (MT) are described below.  Some of these
   functions  accept  arguments  in  AC3   (refer   to	 the   individual
   descriptions).

   Code      Symbol		       Meaning

    0	     .MOCLE    Clear any error flags from a previous MTOPR call.

    1	     .MOREW    Rewind the tape.  This function waits for activity
		       to  stop  before  winding the tape.  If sequential
		       data is being output, the last partial  buffer  is
		       written	before	the  tape  is  rewound.   Control
		       returns to  caller  when  rewinding  begins.   For
		       labeled	tapes,	this  function	causes	the first
		       volume in the set to be mounted and positioned  to
		       the  first  file  in the file set.  Since a volume
		       switch may be required, this function could  block
		       for a considerable amount of time.

		       Use function .MORVL to rewind the current volume.

    2	     .MOSDR    Set the direction of the  tape  motions	for  read
		       operations.  This function requires AC3 to contain
		       the desired direction.	If  AC3  =  0,	the  tape
		       motion  is  forwards;  if AC3 = 1, the tape motion
		       is backwards.

		       This function is not available for  labeled  tapes
		       and  will  return  an MTOX1 error if used for that
		       purpose.

    3	     .MOEOF    Write a tape mark.  This  function  requires  that
		       the  magnetic tape be opened for write access.  If
		       sequential data is being output, the last  partial
		       buffer is written before the tape mark.

		       For labeled  tapes,  issuing  this  function  will
		       terminate  the data portion of the file, write EOF
		       trailer labels and leave the  tape  positioned  to
		       accept  user  trailer  labels.	It is possible at
		       this point to write user trailer labels	or  close
		       the file.  A second .MOEOF function issued without
   (MTOPR)
   

		       positioning the tape backwards  will  "close"  the
		       file (subsequent writes will create a new file).

    4	     .MOSDM    Set  the  hardware  data  mode  to  be  used  when
		       transferring  data  to  and  from  the tape.  This
		       function requires AC3 to contain the desired  data
		       mode:

		       0    .SJDDM    default system data mode
		       1    .SJDMC    dump mode (36-bit bytes)
		       2    .SJDM6    SIXBIT byte mode for 7-track drives
		       3    .SJDMA    ANSI ASCII mode (7  bits	in  8-bit
				      bytes)
		       4    .SJDM8    industry compatible mode
		       5    .SJDMH    High-density mode for TU70 and TU72
				      tape  drives only (nine 8-bit bytes
				      in two words).

		       For labeled tapes, this function is  allowed  only
		       if  the	file is opened in dump mode (.GSDMP).  If
		       this is not the case, an MTOX1 error is returned.

    5	     .MOSRS    Set  the  size  of  the	records.   This  function
		       requires  AC3  to  contain  the	desired number of
		       bytes in the records.  This  function  is  allowed
		       only  if  no  I/O  has been done since the JFN was
		       opened.

		       For labeled tapes, this function is  allowed  only
		       if  the file has been opened in dump mode.  If the
		       file has not been opened in dump  mode,	an  MTOX1
		       error is returned.

		       The maximum size of the records (in bytes)  is  as
		       follows:

		       Hardware 	       Maximum
		       I/O Mode 	       Record Size (bytes)

		       system-default		 -
		       dump		       8192
		       SIXBIT		       49152
		       ANSI ASCII	       40960
		       industry compatible     32768
		       high density	       8192

		       The above values can be exceeded in the	execution
		       of  .MOSRS,  however  the first data transfer will
		       fail.

    6	     .MOFWR    Advance over one record in the direction away from
		       the  beginning of the tape.  If sequential data is
		       being read in the forward direction and not all of
		       the  record  has been read, this function advances
		       to the start of the next  record.   If  sequential
   (MTOPR)
   

		       data  is  being	read in the reverse direction and
		       not all of the record has been read, this function
		       positions the tape at the end of that record.

		       For labeled tapes,  forward  space  will  position
		       over  a	logical  record.   This implies that many
		       physical records may be skipped (if  S  format  is
		       used)   perhaps	 involving  one  or  more  volume
		       switches.

    7	     .MOBKR    Space backward over one record  in  the	direction
		       toward  the  beginning of the tape.  If sequential
		       data is being read in the  forward  direction  and
		       not all of the record has been read, this function
		       positions the tape  back  to  the  start  of  that
		       record.	 If  sequential data is being read in the
		       reverse direction and not all of  the  record  has
		       been read, this function positions the tape to the
		       end  of	the  record  physically  preceding   that
		       record.

		       For labeled tapes, backward spacing will  position
		       over  a	logical  record.   This implies that many
		       physical records may be skipped (if  S  format  is
		       used)   perhaps	 involving  one  or  more  volume
		       switches.

    10	     .MOEOT    Advance forward until two  sequential  tape  marks
		       are  seen  and  position tape after the first tape
		       mark.

		       For labeled tapes, this function will position the
		       volume  set beyond the end of the last file in the
		       set.  This is useful for adding a new file to  the
		       end  of	an  already  existing  volume  set.  This
		       function may take some time to complete as one  or
		       more volumes switches may be required.

    11	     .MORUL    Rewind and unload  the  tape.   This  function  is
		       identical  to the .MOREW function and also unloads
		       the tape if the hardware supports tape unloading.

		       For labeled tapes, an  unload  is  illegal  unless
		       accompanying  a DISMOUNT request.  For MT devices,
		       this will generate a DESX9 error.

    12	     .MORDN    Return  the  current  density   setting.    On	a
		       successful   return,   AC3  contains  the  current
		       density.

    13	     .MOERS    Erase three inches  of  tape  (i.e.,  erase  gap).
		       This  function  requires that the magnetic tape be
		       opened for write access.

		       This function is illegal for labeled tapes.
   (MTOPR)
   

    14	     .MORDM    Return the hardware data mode currently being used
		       in   transfers	to  and  from  the  tape.   On	a
		       successful return, AC3 contains the  current  data
		       mode.

    15	     .MORRS    Return the size of the records.	On  a  successful
		       return,	AC3  contains  the number of bytes in the
		       records.

    16	     .MOFWF    Advance to the  start  of  the  next  file.   This
		       function  advances  the tape in the direction away
		       from the beginning of the  tape	until  it  passes
		       over a tape mark.

		       For labeled tapes, forward  space  will	skip  one
		       logical	file.	This  implies  that many physical
		       files may be skipped,  involving  perhaps  one  or
		       more volume switches.

    17	     .MOBKF    Space backward over one file.  This function moves
		       the  tape in the direction toward the beginning of
		       the tape until it  passes  over	a  tape  mark  or
		       reaches	the  beginning	of  the  tape,	whichever
		       occurs first.

		       For labeled tapes, backspace file will back up one
		       logical	file.	This  implies  that many physical
		       files may be skipped,  involving  perhaps  one  or
		       more volume switches.

					      NOTE

			   For labeled ANSI  tape,  the  monitor  can
			   compute  the  number  of  volume  switches
			   required to get to the  first  section  of
			   the	file.	Thus,  if  this  function  is
			   issued for  an  ANSI  tape,	at  most  one
			   volume  switch  will be required.  This is
			   not true for EBCDIC tape.

		       Issuing this function when  the	tape  is  already
		       positioned  at  the first volume of the volume set
		       will not produce an error.   The  program  issuing
		       this  function must follow the .MOBKF with a GDSTS
		       call to	determine  if  the  BOT  was  encountered
		       during the backspacing operation.

    20	     .MOSPR    Set the parity.	This  function	requires  AC3  to
		       contain the desired parity:

		       0    .SJPRO    odd parity
   (MTOPR)
   

		       1    .SJPRE    even parity

    21	     .MORPR    Return  the  current  parity.   On  a   successful
		       return, AC3 contains the current parity.

    22	     .MONRB    Return number of bytes remaining  in  the  current
		       record.	 On a successful return, AC3 contains the
		       number of bytes remaining.  This function is  only
		       meaningful during sequential I/O.

    23	     .MOFOU    Force any partial records  to  be  written  during
		       sequential output.

    24	     .MOSDN    Set the density.  The  function	requires  AC3  to
		       contain the desired density.

		       0    .SJDDN    default system density
		       1    .SJDN2    200 BPI (8 rows/mm)
		       2    .SJDN5    556 BPI (22 rows/mm)
		       3    .SJDN8    800 BPI (31 rows/mm)
		       4    .SJD16    1600 BPI (63 rows/mm)
		       5    .SJD62    6250 BPI (246 rows/mm)

				      This  function   is   illegal   for
				      labeled tapes.

		   25	    .MOINF    Return information about the  tape.
				      This   function	requires  AC3  to
				      contain the address of the argument
				      block  in  which the information is
				      to be returned.  The format of  the
				      argument block is as follows:

				      Word	    Symbol Contents

			 0    .MOICT   Length of  argument  block  to  be
				       returned (not including this word)
			 1    .MOITP   MTA type code
			 2    .MOIID   MTA reel ID
			 3    .MOISN   Channel, controller, and  unit  in
				       the left half and serial number in
				       the right half.
			 4    .MOIRD   Number of reads done
			 5    .MOIWT   Number of writes done
			 6    .MOIRC   Record number  from  beginning  of
				       tape
			 7    .MOIFC   Number of files on tape
			 10   .MOISR   Number of soft read errors
			 11   .MOISW   Number of soft write errors
			 12   .MOIHR   Number of hard read errors
			 13   .MOIHW   Number of hard write errors
			 14   .MOIRF   Number of frames read
			 15   .MOIWF   Number of frames written

    26	     .MORDR    Return the  direction  that  the  tape  is  moving
   (MTOPR)
   

		       during  read  operations.  On a successful return,
		       AC3 = 0 if the direction of  the  tape  motion  is
		       forwards,  or AC3 = 1 if the direction of the tape
		       motion is backwards.

    27	     .MOSID    Set the reel identification of the  tape  mounted.
		       The process must have WHEEL or OPERATOR capability
		       enabled.  This function requires  AC3  to  contain
		       the desired 36-bit reel ID.

    30	     .MOIEL    Inhibit error logging for the tape.

    31	     .MONOP    Wait for all activity to stop.

   32	     .MOLOC    Specifies the first volume in a MOUNT request,  or
		       identifies  the "next" volume for a volume switch.
		       This   function	 requires   OPERATOR   or   WHEEL
		       capability.

		       AC3 contains a pointer to an argument block having
		       the following format:

		       Word   Symbol		    Contents

			 0    .MOCNT   count of words in the block
			 1    .MOMTN   MT unit number to  associate  with
				       this MTA
			 2    .MOLBT   label type (.LTxxx)
			 3    .MODNS   density
			 4    .MOAVL   address of volume labels
			 5    .MONVL   number of volume labels at .MOAVL
			 6    .MOCVN   volume number in the volume set
			 7    .MOVSN   SIXBIT file set identifier

   37	     .MOSTA    Return  current	magtape   status.    Returns   an
		       argument  block	having	the  following	form  and
		       contents:

	       Word    Symbol	 Contents

		0      .MOCNT	 Count of words in  the  block	including
				 this word
		1      .MODDN	 density flags

				 Bit	Symbol	  Meaning

				 B1	SJ%CP2	  200 BPI
				 B2	SJ%CP5	  556 BPI
				 B3	SJ%CP8	  800 BPI
				 B4	SJ%C16	  1600 BPI
				 B5	SJ%C62	  6250 BPI

		2      .MODDM	 data mode flags
   (MTOPR)
   

				 Bit	Symbol	  Meaning

				 B1	SJ%CMC	  core dump
				 B2	SJ%CM6	  SIXBIT
				 B3	SJ%CMA	  ANSI ASCII
				 B4	SJ%CM8	  industry compatible
				 B5	SJ%CMH	  high density mode

		3      .MOTRK	 recording track flags

				 Bit	Symbol	  Meaning

				 B1	SJ%7TR	  7-track drive
				 B2	SJ%9TR	  9-track drive

		4      .MOCST	 tape status flags

				 Bit	Symbol	  Meaning

				 B0	SJ%OFS	  off line
				 B1	SJ%MAI	  maintenance mode
						  enabled
				 B2	SJ%MRQ	  maintenance mode
						  requested
				 B3	SJ%BOT	  beginning of tape
				 B4	SJ%REW	  rewinding
				 B5	SJ%WLK	  write locked

		5      .MODVT	 device type

				 Code	Symbol	  Meaning

				 3	.MTT45	  TU45 (system default)
				 17	.MTT70	  TU70
				 20	.MTT71	  TU71
				 21	.MTT72	  TU72
				 13	.MTT77	  TU77
				 19	.MTT78	  TU78

   41	     .MOOFL    Enable interrupts for  online/offline  transition.
		       Allows  a  process to be interrupted if a magnetic
		       tape drive's state changes from online to  offline
		       or   vice-versa	 and   when  a	rewind	operation
		       completes.  This function must be  performed  once
		       for  each  drive  for  which  interrupts are to be
		       enabled.   If  multiple	drives	are  enabled  for
		       interrupts,  then  a  .MOSTA  function  should  be
		       performed (for each drive) before  interrupts  for
		       the  drives  are enabled.  Then, when an interrupt
		       occurs, .MOSTA can be performed for each drive and
		       the  current  status of that drive can be compared
		       against the previous  status.   Thus,  it  can  be
		       determined which drive (or drives) interrupted.

		       This   function	 requires   OPERATOR   or   WHEEL
   (MTOPR)
   

		       capability.

   42	     .MOPST    Declares the software interrupt channel to be used
		       by  the monitor to indicate that the UTL labels at
		       the end-of-volume or the UHL labels at  the  start
		       of the new volume are available.  If this MTOPR is
		       not  performed  before  an  EOV	 label	 set   is
		       encountered,  the  user	program will not be given
		       the opportunity to process the UTL or  UHL  labels
		       during the volume switch operation.

		       AC3 contains the PSI channel number to  set.   The
		       channel can be cleared by using -1 in AC3.

   43	     .MORVL    Rewind current labeled tape volume.

   44	     .MOVLS    Switch volumes for an unlabled multi-volume set.
		       If  an  unlabeled  tape	is   mounted   specifying
		       multiple  volumes  in  the volume set, the monitor
		       will not automatically perform a volume switch  at
		       the  end  of each volume.  The .MOVLS function may
		       be issued in such  a  case  to  perform	a  volume
		       switch.	 It  can  also	be used to force a volume
		       switch for a labeled tape.

		       AC3 contains the  address  of  an  argument  block
		       having the following format:

		       Word   Symbol		    Contents

			 0	       count of words in block	including
				       this word
			 1	       flags,,function code
			 2	       argument (if required)

				       Available functions are:

				       Word  Symbol   Function

					1    .VSMNV   mount	 absolute
						      volume	   number
						      (volume  number  in
						      word   2	 of   the
						      argument block)
					2    .VSFST   mount first  volume
						      in set
					3    .VSLST   mount  last  volume
						      in set
					4    .VSMRV   mount	 relative
						      volume	   number
						      (volume  number  in
						      word   2	 of   the
						      argument block)

						      For   .VSMRV,   the
   (MTOPR)
   

						      argument	in word 2
						      of   the	 argument
						      block is the volume
						      number relative  to
						      the current mounted
						      volume  to   mount.
						      For   example,   if
						      volume	 2     is
						      currently   mounted
						      and    .VSMRV    is
						      performed with 2 in
						      word   2	 of   the
						      argument	   block,
						      then volume 4  will
						      be	 mounted.
						      Specifying   1   in
						      word   2	 of   the
						      argument block will
						      mount    the   next
						      volume in the set.
					5    .VSFLS   force volume switch
						      for  labeled  tape.
						      This  function   is
						      only  for tapes for
						      which  .MOSDS   has
						      previously     been
						      set.

   45	     .MONTR    Set no translate.

		       Sets or clears the EBCDIC to ASCII translate flag.
		       If the flag is set and the tape file being read is
		       from an IBM EBCDIC volume, then all data delivered
		       to the user program will be in its original EBCDIC
		       form.  If the flag is not set,  and  the  file  is
		       from an IBM EBCDIC volume, then all data delivered
		       to the user program will be in ASCII.  In order to
		       perform	this translation, certain information may
		       be lost (as the EBCDIC character set contains  256
		       codes  while the ASCII character set contains only
		       128 codes).  Note that the setting  of  this  flag
		       has  no	effect	on  the data delivered by the MTU
		       JSYS.

		       If AC3 is zero then the translate flag is cleared.
		       If AC3 is non-zero, the translate flag is set.

   46	     .MORDL    Read user header  labels.   Labels  must  be  read
		       immediately  after  the file is opened (and before
		       the first input is requested) or  after	a  volume
		       switch  has occurred and the volume switch PSI has
		       been generated.	.MORDL may be used to read either
		       the  UHL or UTL labels.	User header labels may be
		       read only if  the  file	is  opened  for  read  or
		       append.	 The  labels  may  be  a  maximum  of  76
   (MTOPR)
   

		       characters long.

		       User trailer labels may be read at any  time.   If
		       the  program requests to read user trailer labels,
		       the tape will be positioned  to	the  EOF  trailer
		       section.

		       AC3 contains  a	byte  pointer  to  the	area  for
		       receiving the label.

		       On a successful	return,  AC2  contains	the  user
		       label   identifier.    This   will  be  the  ASCII
		       character following the UHL or the UTL.	AC3  will
		       contain an updated byte pointer.

   47	     .MOWUL    Write user header labels or user  trailer  labels.
		       User  header  labels may be written only after the
		       file is opened (and  before  the  first	write  is
		       performed)  or when a PSI is generated, indicating
		       that a volume switch has  occurred.   User  header
		       labels  may  be written only if the file is opened
		       for write access.

		       User trailer labels may be read or written at  any
		       time.   If  the	program  requests  to  write user
		       trailer labels, the file will be  terminated  with
		       an  EOF trailer section.  Once user trailer labels
		       are written in this manner, no more  data  may  be
		       read or written.

		       User trailer labels may also be written	during	a
		       volume  switch  sequence.  Once the PSI indicating
		       EOV has been received, the user program may  write
		       a  UTL  label  into the EOV trailer section.  This
		       operation must be performed at interrupt level.

		       AC3 contains a byte pointer to the label contents.
		       This  string  must  contain  76 bytes of data (the
		       monitor will use only the first	76  bytes).   AC4
		       contains   a  label  identifier	code  (any  ASCII
		       character).

		       It is possible to encounter EOT while writing  the
		       first  UTL in the EOF trailer set.  This can occur
		       if the last data write overwrote the EOT mark.  In
		       this  instance,	the user program will receive the
		       EOV PSI from  within  the  code	writing  the  UTL
		       labels  for  the  file.	 It  is  not  possible to
		       receive an  EOV	PSI  while  writing  the  trailer
		       labels in the EOV set.

   50	     .MORLI    Reads  the  available  fields  from  the  standard
		       volume  and  header  labels.   The  ANSI  standard
		       distinguishes protected from  unprotected  fields;
		       .MORLI only returns the unprotected fields.
   (MTOPR)
   

		       AC3 contains a pointer to an argument block of the
		       form:

		       Word			 Contents

			0	count of words in block
			1	word to store label type of this tape

				Value	Symbol	 Label Type

				  1	.LTUNL	 Unlabeled
				  2	.LTANS	 ANSI
				  3	.LTEBC	 EBCDIC
				  4	.LTT20	 TOPS-20

			2	byte pointer to area for  storing  volume
				name string
			3	byte pointer to area  for  storing  owner
				name string
			4	word  to   store   tape   format   (ASCII
				character)
			5	word to store record length
			6	word to store block length
			7	word to store creation date (in  internal
				format)
			10	word  to  store   expiration   date   (in
				internal format)
			11	byte pointer to  area  for  storing  file
				name string
			12	word to store generation number
			13	word to store version number
			14	word to store  mode  value  (form-control
				value).    The	 possible  modes  are  as
				follows:

				Mode
				Value	  Meaning

				space	  no line format characters are
					  present
				  A	  FORTRAN format control
					  characters are present
				  M	  All necessary line format
					  characters are present
				  X	  Data in stream mode

		       The user specifies only the block  count  and  the
		       byte  pointers;	the remaining values are returned
		       by the monitor.	If a zero is substituted for  any
		       of  the	byte pointers, then the associated string
		       is not returned.

		       This function is normally issued when the  JFN  is
		       open.   If issued when the JFN is closed, only the
		       first 3 words of the argument block are	returned.
   (MTOPR)
   

		       If  the	tape is unlabeled, only the first word of
		       the argument block is returned.

   51	     .MOSMV    Declares the value to be placed in the DEC-defined
		       "form-control"  field  in  the  HDR2  label.  This
		       field is not defined  in  the  ANSI  standard  but
		       should  be  specified  whenever	the  data file is
		       meant to be read with DEC-supplied software.  This
		       function merely declares the value to be placed in
		       the   label.    It   is	 the	user	program's
		       responsibility  to produce records that conform to
		       the declared mode.

		       AC3 contains one of the following modes:

		       Value	 Symbol    Mode

			 0	 .TPFST    X - (stream mode)
			 1	 .TPFCP    M - (all formatting control
					   present)
			 2	 .TPFFC    A - (FORTRAN control present)
			 3	 .TPFNC    space - (no controls present)

   52	     .MOSDS    Set deferred volume switch.  Inhibits the  monitor
		       from doing an automatic volume switch and allows a
		       program	to  write  its	own  trailer  information
		       beyond	the   physical	end-of-tape  mark.   This
		       function is intended for labeled MT  devices  open
		       for writing in DUMP mode.

   PLPT Functions
    

   The	functions  available  for  physical  line  printers  (PLPT)   are
   described  below.   Some  of  these functions accept the address of an
   argument block in AC3.  The first word of the argument block  contains
   the length (including this word) of the block.  Remaining words of the
   block contain arguments for the particular function.

   Code      Symbol			   Meaning

    27	     .MOPSI    Enable for a software interrupt on nonfatal device
		       conditions.  Examples of these conditions are:

		       1.  Device changed from offline to online.

		       2.  Device changed from online to offline.

		       3.  Device's page counter has overflowed.

		       Other device errors or software conditions are not
		       handled	by  this  function;  instead they cause a
		       software interrupt on channel 11 (.ICDAE).

		       Argument Block
   (MTOPR)
   

		       E:    3
		       E+1:  interrupt channel number
		       E+2:  flags.  The following flag is defined:

			     B0(MO%MSG)   Suppress  standard  CTY  device
					  messages.

    31	     .MONOP    Wait for all  activity  to  stop.   This  function
		       blocks  the  process  until  all data has actually
		       been sent to the printer  and  has  been  printed.
		       Because this function is transferring data, it can
		       return an IOX5 data error.

    32	     .MOLVF    Load the line printer's VFU  (Vertical  Formatting
		       Unit)  from  the  file  indicated  in the argument
		       block.

		       Argument Block

		       E:    2
		       E+1:  JFN of the file containing the VFU

		       The system opens the file for input  with  a  byte
		       size  of 18 bits.  It closes the file and releases
		       the JFN when the loading of the VFU is complete.

    33	     .MORVF    Read the name of the current VFU  file  stored  in
		       the monitor's data base.

		       Argument Block

		       E:    3
		       E+1:  pointer to destination area for  ASCIZ  name
			     string
		       E+2:  number of bytes in destination area

    34	     .MOLTR    Load the line printer's	translation  RAM  (Random
		       Access  Memory)	from  the  file  indicated in the
		       argument block.

		       Argument Block

		       E:    2
		       E+1:  JFN of the file containing  the  translation
			     RAM

		       The system opens the file for input  with  a  byte
		       size  of 18 bits.  It closes the file and releases
		       the JFN when the loading of the translation RAM is
		       complete.

    35	     .MORTR    Read the name of the current translation RAM  file
		       stored in the monitor's data base.

		       Argument Block
   (MTOPR)
   

		       E:    3
		       E+1:  pointer to destination area for  ASCIZ  name
			     string
		       E+2:  number of bytes in destination area
    36	     .MOSTS    Set the status of the line printer.

		       Argument Block

		       E:    3
		       E+1:  software status  word,  with  the	following
			     status bits settable by the caller:

			     B0(MO%LCP)   Set line  printer  as  a  lower
					  case printer.

			     B12(MO%EOF)  Set bit MO%EOF in  the  printer
					  status  word when all data sent
					  to printer  has  actually  been
					  printed.   The  status word can
					  be  obtained	with  the  .MORST
					  function.

			     B14(MO%SER)  Clear   the	software    error
					  condition  on the line printer.
					  This condition  usually  occurs
					  on a character interrupt.

			     Other status  bits  can  be  read	with  the
			     .MORST  function  (see  below) but cannot be
			     set by the caller.

		       E+2:  value for page counter register.  The caller
			     can  indicate  the  number  of  pages  to be
			     printed by specifying a value of  up  to  12
			     bits  (4096).  Each time the printer reaches
			     the top of a new  page,  it  decrements  the
			     value  by one.  When the value becomes zero,
			     the  printer  sets  status  bit  MO%LPC  and
			     generates	 an   interrupt   if  the  .MOPSI
			     function was given previously.

			     If the caller specifies a value of 0 in  the
			     register,	the system will maintain the page
			     counter and will not generate  an	interrupt
			     to  the caller when the page counter becomes
			     zero.

			     If the caller specifies a value of -1 in the
			     register, the value will be ignored.

	37   .MORST    Read the status of the line printer.   The  status
		       is  obtained from the front end, and the caller is
		       blocked until it receives the status.

		       Argument Block
   (MTOPR)
   

		       E:    3
		       E+1:  status  word.   The   following   bits   are
			     defined:

			     B0(MO%LCP)   Line printer is  a  lower  case
					  printer.   This bit is set only
					  if a .MOSTS function	declaring
					  the	printer  lower	case  was
					  executed previously.

			     B1(MO%RLD)   Front end  has  been	reloaded.
					  This	bit  is reset to zero the
					  next	time  any  I/O	 activity
					  begins for the line printer.

			     B10(MO%FER)  A    fatal	hardware    error
					  occurred.	This	condition
					  generates a software	interrupt
					  on channel 11 (.ICDAE).

			     B12(MO%EOF)  All data sent  to  printer  has
					  actually been printed.

			     B13(MO%IOP)  Output to the line  printer  is
					  in progress.

			     B14(MO%SER)  A   software	  error    (e.g.,
					  interrupt    character,    page
					  counter overflow) occurred.

			     B15(MO%HE)   A  hardware	error	occurred.
					  This error generates a software
					  interrupt   on    channel    11
					  (.ICDAE).	This	condition
					  usually requires that the forms
					  be realigned.

			     B16(MO%OL)   Line printer is offline.   This
					  bit is set on the occurrence of
					  any  hardware  condition   that
					  requires operator intervention.

			     B17(MO%FNX)  Line printer does not exist.

			     B30(MO%RPE)  A RAM parity error occurred.

			     B31(MO%LVU)  The line printer has an optical
					  (12-channel tape reader) VFU.

			     B33(MO%LVF)  A  VFU  error  occurred.    The
					  paper has to be realigned.

			     B34(MO%LCI)  A character interrupt occurred.
					  This	 generates   a	 software
					  interrupt   on    channel    11
   (MTOPR)
   

					  (.ICDAE).

			     B35(MO%LPC)  The page counter  register  has
					  overflowed.

			     Bits 2-17 contain the software  status  word
			     from  the	front end, and bits 20-35 contain
			     the hardware status word.

		       E+2:  value of page counter register.  A value  of
			     -1 indicates the printer has no page counter
			     value defined.

    40	     .MOFLO    Flush any line printer output  that  has  not  yet
		       been printed.

  PCDP Functions
   

  The functions available for physical card punches (PCDP) are described
  below.   Like the LPT functions, these functions accept the address of
  an argument block in AC3.  The first word of the  block  contains  the
  length  (including  this  word)  of the block.  Remaining words in the
  block contain arguments for the particular function.

  Code      Symbol		 Meaning

   27	     .MOPSI    Enable for a software interrupt on nonfatal device
		       conditions.  Examples of these conditions are:

		       1.  Device changed from offline to online.

		       2.  Device changed from online to offline.

		       Other device errors or software conditions are not
		       handled	by  this  function;  instead they cause a
		       software interrupt on channel 11 (.ICDAE).

		       Argument Block

		       E:    3
		       E+1:  interrupt channel number
		       E+2:  flags.  The following flag is defined:

			     B0(MO%MSG)   Suppress  standard  CTY  device
					  messages.

   37	     .MORST    Read the status of the card punch.  The status  is
		       obtained  from  the  front  end, and the caller is
		       blocked until it receives the status.

		       Argument Block

		       E:    2
		       E+1:  status word.  Bits 2-17 contain the software
			     status  word  from  the  front end, and bits
   (MTOPR)
   

			     20-35 contain the hardware status word.

			     B10(MO%FER)  Fatal error condition
			     B12(MO%EOF)  All  pending	output	has  been
					  processed
			     B13(MO%IOP)  Output in progress
			     B14(MO%SER)  Software  error  has	 occurred
					  (would generate an interrupt on
					  an assigned channel)
			     B15(MO%HE)   Hardware  error  has	 occurred
					  (would  generate  interrupt  on
					  channel .ICDAE)
			     B16(MO%OL)   Card punch  is  offline.   This
					  bit	is   set   when  operator
					  intervention is required  (card
					  jam,	hopper	empty, or stacker
					  full).
			     B17(MO%FNX)  Card punch doesn't exist
			     B32(MO%HEM)  Hopper is empty or  stacker  is
					  full
			     B33(MO%SCK)  Hopper is empty or  stacker  is
					  full (same as above)
			     B34(MO%PCK)  Pick check

   PCDR Functions
    

   The functions available for physical card readers (PCDR) are described
   below.   These  functions  accept  the address of an argument block in
   AC3.  The first word of the block contains the length (including  this
   word)  of  the  block.  Remaining words in the block contain arguments
   for the particular function.

   Code      Symbol		 Meaning

    27	     .MOPSI    Enable for a software interrupt on nonfatal device
		       conditions.  Examples of these conditions are:

		       1.  Device changed from offline to online.

		       2.  Device changed from online to offline.

		       Other device errors or software conditions are not
		       handled	by  this  function;  instead they cause a
		       software interrupt on channel 11 (.ICDAE).

		       Argument Block

		       E:    3
		       E+1:  interrupt channel number
		       E+2:  flags.  The following flag is defined:

			     B0(MO%MSG)   Suppress  standard  CTY  device
					  messages.

    37	     .MORST    Read the status of the card reader.  The status is
   (MTOPR)
   

		       obtained  from  the  front  end, and the caller is
		       blocked until it receives the status.

		       Argument Block

		       E:    2
		       E+1:  status word.  Bits 2-17 contain the software
			     status  word  from  the  front end, and bits
			     20-35 contain the hardware status word.

			     B0(MO%COL)   Card reader is on  line.   This
					  bit  is  not	obtained from the
					  front end.

			     B1(MO%RLD)   Front end  has  been	reloaded.
					  This	bit  is reset to zero the
					  next time I/O  activity  begins
					  for the card reader.

			     B10(MO%FER)  A    fatal	hardware    error
					  occurred.	This	condition
					  generates a software	interrupt
					  on channel 11 (.ICDAE).

			     B12(MO%EOF)  Card reader is at end of file.

			     B13(MO%IOP)  Input from the card  reader  is
					  in progress.

			     B14(MO%SER)  A   software	  error    (e.g.,
					  interrupt character) occurred.

			     B15(MO%HE)   A  hardware	error	occurred.
					  This error generates a software
					  interrupt   on    channel    11
					  (.ICDAE).

			     B16(MO%OL)   Card reader is off line.   This
					  bit is set on the occurrence of
					  any  hardware  condition   that
					  requires operator intervention.

			     B17(MO%FNX)  Card reader does not exist.

			     B31(MO%SFL)  The output stacker is full.

			     B32(MO%HEM)  The input hopper is empty.

			     B33(MO%SCK)  A card did not stack	correctly
					  in the output stacker.

			     B34(MO%PCK)  The card reader failed to  pick
					  a card correctly from the input
					  hopper.
   (MTOPR)
   

			     B35(MO%RCK)  The card reader detected a read
					  error when reading a card.

   PTY Functions
    

		       The functions available for pseudo-terminals (PTY)
		       are  described  below.	Some  of  these functions
		       accept arguments in AC3.  (Refer to the individual
		       descriptions.)

		       Code	 Symbol Meaning

    24	     .MOAPI    Assign  PTY  interrupt  channels.   This  function
		       requires AC2 to contain
		       B0(MO%WFI)      enable waiting-for-input interrupt
		       B1(MO%OIR)      enable output-is-ready interrupt
		       B12-B17(MO%SIC) software interrupt channel  number
				       for   output   to  the  PTY.   The
				       channel number used for input from
				       the  PTY  is  one greater than the
				       channel number used for output  to
				       the PTY.
		       B18-B35	       function code

    25	     .MOPIH    Determine if PTY job needs input.  On a successful
		       return,	AC2  contains 0(.MONWI) if PTY job is not
		       waiting for input or contains  -1(.MOWFI)  if  PTY
		       job is waiting for input.

    26	     .MOBAT    Set batch control bit.  This function requires AC3
		       to  contain  0(.MONCB)  if  the	job  is not to be
		       controlled by batch or to contain 1(.MOJCB) if the
		       job  is to be controlled by batch.  To obtain this
		       value, the process can  execute	the  GETJI  JSYS,
		       function .JIBAT.

   TTY Functions
    

    25	     .MOPIH    Determine if TTY job needs input.  On a successful
		       return,	AC2  contains 0(.MONWI) if TTY job is not
		       waiting for input or contains  -1(.MOWFI)  if  TTY
		       job is waiting for input.

    26	     .MOSPD    Set  the  terminal  line  speed.   This	 function
		       accepts in AC3 the desired line speed (input speed
		       in the left half and output  speed  in  the  right
		       half).	The  left  half of AC2 contains flag bits
		       indicating  the	type  of  line	being  set.    If
		       B0(MO%RMT)  is  on, the line is a remote (dataset)
		       line.  If B1(MO%AUT) is on, the line is	a  remote
		       autobaud  line  (i.e., is automatically set at 300
		       baud, and the contents of AC3  are  ignored.   The
		       process	must  have  WHEEL  or OPERATOR capability
   (MTOPR)
   

		       enabled to set B0(MO%RMT) and B1(MO%AUT).

    27	     .MORSP    Return the terminal line speed.	On  a  successful
		       return,	the  left  half of AC2 contains flag bits
		       indicating the type of line, and AC3 contains  the
		       speed  (input  speed  in  the left half and output
		       speed in the right half).  If B0(MO%RMT) of AC2 is
		       on,  the  line is a remote line, and if B1(MO%AUT)
		       is on, the line is a remote  autobaud  line.   AC3
		       contains  the speed or contains -1 if the speed is
		       unknown or is not applicable.

    30	     .MORLW    Return the terminal page width.	On  a  successful
		       return, AC3 contains the width.

    31	     .MOSLW    Set  the  terminal  page  width.   This	 function
		       requires AC3 to contain the desired width.

    32	     .MORLL    Return the terminal page length.  On a  successful
		       return, AC3 contains the length.

    33	     .MOSLL    Set  the  terminal  page  length.   This  function
		       requires AC3 to contain the desired length.

    34	     .MOSNT    Specify if  terminal  line  given  in  AC1  is  to
		       receive	system	messages.  This function requires
		       AC3 to contain 0 (.MOSMY) to allow messages  or	1
		       (.MOSMN) to suppress messages.

    35	     .MORNT    Return a code indicating if terminal line given in
		       AC1   is   to   receive	system	messages.   On	a
		       successful return,  AC3	contains  0  (.MOSMY)  if
		       messages are being sent to this line or 1 (.MOSMN)
		       if messages are being suppressed to this line.

    36	     .MOSIG    Specify if input on this terminal line  is  to  be
		       ignored	when  the  line is inactive (i.e., is not
		       assigned or opened).  This function  requires  AC3
		       to contain 0 if characters on this line are not to
		       be ignored or 1 if characters on this line are  to
		       be  ignored.   When  input  is  being  ignored and
		       characters are typed, no CTRL/G (bell) is sent, as
		       is the normal case when characters are typed on an
		       inactive line.

   37	     .MORBM    Read the 128-character break mask.   The  argument
		       block is the same as for .MOSBM (below).

   40	     .MOSBM    Sets the 128-character break mask.  Argument Block

		       E:    0,,4
		       E+1-E+4: character mask.  The leftmost 32 bits  of
				each  consecutive  word correspond to the
				ASCII character set in	ascending  order.
				For  example,  1B0  in	word  E+1 (of the
   (MTOPR)
   

				argument block) corresponds to ASCII code
				000  (null),  1B1 in word E+1 corresponds
				to ASCII code 001 (SOH), etc.  Bits 32-35
				must be zero.

   41	     .MORFW    Returns the current value of the  field	width  in
		       AC3.   Note  that  this may be less than the value
		       last set by .MOSFW.  If the field width is set  to
		       value  X  and  two  characters are read before the
		       .MORFW is executed, the	value  returned  will  be
		       X-2.   A  zero  returned  in AC3 indicates that no
		       field width is now in effect.

   42	     .MOSFW    Set the field width to the value in AC3.   A  zero
		       indicates that no field width is in effect.

   45	     .MOSLC    Set the terminal's line counter to value  in  AC3.
		       This   counter	is  incremented  by  the  monitor
		       everytime a linefeed is output  to  the	terminal.
		       The  monitor  clears this counter only when a line
		       becomes active.

   46	     .MORLC    Read the terminal's line counter and  return  with
		       its value in AC3.

   47	     .MOSLM    Set line  maximum  to  the  value  in  AC3.   This
		       function  sets  the  maximum  value  of	the  line
		       counter seen so far.   The  monitor  compares  the
		       line   counter  with  the  maximum  every  time	a
		       linefeed is typed, and if  the  the  line  counter
		       value is larger, the monitor sets the line maximum
		       to the value of	the  line  counter.   When  TEXTI
		       moves  the  cursor  up  on  screen  terminals,  it
		       decrements the line counter.

   50	     .MORLM    Read the current value of  the  line  maximum  and
		       return with its value in AC3.

   51	     .MOTPS    Assign  interrupt  channels  for   non-controlling
		       terminal.   The	channels  are specified in AC3 as
		       follows:  input PSI channel,, output PSI  channel.
		       An  interrupt  will be generated if a character is
		       input, or an output-buffer-empty condition  occurs
		       on output.  The channels can be cleared by setting
		       the appropriate half (or halves) of AC3 to -1.

   Generates an illegal instruction interrupt on error conditions below.

   MTOPR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned
   (MTOPR)
   

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   DESX9:    invalid operation for this device

   IOX4:     end of labels encountered

   IOX5:     device or data error

   MTOX1:    invalid function

   MTOX2:    record size was not set before I/O was done

   MTOX3:    function not legal in dump mode

   MTOX4:    invalid record size

   MTOX5:    invalid hardware data mode for magnetic tape

   MTOX6:    invalid magnetic tape density

   MTOX7:    WHEEL or OPERATOR capability required

   MTOX8:    argument block too long

   MTOX9:    output still pending

   MTOX10:   VFU or RAM file cannot be OPENed

   MTOX11:   data too large for buffers

   MTOX12:   input error or not all data read

   MTOX13:   argument block too small

   MTOX14:   invalid software interrupt channel number

   MTOX15:   device does not have Direct Access (programmable) VFU

   MTOX16:   VFU or Translation RAM file must be on disk

   MTOX17:   device is not on line

   MTOX18:   invalid software interrupt channel number

   MTOX19:   invalid terminal line width

   MTOX20:   invalid terminal line length

   TTYX01:   line is not active
   (MTU%)
   


Node: MTU%	Previous: MTOPR	Next: MUTIL	Up: Top
			     MTU%     JSYS 600

  Allows privileged programs to perform various  utility  functions  for
  mag	tape  MTnn:   devices.	 This JSYS differs from the MTOPR JSYS in
  that the invoking program need not have a JFN on the MT  nor  need  it
  even  have access to the MT.  It is used by MOUNTR to declare a volume
  switch error and by the access-control program (user supplied) to read
  file and volume labels.

  RESTRICTIONS:    Requires enabled WHEEL or OPERATOR capabilities

  ACCEPTS IN AC1:  function code

	      AC2:  MT unit number

	      AC3:  address of argument block

  RETURNS     +1:  always

  The functions and associated argument blocks are as follows:

  Code      Symbol		       Function

   0	     .MTNNV    Declare volume switch error

		       Argument Block:

		       Word   Symbol		    Contents

			 0    .MTCNT   count of words in block
			 1    .MTCOD   error code to return to user
			 2    .MTPTR   byte pointer to operator response

   1	     .MTRAL    Read labels.

		       Argument Block:

		       Word   Symbol		    Contents

			 0    .MTCNT   count of words in block
			 1    .MTVL1   byte pointer to area to hold  VOL1
				       label
			 2    .MTVL2   byte pointer to area to hold  VOL2
				       label
			 3    .MTHD1   byte pointer to area to hold  HDR1
				       label
			 4    .MTHD2   byte pointer to area to hold  HDR2
				       label

		       If  any	of  the  byte  pointers  is   zero,   the
		       associated string is not returned.

   2	     .MTASI    return assignment information
   (MTU%)
   

		       Argument Block:

		       Word   Symbol		    Contents

			 0    .MTCNT   count of words in block
			 1    .MTPHU   returned  MTA  number   associated
				       with  the  MT.	If  there  is  no
				       association, .MTNUL is returned.

		       This function is used by MOUNTR	to  determine  if
		       there  are  any	existing  MT to MTA associations.
		       This is necessary when MOUNTR is restarted.


Node: MUTIL	Previous: MTU%	Next: NIN	Up: Top
			     MUTIL     JSYS 512

   Performs   various	IPCF   (Inter-Process	Communication	Facility)
   functions,  such  as  enabling and disabling PIDs, assigning PIDs, and
   setting quotas.  Refer to the TOPS-20 Monitor Calls User's  Guide  for
   an	overview  and  description  of	the  Inter-Process  Communication
   Facility.

   RESTRICTIONS:    some  functions  require  WHEEL,  OPERATOR,  or  IPCF
		    capability enabled

   ACCEPTS IN AC1:  length of argument block

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success.  Responses from the requested  function  are
		    returned in the argument block.

   The format of the argument block is as follows:

	Word			      Meaning

	  0	       Code of desired function.  (See below.)
	1 through n    Arguments   for	 the   desired	 function.    The
		       arguments, which depend on the function requested,
		       begin in word 1 and are given in the  order  shown
		       below.	Responses from the requested function are
		       returned in these words.

   The available functions, along with	their  arguments,  are	described
   below.

   Code      Symbol		      Meaning

    1	     .MUENB    Enable the specified PID to receive packets.   The
   (MUTIL)
   

		       PID  must  have	been created by the caller's job.
		       Also, if the calling process was not  the  creator
		       of  the	PID,  the  no-access bit (IP%NOA) must be
		       off.

		       Argument

			  PID

    2	     .MUDIS    Disable the specified PID from receiving  packets.
		       The  PID  must  have  been created by the caller's
		       job.  Also, if the calling  process  was  not  the
		       creator	of  the  PID,  the no-access bit (IP%NOA)
		       must be off.

		       Argument

			  PID
     3	     .MUGTI    Return the PID associated with <SYSTEM>INFO.   The
		       PID is returned in word 2 of the argument block.

		       Argument

			  PID or job number

     4	     .MUCPI    Create a private  copy  of  <SYSTEM>INFO  for  the
		       specified   job.   The  caller  must  have  WHEEL,
		       OPERATOR, or IPCF capability enabled.

		       Arguments

			  PID to be assigned to <SYSTEM>INFO
			  PID or number of job creating private copy

     5	     .MUDES    Delete the specified PID.  The caller must own the
		       PID being deleted.

		       Argument

			  PID

     6	     .MUCRE    Creates a PID for the specified	process  or  job.
		       The  flags that can be specified are B6(IP%JWP) to
		       make the PID job wide and  B7(IP%NOA)  to  prevent
		       access  to  PID	from other processes.  The caller
		       must have  IPCF	capability  enabled  if  the  job
		       number  given  is not that of the caller.  The PID
		       created is returned in  word  2	of  the  argument
		       block.	If a job number is specified, the created
		       PID will belong to the top fork of the job.

		       Argument

			  flags,,process handle or job number
   (MUTIL)
   

     7	     .MUSSQ    Set send and receive quotas for the specified PID.
		       The caller must have IPCF capability enabled.  The
		       new send quota is given in B18-B26,  and  the  new
		       receive	quota  is  given in B27-B35.  The receive
		       quota applies to the specified PID, but	the  send
		       quota  applies  to  the	job  to  which	that  PID
		       belongs.

		       Arguments

			  PID
			  new quotas

     10      .MUCHO    Change  the  job  number   associated   with   the
		       specified  PID.	 The  caller  must  have WHEEL or
		       OPERATOR capability enabled.

		       Arguments

			  PID
			  new job number or PID belonging to new job

     11      .MUFOJ    Return  the  job  number   associated   with   the
		       specified PID.  The job number is returned in word
		       2 of the argument block.

		       Argument

			  PID

     12      .MUFJP    Return all PIDs associated with the specified job.
		       Two  words are returned, starting in word 2 of the
		       argument block, for each PID.  The first  word  is
		       the  PID.   The	second word has B6(IP%JWP) set if
		       the PID is job wide and B7(IP%NOA) set if the  PID
		       is not accessible by other processes.  The list is
		       terminated by a 0 PID.

		       Argument

			  job number or PID belonging to that job

     13      .MUFSQ    Return  the  send  and  receive	quotas	for   the
		       specified  PID.	The quotas are returned in word 2
		       of the argument	block  with  the  send	quota  in
		       B18-B26	and  the  receive  quota in B27-B35.  The
		       receive quota applies to the  specified	PID,  but
		       the  send  quota  applies to the job to which that
		       PID belongs.

		       Argument

			  PID

     15      .MUFFP    Return all PIDs associated with the  same  process
   (MUTIL)
   

		       as  that  of  the specified PID.  The list of PIDs
		       returned  is  in  the  same  format  as	the  list
		       returned for the .MUFJP function (12).

		       Argument

			  PID

     16      .MUSPQ    Set the maximum number of  PIDs	allowed  for  the
		       specified   job.    The	 caller  must  have  IPCF
		       capability enabled.

		       Arguments

			  job number or PID
			  PID quota

     17      .MUFPQ    Return the maximum number of PIDs allowed for  the
		       specified  job.	The PID quota is returned in word
		       2 of the argument block.

		       Argument

			  job number or PID

     20      .MUQRY    Return the Packet Descriptor Block  for	the  next
		       packet  in the queue associated with the specified
		       PID.   An  argument  of	-1   returns   the   next
		       descriptor  block for the process, and an argument
		       of -2 returns the next descriptor  block  for  the
		       job.  The descriptor block is returned starting in
		       word 1 of the argument block.  The calling process
		       and  the  process that owns the specified PID must
		       belong to the same job.

		       Argument

			  PID

    21      .MUAPF    Associate the PID with the specified process.  The
		       calling	process  and  the  process  that owns the
		       specified PID must belong to the same job.

		       Arguments

			  PID
			  process handle

    22      .MUPIC    Place the specified PID on  a  software	interrupt
		       channel.  An interrupt is then generated when:

		       1.   The .MUPIC function is issued while  the  PID
			   has one or more messages in its receive queue.
   (MUTIL)
   

		       2.  The PID's receive  queue  message  count  goes
			   from 0 to 1.

		       If the channel number is given as -1, the  PID  is
		       removed from its current channel.

		       The calling process and the process that owns  the
		       specified PID must belong to the same job.

		       Arguments

			  PID
			  channel number

     23      .MUDFI    Set the PID of <SYSTEM>INFO.  An error is given if
		       <SYSTEM>INFO  already  has a PID.  The caller must
		       have IPCF capability enabled.

		       Argument

			  PID of <SYSTEM>INFO

     24      .MUSSP    Place the specified PID into the system PID  table
		       at  the given offset.  The caller must have WHEEL,
		       OPERATOR, or IPCF capability enabled.  See  .MURSP
		       for a list of system PIDs.

		       Arguments

			  index into system PID table
			  PID

     25      .MURSP    Return a PID from the system PID table.	 The  PID
		       is  returned in word 2 of the argument block.  The
		       system  PID  table  currently  has  the	following
		       entries:

			  0  .SPIPC   Reserved for DEC
			  1  .SPINF   PID of <SYSTEM>INFO
			  2  .SPQSR   PID of QUASAR
			  3  .SPMDA   PID of QSRMDA
			  4  .SPOPR   PID of ORION

		       Argument

			  index into system PID table

    26      .MUMPS    Return the system-wide maximum packet  size.   The
		       size is returned in word 1 of the argument block.

     27      .MUSKP    Set PID to receive deleted PID messages.  Allows a
		       controller  task  to  be  notified  if  one of its
		       subordinate tasks crashes.  After this function is
		       performed,  if the subordinate PID is ever deleted
   (MUTIL)
   

		       (via RESET or  the  .MUDES  MUTIL  function),  the
		       monitor	 will	send   an  IPCF  message  to  the
		       controlling PID notifying it that the  subordinate
		       PID  has  been  deleted.   This	message  contains
		       .IPCKP in word 0 and the deleted PID in word 1.

		       Argument

			  Source (subordinate) PID

			  Object (controller) PID

     30      .MURKP    Return controlling PID for this subordinate PID.

		       Argument

			  Source (subordinate) PID

			  Object (controller) PID (returned)

   MUTIL ERROR MNEMONICS:

   IPCFX2:   no message for this PID

   IPCFX3:   data too long for user's buffer

   IPCFX4:   receiver's PID invalid

   IPCFX5:   receiver's PID disabled

   IPCFX6:   send quota exceeded

   IPCFX7:   receiver quota exceeded

   IPCFX8:   IPCF free space exhausted

   IPCFX9:   sender's PID invalid

   IPCF10:   WHEEL capability required

   IPCF11:   WHEEL or IPCF capability required

   IPCF12:   no free PID's available

   IPCF13:   PID quota exceeded

   IPCF14:   no PID's available to this job

   IPCF15:   no PID's available to this process

   IPCF16:   receive and message data modes do not match

   IPCF17:   argument block too small

   IPCF18:   invalid MUTIL JSYS function
   (MUTIL)
   

   IPCF19:   no PID for [SYSTEM]INFO

   IPCF20:   invalid process handle

   IPCF21:   invalid job number

   IPCF22:   invalid software interrupt channel number

   IPCF23:   [SYSTEM]INFO already exists

   IPCF24:   invalid message size

   IPCF25:   PID does not belong to this job

   IPCF26:   PID does not belong to this process

   IPCF27:   PID is not defined

   IPCF28:   PID not accessible by this process

   IPCF29:   PID already being used by another process

   IPCF30:   job is not logged in

   IPCF32:   page is not private

   IPCF33:   invalid index into system PID table

   IPCF35:   invalid IPCF quota


Node: NIN	Previous: MUTIL	Next: NODE	Up: Top
			      NIN     JSYS 225

   Inputs an integer number, with  leading  spaces  ignored.   This  call
   terminates on the first character not in the specified radix.  If that
   character is a carriage return followed by a line feed, the line  feed
   is also input.

   ACCEPTS IN AC1:  source designator

	      AC3:  radix (2-10) of number being input

   RETURNS     +1:  failure, error code in AC3, updated  string  pointer,
		    if pertinent, in AC1

	       +2:  success, number in AC2 and updated string pointer, if
		    pertinent, in AC1

   NIN ERROR MNEMONICS:

   IFIXX1:   radix is not in range 2 to 10
   (NIN)
   

   IFIXX2:   first nonspace character is not a digit

   IFIXX3:   overflow (number is greater than 2**35)

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open


Node: NODE	Previous: NIN	Next: NOUT	Up: Top
			     NODE     JSYS 567

   Performs the following network  utility  functions:	 set  local  node
   name,  get  local  node  name,  set	local node number, get local node
   number, set loopback port, clear  loopback  port,  and  find  loopback
   port.

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS    +1:   always.  If an error occurs, an  illegal  instruction
		    trap is generated.

   The available functions and their argument blocks are described below.

    Code     Symbol    Function

     0	     .NDSLN    Set local node name

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNOD    Byte pointer to ASCIZ node name.

     1	     .NDGLN    Get local node name

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNOD    Byte pointer  to  destination  for
				       ASCIZ name of local node.

     2	     .NDSNM    Set local node number

		       Argument Block:
   (NODE)
   

		       Word  Symbol    Contents

			0    .NDNOD    Number to  set  (greater  than  2,
				       less than 127)

     3	     .NDGNM    Get local node number.

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNOD    Number to  set  (greater  than  2,
				       less than 127)

     4	     .NDSLP    Set loopback port (2020 only)

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDPRT    NSP port number.
			1    .BTLID    Pointer to line id.

     5	     .NDCLP    Clear loopback port (2020 only)

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDPRT    NSP port number.

     6	     .NDFLP    Find loopback port (2020 only)

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDPRT    NSP port number

				       1B0 (ND%LPR) Loopback running.
				       1B1   (ND%LPA)	 Loopback    port
				       assigned.

    7	     .NDSNT    Set node table

		       Sets the system's table of accessible nodes.

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNND    Number of following words  (1  per
				       node) in right half.  Left half is
				       reserved.
   (NODE)
   

			1    .NDCNT    Number of words in  a  node  block
				       (described below)

			2    .NDBK1    Addresses   of	N    blocks    of
				       information   for  each	node  for
				       which updated information is to be
				       conveyed   to  the  monitor.   The
				       format	of   these   blocks    is
				       described below.

		       Node Block:

		       Word  Symbol    Contents

			0    .NDNAM    Byte pointer to ASCIZ node name

			1    .NDSTA    Node state:

				       .NDSON	  On
				       Add to table of reachable nodes if
				       not already there.

				       .NDSOF	  Off
				       Remove from  table  if  previously
				       there.

			2    .NDNXT    Byte pointer to the DN20 name.

    10      .NDGNT    Get node table

		       Reads the  system's  table  of  accessible  nodes.
		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNND    Number of following words  in  the
				       right half (set by the user on the
				       call) and the number of nodes  for
				       which	the    monitor	 actually
				       returned data  in  the  left  half
				       (set by the monitor on return).

			1    .NDCNT    Number of words in  a  node  block
				       (described below)

			2    .NDBK1    Addresses   of	N    blocks    of
				       information   for  each	node  for
				       which the monitor will return data
				       to  the user.  The format of these
				       blocks is described below.

			     .NDBK1+N  Start of an area  into  which  the
				       monitor	will  sequentially  place
				       node blocks (described below).  If
				       there  is not enough space to hold
   (NODE)
   

				       all  of	 the   information,   the
				       monitor	will  store  as  much  as
				       possible and then fail with  error
				       code ARGX04.

		       Node Block:

		       Word  Symbol    Contents

			0    .NDNAM    Byte pointer  to  the  ASCIZ  node
				       name

			1    .NDSTA    Node state

				       .NDSON	  On
				       .NDSOF	  Off
				       .NDSSH	  Shut

    11      .NDSIC    Set topology interrupt channel

		       This function is used by a process wishing  to  be
		       notified  that  the  network topology has changed.
		       The program must do the .NDGNT function to  obtain
		       the current topology.

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDCHN    Channel number on which interrupts
				       are desired.

    12      .NDCIC    Clear topology interrupt channel

		       This function is used to  clear	the  request  for
		       interrupt  on  topology	change	(set  by function
		       .NDSIC).

    13      .NDGVR    Get NSP version number

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNVR    Number of versions returned

			1    .NDCVR    Address of a block  in  which  the
				       NSP communications version will be
				       returned.  (Block format is  shown
				       below.)

			2    .NDRVR    Address of a block  in  which  the
				       NSP   routing   version	 will  be
				       returned.  (Block format is  shown
				       below.)
   (NODE)
   

				       Version Block:

		       Word  Symbol    Contents

			0    .NDVER    Version number

			1    .NDECO    ECO number

			2    .NDCST    Customer change order

    14      .NDGLI    Get line number

		       Returns information on lines known to NSP.

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNLN    Number  of  entries  following  in
				       right  half  (set by user on call)
				       and  number  of	lines  for  which
				       information  was  returned  in the
				       left  half  (set  by  monitor   on
				       return).

			1    .NDCNT    Number of words in a  line  block,
				       as described below.

			2    .NDBK1    Addresses   of	N    blocks    of
				       information   for  each	line  for
				       which the monitor will return data
				       to  the user.  The format of these
				       blocks is described below.

			     .NDBK1+N  Start of an area  into  which  the
				       monitor	will  sequentially  place
				       line blocks (described below).  If
				       there  is not enough space to hold
				       all  of	 the   information,   the
				       monitor	will  store  as  much  as
				       possible and then fail with  error
				       code ARGX04.

		       Line Block:

		       Word  Symbol    Contents

			0    .NDLNM    line number
			1    .NDLST    State of Line

				       .NDLON	  On
				       .NDLOF	  Off
				       .NDLCN	  Controller
						  loopback
				       .NDLCB	  Cable
   (NODE)
   

						  loopback
				       .NDLND	  Byte pointer	to  ASCIZ
						  name of node at the end
						  of the line.

    15      .NDVFY    Verify node name

		       This function  indicates  whether  the  node  name
		       supplied by the user is or is not in the monitor's
		       database of known nodes.

		       Argument Block:

		       Word  Symbol    Contents

			0    .NDNOD    Byte pointer to ASCIZ node name to
				       be checked.

			1    .NDFLG    Flags returned by monitor.

				       Flags:

				       ND%EXM The specified node  exactly
						matches  a  node  name in
						the    monitor's     node
						database.

   NODE ERROR MNEMONICS:

   ARGX02:   Invalid function

   ARGX19:   Invalid unit number

   CAPX2:    WHEEL, OPERATOR, or MAINTENANCE capability required

   NODX02:   Line not turned off

   NODX03:   Another line already looped


Node: NOUT	Previous: NODE	Next: ODCNV	Up: Top
			     NOUT     JSYS 224

   Outputs an integer number.

   ACCEPTS IN AC1:  destination designator

	      AC2:  number to be output

	      AC3:  B0(NO%MAG) output the magnitude.  That is, output the
			       number as an unsigned 36-bit number (e.g.,
			       output -1 as 777777 777777).
   (NOUT)
   

		    B1(NO%SGN) output a plus sign for a positive number.

		    B2(NO%LFL) output leading filler.  If this bit is not
			       set,  trailing  filler  is output, and bit
			       3(NO%ZRO) is ignored.

		    B3(NO%ZRO) output 0's as the leading  filler  if  the
			       specified   number   of	columns  (NO%COL)
			       allows filling.	If this bit is	not  set,
			       blanks are output as leading filler if the
			       number of columns allows filling.

		    B4(NO%OOV) output on column overflow  and  return  an
			       error.	If  this  bit  is not set, column
			       overflow is not output.

		    B5(NO%AST) output asterisks on column  overflow.   If
			       this  bit is not set and bit 4 (NO%OOV) is
			       set, all necessary digits  are  output  on
			       column overflow.

		    B11-B17    number of columns (including  sign column)
		    (NO%COL)   to output.  If this field is  0,  as  many
			       columns as necessary are output.

		    B18-B35    radix (2-36) of number being output
		    (NO%RDX)

   RETURNS     +1:  failure, error code in AC3

	       +2:  success, updated string pointer in AC1, if pertinent

   NOUT ERROR MNEMONICS:

   NOUTX1:   radix is not in range 2 to 36

   NOUTX2:   column overflow

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX11:    quota exceeded or disk full


Node: ODCNV	Previous: NOUT	Next: ODTIM	Up: Top
			     ODCNV     JSYS 222
   (ODCNV)
   

   Converts the internal date and time format into separate  numbers  for
   local  weekday,  day,  month,  year, and time and does not convert the
   numbers to text.  (Refer to Section 2.8.2 for more  information.)  The
   ODCNV  call	gives  the caller the option of explicitly specifying the
   time zone and daylight savings time.

   ACCEPTS IN AC2:  internal date and time, or -1 for  current	date  and
		    time

	      AC4:  B0(IC%DSA) apply daylight savings  according  to  the
			       setting	of  B1(IC%ADS).   If  B0  is off,
			       daylight  savings  is  applied	only   if
			       appropriate for date.

		    B1(IC%ADS) apply daylight savings  if  B0(IC%DSA)  is
			       on.

		    B2(IC%UTZ) use time zone in B12-B17(IC%TMZ).  If this
			       bit is off, the local time zone is used.
		    B3(IC%JUD) apply Julian day format (Jan 1 is day 1 in
			       conversion)

		    B12-B17    time zone to use if B2(IC%UTZ) is on.
		    (IC%TMZ)

   RETURNS     +1:  always, with

		    AC2 containing the year in the  left  half,  and  the
			numerical month (0=January) in the right half.

		    AC3 containing the day of the month (0=first day)  in
			the left half, and the day of the week (0=Monday)
			in the right half.

		    AC4 containing

			B0 and B2   on for compatibility with  the  IDCNV
				    call
			B1(IC%ADS)  on if daylight savings was applied
			B3(IC%JUD)  on if Julian day format was applied
			B12-B17     time zone used
			(IC%TMZ)
			B18-B35     local time in seconds since midnight
			(IC%TIM)

  If IC%JUD is set, the julian day (1 = Jan 1, 365 =  non-leap  Dec  31,
  366	=  leap Dec 31, etc) is returned in the right half of AC2 and the
  left half of AC3 is set to zero.

   Generates an illegal instruction interrupt on error conditions below.

   ODCNV ERROR MNEMONICS:

   DATEX6:   system date and time are not set
   (ODCNV)
   

   TIMEX1:   time cannot be greater than 24 hours

   ZONEX1:   time zone out of range


Node: ODTIM	Previous: ODCNV	Next: ODTNC	Up: Top
			     ODTIM     JSYS 220

   Outputs the date and time by converting the	internal  format  of  the
   date and/or time to text.  (Refer to Section 2.8.2.)

   ACCEPTS IN AC1:  destination designator

	      AC2:  internal date and time, or -1 for  current	date  and
		    time

	      AC3:  format option flags (see below), 0 is the normal case

   RETURNS     +1:  always, updated string pointer in AC1, if pertinent

   The format option flags in AC3 indicate the format in which	the  date
   and time are to be output.

			     ODTIM Option Flags
			       

      B0(OT%NDA)  do not output the date and ignore B1-B8.

      B1(OT%DAY)  output the day of the  week  according  to  the  format
		  specified by B2(OT%FDY).

      B2(OT%FDY)  output the full text for the day of the week.  If  this
		  bit is off, the 3-letter abbreviation of the day of the
		  week is output.

      B3(OT%NMN)  output the month as numeric and ignore B4(OT%FMN).

      B4(OT%FMN)  output the full text for the month.	If  this  bit  is
		  off, the 3-letter abbreviation of the month is output.

      B5(OT%4YR)  output the year as a 4-digit number.	If  this  bit  is
		  off,	the year is output as a 2-digit number if between
		  1900 and 1999.

      B6(OT%DAM)  output the day of the month after the month.	 If  this
		  bit is off, the day is output before the month.

      B7(OT%SPA)  output  the	date   with   spaces  between  the  items
		  (e.g.,    6 Feb 76).	If B6(OT%DAM) is also on, a comma
		  is output after the day of the month (e.g., Feb 6, 76).
   (ODTIM)
   

      B8(OT%SLA)  output the date with slashes (e.g., 2/6/76).

		  If B7-B8 are both off, the date is output  with  dashes
		  between the items (e.g., 6-Feb-76).

      B9(OT%NTM)  do not output the time and ignore B10-B13.

      B10(OT%NSC) do not output the seconds.  If this  bit  is	off,  the
		  seconds are output, preceded by a colon.

      B11(OT%12H) output the  time  in	12-hour  format  with  AM  or  PM
		  following  the  time.   If this bit is off, the time is
		  output in 24-hour format.

      B12(OT%NCO) output the time without a colon between the  hours  and
		  minutes.

      B13(OT%TMZ) output the time and follow it with a	"-"  and  a  time
		  zone (e.g., -EDT).

      B17(OT%SCL) suppress columnation of the date and time  by  omitting
		  leading  spaces  and	zeros.	This produces appropriate
		  output for a message.  If this bit is off, the date and
		  time are output in columns of constant width regardless
		  of the particular date or time.  However, full texts of
		  months and weekdays are not columnated.  This output is
		  appropriate for tables.

   If AC3 is 0, the ODTIM call outputs the date and time  in  columns  in
   the format

	     dd-mmm-yy	hh:mm:ss

   For example, 6-Feb-76  15:14:03.

   If  AC3  is	-1,  the  ODTIM  call  interprets  the	contents  as   if
   B1-B2,B4-B7,  and B17 were on (i.e., AC3=336001000000) and outputs the
   date and time in the format

	     weekday, month day, year hh:mm:ss

   as in Friday, February 6, 1976  15:14:03

   Additional examples are:

	Contents of AC3     Typical Text

	202201000000	    Fri 6 Feb 76 1:06
	336321000000	    Friday, February 6, 1976 1:06AM-EST
	041041000000	    6/2/76 106:03
	041040000000	    6/02/76 106:03

   Generates an illegal instruction interrupt on error conditions below.

   ODTIM ERROR MNEMONICS:
   (ODTIM)
   

   DATEX6:   system date and time are not set

   TIMEX1:   time cannot be greater than 24 hours

   All I/O  errors  are  also  possible.   These  errors  cause  software
   interrupts  or  process  terminations  as  described for the BOUT call
   description.


Node: ODTNC	Previous: ODTIM	Next: OPENF	Up: Top
			     ODTNC     JSYS 230

   Outputs the date and/or the time as separate numbers for  local  year,
   month,  day, or time.  (Refer to Section 2.8.2.) This JSYS is a subset
   of the ODTIM call because the output of dates and times not stored  in
   internal  format  is permitted.  Also, the caller has control over the
   time and zone printed.

   ACCEPTS IN AC1:  destination designator

	      AC2:  year  in  the  left   half,   and	numerical   month
		    (0=January) in the right half

	      AC3:  day of the month (0=first day) in the left half,  and
		    day  of the week (0=Monday), if desired, in the right
		    half

	      AC4:  B1(IC%ADS)	    apply daylight savings on output

		    B12-B17(IC%TMZ) time zone in which to output

		    B18-B35(IC%TIM) local time in seconds since midnight

	      AC5:  format  option  flags  (refer  to	ODTIM	for   the
		    description of these flags)

					    NOTE

			The only time zones that  can  be  output  by
			B13(OT%TMZ) are Greenwich and USA zones.

   RETURNS     +1:  always, updated string pointer in AC1, if pertinent.

   Generates an illegal instruction interrupt on error conditions below.

   ODTNC ERROR MNEMONICS:

   DATEX1:   year out of range

   DATEX2:   month is not less than 12
   (ODTNC)
   

   DATEX3:   day of month too large

   DATEX4:   day of week is not less than 7

   ZONEX1:   time zone out or range

   ODTNX1:   time zone must be USA or Greenwich

   All I/O errors can occur.  These errors cause software  interrupts  or
   process terminations as described for the BOUT call description.


Node: OPENF	Previous: ODTNC	Next: PBIN	Up: Top
			     OPENF     JSYS 21

   Opens the given file.  Refer to the TOPS-20 Monitor Calls User's Guide
   for the explanations of the types of access allowed to a file.

   ACCEPTS IN AC1:  JFN (right half of AC1) of the file being opened.

	      AC2:  B0-B5(OF%BSZ) Byte size (maximum of 36 decimal).   If
				  a  zero byte size is supplied, the byte
				  size defaults to 36 bits.

		    B6-B9(OF%MOD) File data mode.   Possible  data  modes
				  are:

				  Code	 Symbol   Mode

				   0	 .GSNRM Normal (ASCII)

				   10	 .GSIMG   Image

				   17	 .GSDMP   Dump

				  The legal modes for a given device are:

				   Device   Legal Modes

				   Disk     .GSNRM, .GSDMP
				   Card
				   Reader   .GSNRM, .GSIMG
				   Card
				   Punch    .GSNRM, .GSIMG
				   PTY	    .GSNRM (PTY receives data  in
					    mode of its TTY)
				   Tape     .GSNRM, .GSDMP
				   TTY	    .GSNRM, .GSIMG

				Modes for opening an Ethernet connection:

				Mode	Symbol	Description
				 0	.PUOI	Initiate  connection,
						wait for  completion

				 1	.PUOIN	Initiate  connection,
						no wait

				 2	.PUOL	Listen mode, wait for
						a connection

				 3	.PUOLN	Listen mode, no wait

				 4	.PUOCN	Open PUP set to OPEN
						state

				10	.PUORW	"Raw" IO mode, i.e.,
						no BSP processing

				Note that these  modes do not  correspond
				to the hardware data modes, which may  be
				specified  by  the  .MOPSM  function   of
				MTOPR%.  The  default  hardware  mode  is
				.PM32, 32 bits left  justified in a  full
				word.

				In addition to  the above  modes, a  user
				may specify an optional timeout  interval
				in 1B9-1B17 of AC2 and a connection ID in
				AC3.
	
		    B18(OF%HER)   Halt on I/O device or data  error.   If
				  this	bit  is on and a condition occurs
				  that causes an I/O device or data error
				  interrupt,  the process will instead be
				  halted,  and	an  illegal   instruction
				  interrupt  will  be generated.  If this
				  bit is off and  the  condition  occurs,
				  the	interrupt  is  generated  on  its
				  normally-assigned  channel.	This  bit
				  remains  in  affect for the entire time
				  that the file is open.

		    B19(OF%RD)	  Allow read access.

		    B20(OF%WR)	  Allow write access.

		    B21(OF%EX)	  Reserved for future use.

		    B22(OF%APP)   Allow append access.

		    B25(OF%THW)   Allow thawed access.	If  this  bit  is
				  off,	the  file  is  opened  for frozen
				  access.

		    B26(OF%AWT)   Block program and print  a  message  on
				  the	job's	controlling  terminal  if
				  access to  file  cannot  be  permitted.
				  The  program is blocked until access is
				  granted.

		    B27(OF%PDT)   Do not update access dates of the file.

		    B28(OF%NWT)   Return  an  error  if  access  to  file
				  cannot be permitted.

				  If  B26  and	B28  are  both	off,  the
				  default is to return an error if access
				  to the file cannot be granted.

		    B29(OF%RTD)   Enforce restriced access.  No other JFN
				  in  the  system may be opened with this
				  file until the current JFN is closed.

		    B30(OF%PLN)   Disable  line   number   checking   and
				  consider  a line number as 5 characters
				  of text.

		    B31(OF%DUD)   Suppress   the   system   updating   of
				  modified  pages  in  memory  to  thawed
				  files on disk until a  UFPGS	or  CLOSF
				  JSYS	is executed.  This bit is ignored
				  for new files.

		    B32(OF%OFL)   Open the device even if it is off line.

		    B33(OF%FDT)   Force an update of the .FBREF date  and
				  time	(last  read)  in  the FDB.  Also,
				  increment  right  halfword  (number  of
   (OPENF)
   

				  file	references)  of .FBCNT count word
				  in the FDB.

		    B34(OF%RAR)   Wait if the file is offline.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   A byte size of 0 opens the file in 36-bit (full word) bytes and can be
   given  when	subsequent  I/O  will be done with the PMAP call.  A byte
   size of 8 given for a JFN referring to a terminal opens  the  terminal
   in  binary mode.  (Refer to Section 2.4.3.) A byte size of 8 given for
   a JFN referring to a line printer opens  the  printer  in  8-bit  byte
   mode,  thereby  allowing  the  data	to  be	accessed  with 8-bit byte
   pointers.  (Refer to Section 2.4.1.) A byte size other  than  8  given
   for the printer results in using 7-bit bytes.
				    NOTE

		  For sequential  I/O,	bytes  are  packed
		  into	a  36-bit  monitor  buffer and are
		  unpacked by a pointer standard  for  the
		  device  and  data  mode being used.  For
		  example, a byte size of 7 (which is  the
		  system standard for ASCII data) causes 5
		  7-bit bytes to be packed into the buffer
		  with	the  setting  of the remaining bit
		  being unpredictable.	If a byte size	is
		  then	used that retrieves all 36 bits of
		  data from the buffer, the  last  bit	of
		  each word is indeterminate.

   Even though each type of desired access can be indicated by a separate
   bit,  some  accesses  are  implied  when  specific  bits are set.  For
   example, the setting of the write access bit implies  read  access  if
   the process is allowed to read the file according to the file's access
   code.  This means that if the process has access to read the file  and
   it  sets  only  the	write  access bit, the process will have the file
   opened for read, write, and execute access.	However, if  an  existing
   file is opened and only write access is specified (only OF%WR is set),
   the contents of the file are  deleted,  and	the  file  is  considered
   empty.  Thus, to update an existing file, both OF%RD and OF%WR must be
   set.

  Note that if OF%RD,	OF%WR,	and  OF%APP  are  all  zero,  OPENF  will
  generate an error.

  OPENF works as follows for archived versus migrated files:

		     Archived

	OPENF Access	      Online			  Offline

   (OPENF)
   

	    Read	       Ok		   Fail/Wait
	    Write	       Fail		   Fail
	    Append	       Fail		   Fail

		     Migrated

	OPENF Access	      Online			  Offline

	    Read	       Ok		   Fail/Wait
	    Write	       Ok
			       (discard
			       implied)
	    Append	       Ok		   Fail/Wait
			       (discard 	   (discard
			       implied) 	   implied)

  The fail cases will all return an appropriate error message	(OPNXnn).
  The	fail/wait  cases  will return an error for fail or wait until the
  OPENF can be successfully completed.  Whether a fail  or  wait  occurs
  will  be determined by the setting of OF%NWT (never wait for file) and
  OF%RAR (retrieve file if necessary).  If OF%NWT is set  on  the  OPENF
  call,  OPENF  will always fail (in the fail/wait cases).  If OF%RAR or
  the job default is set, the	OPENF  will  wait  for	the  file  to  be
  retrieved and then complete successfully.  In the Ok (discard implied)
  cases, tape pointers, if any, for the file are discarded.

   The CLOSF monitor call can be used to close a specific file.

   OPENF ERROR MNEMONICS:

   OPNX1:    file is already open

   OPNX2:    file does not exist

   OPNX3:    read access required

   OPNX4:    write access required

   OPNX5:    execute access required

   OPNX6:    append access required

   OPNX7:    device already assigned to another job

   OPNX8:    device is not on line

   OPNX9:    invalid simultaneous access

   OPNX10:   entire file structure full

   OPNX12:   list access required
   (OPENF)
   

   OPNX13:   invalid access requested

   OPNX14:   invalid mode requested

   OPNX15:   read/write access required

   OPNX16:   file has bad index block

   OPNX17:   no room in job for long file page table

   OPNX18:   Unit Record Devices are not available

   OPNX23:   disk quota exceeded

   OPNX25:   device is write-locked

   OPNX26:   illegal to open a string pointer

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   SFBSX2:   invalid byte size

   TTYX01:   line is not active


Node: PBIN	Previous: OPENF	Next: PBOUT	Up: Top
			      PBIN     JSYS 73

   Inputs the next sequential byte from  the  primary  input  designator.
   This call is equivalent to a BIN call with the source designator given
   as .PRIIN.

   RETURNS     +1:  always, with the byte right-justified in AC1

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   PBIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX5:    file is not open
   (PBIN)
   

   IOX1:     file is not open for reading

   IOX4:     end of file reached

   IOX5:     device or data error


Node: PBOUT	Previous: PBIN	Next: PEEK	Up: Top
			     PBOUT     JSYS 74

   Outputs a byte sequentially to the primary  output  designator.   This
   call  is  equivalent  to  a	BOUT call with the destination designator
   given as .PRIOU.

   ACCEPTS IN AC1:  byte to be output, right-justified

   RETURNS     +1:  always

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   PBOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX2:     file is not open for writing

   IOX5:     device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX11:    quota exceeded or disk full


Node: PEEK	Previous: PBOUT	Next: PLOCK	Up: Top
			     PEEK     JSYS 311

   Transfers a block of words from the monitor to the  user  space.   The
   desired  monitor  pages  must  have read access.  This monitor call is
   used to obtain data from the monitor for maintenance and test purposes
   and should be executed only when GETAB information is not available.
   (PEEK)
   

   RESTRICTIONS:    requires WHEEL, OPERATOR, or  MAINTENANCE  capability
		    enabled

   ACCEPTS IN AC1:  word count	in  the  left  half,  and  first  virtual
		    address of the monitor in the right half

	      AC2:  first user address

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, the desired words are transferred.

		    PEEK ERROR MNEMONICS:

		    CAPX1:  WHEEL or OPERATOR capability required

		    PEEKX2:  read access failure on monitor page


Node: PLOCK	Previous: PEEK	Next: PMAP	Up: Top
			     PLOCK     JSYS 561

   Acquires physical memory  and  places  a  designated  section  of  the
   process'  address  space in memory.	Allows the process to specify the
   memory pages to be used, or permits the system to select the pages.

   RESTRICTIONS:    requires WHEEL, OPERATOR, or  MAINTENANCE  capability
		    enabled

   ACCEPTS IN AC1:  address of first page if acquiring (locking) or -1 if
		    unlocking.

	      AC2:  process handle (currently .FHSLF only)  in	the  left
		    half and number of first page in the right half.

	      AC3:  control flags in the left half and	repeat	count  in
		    the right half.  The control flags are

		    B0 (LK%CNT) right half of AC3 contains a count of the
				number of pages to lock.

		    B1 (LK%PHY) value in AC1 is the first  page  desired.
				If this bit is off and AC1 is not -1, the
				system selects pages.

		    B2 (LK%NCH) pages will not be cached.

		    B3 (LK%AOL) off-line pages are to be locked.

   RETURNS     +1:  always

   If the PLOCK call is unable to honor any one of the requests to unlock
   (PLOCK)
   

   any one of the pages specified by the repeat count, it will unlock all
   of the others.

   A page that was locked with the PLOCK call may be unmapped.	(Refer to
   the PMAP call.)  This will unlock the process' page and return the now
   unlocked physical page to its previous state.

   The page selected by the user must be capable of being placed off-line
   for the PLOCK call to acquire it.

   Generates an illegal instruction interrupt on error conditions below.

   PLOCK ERROR MNEMONICS:

   ARGX22:   invalid flag

   ARGX24    invalid count


Node: PMAP	Previous: PLOCK	Next: PMCTL	Up: Top
			      PMAP     JSYS 56

   Maps one or more complete pages from a file to a process (for  input),
   from  a process to a file (for output), or from one process to another
  process.  Also unmaps pages from a process and deletes  pages  from	a
  file.  Each of the five uses of PMAP is described below.

   Case I Mapping File Pages to a Process
          

   This use of the PMAP call does not actually	transfer  any  data;   it
   simply  changes  the  contents of the process' page map.  When changes
   are made to the  page  in  the  process,  the  changes  will  also  be
   reflected  in the page in the file, if write access has been specified
   for the file.

   ACCEPTS IN AC1:  JFN of the file in the left half, and the page number
		    in	the file in the right half.  This AC contains the
		    source.

	      AC2:  process handle in the left half, and the page  number
		    in	the  process in the right half.  This AC contains
		    the destination.

	      AC3:  B0(PM%CNT)	A count is in  the  right  half  of  AC3.
				This   count   specifies  the  number  of
				sequential pages to be mapped.

		    B2(PM%RD)	Permit read access to the page.

		    B3(PM%WR)	Permit write access to the page.
   (PMAP)
   

		    B4(PM%EX)	Reserved for future use.
				The symbol PM%RWX  can	be  used  to  set
				B2-B4.

		    B5(PM%PLD)	Preload the page being mapped (i.e., move
				the  page  immediately instead of waiting
				until it is referenced).

		    B9(PM%CPY)	Create a private copy of the page when it
				is  written into (copy-on-write).  If the
				page  is  mapped  between  two	processes
				(Case  III  below),  both  processes will
				receive a private copy of the page.

		    B11(PM%ABT) Unmap  a  page	and  throw  its   changed
				contents  away.   This bit is significant
				only when unmapping pages  in  a  process
				(see  case IV below) and OF%DUD is set in
				the OPENF.  PM%ABT is particularly useful
				in  the case of erroneous data written to
				a  mapped  page  of  a	file   open   for
				simultaneous access.  In this case, it is
				important  that  the  erroneous  page  be
				discarded  and	not be used to update the
				file page.

		    B18-B35	Number	of  pages   to	 be   mapped   if
		    (PM%RPT)	B0(PM%CNT) is set.

   RETURNS     +1:  always

   This use of PMAP changes the map of the process such that addresses in
   the	page  in  the process specified by the right half of AC2 actually
   refer to the page in the file specified by the right half of AC1.  The
   present  contents of the page in the process are removed.  If the page
   in the file is currently nonexistent, it will be created  when  it  is
   written (i.e., when the corresponding page in the process is written).

   This use of PMAP is legal only if the file is opened for at least read
   access.  The access bits specified in the PMAP call are ANDed with the
   access  that  was  specified  when  the  file  was  opened.	 However,
   copy-on-write is always granted, regardless of the file's access.  The
   access granted is placed in the process'  map.   The  file  cannot  be
   closed  while  any  of  its	pages are mapped into any process.  Thus,
   before the file is closed, pages must be unmapped from each process by
   a PMAP call with -1 in AC1 (see below).

   Case II Mapping Process Pages to a File
          

   This use of the PMAP  call  actually  transfers  data  by  moving  the
   contents of the specified page in the process to the specified page in
   the file.  The process' map for that page becomes empty.

   ACCEPTS IN AC1:  process handle in the left half, and the page  number
   (PMAP)
   

		    in	the  process in the right half.  This AC contains
		    the source.

	      AC2:  JFN of the file in the left half, and the page number
		    in	the file in the right half.  This AC contains the
		    destination.

	      AC3:  access bits and repetition count.  (Refer to Case I.)

   RETURNS     +1:  always

   The process page and  the  file  page  must	be  private  pages.   The
   ownership  of  the  process page is transferred to the file page.  The
   present contents of the page in the file is deleted.

   The access granted to the file page is determined by ANDing the access
   specified in the PMAP call with the access specified when the file was
   opened.

   When mapping pages from a process to  a  file,  the	end-of-file  byte
   pointer  and  the  byte size are not automatically updated in the File
   Descriptor Block (FDB).  To allow the file to be read  later  via  the
   sequential  I/O calls (e.g., BIN, SIN), the process executing the PMAP
   call should close the file keeping the JFN (CLOSF call,  bit  CO%NRJ),
   update the byte pointer and the byte size in the FDB (CHFDB call), and
   then release the JFN (RLJFN call).  (Refer to Section  2.2.8  for  the
   format of the FDB fields.)

   Case III Mapping One Process' Pages to Another Process
           

   This use of the PMAP call normally does not	transfer  any  data;   it
   simply  changes  the contents of the page maps of the processes.  When
   changes are made to the page in one process, the changes will also  be
   reflected in the corresponding page in the other process.

   ACCEPTS IN AC1:  process handle in the left half, and the page  number
		    in	the  process in the right half.  This AC contains
		    the source.

	      AC2:  a second process handle in the left  half,	and  page
		    number  in	that  process in the right half.  This AC
		    contains the destination.

	      AC3:  access bits and repetition count.  (Refer to Case I.)

   RETURNS     +1:  always

   This use of PMAP changes the map of the destination process such  that
   addresses  in  the  page  specified	by the right half of AC2 actually
   refer to the page in the source process specified by the right half of
   AC1.  The present contents of the destination page are deleted.

   The access granted to the destination page is determined by the access
   specified in the PMAP call.
   (PMAP)
   

   Case IV Unmapping Pages In a Process
         

   As stated previously, a file cannot be closed if any of its pages  are
   mapped in any process.

   ACCEPTS IN AC1:  -1

	      AC2:  process handle in the left half, and page  number  in
		    the process in the right half

	      AC3:  B0(PM%CNT)	Repeat	count.	 Only  the  process  page
				numbers are incremented.

		    B18-B35	Number of pages to remove from process

   This format of the PMAP call removes the pages indicated in	AC2  from
   the process.

   A page that was locked with the PLOCK call may be unmapped.	Doing  so
   will  unlock  the  process'	page and return the now unlocked physical
   page to its previous state.

  Case V Deleting One or More Pages from a File
           

  Deletes one or more pages from a file on disk and does not affect  the
  address space of any process.

  ACCEPTS IN AC1:  -1

	      AC2:  JFN of the file in the left half and page  number  of
		    the file in the right half.

	      AC3:  B0(PM%CNT)	Indicates a repeat count is in right half
		    of AC3.

		    B18-35	Number of pages to delete from file

   Illegal PMAP calls
     

   The PMAP call is illegal if:

	1.  Both AC1 and AC2 designate files.

	2.  Both AC1 and AC2 are 0.

	3.  The PMAP call designates a file with write-only access.

	4.  The PMAP call designates a file with append-only access.

	5.  The source and/or the destination designates an  execute-only
	    process and the process is not self (.FHSLF).

   Can cause several software interrupts on certain file conditions.
   (PMAP)
   

   Generates an illegal instruction interrupt on error conditions below.

   PMAP ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DESX7:    JFN cannot refer to output wildcard designators

   PMAPX1:   invalid access requested

   PMAPX2:   invalid use of PMAP

   PMAPX3:   illegal to move shared page into file

   PMAPX4:   illegal to move file page into process

   PMAPX5:   illegal to move special page into file

   PMAPX6:   disk quota exceeded

   PMAPX7:   illegal to map file on dismounted structure

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX7:   process page cannot exceed 777

  FRKHX8:   illegal to manipulate an execute-only process

   LNGFX1:   page table does not exist and file not open for write

   IOX11:    quota exceeded or disk full

   ARGX06:   invalid page number

  CFRKX3:   insufficient system resources


Node: PMCTL	Previous: PMAP	Next: PPNST	Up: Top
			     PMCTL     JSYS 560

   Controls physical memory.  This call allows a  privileged  program  to
   add	or  remove  most  pages  of physical memory and to control use of
   cache memory.
   (PMCTL)
   

   The PMCTL monitor call requires the process to have	WHEEL,	OPERATOR,
   or MAINTENANCE capability enabled.

   ACCEPTS IN AC1:  function code

	      AC2:  length of the argument block

	      AC3:  address of the argument block

   RETURNS     +1:  always

   The defined functions and their argument blocks are as follows:

   Function	  Symbol		   Meaning

       0	  .MCRCE    Return  the  status  of  cache  memory.   The
			    status  is	returned  in  word  .MCCST of the
			    argument block.

			    Argument Block

			    0	.MCCST	 If B35(MC%CEN) is on, the  cache
					 is enabled.

       1	  .MCSCE    Set the status of cache memory.

			    Argument Block

			    0	.MCCST	 Enable the cache if  B35(MC%CEN)
					 is on.

       2	  .MCRPS    Return the status of the given page(s).   The
			    number  of	the page is given in word .MCPPN,
			    and its status is returned in word .MCPST.

			    Argument Block

			    0	.MCPPN	 Negative count in the left half;
					 number  of  physical page in the
					 right half

			    1	.MCPST	 Returned   page   status.    The
					 status  is represented by one of
					 the following values:

					 0   .MCPSA   Page  is	available
						      for normal use.

					 1   .MCPSS   Page   is   in	a
						      transition state.

					 2   .MCPSO   Page  is	off  line
						      because	 it    is
						      nonexistent.
						      Nonexistent  memory
   (PMCTL)
   

						      is  marked  as  off
						      line    at   system
						      startup.

					 3   .MCPSE   Page  is	off  line
						      because the monitor
						      detected an error.

       3	  .MCSPS    Set the status of the given page.  The number
			    of	the page is given in word .MCPPN, and the
			    status value is given in word .MCPST.

			    Argument Block

			    0	.MCPPN	 Number of physical page.

			    1	.MCPST	 Status for page.  The status  is
					 represented   by   one   of  the
					 following values:

					 0   .MCPSA   Mark page available
						      for normal use.

					 2   .MCPSO   Mark page off  line
						      because it does not
						      exist.

					 3   .MCPSE   Mark page off  line
						      because  it  has an
						      error.

					 4   .MCRME   Collect information
						      about   MOS  memory
						      errors.  Store  the
						      information      in
						      block addressed  by
						      AC3  and update AC2
						      on return.

   A list of those pages that PMCTL cannot acquire follows:

	1.  the EPT

	2.  the monitor's UPT

	3.  any page containing a CST0 entry

	4.  any page containing an SPT entry

	5.  the page containing MMAP

	6.  any page belonging to the resident free space pool
   (PMCTL)
   

   In certain specialized monitors,  for  example  TOPS-20AN,  there  are
   additional  pages that cannot be acquired.  An estimate of the size of
   these areas follows:

	CST0   one word for every page of memory supported (two  to  four
	       pages)
	SPT    four pages
	MMAP   one page
	Resident Free Space Pool     two pages minimum

   Generates an illegal instruction interrupt on error conditions below.

   PMCTL ERROR MNEMONICS:

   CAPX2:    WHEEL, OPERATOR, or MAINTENANCE capability required

   PMCLX1:   invalid page state or state transition

   PMCLX2:   requested physical page is  unavailable  PMCLX3:	requested
   physical page contains errors

   ARGX02:   invalid function

   ARGX06:   invalid page number


Node: PPNST	Previous: PMCTL	Next: PRARG	Up: Top
			     PPNST     JSYS 557

   Translates a project-programmer number  (a  TOPS-10	36-bit	directory
   designator)	to its corresponding TOPS-20 string.  The string consists
   of the structure name and a	colon  followed  by  the  directory  name
   enclosed  in  brackets.   This monitor call and the STPPN monitor call
   should  appear  only  in  programs  that   require	translations   of
   project-programmer  numbers.   Both	calls are temporary calls and may
   not be defined in future releases.

   ACCEPTS IN AC1:  destination designator

	      AC2:  project-programmer number (36 bits)

	      AC3:  byte pointer to structure name string for  which  the
		    given project-programmer number applies.

   RETURNS     +1:  always, string written to destination,  with  updated
		    byte pointer, if pertinent, in AC1

   If the structure name  string  is  a  logical  name,  then  the  first
   structure appearing in the logical name definition is used.

   Generates an illegal instruction interrupt on error conditions below.
   (PPNST)
   

   PPNST ERROR MNEMONICS:

   PPNX1:    invalid PPN

   PPNX2:    structure is not mounted

   GJFX22:   insufficient system resources (Job Storage Block full)

   STDVX1:   no such device

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DELFX6:   internal format of directory is incorrect

   DIRX1:    invalid directory number

   DIRX2:    insufficient system resources

   DIRX3:    internal format of directory is incorrect

   STRX01:   structure is not mounted

   STRX06:   no such user number

   IOX11:    quota exceeded or disk full


Node: PRARG	Previous: PPNST	Next: PSOUT	Up: Top
			     PRARG     JSYS 545

   Returns and/or sets arguments for the specified process.

   ACCEPTS IN AC1:  function code in the left half, and a process  handle
		    in the right half

	      AC2:  address of argument block

	      AC3:  length of argument block

   RETURNS     +1:  always, with the number  of  words	in  the  argument
		    block in AC3

   The codes for the functions are as follows:

      1      .PRARD    return the  arguments  beginning  at  the  address
		       specified in AC2
   (PRARG)
   

      2      .PRAST    set the arguments using the argument block at  the
		       address specified in AC2

   Generates an illegal instruction interrupt on error conditions below.

   PRARG ERROR MNEMONICS:

   PRAX1:    invalid PRARG function code

   PRAX2:    no room in monitor data base for argument block

   PRAX3:    PRARG argument block too large


Node: PSOUT	Previous: PRARG	Next: PUPI	Up: Top
			     PSOUT     JSYS 76

   Outputs a string sequentially to the primary output designator.

   ACCEPTS IN AC1:  byte pointer to  an  ASCIZ	string	in  the  caller's
		    address space

   RETURNS     +1:  always, updated byte pointer in AC1

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   PSOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX2:     file is not open for writing

   IOX5:     device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX11:    quota exceeded or disk full


Node: PUPI	Previous: PSOUT		Next: PUPO	Up: Top
			PUPI  JSYS 441

Used for reading in PUP's directly without BSP processing.

ACCEPTS IN AC1:	 B0 (PU%NOW) never dismiss for I/O, give PUPX3 error instead

		 B1 (PU%CHK) check pup checksum, give PUPX5 error if bad

		 B2 (PU%SRC) perform source address check, PUPX7 error if bad

		 B3 (PU%MEI) Want header in 16-bit header mode (.PM16)

		 B18-B35     JFN of open port

	   AC2:  length of user data area in words in the left half and
	         address of the user data block block in the right half

RETURNS:    +1:	 failure, error code in AC1.

	    +2   success


PUPI ERROR MNEMONICS:

IOX1:	Not open for reading

DESX4:	Invalid use of terminal designator or string pointer

DESX5:  File is not open

PUPX1:	Block size error

PUPX3:  Operation not possible now

PUPX4:  JFN open for sequential I/O only

PUPX5:	Checksum incorrect

PUPX7:  Source address incorrect

PUPX8:	JFN does not refer to device PUP:


Node: PUPO	Previous: PUPI		Next: PUPNM	Up: Top
			PUPO  JSYS 442

Used for outputting PUP's directly without BSP processing.

ACCEPTS IN AC1:  B0 (PU%NOW) never dismiss for I/O, give PUPX3 error instead

		 B1 (PU%CHK) check pup checksum

		 B2 (PU%SRC) perform source address check

		 B3 (PU%MEI) Header is in 16-bit header mode (.PM16)

		 B18-B35     JFN of open port

	   AC2:  length of user data area in words in the left half and
	         address of the user data block block in the right half

RETURNS:    +1:	 failure, error code in AC1.

	    +2   success


PUPO ERROR MNEMONICS:

IOX2:	File is not open for writing

DESX4:	Invalid use of terminal designator or string pointer

DESX5:  File is not open

PUPX1:	Block size error

PUPX2:  PUP address error

PUPX4:  JFN open for sequential I/O only

PUPX5:	Checksum incorrect

PUPX7:  Source address incorrect

PUPX8:	JFN does not refer to device PUP:


Node: PUPNM	Previous: PUPO		Next: RCDIR	Up: Top
			PUPNM  JSYS 443

Do pup name/address translation.

ACCEPTS IN AC1:	 Source/destination designator.  If source, must be a string
		 pointer

	   AC2:  1B0 (PN%NAM) If set, lookup name string given by AC1 and
			      return address(es) to block pointed by AC2.

			      If not set, look up name string pointed to by AC2
			      and output resulting name string to AC1.
			      If PN%ATT is set, do this for the attribute
			      string.

		 1B1 (PN%FLD) If set and PN%NAM is set, allow recognition.

			      If set and PN%NAM is not set, omit fields where
			      possible.

			      If not set and PN%NAM is set, do not allow
			      recognition

			      If not set and PN%NAM is not set, output each
			      field.

		 1B2 (PN%OCT) If set, output octal numbers for unknown fields.

			      If not set and PN%NAM off, return an error if
			      the address is not found.

		 1B3 (PN%ADR) If PN%NAM is off, return address block pointer
			      in AC3

		 1B4 (PN%ATT) If set, lookup attribute name string pointer to
			      by AC4, output corresponding attribute value
			      string to AC1.  PN%NAM must be off.  PN%ATT on
			      suppresses outputting of the name string and
			      forces PN%OCT off.

		 B9-B17      Block length in words if PN%NAM is on.

		 B18-B35     Block address.
	
	   AC3:	 not used

	   AC4:	 Destination designator for attribute value string if
		 PN%ATT is on.

RETURNS:    +1:	 failure, error code in AC1.

	    +2   success, with updated string pointers in AC1 and AC4 if
		 relevant.  AC2 is updated only if PN%NAM is set; the left
		 half contains the number of words used in the block (i.e.,
		 twice the number of matching addresses, which can be greater
		 than the number of words in the block); the right half of AC2
		 is unchanged.  The left half of AC3 contains the version
		 number of SYSTEM:PUP-NETWORK.DIRECTORY; the right half
		 contains the 16-bit byte address of the first word of the
		 address block if PN%ADR on in AC2 or a zero if not found

The format of the block pointed to by AC2 is any number of repetitions of the
following two word block:

		<Network number>,,<Host number>
		<Socket>

PUPNM ERROR MNEMONICS:

DESX1:	  Invalid source/destination designator

PUPNX1:	  Name or address not found

PUPNX2:   Recognition invoked and name ambiguous

PUPNX3:   Syntax error or illegal address

PUPNX4:   Inconsistent overlapping elements in name string

PUPNX5:   Syntax error in attribute name string

PUPNX6:   Attribute name not found


Node: RCDIR	Previous: PUPNM	Next: RCM	Up: Top
			     RCDIR     JSYS 553
   (RCDIR)
   

   Translates the given directory  string  to  its  corresponding  36-bit
   directory number.  The directory string consists of the structure name
   or logical name and a colon followed by the directory name enclosed in
   either  square  brackets  or  angle	brackets.   No	spaces can appear
   between the structure name and the  directory  name,  and  each  field
   given  must include its punctuation.  An example of a directory string
   is PS:<SMITH>.  If the structure name is omitted from the string,  the
   user's  connected structure is used.  If the directory name is omitted
   from the string, the user's connected directory is used.

   Recognition can be used on the string but only on the  directory  name
   field;   recognition  cannot  be  used  on  the  structure name field.
   Partial  recognition  can  be  allowed  so  that  a	user  can  employ
   recognition	when typing the name of a subdirectory.  When recognition
   is used on the directory name field and  the  directory  name  is  not
   ambiguous, the closing bracket is not required.

   The directory name field can contain wildcard characters, and repeated
   RCDIR  calls  can be executed to obtain the numbers of the directories
   whose characters match the given directory.	 After	the  first  call,
   each subsequent RCDIR call returns the number of the next directory in
   the group.

   ACCEPTS IN AC1:  flag bits in the left half

	      AC2:  byte pointer to ASCIZ string to be translated, a JFN,
		    a  36-bit  user  number, or a 36-bit directory number
		    (given for the purpose of checking its validity)

	      AC3:  36-bit directory number (given when stepping  to  the
		    next directory in a group of directories)

   RETURNS     +1:  always, with

		    AC1 containing flag bits in the left half

		    AC2 containing an updated byte pointer (if a  pointer
			was  supplied  as  the argument).  If recognition
			was used, this pointer reflects the remainder  of
			the  string  that  was	appended  to the original
			string.

		    AC3 containing a 36-bit directory number if execution
			of the call was successful

   The flag bits supplied in the left half of AC1 are as follows:

   B14(RC%PAR)	  Allow partial recognition on the  directory  name.   If
		  the  name  given  matches  more than one directory, bit
		  RC%AMB is set on return and the string  is  updated  to
		  reflect  the	unique portion of the directory name.  If
		  bit RC%PAR is not set, the name given matches more than
		  one  directory,  and	recognition  is  being	used, bit
		  RC%AMB is set on return, but the string is not updated.
   (RCDIR)
   

   B15(RC%STP)	  Step to the next directory in the group and return  the
		  number  of  that  directory.	 AC1 must have bit RC%AWL
		  set.	AC2 must contain  a  pointer  to  a  string  that
		  contains  wildcard  characters  in  the  directory name
		  field.  AC3 must contain a directory number.

   B16(RC%AWL)	  Allow  the   directory   name   to   contain	 wildcard
		  characters.  No recognition is performed on a directory
		  name that  contains  wildcard  characters.   Also,  the
		  directory  name  must  include its terminating bracket.
		  This bit must be set if bit RC%STP is also set.

   B17(RC%EMO)	  Match the given string exactly.  When both  the  RC%PAR
		  and  RC%EMO bits are on, recognition is not used on the
		  string, and the string is matched exactly.  If this bit
		  is off, recognition is used on the string.

   The flag bits returned in the left half of AC1 are as follows:

   On success
    

   B0(RC%DIR)	  Directory can be used only by connecting to  it  (i.e.,
		  it is a files-only directory).  If this bit is off, the
		  user can also login to (if  the  directory  is  on  the
		  public structure) or access this directory.

   B1(RC%ANA)	  Obsolete

   B2(RC%RLM)	  All messages from <SYSTEM>MAIL.TXT are  repeated  every
		  time	the  user  logs in.  If this bit is off, messages
		  are printed only once.

   B6(RC%WLD)	  The directory name given contained wildcard characters.

   On failure
    

   B3(RC%NOM)	  No match was found for the string given.  This  bit  is
		  returned if either 1) bit RC%EMO was on in the call and
		  a string was given that matched more than one directory
		  or 2) the syntax of the fields in the string is correct
		  but the structure is not mounted or the directory  does
		  not exist.

   B4(RC%AMB)	  The argument given was ambiguous.  This bit is returned
		  if  bit RC%EMO was off in the call and the string given
		  either matched more  than  one  directory  or  did  not
		  include  the	beginning  bracket  of the directory name
		  field.

   B5(RC%NMD)	  There  are  no  more	directories  in  the   group   of
		  directories.	 This bit is returned if RC%STP was on in
		  the call and the numbers of all the directories in  the
		  group have been returned.

   The RCDIR monitor call can be used in one of two ways.   The  simplest
   (RCDIR)
   

   way	is  to	translate a directory string that corresponds to only one
   directory to its corresponding 36-bit directory  number.   The  string
   can	be  either recognized or matched exactly.  Instead of accepting a
   string, the program can supply a JFN  or  a	36-bit	user  number  and
   translate this argument to a directory number.  When a JFN is supplied
   as  an  argument,  the  number  returned  is  that  of  the	directory
   containing  the  file  associated with the JFN.  When a user number is
   supplied  as  an  argument,	the  number  returned  is  the	logged-in
   directory  for that user.  Finally, the program can supply a directory
   number to check the number's  validity,  and  if  the  RCDIR  call  is
   successful, this same number is returned.

   The second way of using the RCDIR call is to accept a directory string
   that  corresponds  to  more than one directory and to step through all
   the directories matching the given string to obtain all the	directory
   numbers.   Repeated	RCDIR  calls are executed until the number of the
   last directory is returned.	This use of RCDIR requires AC2 to contain
   a pointer to a string containing wildcard characters and is ignored if
   the string does not	contain  wildcard  characters  or  if  any  other
   argument is given in AC2.

   The first RCDIR call executed must have bit RC%AWL set in AC1 and  the
   pointer to the string in AC2.  If execution of the call is successful,
   AC3 contains the number of the directory corresponding  to  the  first
   directory  in the group.  For example, if the string given is <SMITH*>
   and the  call  is  successful,  the	number	returned  corresponds  to
   <SMITH>.   Subsequent  RCDIR  calls must set bits RC%STP and RC%AWL in
   AC1, reset the pointer in AC2 (because it is updated on  a  successful
   RCDIR  call),  and leave in AC3 the directory number returned from the
   previous RCDIR call.  (The directory number in AC3 is accepted only if
   RC%STP  is  set  in	AC1 and a pointer to a string containing wildcard
   characters  is  given  in  AC2.)  On  successful  execution	of   each
   subsequent  RCDIR  call, the number returned in AC3 corresponds to the
   next directory in the group.  When the number of the last directory in
   the	group  has been returned, a subsequent RCDIR call sets bit RC%NMD
   in AC1;  the content of AC3 is indeterminate.

   The RCUSR monitor call can be used to translate a user name string  to
   its	corresponding user number.  The DIRST monitor call can be used to
   translate  either  a  directory  number  or	a  user  number  to   its
   corresponding string.

   Generates an illegal instruction interrupt on error conditions below.

   RCDIR ERROR MNEMONICS:

   RCDIX1:   insufficient system resources

   RCDIX2:   invalid directory specification

   RCDIX3:   invalid structure name

   RCDIX4:   monitor internal error

   DESX1:    invalid source/destination designator
   (RCDIR)
   

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DESX8:    file is not on disk

   DESX10:   structure is dismounted

   STRX01:   structure is not mounted


Node: RCM	Previous: RCDIR	Next: RCUSR	Up: Top
			      RCM     JSYS 134

   Returns the word mask of the  activated  interrupt  channels  for  the
   specified  process.	(Refer to Section 2.5.1 and the AIC and DIC calls
   for information on  activating  and	deactivating  software	interrupt
   channels.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, 36-bit word in AC1, with  bit  n  on  meaning
		    channel n is activated

   Generates an illegal instruction interrupt on error conditions below.

   RCM ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RCUSR	Previous: RCM	Next: RCVIM	Up: Top
			     RCUSR     JSYS 554

   Translates the given user name string to its corresponding 36-bit user
   number.   The user name string consists of the user's name without any
   punctuation.  The string  must  be  associated  with  a  directory  on
   structure PS:  that is not a files-only directory.

   Recognition can be used on the string.  In addition,  the  string  can
   (RCUSR)
   

   contain wildcard characters.

   ACCEPTS IN AC1:  flag bits in the left half

	      AC2:  byte pointer to ASCII string to be translated

	      AC3:  36-bit user number (given when stepping to	the  next
		    user name in a group)

   RETURNS     +1:  always, with

		    AC1 containing flag bits in the left half

		    AC2 containing   an   updated   byte   pointer.    If
			recognition  was  used, this pointer reflects the
			remainder of the string that is appended  to  the
			original string.

		    AC3 containing a 36-bit user number if  execution  of
			the  call  was	successful.  An example of a user
			number is:  500000,,261.

   The flag bits supplied in the left half of AC1 are  as  follows.   For
   additional  information on these bits, refer to the RCDIR monitor call
   description.

   B14(RC%PAR)	  Allow partial recognition on the user name string.

   B15(RC%STP)	  Step to the next user name in the group.

   B16(RC%AWL)	  Allow the user name to contain wildcard characters.

   B17(RC%EMO)	  Match the given string exactly.

   The flag bits returned in the left half of AC1 are  as  follows.   For
   additional  information on these bits, refer to the RCDIR monitor call
   description.

   On success
    

   B1(RC%ANA)	  Obsolete

   B2(RC%RLM)	  User sees all messages from <SYSTEM>MAIL.TXT every time
		  he  logs  in.   If  this  bit is off, the user sees the
		  messages only once.

   B6(RC%WLD)	  The user name given contained wildcard characters.

   On failure
    

   B3(RC%NOM)	  No match was found for the string given.  This bit will
		  be  on  if  the  string  given  refers  to a files-only
		  directory, if there is no directory  on  PS:	 that  is
		  associated with the user name string, or bit RC%EMO was
		  on in the call and a string was given that matched more
   (RCUSR)
   

		  than one user.

   B4(RC%AMB)	  The string given was ambiguous because it matched  more
		  than one user.

   B5(RC%NMD)	  There are no more user names in the group.

   The RCDIR monitor call can be used to translate a directory string  to
   its	corresponding  directory  number.   The DIRST monitor call can be
   used to translate either a user number or a directory  number  to  its
   corresponding string.

   Generates an illegal instruction interrupt on error conditions below.

   RCUSR ERROR MNEMONICS:

   RCUSX1:   insufficient system resources

   RCDIX4:   monitor internal error

   STRX07:   invalid user number

   STRX08:   invalid user name


Node: RCVIM	Previous: RCUSR	Next: RCVOK%	Up: Top
			     RCVIM     JSYS 751

  Retrieves a message from the ARPANET special message queue.	The queue
  must have been previously assigned with the ASNSQ JSYS.

  RESTRICTIONS:    for ARPANET systems only.

  ACCEPTS IN AC1:  special queue handle
	      AC2:  address where extended message is to be stored

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, message block stored at address specified in
		    AC2

  The RCVIM JSYS will block until the message is received.

  See SNDIM JSYS for a description of the message format.

  RCVIM ERROR MNEMONICS:

  SQX1:     Special network queue handle out of range

  SQX2:     Special network queue not assigned
   (RCVOK%)
   


Node: RCVOK%	Previous: RCVIM	Next: RDTTY	Up: Top
			    RCVOK%     JSYS  575

  Allows the access-approval program (written by  the	installation)  to
  service  an	approval request in the GETOK% request queue after a user
  program has issued a GETOK% JSYS.

  RESTRICTIONS:  Requires WHEEL or OPERATOR capability enabled

  ACCEPTS IN AC1:  Address of argument block

	      AC2:  Length of argument block

  RETURNS     +1:  always

  Argument Block (returned):

  Word   Symbol     Contents

   0	  .RCFCJ     Function code,,job number
   1	  .RCUNO     User number
   2	  .RCCDR     Connected directory
   3	  .RCRQN     Request number
   4	  .RCNUA     # user args actually passed to RCVOK% block,,#  user
		     args supplied in user block
   5	  .RCARA     Address of user arguments
   6	  .RCCAP     Capabilities enabled
   7	  .RCTER     Controlling terminal number
   10	  .RCRJB     Job number request is for

   11		     User arguments
   .		     ..
   .		     ..
   11+n	     ..

  The argument block returned	contains  two  major  segments,  the  job
  section,  which  contains  information  about  the job that issued the
  GETOK% JSYS,  and  the  user  argument  section,  which  contains  the
  arguments  the  user supplied with the GETOK% call.	The user argument
  section immediately follows the job	section.   However,  as  the  job
  section's  length  may  grow  with  future  releases  of  TOPS-20, the
  access-control program should extract the address of the user argument
  section  from  word	4  of  the  RCVOK% argument block.  The following
  sequence of instructions illustrates how to	index  through	the  user
  argument section of the RCVOK% argument block:

		;Build AOBJN pointer
		HLRZ	T1,ARGBLK+.RCNUA	;Get # user args passed
		MOVN	T1,T1			;Negate
		HRLZ	T1,T1			;Move to left half-word
		HRR	T1,ARGBLK+.RCARA	;Get address of user args

	LP:	MOVE	T2,(T1) 		;Get user arg

   (RCVOK%)
   

		...
		...

		AOBJN	T1,LP

  Returns an illegal instruction interrupt on error conditions below.

  RCVOK% ERROR MNEMONICS:

  CAPX1:    wheel or operator capability required


Node: RDTTY	Previous: RCVOK%	Next: RELD	Up: Top
			     RDTTY     JSYS 523

	     Reads input from the primary input designator (.PRIIN)  into
	     the  caller's  address  space.  Input is read until either a
	     break character is encountered or the given  byte	count  is
	     exhausted,  whichever  occurs  first.  Output generated as a
	     result of character editing is output to the primary  output
	     designator (.PRIOU).

	     The RDTTY call handles the following editing functions:

	     1.  Delete the last character input (DELETE).

	     2.  Delete back to the last punctuation character (CTRL/W).

	     3.  Delete back to the beginning of the current line or,  if
		 the  current line is empty, back to the beginning of the
		 previous line (CTRL/U).

	     4.  Retype the current line from its beginning  or,  if  the
		 current   line   is  empty,  retype  the  previous  line
		 (CTRL/R).

	     5.  Accept the next character without regard  to  its  usual
		 meaning (CTRL/V).

	     By handling these functions, the RDTTY  call  serves  as  an
	     interface between the terminal and the user program.

   ACCEPTS IN AC1:  byte pointer to  string  in  caller's  address  space
		    where input is to be placed

	      AC2:  B0(RD%BRK)	Break on CTRL/Z or ESC.
		    B1(RD%TOP)	Break on  CTRL/G,  CTRL/L,  CTRL/Z,  ESC,
				carriage return, line feed.
		    B2(RD%PUN)	Break on punctuation (see below).
		    B3(RD%BEL)	Break on end of line (carriage return and
				line feed, or line feed only).
   (RDTTY)
   

		    B4(RD%CRF)	Suppress a carriage return and	return	a
				line feed only.
		    B5(RD%RND)	Return to user program if user	tries  to
				delete	beyond	beginning  of  the  input
				buffer (e.g.,  user  types  a  CTRL/U  or
				DELETE	past  the  first character in the
				buffer).  If this bit  is  not	set,  the
				call  rings the terminal's bell and waits
				for more input.
		    B7(RD%RIE)	Return to user program if input buffer is
				empty.	 If this bit is not set, the call
				waits for more input.
		    B10(RD%RAI) Convert lower-case  input  to  upper-case
				input.

		    B11(RD%SUI) Suppress CTRL/U indication (i.e., do  not
				print  XXX,  and on display terminals, do
				not  delete  the  characters   from   the
				screen).
		    B18-B35	Number of bytes available in the  string.
				The  input  is terminated when this count
				is exhausted, even if the specified break
				character has not yet been typed.

		    If the left half of AC2 is 0, the input is terminated
		    on end of line only.

	      AC3:  byte pointer to prompting-text (CTRL/R buffer), or	0
		    if	no  text.  This text, followed by any text in the
		    input buffer, is output if the user types  CTRL/R  in
		    his first line of input.  If no CTRL/R text exists or
		    the user types CTRL/R on other than the first line of
		    input,  only  the  text  on  the current line will be
		    output.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated byte  pointer  in	AC1,  appropriate
		    bits  set  in the left half of AC2, and updated count
		    of available bytes in the right half of AC2

   The bits returned in the left half of AC2 on a successful return are:

		    B12(RD%BTM) Break character terminated the input.  If
				this  bit  is  not  set,  the  input  was
				terminated because  the  byte  count  was
				exhausted.
		    B13(RD%BFE) Control  was  returned	to  the   program
				because  the  user tried to delete beyond
				the beginning of  the  input  buffer  and
				RD%RND was on in the call.
		    B14(RD%BLR) The backup limit for editing was reached.

				    NOTE
   (RDTTY)
   

		  Bits not described are reserved for  use
		  by the monitor.  The state of these bits
		  on  completion  of  the  RDTTY  call	is
		  undefined.

   The punctuation break character set (RD%PUN) is as follows:

	CTRL/A-CTRL/F	    ASCII codes 34-36
	CTRL/H-CTRL/I	    ASCII codes 40-57
	CTRL/K		    ASCII codes 72-100
	CTRL/N-CTRL/Q	    ASCII codes 133-140
	CTRL/S-CTRL/T	    ASCII codes 173-176
	CTRL/X-CTRL/Y

   Upon completion of the call, the terminating character  is  stored  in
   the	string, followed by a NULL (unless the byte count was exhausted).
   Also, any CTRL/V, along with the character following it, is stored  in
   the string.

   RDTTY ERROR MNEMONICS:

   RDTX1:    invalid string pointer

   IOX11:    quota exceeded or disk full


Node: RELD	Previous: RDTTY	Next: RELSQ	Up: Top
			      RELD     JSYS 71

   Releases one or all devices assigned to the job.   When  a  device  is
   released  by  the job, the resource allocator receives an IPCF packet.
   (Refer to the ALLOC monitor call description for  the  format  of  the
   packet sent to the allocator.)

   ACCEPTS IN AC1:  device designator,	or  -1	to  release  all  devices
		    assigned to this job

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The ASND monitor call can be used to assign a device to the caller.

  If this JSYS is issued for a device on which the user has an open JFN,
  an error will be returned.

   RELD ERROR MNEMONICS:

   DEVX1:    invalid device designator

   DEVX2:    device already assigned to another job
   (RELD)
   

   DEVX6:    job has open JFN on device


Node: RELSQ	Previous: RELD	Next: RESET	Up: Top
			     RELSQ     JSYS 753

  Deassigns  the  ARPANET  special  message  queue.   (The  LGOUT   JSYS
  deassigns  all  special message queues.) All pending messages relative
  to the specified queue(s) are discarded.

  RESTRICTIONS:    for ARPANET systems only.

  ACCEPTS IN AC1:  special queue handle (returned by ASNSQ),  or  -1  to
		    deassign all special queues.

  RETURNS     +1:  always

  RELSQ functions as a no-op if an unassigned queue is specified in AC1.


Node: RESET	Previous: RELSQ	Next: RFACS	Up: Top
			     RESET     JSYS 147

   Resets and initializes the current process.	It is a good  programming
   practice  to  include  this	call  at  the  beginning of each assembly
   language program.

   RETURNS     +1:  always

   The RESET monitor call performs the following:

	1.  Closes all files at or below the current process and releases
	    all  JFNs.	 If  a	file is nonexistent (i.e., has never been
	    closed), it is closed and then expunged.

	2.  Kills all inferior processes.

	3.  Clears the current process' software interrupt  system.   The
	    channel  table  and  priority  level  table  addresses remain
	    unchanged from any previous settings.

	4.  Sets the following fields of the controlling  terminal's  JFN
	    mode word (refer to Section 2.4.3.1):

	    TT%WAK(B18-B23) to wake up on every character
	    TT%ECO(B24)     to cause echoing
	    .TTASI(B29)     to translate both echo and output (ASCII data
			    mode)
   (RESET)
   

	    Remaining fields of the mode word are not changed.

	5.  Releases all of the current process' PIDs.

	6.  Dequeues all of the current process' ENQ requests.

	7.  Clears the compatibility package's entry vector.

	8.  Releases all process handles that can be released.	(Refer to
	    the RFRKH call description.)


Node: RFACS	Previous: RESET	Next: RFBSZ	Up: Top
			     RFACS     JSYS 161

   Returns the ACs of the specified process.

   ACCEPTS IN AC1:  process handle

	      AC2:  address of the beginning of a 20(octal) word table in
		    the caller's address space where the AC values of the
		    specified process are to be stored

   RETURNS     +1:  always

   The SFACS monitor call can be used to set  the  ACs	for  a	specified
   process.

   Generates an illegal instruction interrupt on error conditions below.

   RFACS ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX4:   process is running

  FRKHX8:   illegal to manipulate an execute-only process


Node: RFBSZ	Previous: RFACS	Next: RFCOC	Up: Top
			     RFBSZ     JSYS 45

   Returns the byte size for a specific opening of a file.  (Refer to the
   OPENF or SFBSZ call description for setting the byte size.)
   (RFBSZ)
   

   ACCEPTS IN AC1:  JFN

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, byte size right-justified in AC2

   RFBSZ ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open


Node: RFCOC	Previous: RFBSZ	Next: RFMOD	Up: Top
			     RFCOC     JSYS 112

   Returns the control character output  control  (CCOC)  words  for  the
   specified terminal.	(Refer to Section 2.4.3.2.)

   ACCEPTS IN AC1:  file designator

   RETURNS     +1:  always, with output control words in AC2 and AC3

   The CCOC words consist of 2-bit  bytes,  each  byte	representing  the
   output  control  for  one  of  the  ASCII  codes  0-37.   If the given
   designator is not associated with  a  terminal,  the  CCOC  words  are
   returned  in  AC2 and AC3 with each 2-bit byte containing a value of 2
   (send actual code and account format action).

   The SFCOC monitor call can be  used	to  set  the  CCOC  words  for	a
   specified terminal.

   Generates an illegal instruction interrupt on error conditions below.

   RFCOC ERROR MNEMONICS:

   TTYX01:   line is not active


Node: RFMOD	Previous: RFCOC	Next: RFORK	Up: Top
			     RFMOD     JSYS 107

   Returns the JFN mode word associated with the specified file.   (Refer
   (RFMOD)
   

   to  Section 2.4.3.1.)  The MTOPR monitor call should be used to return
   the page length and width fields,  especially  when	the  fields  have
   values  greater  than  127.	 The RFMOD call returns these fields as 1
   when their values are greater than 127.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  always, with mode word in AC2

   If the designator is not a terminal, the RFMOD call returns in  AC2	a
   word in the following format

    7B3+^D66B10+^D72B17+ 4 mode bits from the OPENF for the designator

   This setting of the left half of AC2 indicates that the designator has
   mechanical  form  feed, mechanical tab, lower case, page length of 66,
   and page width of 72.

   The SFMOD and STPAR monitor calls can be used to set various fields of
   the JFN mode word.

   RFMOD ERROR MNEMONICS:

   TTYX01:   line is not active


Node: RFORK	Previous: RFMOD	Next: RFPOS	Up: Top
			     RFORK     JSYS 155

   Resumes one or more processes that had  been  directly  frozen.   This
   monitor  call  does	not  resume  a	process  that has been indirectly
   frozen.  (Refer to Section 2.6.2.1.)  Also, the RFORK call  cannot  be
   used  to  resume a process that is suspended because of a monitor call
   intercept.  (Refer to the UTFRK call.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   The RFORK monitor call is a no-op if the referenced process(s) was not
   directly frozen.

   The FFORK monitor call can be used to freeze one or more processes.

   Generates an illegal instruction interrupt on error conditions below.

   RFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process
   (RFORK)
   

   FRKHX3:   invalid use of multiple process handle


Node: RFPOS	Previous: RFORK	Next: RFPTR	Up: Top
			     RFPOS     JSYS 111

   Returns the current position  of  the  specified  terminal's  pointer.
   (Refer  to  Section 2.4.3.4 for information on page lengths and widths
   of terminals.)

   ACCEPTS IN AC1:  device designator

   RETURNS     +1:  always, AC2 contains position within  a  page  (i.e.,
		    line  number) in the left half, and position within a
		    line (i.e., column number) in the right half

   AC2 contains 0 if the designator is not associated with a terminal.

   The SFPOS monitor call  can	be  used  to  set  the	position  of  the
   terminal's pointer.

   Generates an illegal instruction interrupt on error conditions below.

   RFPOS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: RFPTR	Previous: RFPOS	Next: RFRKH	Up: Top
			     RFPTR     JSYS 43

   Returns the current position of the specified file's pointer.

   ACCEPTS IN AC1:  JFN

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, byte number in AC2

   The SFPTR monitor call can be used to set the position of  the  file's
   (RFPTR)
   

   pointer.

   RFPTR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open


Node: RFRKH	Previous: RFPTR	Next: RFSTS	Up: Top
			     RFRKH     JSYS 165

   Releases the specified handle of a process.	A handle can be  released
   only  if  it describes either an existent process inferior to at least
   one other process in the job or a process that  has	been  killed  via
   KFORK (i.e., a nonexistent process).

   ACCEPTS IN AC1:  process handle, or -1 to release all relative handles
		    that can be released

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The process handles released when AC1 is -1 are the ones released on a
   RESET or a KFORK monitor call.

   RFRKH ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RFSTS	Previous: RFRKH	Next: RFTAD	Up: Top
			     RFSTS     JSYS 156

   Returns the status of the specified process.

  SHORT FORM:
   (RFSTS)
   

  ACCEPTS IN AC1:  0,,process handle

  RETURNS     +1:  always, with the status word in AC1 and the PC in AC2

  Flags:

  B0-B17	     Unused, must be zero.

   The process status word has the following format:

	B0(RF%FRZ)	    The process is frozen.  If this bit  is  off,
			    the process is not frozen.

	B1-B17(RF%STS)	    The  status  code  for  the   process.    The
			    following values are possible:

			    Value   Symbol		  Meaning

			      0     .RFRUN	The process is runnable.

			      1     .RFIO	The process is	dismissed
						for I/O.

			      2     .RFHLT	The process is	dismissed
						by    voluntary   process
						termination   (HFORK   or
						HALTF)	 or   was   never
						started.

			      3     .RFFPT	The process is	dismissed
						by     forced	  process
						termination.	   Forced
						termination  occurs  when
						bit  17(SC%FRZ)  of   the
						process  capability  word
						is not set.

			      4     .RFWAT	The process is	dismissed
						waiting    for	  another
						process to terminate.

			      5     .RFSLP	The process is	dismissed
						for a specified amount of
						time.

			      6     .RFTRP	The process is	dismissed
						because  it  attempted to
						execute a call	on  which
						an intercept has been set
						by its superior (via  the
						TFORK call).

			      7     .RFABK	The process is	dismissed
   (RFSTS)
   

						because it encountered an
						instruction on	which  an
						address   break  was  set
						(via the ADBRK call).

	B18-B35(RF%SIC)     The number of the software interrupt  channel
			    that caused the forced process termination.

  The RFSTS call returns with -1 (fullword)  in  AC3  if  the	specified
   handle  is  assigned  but  refers  to  a  deleted  process.	 The call
   generates  an  illegal  instruction	interrupt  if	the   handle   is
   unassigned.

  LONG FORM:

  ACCEPTS IN AC1:  flags,,process handle

  AC2: 	    address of status return block (used  for  long  form
		    only)

  RETURNS     +1:  always

  Flags:

  B0	  RF%LNG       Long form call

  B1-B17	       Unused, must be zero.

  In the long form call, RF%LNG is set  in  AC1  and  AC2  contains  the
  address  of a status-return block.  On the return, AC1 and AC2 are not
  modified.  The status-return block has the following format:

  Word     Symbol     Meaning

   0	    .RFCNT     Count of words returned in this block in the  left
		       half,  and  count  of  maximum  number of words to
		       return in right half (including this word).   This
		       word is specified by the user.

   1	    .RFPSW     Process status  word.   This  word  has	the  same
		       format as AC1 on a return from a short call.

   2	    .RFPFL     Process	PC  flags.   These  are  the  same  flags
		       returned in AC2 on a short call.

   3	    .RFPPC     Process PC.  This is only the  PC,  no  flags  are
		       returned  in this word.	This word is specified by
		       the user.

   4	    .RFSFL     Status flag word.

		       Flags:

		       Bit    Symbol	Meaning
   (RFSTS)
   

		       B0     RF%EXO	Process is execute-only

   Generates an illegal instruction interrupt on error conditions below.

   RFSTS ERROR MNEMONICS:

   DECRSV    DEC reserved bits not zero

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RFTAD	Previous: RFSTS	Next: RIN	Up: Top
			     RFTAD     JSYS 533

   Returns the dates and times associated with the specified file.

   ACCEPTS IN AC1:  source designator

	      AC2:  address of argument block

	      AC3:  length of argument block

   RETURNS     +1:  always, dates returned in the argument block

   The format of the argument block is as follows:

      Word   Symbol	    Meaning

       0     .RSWRT    Internal date and time file was last written.

       1     .RSCRV    Internal date and time file was created.

       2     .RSREF    Internal date and time file was last referenced.

       3     .RSCRE    Internal system date and time of last write.

      4     .RSTDT    Tape-write date and time

      5     .RSNET    Online expiration date and time.  May  be  a  date
		       and  time  (in internal format) or an interval (in
		       days).  Intervals are limited to half-word values.

      6     .RSFET    Offline expiration date and time.  May be  a  date
		       and  time  (in internal format) or an interval (in
		       days).  Intervals are limited to half-word values.

   On a successful return, the values for the number of  words	specified
   in  AC3  are  returned  in  the argument block.  Words in the argument
   (RFTAD)
   

   block contain -1 if any one of the following occurs:

	1.  The corresponding date does not exist for the file.

	2.  The designator is not associated with a file.

	3.  The corresponding date is not currently assigned  (i.e.,  the
	    argument block contains more than 4 words).

   The SFTAD monitor call  can	be  used  to  set  the	dates  and  times
   associated with a specified file.

   Generates an illegal instruction interrupt on error conditions below.

   RFTAD ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX7:    JFN cannot refer to output wildcard designators


Node: RIN	Previous: RFTAD	Next: RIR	Up: Top
			      RIN     JSYS 54

   Inputs a byte nonsequentially  (i.e.,  random  byte	input)	from  the
   specified file.  The size of the byte is that given in the OPENF call.
   The RIN call can be used only when reading data from disk files.

   ACCEPTS IN AC1:  JFN

	      AC3:  byte number within the file

   RETURNS     +1:  always, with the byte right-justified in AC2

   If the end of the file is reached, AC2 contains 0.	The  program  can
   process  this  end-of-file  condition if an ERJMP or ERCAL is the next
   instruction following the RIN call.	Upon successful execution of  the
   call, the file's pointer is updated for subsequent I/O to the file.

   The ROUT monitor call can be used to output a byte nonsequentially  to
   a specified file.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   RIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator
   (RIN)
   

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   IOX1:     file is not open for reading

   IOX3:     illegal to change pointer for this opening of file

   IOX4:     end of file reached

   IOX5:     device or data error


Node: RIR	Previous: RIN	Next: RIRCM	Up: Top
			      RIR     JSYS 144

   Returns the	channel  and  priority	level  table  addresses  for  the
   specified  process.	 (Refer  to Section 2.5.3.) These table addresses
   are set by the SIR monitor call.  The RIR monitor call is useful  when
   several  independent  processes  in	one  job  want	to share software
   interrupt tables.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, with the priority level table address in  the
		    left  half	of  AC2, and the channel table address in
		    the right half of AC2

   AC2 contains 0 if the SIR monitor call has not been	executed  by  the
   designated process.

   Generates an illegal instruction interrupt on error conditions below.

   RIR ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RIRCM	Previous: RIR	Next: RLJFN	Up: Top
			     RIRCM     JSYS 143
   
   Returns the mask for reserved  software  interrupt  channels  for  the
   specified  process.	 A  process  is  able  to  read  its  own  or its
   inferiors' channel masks.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always,  with  the	reserved  channel  mask  for  the
		    specified process in AC2

   The SIRCM monitor call can be  used	to  set  the  mask  for  reserved
   software interrupt channels.

   Generates an illegal instruction interrupt on error conditions below.

   RIRCM ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RLJFN	Previous: RIRCM	Next: RMAP	Up: Top
			     RLJFN     JSYS 23

   Releases the specified JFNs.  A  JFN  cannot  be  released  unless  it
   either  has never been opened or has already been closed.  Also, a JFN
   cannot be released if it is currently being	assigned  by  a  process,
   unless  that process is the same as the one executing the RLJFN and is
   not at interrupt level.  The GS%ASG bit returned from a GTSTS call for
   the JFN indicates if the JFN is currently being assigned.

   ACCEPTS IN AC1:  JFN, or -1 to release all JFNs that  do  not  specify
		    open files

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   RLJFN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   RJFNX1:   file is not closed

   RJFNX2:   JFN is being used to accumulate filename
   (RLJFN)
   

   RJFNX3:   JFN is not accessible by this process

   OPNX1:    file is already open


Node: RMAP	Previous: RLJFN	Next: RNAMF	Up: Top
			      RMAP     JSYS 61

   Acquires a handle on a page in  a  process  to  determine  the  access
   allowed for that page.

   ACCEPTS IN AC1:  process handle in the left half, and  a  page  number
		    within the process in the right half

   RETURNS     +1:  always, with a handle on the page in AC1, and  access
		    information   in   AC2.   The  handle  in  AC1  is	a
		    process/file designator in the left half and  a  page
		    number in the right half.

   The access information returned in AC2 is as follows:

	B2(RM%RD)  read access allowed
	B3(RM%WR)  write access allowed
	B4(RM%EX)  execute access allowed
	B5(RM%PEX) page exists
	B9(RM%CPY) copy-on-write access

   On rare conditions, if the specified page is shared with a file but no
   JFN is associated with the file, AC1 contains -1 and AC2 contains 0.

   Generates an illegal instruction interrupt on error conditions below.

   RMAP ERROR MNEMONICS:

   FRKHX1:   invalid process handle


Node: RNAMF	Previous: RMAP	Next: ROUT	Up: Top
			     RNAMF     JSYS 35

   Renames an existing file.  The JFNs of both the existing file and  the
   new file specification must be closed.

   ACCEPTS IN AC1:  JFN of existing file  to  be  renamed  (i.e.,  source
		    file)

	      AC2:  JFN of new file specification (i.e., destination file
		    specification)
   (RNAMF)
   

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, JFN in AC1 is released, and the JFN  in  AC2
		    is	associated  with  the  file  under  its  new file
		    specification

   If the JFN of the new file specification already refers to an existing
   file, the existing file's contents are expunged.

   When a file is renamed, many of the attributes of  the  existing  file
   are given to the renamed file.  The settings of the following words in
   the FDB (refer to Section 2.2.8) are copied from the existing file  to
   the renamed file.

	Word	  .FBCTL (FB%LNG, FB%DIR, FB%NOD, FB%BAT, FB%FCF)
	Word	  .FBADR
	Word	  .FBCRE
	Word	  .FBGEN (FB%DRN)
	Word	  .FBBYV (FB%BSZ, FB%MOD, FB%PGC)
	Word	  .FBSIZ
	Word	  .FBCRV
	Word	  .FBWRT
	Word	  .FBREF
	Word	  .FBCNT
	Word	  .FBUSW

   Note that the setting of FB%PRM (permanent file) does not get  copied.
   Thus,  if  a  file with bit FB%PRM on is renamed, the renamed file has
   FB%PRM off.	The existing file is left in a	deleted  state	with  its
   contents empty but its FDB existent.

  Renaming a file with tape information (an archived or  migrated  file)
  carries  the  tape  information  to	the new file name.  Renames which
  would effectively destroy a file with archive status will fail.

   RNAMF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   OPNX1:    file is already open

   RNAMX1:   files are not on same device

   RNAMX2:   destination file expunged

   RNAMX3:   write or owner access to destination file required

   RNAMX4:   quota exceeded in destination of rename
   (RNAMF)
   

   RNAMX5:   destination file is not closed

   RNAMX6:   destination file has bad page table

   RNAMX7:   source file expunged

   RNAMX8:   write or owner access to source file required

   RNAMX9:   source file is nonexistent

   RNMX10:   source file is not closed

   RNMX11:   source file has bad page table

   RNMX12:   illegal to rename to self

   RNMX13:   insufficient system resources


Node: ROUT	Previous: RNAMF	Next: RPACS	Up: Top
			      ROUT     JSYS 55

   Outputs a byte nonsequentially  (i.e.,  random  byte  output)  to  the
   specified  file.  The size of the byte is that given in the OPENF call
   for the JFN.  The ROUT call can be used only when writing data to disk
   files.

   ACCEPTS IN AC1:  JFN

	      AC2:  the byte to be output, right-justified

	      AC3:  the byte number within the file

   RETURNS     +1:  always

   Upon successful execution of the call, the file's pointer  is  updated
   for subsequent I/O to the file.

   The RIN monitor call can be used to input a byte nonsequentially  from
   a specified file.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   ROUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned
   (ROUT)
   

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   IOX2:     file is not opened for writing

   IOX3:     illegal to change pointer for this opening of file

   IOX5:     device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX11:    quota exceeded or disk full


Node: RPACS	Previous: ROUT	Next: RPCAP	Up: Top
			     RPACS     JSYS 57

   Returns the accessibility of a page.

   ACCEPTS IN AC1:  process/file designator in the left  half,	and  page
		    number within the file in the right half

   RETURNS     +1:  always,   with   AC2   containing	 the	following
		    information:

		    B2(PA%RD)	read access allowed
		    B3(PA%WT)	write access allowed
		    B4(PA%EX)	execute access allowed
		    B5(PA%PEX)	page exists
		    B6(PA%IND)	indirect pointer
		    B9(PA%CPY)	copy-on-write
		    B10(PA%PRV) private page
		    B20(P1%RD)	read access allowed in first pointer
		    B21(P1%WT)	write access allowed in first pointer
		    B22(P1%EX)	execute access allowed in first pointer
		    B23(P1%PEX) page exists in first pointer
		    B27(P1%CPY) copy-on-write in first pointer

   The bits in the left half are  the  result  of  tracing  any  indirect
   pointer  chains,  and  the  bits in the right half contain information
   about the first pointer (the one in the map directly indicated by  the
   argument)  only.   The  left  half  and right half information will be
   different only if an indirect pointer was  encountered  in  the  first
   map.   In  this  case, B6(PA%IND) is set, the left half access is less
   than or equal to the right half access, and B9(PA%CPY) is  set  if  it
   was	found  set at any level.  B5(PA%PEX) and B10(PA%PRV) always refer
   to the last pointer (i.e., first non-indirect pointer) encountered.

   The SPACS monitor call can be used to set the accessibility of a page.

   Generates an illegal instruction interrupt on error conditions below.
   (RPACS)
   

   RPACS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   DESX8:    file is not on disk

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RPCAP	Previous: RPACS	Next: RSCAN	Up: Top
			     RPCAP     JSYS 150

   Returns the capabilities for the specified process.	(Refer to Section
   2.6.1 for the description of the capability word.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, capabilities possible  for	this  process  in
		    AC2, and capabilities enabled for this process in AC3

   The EPCAP monitor call can be used to enable  the  capabilities  of	a
   process.

   Generates an illegal instruction interrupt on error conditions below.

   RPCAP ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX3:   invalid use of multiple process handle


Node: RSCAN	Previous: RPCAP	Next: RTFRK	Up: Top
			     RSCAN     JSYS 500

   Places a text string in, or reads a text string from, the job's rescan
   buffer  (an	area of storage in the Job Storage Block).  This facility
   allows a program to receive information that will be used  as  primary
   input  for  another program before this other program reads input from
   (RSCAN)
   

   the terminal.

   The RSCAN call has two steps:  the acceptance and the use of the  text
   string.   Each  step has a different calling sequence.  The first step
   is to accept the text string to be used as input  and  to  place  this
   string  in  the  rescan  buffer.   The  calling sequence for this step
  specifies, in AC1, a pointer to the text string  to	be  input.   Note
  that  the  string  stored in the rescan buffer is terminated by a null
  byte.

   The second step is to cause the string to be available to the  program
   for	reading  via  the BIN call.  The calling sequence for this second
   step specifies a function code of 0(.RSINI) in AC1  to  indicate  that
   the	last  string  entered  at  command  level  from  the  terminal is
   available for reading.  The	program  executing  the  RSCAN	call  can
   determine  when  the  data has been read by issuing a function code of
   1(.RSCNT), which returns the number of  characters  remaining  in  the
   buffer.

   In other words, the first RSCAN call  specifying  a	new  text  string
   stores  the	string	in  the rescan buffer but does not cause it to be
   read.  A second RSCAN call must be given  before  the  string  can  be
   read.   This  second RSCAN causes the system to provide input from the
   most recent string stored and can be  given	only  once.   After  this
   second  RSCAN,  nothing  will  be  read  from  the rescan buffer until
   another RSCAN call specifying a different text string  is  given.   In
   addition,  the  job	receives input from the rescan buffer only if the
   source for input in the  BIN  call  is  the	JFN  of  the  controlling
   terminal.   Therefore,  if  the  source  for  input	is other than the
   controlling terminal, input will not come from the rescan buffer.

   ACCEPTS IN AC1:  byte pointer to a new text string, or 0 in	the  left
		    half and function code in the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The defined functions are as follows:

   Function	  Symbol		   Meaning

       0	  .RSINI    Make the data  in  the  buffer  available  as
			    input  to any process in the current job that
			    is	reading   data	 from	its   controlling
			    terminal.

       1	  .RSCNT    Return the number of characters remaining  to
			    be	read  in  the buffer.  This function does
			    not cause data to be read;	 it  is  used  to
			    determine  when  all  the  data has been read
			    after making the data available.

   On a successful return, AC1 contains an  updated  byte  pointer  if	a
   pointer  was given in the call.  Otherwise, AC1 contains the number of
   (RSCAN)
   

   characters in the rescan buffer or 0 if there are no characters.

  To clear the RSCAN buffer, supply a byte pointer (in AC1)  to  a  null
  string.

   RSCAN ERROR MNEMONICS:

   RSCNX2:   invalid function code


Node: RTFRK	Previous: RSCAN	Next: RTIW	Up: Top
			     RTFRK     JSYS 322

   Returns the handle of the process that  was	suspended  because  of	a
   monitor  call  intercept  and  the  monitor	call that the process was
   attempting to execute.  The superior process monitoring the intercepts
   can	receive only one interrupt at a time.  Thus, the superior process
   should execute the RTFRK call after receiving an interrupt to identify
   the process that caused the interrupt.

   The system maintains a queue of the processes that have been suspended
   and	that are waiting to interrupt the superior process monitoring the
   intercepts.	The RTFRK call advances the processes on the  queue,  and
   if the call is not executed, subsequent interrupts are not generated.

   See the description of the TFORK JSYS  for  more  information  on  the
   monitor call intercept facility.

   RETURNS     +1:  always, with AC1 containing the handle of the process
		    that  generated the interrupt, and AC2 containing the
		    monitor call instruction that caused the  process  to
		    be	suspended.   If no process is currently suspended
		    because of a monitor  call	intercept,  AC1  and  AC2
		    contain 0 on return.

   Because the process handle returned	in  AC1  is  a	relative  process
   handle,  it is possible that a process is currently suspended but that
   all relative handles are in use.  In  this  case,  the  caller  should
   release a relative process handle with the RFRKH call and then reissue
   the RTFRK call.

   Generates an illegal instruction interrupt on error conditions below.

   RTFRK ERROR MNEMONICS:

   FRKHX6:   all relative process handles in use
   (RTIW)
   


Node: RTIW	Previous: RTFRK	Next: RUNTM	Up: Top
			     RTIW     JSYS 173

   Reads the terminal interrupt word (refer to	Section  2.5.6)  for  the
   specified process or the entire job and returns the terminal interrupt
   word mask.

   ACCEPTS IN AC1:  B0(RT%DIM) return  the  mask  for  deferred  terminal
			       interrupts

		    B18-B35    process handle, or -5 for entire job
		    (RT%PRH)

   RETURNS     +1:  always, with the terminal interrupt mask in AC2,  and
		    the  deferred  terminal  interrupt	mask in AC3.  The
		    deferred interrupt mask  is  returned  only  if  both
		    B0(RT%DIM)	is on and the right half of AC1 indicates
		    a specific process.

   The STIW monitor call can be used to set the terminal  interrupt  word
   masks.

   Generates an illegal instruction interrupt on error conditions below.

   RTIW ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RUNTM	Previous: RTIW	Next: RWM	Up: Top
			     RUNTM     JSYS 15

   Returns the runtime of the specified process or of the entire job.

   ACCEPTS IN AC1:  process handle, or -5 for the entire job

   RETURNS     +1:  always,    with	runtime     (in     milliseconds)
		    right-justified  in AC1, a divisor to convert time to
		    seconds in AC2, and console time (in milliseconds) in
		    AC3.   AC2	always	contains  1000;   thus, it is not
		    necessary to examine its contents.

   Generates an illegal instruction interrupt on error conditions below.

   RUNTM ERROR MNEMONICS:

   FRKHX1:   invalid process handle
   (RUNTM)
   

   RUNTX1:   invalid process handle -3 or -4


Node: RWM	Previous: RUNTM	Next: RWSET	Up: Top
			      RWM     JSYS 135

   Returns the word mask for the interrupts waiting on software  channels
   for the specified process.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always, with

		    AC1 containing a 36-bit word with bit n on meaning an
			interrupt on channel n is waiting.

		    AC2 containing  the  status  of  the  interrupts   in
			progress.   Bit  n  on	in the left half means an
			interrupt of priority level  n	occurring  during
			execution  of user code is in progress.  Bit 18+n
			on in  the  right  half  means	an  interrupt  of
			priority  level  n  occurring during execution of
			monitor code is in progress.

   Generates an illegal instruction interrupt on error conditions below.

   RWM ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: RWSET	Previous: RWM	Next: SACTF	Up: Top
			     RWSET     JSYS 176

   Releases the working set by removing all of the current process' pages
   from  its  working  set.  The pages are moved to secondary storage and
   are not preloaded the next time  the  process  is  swapped  in.   This
   operation is invisible to the user.

   RETURNS     +1:  always
   (SACTF)
   


Node: SACTF	Previous: RWSET	Next: SAVE	Up: Top
			     SACTF     JSYS 62

   Sets the account to which the specified file is to be charged.

   ACCEPTS IN AC1:  JFN

	      AC2:  account number in  bits  3-35  if  bits  0-2  are  5.
		    Otherwise  contains  a  byte  pointer  to  an account
		    string in the address space of  caller.   If  a  null
		    byte  is  not seen, the string is terminated after 39
		    characters are processed.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC2

   If the account validation facility is enabled, the SACTF call verifies
   the	account  given	and  returns  an error if it is not valid for the
   caller.

   The GACTF monitor call can be used to obtain the account designator to
   which a file is being charged.

   SACTF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   SACTX1:   file is not on multiple-directory device

   SACTX2:   insufficient system resources (Job Storage Block full)

   SACTX3:   directory requires numeric account

   SACTX4:   write or owner access required

   VACCX0:   invalid account

   VACCX1:   account string exceeds 39 characters

   VACCX2:   account has expired


Node: SAVE	Previous: SACTF	Next: SCTTY	Up: Top
			     SAVE     JSYS 202

   Saves, in nonsharable format, pages of a process  into  the	specified
   file.   (Refer  to  Section 2.7.1 for the format of a nonsharable save
   (SAVE)
   

   file.) This file can then be copied into a given process with the  GET
   monitor call.

   ACCEPTS IN AC1:  process handle in the left half, and JFN in the right
		    half

	      AC2:  one table entry, or 0 in the left half and pointer to
		    the table in the right half (see below)

   RETURNS     +1:  always

   The table has words in the format:  length of the area to save in  the
   left  half  and  address  of the first word to save in the right half.
   The table is terminated by a 0 word.

   Nonexistent pages are not saved.  The SAVE call also does not save the
   accumulators.   Thus,  it  is  possible  to	save all assigned nonzero
   memory with the one table entry 777760,,20 in AC2.

   The SAVE call closes and releases the given JFN.

   Can cause several  software	interrupts  or	process  terminations  on
   certain file conditions.

   Generates an illegal instruction interrupt on error conditions below.

   SAVE ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process

   SAVX1:    illegal to save files on this device

   IOX11:    quota exceeded or disk full

   All file errors can also occur.


Node: SCTTY	Previous: SAVE	Next: SCVEC	Up: Top
			     SCTTY     JSYS 324

   Redefines the controlling terminal for the specified process  and  all
   of  its  inferiors.	 The controlling terminal can be redefined at any
   level in the job's process structure;  inferior processes  below  this
   level will use this terminal by default as their controlling terminal.
   Therefore, the controlling terminal of a process is defined to be:
   (SCTTY)
   

	1.  The one that has been explicitly defined for it via  a  SCTTY
	    call.

	2.  If no terminal has been explicitly defined for  the  process,
	    the terminal that has been explicitly defined for its closest
	    superior via a SCTTY call.

	3.  If no SCTTY call has been executed for  a  superior  process,
	    the job's controlling terminal.

   The effect of terminal interrupts on a  process  is	dictated  by  the
   controlling	terminal for the process.  This means that processes that
   have enabled specific terminal characters will  receive  an	interrupt
   when  those	characters  are typed on the controlling terminal.  If no
   SCTTY call  has  been  executed  for  any  process  in  the	job,  the
   controlling	terminal  for  all  processes within the job is the job's
   controlling terminal.  (The job's controlling terminal is usually  the
   one	used  to  log  in and control the job.)  In addition to being the
   source of all terminal  interrupts,	the  job's  controlling  terminal
   serves  as  the primary I/O designators (refer to Section 1.1) for all
   processes in the job, unless these designators have been changed for a
   process.

   When a SCTTY call  is  executed  for  a  process  within  a	job,  the
   controlling terminal and the source of terminal interrupts are changed
   for that process and all of its inferiors.  This  group  of	processes
   will  receive interrupts only from the new controlling terminal and no
   longer from the job's controlling terminal.	 These	processes  cannot
   receive  or	change	terminal  interrupts  from  any other controlling
   terminals.  However, primary I/O will continue to be received from and
   sent  to the job's controlling terminal if the primary I/O designators
   have not  been  changed.   For  most  applications,	the  primary  I/O
   designators should be changed with the SPJFN call to correspond to the
   new controlling terminal.

   ACCEPTS IN AC1:  function code in the left half, and process handle in
		    the right half

	      AC2:  terminal designator

   RETURNS     +1:  always

   The available functions are as follows:

      Code   Symbol			   Meaning

       0     .SCRET	    Return the designator of the  given  process'
			    controlling   terminal.   The  designator  is
			    returned in AC2.

       1     .SCSET	    Change   the   given   process'   controlling
			    terminal  to  the terminal designated in AC2.
			    The terminal designator cannot refer  to  the
			    job's  controlling	terminal.   This function
			    also changes the controlling terminal of  all
   (SCTTY)
   

			    processes inferior to the given process.

       2     .SCRST	    Reset the given process' controlling terminal
			    to	the  job's  controlling  terminal.   This
			    function also resets the controlling terminal
			    of	 all  processes  inferior  to  the  given
			    process.

   Functions .SCSET and .SCRST require the process  to	have  the  SC%SCT
   capability (refer to Section 2.6.1) enabled in its capability word.

   The SCTTY monitor call  cannot  be  used  to  change  the  controlling
   terminal  for  the  current process or for any process superior to the
   current process.

   Generates an illegal instruction interrupt on error conditions below.

   SCTTY ERROR MNEMONICS:

   SCTX1:    invalid function code

   SCTX2:    terminal already in use as controlling terminal

   SCTX3:    illegal to redefine the job's controlling terminal

   SCTX4:    SC%SCT capability required

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   DESX1:    invalid source/destination designator

   DEVX2:    device already assigned to another job


Node: SCVEC	Previous: SCTTY	Next: SDSTS	Up: Top
			     SCVEC     JSYS 301

   Sets the entry vector and the  UUO  locations  for  the  compatibility
   package.

   ACCEPTS IN AC1:  process handle

	      AC2:  entry vector length  in  the  left	half,  and  entry
		    vector address in the right half

	      AC3:  UUO location in the left half, and PC location in the
		    right half

   RETURNS     +1:  always
   (SCVEC)
   

   The compatibility package's entry vector is as follows:

	Word	  Symbol	      Meaning

	  0	  .SVEAD    Entry address for interpreting UUO's

	  1	  .SVINE    Initial entry for setup and first UUO

	  2	  .SVGET    Entry for GET share file routine (obsolete)

	  3	  .SV40     Address to receive contents of location 40 on
			    the UUO call

	  4	  .SVRPC    Address to receive the return PC word on  the
			    UUO call

	  5	  .SVMAK    Entry for MAKE share file routine (obsolete)

	6 and 7   .SVCST    Communication  for	handling  CTRL/C,   START
			    sequences  between	the compatibility package
			    and the TOPS-20 Command Language

   The monitor transfers to the address specified in the  right  half  of
   AC2 on any monitor call whose operation code is 040-077 (i.e., monitor
   UUO).  This transfer occurs after the monitor stores the  contents  of
   location  40  and the return PC in the locations specified by the left
   half and right  half  of  AC3,  respectively.   The	entry  vector  is
   retained but is not used by the monitor.

   If AC2 is 0, the next UUO  causes  the  compatibility  package  to  be
   merged  into the caller's address space.  In this case, the UUO and PC
   locations  are  set	from  words  3	and  4,  respectively,	 of   the
   compatibility package's entry vector.

   If AC2 is -1, UUO simulation is disabled, and an occurrence of  a  UUO
   is  considered an illegal instruction.  This action is useful when the
   user is removing UUO's from a program.

   The GCVEC monitor call can be used to obtain the entry vector for  the
   compatibility package.

   SCVEC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX4:   process is running

  FRKHX8:   illegal to manipulate an execute-only process
   (SDSTS)
   


Node: SDSTS	Previous: SCVEC	Next: SDVEC	Up: Top
			     SDSTS     JSYS 146

   Sets  the  status  of  a  device.   (Refer  to  Section  2.4  for  the
   descriptions  of  the status bits.) This call requires that the device
   be opened.

   ACCEPTS IN AC1:  JFN

	      AC2:  new status bits

   RETURNS     +1:  always

   The	SDSTS  call  is  a  no-op  for	 devices   that   do   not   have
   device-dependent status bits.

   The GDSTS monitor call can be used to obtain the  status  bits  for	a
   particular device.

   Generates an illegal instruction interrupt on error conditions below.

   SDSTS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

  DESX9:    invalid operation for this device


Node: SDVEC	Previous: SDSTS	Next: SETER	Up: Top
			     SDVEC     JSYS 543

   Sets the entry vector for the Record Management System (RMS).

   RESTRICTIONS:    requires RMS and BASIC software

   ACCEPTS IN AC1:  process handle

	      AC2:  entry vector length  in  the  left	half,  and  entry
		    vector address in the right half

   RETURNS     +1:  always

   The Record Management System's entry vector is as follows:
   (SDVEC)
   

	Word	  Symbol	      Meaning

	 0	  .SDEAD    Entry address for the RMS calls
	 1	  .SDINE    Inital entry for the first RMS call
	 2	  .SDVER    Pointer to RMS version block
	 3	  .SDDMS    Address in which to store the RMS call
	 4	  .SDRPC    Address in which to store return PC word

   The GDVEC monitor call can be used to obtain the entry vector for RMS.

   Generates an illegal instruction interrupt on error conditions below.

   SDVEC ERROR MNEMONICS:

   ILINS5:   RMS facility is not available

  FRKHX8:   illegal to manipulate an execute-only process


Node: SETER	Previous: SDVEC	Next: SETJB	Up: Top
			     SETER     JSYS 336

   Sets the most recent error condition encountered by a  process.   This
   error condition is stored in the process' Process Storage Block.

   ACCEPTS IN AC1:  process handle

	      AC2:  error code that is to be set

   RETURNS     +1:  always

   The GETER monitor call can be used to obtain  the  most  recent  error
   condition encountered by a process.

   Generates an illegal instruction interrupt on error conditions below.

   SETER ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   process is running

  FRKHX8:   illegal to manipulate an execute-only process


Node: SETJB	Previous: SETER	Next: SETNM	Up: Top
			     SETJB     JSYS 541
   (SETJB)
   

   Sets job parameters for the specified job.

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled

   ACCEPTS IN AC1:  job number, or -1 for the current job

	      AC2:  function code

	      AC3:  value for function

   RETURNS     +1:  always

   The available  functions,  along  with  the	legal  values  for  these
   functions, are described below.

   Function	   Values		   Meaning

   .SJDEN(0)			 Set default for magnetic tape density.

		  .SJDDN(0)	   System default density
		  .SJDN2(1)	   200 bits/inch (8.1 rows/mm)
		  .SJDN5(2)	   556 bits/inch (22.5 rows/mm)
		  .SJDN8(3)	   800 bits/inch (32.2 rows/mm)
		  .SJD16(4)	   1600 bits/inch (65.3 rows/mm)
		  .SJD62(5)	   6250 bits/inch (246 rows/mm)

   .SJPAR(1)			 Set default for magnetic tape parity.

		  .SJPRO(0)	   Odd parity
		  .SJPRE(1)	   Even parity

   .SJDM(2)			 Set default for magnetic tape data mode.

		  .SJDDM(0)	   System default data mode
		  .SJDMC(1)	   Dump mode
		  .SJDM6(2)	   SIXBIT byte mode (7-track drives)
		  .SJDMA(3)	   ANSI  ASCII	mode  (7  bits	in  8-bit
				   bytes)
		  .SJDM8(4)	   Industry compatible mode
		  .SJDMH(5)	   High-density mode for  TU70	and  TU72
				   tape  drives only (nine 8-bit bytes in
				   two words)

  .SJRS(3)			 Set default  for  magnetic  tape  record
				 size  in  bytes.   The maximum allowable
				 number of bytes depends on the  hardware
				 data mode specified for the drive:

							  Maximum
				 Data Mode		  Number Bytes

				 default		     -
				 dump			   8192
				 SIXBIT 		  49152
   (SETJB)
   

				 ANSI ASCII		  40960
				 industry compatible	  32768
				 high density		   8192

				 Note that the SETJB JSYS will not return
				 an error message if the above values are
				 exceeded.  However,  the  OPENF  or  the
				 first	 data	transfer   (whichever  is
				 performed first  after  function  .SJDM)
				 will  fail.   Note  that  MTOPR function
				 .MOSRS  can  be  used	to  override  the
				 default record size specified with SETJB
				 function .SJDM.

   .SJDFS(4)			 Set spooling mode.

		  .SJSPI(0)	   Immediate mode spooling
		  .SJSPD(1)	   Deferred mode spooling

   .SJSRM(5)			 Set remark for current job session.  AC3
				 contains   a	pointer  to  the  session
				 remark, which is updated on a successful
				 return.   The first 39 characters of the
				 session remark are placed in  the  job's
				 Job Storage Block.

  .SJT20(6)			 Indicate if job  is  at  EXEC	level  or
				 program level.

		  -1		   job is at EXEC level
		   0		   job is at program level

  .SJDFR(7)			 Set job  default  retrieval.	Allows	a
				 user  to override the system default for
				 OPENF.

		  .SJRFA(0)	   OPENF should  always  fail  if  file's
				   contents  are not online.  This is the
				   system default.
		  .SJRWA(1)	   OPENF should wait for the ARCF JSYS to
				   restore  the  contents  of  a  file to
				   disk.

   The SETJB monitor call requires the process to have WHEEL or  OPERATOR
   capability  enabled to set parameters for a job other than the current
   job.

   The GETJI monitor call can be used to obtain the job parameters for	a
   specified job.

   Generates an illegal instruction interrupt on error conditions below.

   SETJB ERROR MNEMONICS:

   SJBX1:    invalid function
   (SETJB)
   

   SJBX2:    invalid magnetic tape density

   SJBX3:    invalid magnetic tape data mode

   SJBX4:    invalid job number

   SJBX5:    job is not logged in

   SJBX6:    WHEEL or OPERATOR capability required

   SJBX7:    remark exceeds 39 characters

   SJBX8:    illegal to perform this function


Node: SETNM	Previous: SETJB	Next: SETSN	Up: Top
			     SETNM     JSYS 210

   Sets the private name of the program being used by  the  current  job.
   This name is the one printed on SYSTAT listings.

   ACCEPTS IN AC1:  SIXBIT name used to identify program

   RETURNS     +1:  always

   The GETNM monitor call can be used to obtain the name of  the  program
   currently being used.


Node: SETSN	Previous: SETNM	Next: SEVEC	Up: Top
			     SETSN     JSYS 506

   Sets either the system name or the private name of the  program  being
   used by the current job.

   ACCEPTS IN AC1:  SIXBIT name to be used as the system name.	This name
		    is the one used for system statistics.

	      AC2:  SIXBIT name to be used as  the  private  name.   This
		    name is the same as the one set with the SETNM call.

   RETURNS     +1:  failure.  (Currently, there are  no  failure  returns
		    defined.)

	       +2:  success

   System program usage statistics are accumulated in the  system  tables
   SNAMES,  STIMES,  and  SPFLTS.  (Refer to Section 2.3.2.) To make this
   (SETSN)
   

   possible, the SETSN call must be executed by  each  job  whenever  the
   system  program  name  is  changed.	 In  the  usual case, the TOPS-20
  Command Language handles this.  The argument to SETSN should be:   for
  system  programs  (programs	from SYS:) the filename, truncated to six
   characters and converted to SIXBIT;	for private programs, "(PRIV)."


Node: SEVEC	Previous: SETSN	Next: SFACS	Up: Top
			     SEVEC     JSYS 204

   Sets the entry vector of the specified  process.   (Refer  to  Section
   2.7.3.)

   ACCEPTS IN AC1:  process handle

	      AC2:  entry vector  word	(length  in  the  left	half  and
		    address of first word in the right half), or 0

   RETURNS     +1:  always

   The GEVEC monitor call can  be  used  to  obtain  the  process'  entry
   vector.

   Generates an illegal instruction interrupt on error conditions below.

   SEVEC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process

   SEVEX1:   entry vector is not less than 1000


Node: SFACS	Previous: SEVEC	Next: SFBSZ	Up: Top
			     SFACS     JSYS 160

   Sets the ACs of the specified process.

   ACCEPTS IN AC1:  process handle

	      AC2:  address of the beginning of a 20(octal) word table in
		    the  caller's address space.  This table contains the
		    values to be placed into the  ACs  of  the	specified
		    process.
   (SFACS)
   

   RETURNS     +1:  always

   The specified process must not be running.

   The RFACS call can be used to obtain the ACs for a specified process.

   Generates an illegal instruction interrupt on error conditions below.

   SFACS ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX4:   process is running

  FRKHX8:   illegal to manipulate an execute-only process


Node: SFBSZ	Previous: SFACS	Next: SFCOC	Up: Top
			     SFBSZ     JSYS 46

   Resets the byte size for a specific opening of a file.  (Refer to  the
   OPENF and RFBSZ calls descriptions.)

   ACCEPTS IN AC1:  JFN

	      AC2:  byte size, right-justified

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The SFBSZ monitor call recomputes the EOF limit and the file's pointer
   based on the new byte size given.

   SFBSZ ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   DESX8:    file is not on disk
   (SFBSZ)
   

   SFBSX1:   illegal to change byte size for this opening of file

   SFBX2:    invalid byte size


Node: SFCOC	Previous: SFBSZ	Next: SFMOD	Up: Top
			     SFCOC     JSYS 113

   Sets the control character output control  (CCOC)  for  the	specified
   terminal.  (Refer to Section 2.4.3.2 and the RFCOC call description.)

   ACCEPTS IN AC1:  file designator

	      AC2:  control character output control word

	      AC3:  control character output control word

   RETURNS     +1:  always

   The CCOC words consist of 2-bit  bytes,  each  byte	representing  the
   output control for one of the ASCII codes 0-37.

   The SFCOC call is a no-op if the designator is not associated  with	a
   terminal.

   The RFCOC monitor call can be used to obtain  the  CCOC  words  for	a
   specified terminal.

   SFCOC ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: SFMOD	Previous: SFCOC	Next: SFORK	Up: Top
			     SFMOD     JSYS 110

   Sets the program-related modes for the specified terminal.  The  modes
   that can be set by this call are in the following bits of the JFN mode
   (SFMOD)
   

   word.  (Refer to Section 2.4.3.1.)

	B0(TT%OSP)	output suppression control
	B18-B23(TT%WAK) wakeup control
	B24(TT%ECO)	echoes on
	B28-B29(TT%DAM) data mode

   ACCEPTS IN AC1:  file designator

	      AC2:  JFN mode word

   RETURNS     +1:  always

   The SFMOD call is a no-op if the designator is not associated  with	a
   terminal.

   The STPAR monitor call can be used to set device-related modes of  the
   JFN	mode  word,  and the RFMOD monitor call can be used to obtain the
   JFN mode word.

   SFMOD ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: SFORK	Previous: SFMOD	Next: SFPOS	Up: Top
			     SFORK     JSYS 157

   Starts the specified process.  If the process  is  frozen,  the  SFORK
   call  changes  the PC but does not resume the process.  The RFORK call
   must be used to resume the process.

   ACCEPTS IN AC1:  process handle

	      AC2:  the PC of the process being started.  The PC contains
		    flags  in the left half and the process start address
		    in the right half.

   RETURNS     +1:  always

   The SFRKV monitor call can be used to  start  a  process  at  a  given
   position in its entry vector.

   Generates an illegal instruction interrupt on error conditions below.
   (SFORK)
   

   SFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: SFPOS	Previous: SFORK	Next: SFPTR	Up: Top
			     SFPOS     JSYS 526

   Sets the position of the  specified	terminal's  pointer.   (Refer  to
   Section  2.4.3.4  for  information  on  page  lengths  and  widths  of
   terminals.)

   ACCEPTS IN AC1:  file designator

	      AC2:  position within a page (i.e.,  line  number)  in  the
		    left  half,  and  position	with a line (i.e., column
		    number) in the right half

   RETURNS     +1:  always

   The SFPOS monitor call is a no-op if the designator is not  associated
   with a terminal or is in any way illegal.

   The RFPOS monitor call can be used to obtain the current  position  of
   the terminal's pointer.

   SFPOS ERROR MNEMONICS:

   TTYX01:   line is not active


Node: SFPTR	Previous: SFPOS	Next: SFRKV	Up: Top
			     SFPTR     JSYS 27

   Sets the position of the specified file's pointer for  subsequent  I/O
   to  the  file.   The  SFPTR	call  specifying  a  certain byte number,
   followed by a BIN call, has the same effect as a RIN  call  specifying
   the same byte number.

   ACCEPTS IN AC1:  JFN

	      AC2:  byte number to which the pointer is to be set, or  -1
		    to set the pointer to the current end of the file
   (SFPTR)
   

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The RFPTR monitor call can be used to obtain the current  position  of
   the file's pointer.

   SFPTR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX8:    file is not on disk

   SFPTX1:   file is not open

   SFPTX2:   illegal to reset pointer for this file

   SFPTX3:   invalid byte number


Node: SFRKV	Previous: SFPTR	Next: SFTAD	Up: Top
			     SFRKV     JSYS 201

   Starts the specified process using the given  position  in  its  entry
   vector.

   ACCEPTS IN AC1:  process handle

	      AC2:  position (0-n) in the entry vector	to  use  for  the
		    start  address.   Position	0  is  always the primary
		    start address, and position 1 is the reenter address.

   RETURNS     +1:  always

   The process is started at the specified position in the entry  vector,
   not at the location pointed to by the entry vector word.

   If the process has a TOPS-10 format entry vector  (JRST  in	the  left
   half)  (for	example,  it was obtained from a TOPS-10 format save file
  via a GET call), then the left half of AC2 in the SFRKV  call  is  the
  start  address  offset.   The only legal offsets are 0 and 1, and they
  are only legal for entry vector position 0 (start address).	Thus, for
  TOPS-10  entry  vectors,  the  left	half  of AC2 will be added to the
  contents of .JBSA before using this value to start the program.
   (SFRKV)
   

   Entry vector position 0 means "use the contents of  .JBSA=120  as  the
   start  address,"  and position 1 means "use the contents of .JBREN=124
   as the reenter address."

  Note that it is illegal to use an entry vector position other  than	0
  or 1 for an execute-only process.

   Generates an illegal instruction interrupt on error conditions below.

   SFRKV ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX4:   process is running

  FRKHX8:   illegal to manipulate an execute-only process

   SFRVX1:   invalid position in entry vector


Node: SFTAD	Previous: SFRKV	Next: SFUST	Up: Top
			     SFTAD     JSYS 534

   Sets the dates and times associated with the specified file.

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled

   ACCEPTS IN AC1:  source designator

	      AC2:  address of argument block

	      AC3:  length of argument block

   RETURNS     +1:  always

   The format of the argument block is as follows:

      Word   Symbol		 Meaning

       0     .RSWRT    Internal date and time file was last written.

       1     .RSCRV    Internal date and time file was created.

       2     .RSREF    Internal date and time file was last referenced.

       3     .RSCRE    Internal date and time of last write.
   (SFTAD)
   

      4     .RSTDT    Tape-write date and time

      5     .RSNET    Online expiration date and time.  May  be  a  date
		       and  time  (in internal format) or an interval (in
		       days).  Intervals are limited to half-word values.
		       Date/times    and   intervals   may   not   exceed
		       system/directory maximum.

      6     .RSFET    Offline expiration date and time.  May be  a  date
		       and  time  (in internal format) or an interval (in
		       days).  Intervals are limited to half-word values.
		       Date/times    and   intervals   may   not   exceed
		       system/directory maximum.

   The values in the argument  block  for  the	number	of  words  (i.e.,
   length)  given  in AC3 are set for the file.  These values are checked
   against the current date and time.  Values greater  than  the  current
   date  and  time  can  be set only if the process has WHEEL or OPERATOR
   capability enabled.	In addition,  the  process  must  have	WHEEL  or
   OPERATOR capability enabled to set the internal system date (.RSCRE).

   If the designator represents a device for which dates are  meaningless
   (e.g.,  dates  for  terminals), or if any value given is -1, the given
   value is ignored, and the current date, if pertinent, is not  changed.
   If the argument block has more than four words, given values for these
   words are checked to be in valid format and then ignored, if valid.

   To set dates for disk files, the process  must  have  write	or  owner
   access to the file.

   The RFTAD monitor call can be used  to  obtain  the	dates  and  times
   associated with a specified file.

   Generates an illegal instruction interrupt on error conditions below.

   SFTAD ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX7:    JFN cannot refer to output wildcard designators

   DATE6:    system date and time not set

   STADX2:   invalid date or time

   CFDBX2:   illegal to change specified bits

   OPNX25:   device is write locked

   CAPX1:    WHEEL or OPERATOR capability required

   (SFUST)
   


Node: SFUST	Previous: SFTAD	Next: SIBE	Up: Top
			     SFUST     JSYS 551

   Sets the name of either the author of the file or the  user	who  last
   wrote to the file.

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled

   ACCEPTS IN AC1:  function code in the left half, and JFN of	the  file
		    in the right half

	      AC2:  byte pointer to ASCIZ string containing the name

   RETURNS     +1:  always, with an updated byte pointer in AC2

   The defined functions are as follows:

      Code   Symbol			   Meaning

       0     .SFAUT	    Set the name of the author of the file.

       1     .SFLWR	    Set the name of the user who last  wrote  the
			    file.

   The GFUST monitor call can be used to return the name  of  either  the
   author of the file or the user who last wrote the file.

   The process must have WHEEL or OPERATOR capability enabled to set  the
   writer's  name or to have write or owner access to the file to set the
   author's name.

   Generates an illegal instruction interrupt on error conditions below.

   SFUST ERROR MNEMONICS:

   SFUSX1:   invalid function

   SFUSX2:   insufficient system resources

   SFUSX4:   file expunged

   SFUSX5:   write or owner access required

   SFUSX6:   no such user name

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators
   (SFUST)
   

   DESX8:    file is not on disk

   DESX10:   structure is dismounted

   CAPX1:    WHEEL or OPERATOR capability required


Node: SIBE	Previous: SFUST	Next: SIN	Up: Top
			     SIBE     JSYS 102

   Tests to see if the designated file input buffer is empty.

   ACCEPTS IN AC1:  source designator

  RETURNS     +1:

		    (one of the following is true:)

		    1.	The device is an active terminal  and  the  input
			buffer is not empty.  AC2 contains a count of the
			bytes remaining in the input buffer.

		    2.	The device is not a terminal, is open  for  read,
			and  the input buffer is not empty.  AC2 contains
			a count of  the  bytes	remaining  in  the  input
			buffer.

	       +2:

		    (one of the following is true:)

		    1.	The  device  is  a  non-active	 terminal.    AC2
			contains the error code.

		    2.	The device is an active terminal  and  the  input
			buffer is empty.  AC2 contains zero.

		    3.	The device is not a terminal and is not open  for
			read.  AC2 contains zero.

		    4.	The device is not a terminal, is open  for  read,
			and  the  input  buffer  is  empty.  AC2 contains
			zero.

   The SOBE monitor call can be used to determine if the output buffer is
   empty,  and	the  SOBF  monitor  call  can be used to determine if the
   output buffer is full.
   (SIBE)
   

   SIBE ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: SIN	Previous: SIBE	Next: SINM	Up: Top
			      SIN     JSYS 52

   Reads a string from the specified source  into  the	caller's  address
   space.   The  string  can be a specified number of bytes or terminated
   with a specified byte.

   ACCEPTS IN AC1:  source designator

	      AC2:  byte pointer to string in the caller's address space

	      AC3:  count of number of bytes in string, or 0

	      AC4:  byte (right-justified) on which  to  terminate  input
		    (optional)

   RETURNS     +1:  always, updated byte pointers  in  AC2  and  AC1,  if
		    pertinent, and updated count in AC3, if pertinent

   The contents of AC3 controls the number of bytes to read.

	AC3=0	  The string being read is terminated with a 0 byte.

	AC3>0	  A string of the specified number of bytes is to be read
		  or a string terminated with the byte given in AC4 is to
		  be read, whichever occurs first.

	AC3<0	  A string of minus the specified number of bytes  is  to
		  be read.

   The contents of AC4 is  ignored  unless  the  contents  of  AC3  is	a
   positive number.

   The input is terminated when the byte count becomes 0,  the	specified
   terminating	byte  is  reached,  the end of the file is reached, or an
   error  occurs  during  the  transfer.   The	program  can  process  an
   end-of-file	condition  if  an  ERJMP or ERCAL is the next instruction
   following the SIN call.
   (SIN)
   

   After execution of  the  call,  the	file's	pointer  is  updated  for
   subsequent  I/O to the file.  AC2 is updated to point to the last byte
   read or, if AC3 contained 0, the last nonzero byte read.  The count in
   AC3	is  updated  toward  zero by subtracting the number of bytes read
   from the number of bytes requested to  be  read.   If  the  input  was
   terminated  by  an  end-of-file interrupt, AC1 through AC3 are updated
   (where pertinent) to reflect the number of  bytes  transferred  before
   the end of the file was reached.

   When the SIN call is used to read data from a magnetic tape, the  size
   of  the  records  to  read  is  specified  with  either  the  SET TAPE
   RECORD-LENGTH command or the .MOSRS function of the MTOPR  call.   The
   default  record size is 1000(octal) words.  The record size must be at
   least as large as the largest record being read from  the  tape.   The
   SIN call will read across record boundaries on the tape until it reads
   the number of bytes requested by the contents of AC3.  The call  gives
   the	data  to  the program with no indication of tape marks.  Thus, if
   the record is 1000 bytes and a  SIN	call  is  given  requesting  2000
   bytes, it would return two full records to the program.

   When reading in reverse, the number	of  bytes  requested  (i.e.,  the
   count  in AC3) and the record size should equal the actual size of the
   record on the tape.	(Refer to Section 2.4.2.1  for	more  information
   about magnetic tape I/O.)

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   Generates an illegal instruction interrupt on error conditions below.

   SIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX1:     file is not open for reading

   IOX4:     end of file reached

   IOX5:     device or data error

   IOX7:     insufficient system resources (Job Storage Block full)

   IOX8:     monitor internal error
   (SINM)
   


Node: SINM	Previous: SIN	Next: SINR	Up: Top
			     SINM     JSYS 571

  Reads data from a block-mode terminal on a multiplexed JFN.

  RESTRICTIONS:    requires DECnet and ATS software

  ACCEPTS IN AC1:  source designator

	      AC2:  address of argument block

  RETURNS:	    +1 always

  Argument block (user supplied):

  Word     Contents

   0	    flags,,number of words in block (including this word)

	    Flags:

	    Bit    Symbol    Meaning

	    B0	   SI%TMG    Truncate message if too long and give error

   1	    destination designator

   2	    0,,count of space for input

   3	    Reserved for user's identifier

   4	    Reserved for available count

  Argument block (returned):

  Word     Contents

   0	    flags,,number of words in block (including this word)

	    Flags:

	    Bit    Symbol    Meaning

	    B1	   SI%EOM    end of terminal's message was encountered

   1	     updated destination designator

   2	    0,, updated count

   3	    user's identifier for terminal

   4	    count of available bytes

  SINM ERROR MNEMONICS:
   (SINM)
   

  ARGX17:   invalid argument block length

  ARGX22:   Invalid flags

  ATSX06:   JFN is not an ATS JFN

  ATSX09:   Table length too large

  ATSX11:   Byte count is too large

  DESX4:    invalid use of terminal designator or string pointer

  IOX1:     file is not open for reading



Node: SINR	Previous: SINM	Next: SIR	Up: Top
			     SINR     JSYS 531

   Reads a record from the specified  magnetic	tape  into  the  caller's
   address  space.   The  maximum size of the record to read is specified
   with either the SET TAPE RECORD-LENGTH command or the .MOSRS  function
   of  the  MTOPR  call.   The	default record size is 1000(octal) words.
   Refer to Section 2.4.2.1 for more information about magnetic tape I/O.

   ACCEPTS IN AC1:  source designator

	      AC2:  byte pointer to string in the caller's address space

	      AC3:  count of number of bytes in string, or 0

	      AC4:  byte (right-justified) on which  to  terminate  input
		    (optional)

   RETURNS     +1:  always, updated byte pointers  in  AC2  and  AC1,  if
		    pertinent, and updated count in AC3, if pertinent

   The contents of AC3 and AC4 are interpreted in the same manner as they
   are in the SIN monitor call.

   Each SINR call returns one record to the caller.  Thus, the caller can
   read  variable-length records by indicating in AC3 the number of bytes
   to read.  Upon execution of the call, AC3 is updated  to  reflect  the
   number of bytes read (i.e., the number of bytes in the record).

   The number of bytes read depends on the number of bytes requested  and
   the	record	size.	When  using SINR, the program must set the record
   size to a value greater than or  equal  to  the  actual  size  of  the
   largest  record  being  read from the tape, or an error (IOX5) will be
   returned.  If the SINR call requests the same number of bytes  as  the
   record  size,  the  requested number is given to the caller.  When the
   record size equals the size of the actual record,  all  bytes  in  the
   (SINR)
   

   record  are	read, and AC3 contains 0 on return.  When the record size
   is larger than the actual record, all bytes of the  record  are  read,
   but AC3 contains the difference of the number requested and the number
   read.  If the SINR call  requests  fewer  bytes  than  in  the  actual
   record,  the  requested  number  is given to the caller, the remaining
   bytes are discarded, and an error (IOX10) is returned.  In all  cases,
   the	next  request  for  input begins reading at the first byte of the
   next record on the tape because a SINR call never reads across  record
   boundaries.

   When reading in reverse, the number	of  bytes  requested  (i.e.,  the
   count in AC3) should be at least as large as the size of the record on
   the tape.  If the requested number is smaller, the remaining bytes  in
   the record are discarded from the beginning of the record.

   The action taken on a SINR call differs from the action taken on a SIN
   call.   The	SIN  call  reads across record boundaries to read all the
   bytes in a file.  The SINR call does not read across record boundaries
   and	will  discard  some  bytes in the file if the requested number is
   smaller than the actual record.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   Generates an illegal instruction interrupt on error conditions below.

   SINR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX1:     file is not open for reading

   IOX4:     end of file reached

   IOX5:     device or data error

   IOX7:     insufficient system resources (Job Storage Block full)

   IOX8:     monitor internal error

   IOX10:    record is longer than user requested


Node: SIR	Previous: SINR	Next: SIRCM	Up: Top
			      SIR     JSYS 125

   Sets the channel and priority level table addresses for the	specified
   (SIR)
   

   process.   (Refer  to  Section  2.5.3.)  These  addresses  are  in the
   specified process' address space.

   ACCEPTS IN AC1:  process handle

	      AC2:  address of the priority level table in the left half,
		    and address of the channel table in the right half

   RETURNS     +1:  always.  The addresses  in	AC2  are  stored  in  the
		    Process Storage Block.

   If the contents of the tables are changed after execution of  the  SIR
   call, the new contents will be used on the next interrupt.

   The RIR monitor call can be used to obtain the table addresses  for	a
   specified process.

   Generates an illegal instruction interrupt on error conditions below.

   SIR ERROR MNEMONICS:

   SIRX1:    table address is not greater than 20

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: SIRCM	Previous: SIR	Next: SIZEF	Up: Top
			     SIRCM     JSYS 142

   Sets the  mask  for	reserved  software  interrupt  channels  for  the
   specified inferior process.	Conditions occurring on software channels
   that have the corresponding mask bit set do not generate an	interrupt
   to the inferior process.  Instead, the conditions cause the process to
   terminate or freeze.

   ACCEPTS IN AC1:  inferior process handle

	      AC2:  channel mask with bits set for reserved channels

	      AC3:  deferred terminal interrupt word

   RETURNS     +1:  always

   The RIRCM monitor call can be used to obtain  the  mask  for  reserved
   software  interrupt	channels.   Although  a  process can read its own
   channel mask, it cannot set its own;  the SIRCM call can be given only
   (SIRCM)
   

   for	inferior processes.  This call provides a facility for a superior
   process to monitor an inferior one (e.g., illegal instructions, memory
   traps).   However,  if the inferior process contains an ERJMP or ERCAL
   symbol after instructions that generate an interrupt on  failure,  the
   ERJMP  or  ERCAL  will prevent the generation of the interrupt.  Thus,
   the superior will not be able to monitor the inferior with  the  SIRCM
   call.

   Generates an illegal instruction interrupt on error conditions below.

   SIRCM ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: SIZEF	Previous: SIRCM	Next: SJPRI	Up: Top
			     SIZEF     JSYS 36

   Returns the length of an existing file.

   ACCEPTS IN AC1:  JFN

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, byte count that  referenced  the  last  byte
		    written  into  the	file  in AC2, and number of pages
		    (512 words) in file in AC3.  The byte count  returned
		    depends  on the byte size recorded in the FDB and not
		    on the byte size specified in the OPENF call.

   For a file with holes, the byte count in  AC2  does	not  reflect  the
   file's actual size.

   The GTFDB monitor call can be used to obtain the byte  size	in  which
   the file was written.

   SIZEF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer
   (SJPRI)
   


Node: SJPRI	Previous: SIZEF	Next: SKED%	Up: Top
			     SJPRI     JSYS 245

   Sets the job priority by specifying	the  scheduler	priority  control
  word  for  any  job.  The priority word is set for the top process and
  for all existing inferior  processes.   Also,  the  priority  word  is
  passed  down  to  any  forks  that are created subsequent to the SJPRI
  call.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  job number

	      AC2:  priority word

   RETURNS     +1:  always

   The priority word contains a percentage of CPU resources in	the  left
   half  and  0  in  the  right  half.	By placing the desired percentage
   (1-99) in the left half, a job can be guaranteed a certain  percentage
   of CPU time.  A priority word of 0 indicates no special priority.

   Generates an illegal instruction interrupt on error conditions below.

   SJPRI ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required

   SJPRX1:   job is not logged in


Node: SKED%	Previous: SJPRI	Next: SKPIR	Up: Top
			     SKED%     JSYS 577

  Reads or modifies the  monitor's  data  base  relating  to  the  class
  scheduler.

  RESTRICTIONS:    Some functions require WHEEL or  OPERATOR  capability
		    enabled

  ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

  RETURNS     +1:  always

  The available functions are:

  Code    Symbol    Function

   1	   .SKRBC    Read bias control	knob  setting.	 Return  a  value
		     indicating  the  setting  of  the bias control knob.
   (SKED%)
   

		     This setting determines whether the scheduler favors
		     compute-bound jobs or interactive jobs.

		     Argument block (returned):

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SAKNB	 Bias control knob setting

   2	   .SKSBC    Set bias control setting  to  the	specified  value.
		     Currently,  the  value may be an integer n such that
		     0< n <21.	Requires WHEEL or  OPERATOR  capabilities
		     enabled.

		     Argument block (user supplied):

		     Word     Symbol	 Contents

					 0  .SACNT  Count  of  words   in
					 argument  block  (Including this
					 word)

		      1       .SAKNB	 Bias control knob setting

   3	   .SKRCS    Read  class  parameters.	Returns   the	following
		     values:

		     1.  Class of the job

		     2.  Share of the processor allocated for this class.
			 The  share is returned as a floating-point value
			 n, such that 0<= n <=1.

		     3.  Use - amount of processor actually used  by  the
			 class.   The use is returned as a floating-point
			 value n, such that 0<= n <=1.

		     4.  1 minute  load  average.   The  load  average	=
			 1/((1/J)*P)   where   J   is	the   number   of
			 CPU-runnable jobs in  the  class  for	the  time
			 period and P is the fraction of CPU allocated to
			 the class.  Thus 3 jobs running in a  50%  class
			 would produce a load average of 6.

		     5.  5 minute load average

		     6.  15 minute load average

		     Argument block (returned):
   (SKED%)
   

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SACLS	 Class

		      2       .SASHR	 Share

		      3       .SAUSE	 Use

		      4       .SA1ML	 1 minute load average

		      5       .SA5ML	 5 minute load average

		      6       .SA15L	 15 minute load average

   4	   .SKSCS    Set class parameters (as described above).

		     Argument block (returned):

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SACLS	 Class

		      2       .SASHR	 Share

   5	   .SKICS    Start or stop the class  scheduler.   If  the  class
		     scheduler	is  being  started,  this  function  also
		     specifies	 the   mode   in   which    class-to-user
		     assignments  are  made and whether windfall is to be
		     allocated to the active classes or withheld from the
		     active classes.

		     Argument block (user specified):

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SACTL	 Control flags

					 The flags are as follows:

					  Bit	 Symbol    Meaning

					  B0	 SK%ACT    Class by
							   accounts

					  B1	 SK%WDF    Withhold
							   windfall
   (SKED%)
   

					  B2	 SK%STP    Class
							   scheduler off

   6	   .SKSCJ    Set the class of a job.  This function takes a  pair
		     of  numbers,  the	job to set and the desired class.
		     If setting  the  class  of  the  calling  job,  this
		     function is not privileged.  If setting the class of
		     another  job,  it	 requires   WHEEL   or	 OPERATOR
		     capabilities  enabled.  In either case, the job must
		     be allowed to reside in  the  selected  class.   The
		     calling job may be designated by -1.

		     Argument block (user supplied)

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SAJOB	 Job number

		      2       .SAJCL	 Class of job

   7	   .SKRJP    Read class parameters for a job

		     Returns the following values:

		     1.   Job's share of the processor.   This	value  is
			 returned  as a floating-point value n, such that
			 0<= n <=1.

		     2.  Job's use  of	the  processor.   This	value  is
			 returned  as a floating-point value n, such that
			 0<= n <=1.

		     Argument block (returned):

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (including this word)

		      1       .SAJSH	 Job's share allotment

		      2       .SAJUS	 Job's current use

   10	   .SKBCR    Read  the	class  setting	for  batch  jobs.   A  -1
		     indicates	that  there is no special class for batch
		     jobs.

		     Argument block (returned):

		     Word     Symbol	 Contents
   (SKED%)
   

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SABCL	 Batch class

   11	   .SKBCS    Set batch class.  Specifies the class in  which  all
		     batch  jobs  will	run.   A  -1 indicates no special
		     class for batch jobs.  If this is set, it	overrides
		     the valid classes for any user running a batch job.

		     Argument block (user supplied)

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SABCL	 Batch class

   12	   .SKBBG    Run all batch jobs in the "dregs" queue.  The  dregs
		     queue  is	a  special queue whose processes are only
		     allowed to run when no normally scheduled	processes
		     are available to run.

		     This function applies only if the class scheduler is
		     not being used.  The argument is either 0 (clear) or
		     non-zero (set).  A  non-zero  indicates  that  batch
		     jobs should be run in the "dregs" queue.

		     Argument block (returned):

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SADRG	 Flag word.

					 0 = don't run in dregs queue
					 non-zero = run in dregs queue

   13	   .SKDDC    Reserved

   14	   .SKRCV    Read status.

		     Argument block (returned):

		     Word     Symbol	 Contents

		      0       .SACNT	 Count of words in argument block
					 (Including this word)

		      1       .SACTL	 Flags

   (SKED%)
   

					 The flags are as follows:

					  Bit	 Symbol    Meaning

					  B0	 SK%ACT    Class by
							   accounts

					  B1	 SK%WDF    Withhold
							   windfall

					  B2	 SK%STP    Class
							   scheduler off

					  B3	 SK%DRG    Batch jobs are
							   being run in
							   dregs queue
  SKED% ERROR MNEMONICS:

  ARGX02:   invalid function

  CAPX1:    WHEEL or OPERATOR capability required


Node: SKPIR	Previous: SKED%	Next: SMON	Up: Top
			     SKPIR     JSYS 127

   Tests to see if the software  interrupt  system  is	enabled  for  the
   specified process.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  failure, software interrupt system is off

	       +2:  success, software interrupt system is on

   The EIR monitor call is used to enable the software interrupt  system,
   and the DIR monitor call is used to disable the system.

   Generates an illegal instruction interrupt on error conditions below.

   SKPIR ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle


Node: SMON	Previous: SKPIR	Next: SNDIM	Up: Top
			      SMON     JSYS 6

   Sets various monitor flags.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled.   Some
		    functions are for ARPANET systems only.

   ACCEPTS IN AC1:  function code

	      AC2:  new value for the indicated function

   RETURNS     +1:  always

   The codes for the functions are as follows:

     Code  Symbol		 Meaning

      0    .SFFAC      FACT file entries are allowed.
      1    .SFCDE      CHECKD found errors.
      2    .SFCDR      CHECKD is running.
      3    .SFMST      Manual start is in progress.
      4    .SFRMT      Remote LOGINs (dataset lines) are allowed.
      5    .SFPTY      PTY LOGINs are allowed.
      6    .SFCTY      CTY LOGINs are allowed.
      7    .SFOPR      Operator is in attendance.
     10    .SFLCL      Local LOGINs (hardwired lines) are allowed.
     11    .SFBTE      Bit table errors found on startup.
     12    .SFCRD      Users   can   change    nonprivileged	directory
		       parameters with the CRDIR monitor call.
     13    .SFNVT      ARPANET terminal LOGINs are allowed.
     21    .SFUSG      USAGE file entries are allowed.
     22    .SFFLO      Disk latency optimization using	the  RH20  backup
		       register  is  enabled.	This feature is not to be
		       enabled unless the M8555 board of the RH20  is  at
		       Revision   Level   D  AND  either  of  the  KL10-C
		       processor  is  at  Revision  Level  10  or  KL10-E
		       processor is at Revision Level 2.
     23    .SFMTA      If set, indicates that MOUNTR  magtape  allocation
		       is enabled.
     35    .SFPNV      Ethernet logins are allowed.
     44    .SFNTN      Turn ARPANET on.
     45    .SFNDU      Reinitialize ARPANET if it is down.
     46    .SFNHI      Initialize ARPANET host table.
     47    .SFTMZ      Set the local time zone to the value given in AC2.
     50    .SFLHN      Set the local ARPANET host  number  to  the  value
		       given in AC2.
     51    .SFAVR      Account validation will be running on this system.
     52    .SFSTS      Enable/disable status reporting.
     53    .SFSOK      Set GETOK% defaults
		       For this function, AC2 is set up as follows:

			    AC2:  Flags,,GETOK% function code

		       Flags:

		       Bit Symbol  Meaning

		       1B0 SF%EOK  0 = Disable access checking
				   1 = Enable access checking

		       1B1 SF%DOK  0 = Deny access if checking disabled
				   1 = Allow access if checking disabled

		       This   function	 should   be   given	by    the
		       access-control	 program    (supplied	 by   the
		       installation) to turn on access checking for  each
		       of  the desired functions.  It is also used to set
		       the default action for each function that  is  not
		       being   checked	by  the  access-control  program.
		       Installation-defined function codes (400000+n) can
		       be enabled/disabled by using function code 400000.
		       If there is no access-control program, the default
		       action  of  the GETOK% JSYS will be to deny access
		       for any installation-defined function code.

		       See the description of the GETOK% JSYS for  GETOK%
		       function codes.

      54   .SFMCY      Specifies the maximum  offline  expiration  period
		       (tape recycle period) in days for ordinary files.
      55   .SFRDU      Read date update function
      56   .SFACY      Specifies the maximum  offline  expiration  period
		       (tape recycle period) in days for archive files.
      57   .SFRTW      Sets/clears the	no-retrieval-waits  flag  in  the
		       monitor.  When set, this specifies that those file
		       retrievals  requests  that  are	waiting  for  the
		       retrieval should fail rather than wait.
      60   .SFTDF      Set tape mount controls

		       Flags:

		       Bit     Symbol	 Meaning

		       1B0     MT%UUT	 Set  =   unload   unrecognizable
					 tapes
					 Clear	=  treat   unrecognizable
					 tapes as unlabeled
      61   .SFWSP      Enable working set preloading
      62   .SFDIR      Initialize Pup directory.
      63   .SFROU      Set pup routing table entry.  Call:
			AC2:	net number
			AC3:	Mask of bits to change.
			AC4:	new value for those bits

			Returns +1 always with:
			AC4:	updated value of the routing table entry

		        A routing table entry has the following format:
			1B0	  Network inaccessible.
			1B1	  Broadcast packets allowed on net.
			1B2-1B9   Net number to which packets should be routed.
				  Zero means route directly.
			1B10-1B17 Host to which packets should be routed.
				  Zero means route directly.
			1B18-1B35 Our address on this net.
				  Zero means not on this network.

      64   .SFBUG      Enable Pup bug logging.
 
      65   .SFMEI      Initialize a MEIS to begin reception of datagrams
		       intended for a host on the specified network.
		       Up to 256 host numbers be specified in successive
		       calls.  Note that the network must be the same for
		       each call.  The first call sets the routing table
		       entry for the network.

			AC2:	host number,,network number
			AC3:	MEIS serial number

		       Returns MTOX17 error if MEIS not found, SMONX2 if
		       bad host or network numbers given.

      66   .SFETH      Obsolete.  Returns SMONX2 error always.

   The TMON monitor call can be  used  to  obtain  the	settings  of  the
   various monitor flags.

   Generates an illegal instruction interrupt on error conditions below.

  GOKER3:   Access control job already running

   SMON ERROR MNEMONICS:

   SMONX1:   WHEEL or OPERATOR capability required
   (SMON)
   

   SMONX2:   invalid SMON function


Node: SNDIM	Previous: SMON	Next: SNOOP	Up: Top
			     SNDIM     JSYS 750

  Places a message in a  previously  assigned	ARPANET  special  message
  queue.

  RESTRICTIONS:    for ARPANET systems only.

  ACCEPTS IN AC1:  special queue handle

	      AC2:  address of an extended message

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, message queued

  See BBN Report No.  1822 for the format of the message.

  The RCVIM JSYS can be used to retrieve  a  message  from  the  special
  message queue.

  SNDIM ERROR MNEMONICS:

  SNDIX1:   Invalid message size

  SNDIX2:   Insufficient system resources
	     (no buffers available)

  SNDIX3:   Illegal to specify NCP links 0-72

  SNDIX4:   Invalid header value for this queue

  SNDIX5:   IMP down

  SQX1:     Special network queue handle out of range

  SQX2:     Special network queue not assigned


Node: SNOOP	Previous: SNDIM	Next: SOBE	Up: Top
			     SNOOP     JSYS 516

   Performs system performance	analysis.   The  process  can  patch  any
   instruction	in  the  monitor  with	this call.  For example, the user
   program can build a PC histogram by patching  an  instruction  in  the
   (SNOOP)
   

   code for the 1.0-millisecond clock.

   The general procedure for using the SNOOP call is as follows:

	1.  The user program supplies a set of breakpoint  routines  that
	    are  called  by  the  monitor when control reaches one of the
	    patched instructions.  These routines  are	mapped	into  the
	    monitor's address space into an area selected by the monitor.
	    Thus, the routines must have self-relocating code or must  be
	    relocated  by  the	user  program  to where they will be run,
	    based on the monitor address supplied by the monitor.

	2.  The user program defines a number of  breakpoints,	analogous
	    to DDT breakpoints.

	3.  The   user	 program   inserts   all   of	the   breakpoints
	    simultaneously.

	4.  The user program goes to "sleep" or waits for terminal  input
	    while its breakpoint routines obtain control.

	5.  When the user  program  determines	that  the  routines  have
	    completed, it removes the breakpoints.

   The user program breakpoint routines run in the monitor address space,
   which  means  that  the addresses of the code and the data are monitor
   addresses.  The user program must modify these addresses, based on the
   values  returned  by  the monitor, after the initialization but before
   the	"snooping."   The   breakpoint	 routines   must   preserve   any
   accumulators  they  use.  Also, they must not cause a page fault if at
   interrupt level or if a patch has been made in the page fault  handler
   or  in  the	scheduler.  Thus, the breakpoint routines should test for
   swappable code being in memory before referencing  it.   If	swappable
   code  needs	to  be referenced, the swappable monitor can be locked in
   memory, if desired.	When a patch is made to a routine called at  many
   interrupt  levels, the program must specify a reentrant instruction to
   be used for patching.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  function code

	      AC2:  arguments for

	      AC3:  the specified

	      AC4:  function

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The following functions are available:

	Function  Symbol		   Meaning
   (SNOOP)
   

	 Code

	   0	  .SNPLC    Declare and  lock  code  into  the	monitor's
			    address space.

			    AC2:  number of pages desired

			    AC3:  page number in user space of start of
				  breakpoint routines to be locked

			    On return, the pages are locked  contiguously
			    in	the  monitor's	address  space,  and  AC2
			    contains	the    monitor	  page	  numbers
			    corresponding to the given user page number.

	   1	  .SNPLS    Lock the swappable monitor.  This function is
			    useful   for   analyzing  swappable  data  at
			    interrupt  level.	On  return,  the   entire
			    swappable monitor is locked.

	   2	  .SNPDB    Define a breakpoint

			    AC2:  number of breakpoint

			    AC3:  address in monitor space to be patched.
				  The  patched	instruction can be a skip
				  type	  instruction	 or    a    PUSHJ
				  instruction,	 and   the   patching  is
				  similar to that in DDT.   The  routines
				  will receive control before the patched
				  instruction is executed.

			    AC4:  instuction to be  executed  before  the
				  patched  instruction	is executed.  The
				  instruction can be:

				  JSR LOC where  LOC  is  an  address  in
				  monitor space of the user's routine.

				  PUSHJ P,LOC when reentrant or recursive
				  code is patched.

				  AOS LOC to count frequency  of  monitor
				  execution points.

				  The	error	return	 is   given    if
				  breakpoints have already been inserted.

						   NOTE

				      Putting a SNOOP breakpoint on a
				      PUSHJ  or other subroutine call
				      instruction  (including	JSYS,
   (SNOOP)
   

				      MDISMS,	 etc)	 can	cause
				      problems.  If  the  process  is
				      not  in a NOSKED state already,
				      it can  be  rescheduled  during
				      the    breakpoint    and	  the
				      breakpoint  removed,  whereupon
				      the  subsequent  return is made
				      to non-existent code.

	   3	  .SNPIB    Insert all breakpoints and start analyzing.

	   4	  .SNPRB    Remove all breakpoints and stop analyzing.

	   5	  .SNPUL    Unlock and release all storage, and  undefine
			    and remove all breakpoints.

	   6	  .SNPSY    Obtain the address of a monitor symbol.

			    AC2:  radix-50 symbol

			    AC3:  radix-50  program  name  if	a   local
				  address  is  desired.  If AC3 is 0, the
				  entire symbol table is searched.

			    On return, AC2 contains the  monitor  address
			    or value of the symbol.

	   7	  .SNPAD    Obtain a monitor symbol.

			    AC2:  36-bit value of symbol that  is  to  be
				  looked   up  in  the	monitor's  symbol
				  table.

			    AC3:  radix-50 program name if a local  value
				  is  desired.	 If  AC3 is 0, the entire
				  symbol table is searched.

			    On return, AC2 contains  the  first  radix-50
			    monitor  symbol  that is closest to and has a
			    value less than the specified value, and  AC3
			    contains  the difference between the value of
			    the symbol returned and the specified value.

   SNOOP ERROR MNEMONICS:

   SNOPX1:   WHEEL or OPERATOR capability required

   SNOPX2:   invalid function

   SNOPX3:   .SNPLC function must be first

   SNOPX4:   only one .SNPLC function allowed
   (SNOOP)
   

   SNOPX5:   invalid page number

   SNOPX6:   invalid number of pages to lock

   SNOPX7:   illegal to define breakpoints after inserting them

   SNOPX8:   breakpoint is not set on instruction

   SNOPX9:   no more breakpoints allowed

   SNOP10:   breakpoints already inserted

   SNOP11:   breakpoints not inserted

   SNOP12:   invalid format for program name symbol

   SNOP13:   no such program name symbol

   SNOP14:   no such symbol

   SNOP15:   not enough free pages for snooping

   SNOP16:   multiply-defined symbol

   SNOP17:   breakpoint already defined

   SNOP18:   data page is not private or copy-or-write


Node: SOBE	Previous: SNOOP	Next: SOBF	Up: Top
			     SOBE     JSYS 103

   Tests to see if the designated file output buffer is empty.

   ACCEPTS IN AC1:  destination designator

   RETURNS     +1:  output  buffer  is	not  empty.   Number   of   bytes
		    remaining in output buffer is returned in AC2.

	       +2:  output buffer is empty;  AC2 contains 0.  This return
		    is	given  if  an  error  occurs  on  the  call;  AC2
		    contains the appropriate error code.

   If the designator is not associated with a terminal, the +2 return  is
   given.

   The SIBE call can be used to determine if the input buffer is empty.

   SOBE ERROR MNEMONICS:

   DESX1:    invalid source/destination designator
   (SOBE)
   

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: SOBF	Previous: SOBE	Next: SOUT	Up: Top
			     SOBF     JSYS 175

   Tests to see if the designated file output buffer is full.

   ACCEPTS IN AC1:  file designator

   RETURNS     +1:  output buffer is not full.	This return is	given  if
		    an error occurs on the call;  AC2 will contain 0.

	       +2:  output buffer is full

   On either return, the number of bytes remaining in the  output  buffer
   is returned in AC2 (if no error occurred on the call).

   SOBF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DESX6:    file must be a terminal

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: SOUT	Previous: SOBF	Next: SOUTM	Up: Top
			      SOUT     JSYS 53

   Writes a string from the  caller's  address	space  to  the	specified
   destination.   The  string  can  be	a  specified  number  of bytes or
   terminated with a specified byte.

   ACCEPTS IN AC1:  destination designator

	      AC2:  byte pointer to string to be written
   (SOUT)
   

	      AC3:  count of the number of bytes in string, or 0

	      AC4:  byte (right-justified) on which to terminate output

   RETURNS     +1:  always, updated string pointers in AC2  and  AC1,  if
		    pertinent, and updated count in AC3, if pertinent

   The contents of AC3 controls the number of bytes to write.

	AC3=0	  The string being written is terminated with a 0 byte.

	AC3>0	  A string of the specified number  of	bytes  is  to  be
		  written  or  a string terminated with the byte given in
		  AC4 is to be written, whichever occurs first.

	AC3<***0  A string of minus the specified number of bytes  is  to
		  be written.

   The contents of AC4 is  ignored  unless  the  contents  of  AC3  is	a
   positive number.

   The output is terminated when the byte count becomes 0, the	specified
   terminating	byte  is reached, or an error occurs during the transfer.
   The specified terminating byte is copied to the destination.

   After execution of  the  call,  the	file's	pointer  is  updated  for
   subsequent  I/O to the file.  AC2 is updated to point to the last byte
   written or, if AC3 contained 0, the last nonzero  byte  written.   The
   count in AC3 is updated toward zero by subtracting the number of bytes
   written from the number of bytes requested to be written.

   When the SOUT call is used to write data to a magnetic tape, it  sends
   a  series  of  bytes packed into records of the specified record size.
   The size of the records to write is specified with either the SET TAPE
   RECORD-LENGTH  command  or the .MOSRS function of the MTOPR call.  The
   default record size is 1000(octal) words.  Thus, if the record size is
   1000  bytes,  two  SOUT calls, each writing 500 bytes, would write one
   record.  If during the writing, the end of tape mark  was  passed,  an
   error  (IOX5)  is  given.   However,  the  data  has been successfully
   written and the device status word has the MT%EOT bit set to  indicate
   this  condition.   Refer to Section 2.4.2.1 for more information about
   magnetic tape I/O.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.) Generates an  illegal	instruction  interrupt	on  error
   conditions below.

   SOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned
   (SOUT)
   

   DESX5:    file is not open

   IOX2:     file is not opened for writing

   IOX5:     device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX7:     insufficient system resources (Job Storage Block full)

   IOX8:     monitor internal error

   IOX11:    quota exceeded or disk full


Node: SOUTM	Previous: SOUT	Next: SOUTR	Up: Top
			     SOUTM     JSYS 572

  Writes data to a block-mode terminal on a multiplexed JFN.

  RESTRICTIONS:    requires DECnet and ATS software

  ACCEPTS IN AC1:  destination designator

	      AC2:  address of argument block

  RETURNS:	    +1 always

  Argument block (user supplied):

  Word     Contents

   0	    flags,,number of words in block (including this word)

	    Flags:

	    Bit    Symbol    Meaning

	    B0	   SO%WMG    write a message

   1	    source designator

   2	    0,,count of bytes

   3	    Host's identifier for terminal (HTN)

  Argument block (returned):

  Word     Contents

   0	    flags,,number of words in block (including this word)
   (SOUTM)
   

	    The flags returned are those supplied by the user.

   1	     updated source designator

   2	    0,, updated count

   3	    HTN (unchanged)

  SOUTM ERROR MNEMONICS:

  ARGX17:   invalid argument block length

  ARGX22:   Invalid flags

  ATSX06:   JFN is not an ATS JFN

  ATSX11:   Byte count is too large

  DESX4:    invalid use of terminal designator or string pointer

  IOX2:     file is not open for writing


Node: SOUTR	Previous: SOUTM	Next: SPACS	Up: Top
			     SOUTR     JSYS 532

   Writes a variable-length record from the caller's address space to the
   specified  magnetic	tape.  The maximum size of the record to write is
   specified with either the SET TAPE RECORD-LENGTH command or the .MOSRS
   function  of  the  MTOPR call.  The default record size is 1000(octal)
   words.  (Refer to Section 2.4.2.1 for more information about  magnetic
   tape I/O.)

   ACCEPTS IN AC1:  destination designator

	      AC2:  byte pointer to string to be written

	      AC3:  count of number of bytes in string, or 0

	      AC4:  byte (right-justified) on which to	terminate  output
		    (optional)

   RETURNS     +1:  always, updated byte pointers  in  AC2  and  AC1,  if
		    pertinent, and updated count in AC3, if pertinent

   The contents of AC3 and AC4 are interpreted in the same manner as they
   are in the SOUT monitor call.

   Each SOUTR call writes at least one	record.   Thus,  the  caller  can
   write variable-length records by indicating in AC3 the number of bytes
   to write in the record.  If the SOUTR call requests more bytes  to  be
   written than the maximum record size, then records of the maximum size
   (SOUTR)
   

   are written, plus another record containing the remaining  bytes.   If
   the	SOUTR  call  requests  fewer  bytes than the maximum, or a number
   equal to the maximum, to be written, then  records  of  the	requested
   size are written.

   The SOUTR call differs from the SOUT  call  in  that  the  SOUTR  call
   writes  records on the tape upon execution of the call.  The SOUT call
   does not write a record on the tape until the number of bytes equal to
   the	record	size  have been written.  Thus, if a record is being made
   from several strings in the caller's address space, the SOUT call  can
   be used for the first strings and the SOUTR call for the last string.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   Generates an illegal instruction interrupt on error conditions below.

   SOUTR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX2:     file is not open for writing

   IOX5:     Device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX7:     insufficient system resources (Job Storage Block full)

   IOX8:     monitor internal error

   IOX9:     function legal for sequential write only

   IOX11:    quota exceeded or disk full


Node: SPACS	Previous: SOUTR	Next: SPJFN	Up: Top
			     SPACS     JSYS 60

   Sets the accessibility of a page.  This  call  affects  the	map  word
   directly  indicated	by  the  argument (i.e., no indirect pointers are
   allowed).

   ACCEPTS IN AC1:  process/file designator in the left  half,	and  page
		    number within the file in the right half

	      AC2:  access information
   (SPACS)
   

		    B2(PA%RD)  permit read access

		    B3(PA%WT)  permit write access

		    B4(PA%EX)  permit execute access

		    B9(PA%CPY) copy-on-write

   RETURNS     +1:  always

   When used to modify a process page, the SPACS call does not allow  any
   greater  access  than  can  be  obtained with the PMAP call (i.e., the
   access specified on the OPENF call  is  applied  to	SPACS  operations
   involving file pointers).

   The SPACS call does not allow bits to be set in a page that	does  not
   already exist.

   The RPACS monitor call can be used to obtain the  accessibility  of	a
   page.

   Generates an illegal instruction interrupt on error conditions below.

   SPACS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   DESX8:    file is not on disk

   SPACX1:   invalid access requested

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: SPJFN	Previous: SPACS	Next: SPLFK	Up: Top
			     SPJFN     JSYS 207

   Sets the primary JFNs of the specified process.
   (SPJFN)
   

   ACCEPTS IN AC1:  process handle

	      AC2:  primary input JFN  in  the	left  half,  and  primary
		    output JFN in the right half

   RETURNS     +1:  always

   The JFNs given cannot be either 100 or  101.   These  JFNs  cause  the
   specified process to receive an error on any primary I/O operation.

   The GPJFN monitor call can be used to obtain the primary JFNs.

   Generates an illegal instruction interrupt on error conditions below.

   SPJFN ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   DESX3:    JFN is not assigned


Node: SPLFK	Previous: SPJFN	Next: SPOOL	Up: Top
			     SPLFK     JSYS 314

   Splices a  process  structure.   The  process  that	becomes  the  new
   superior must be either the one executing the SPLFK monitor call or an
   inferior of it.  The new inferior process must be an inferior  of  the
   executing  process.	 The  new  superior  process must not be the same
   process as the new inferior process and must not be	inferior  to  the
   new	inferior  process.   The  new  inferior  process  and  all of its
   inferiors will be frozen after execution of the SPLFK call.

   ACCEPTS IN AC1:  process handle of the new superior process

	      AC2:  process handle of the new inferior process

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, a process handle in AC1.  This handle may be
		    used by the new superior process (in AC1) to refer to
		    its new inferior (in AC2).

   SPLFK ERROR MNEMONICS:

   SPLFX1:   process is not inferior or equal to self

   SPLFX2:   process is not inferior to self
   (SPLFK)
   

   SPLFX3:   new superior process is inferior to intended inferior

   FRKHX1:   invalid process handle


Node: SPOOL	Previous: SPLFK	Next: SPRIW	Up: Top
			     SPOOL     JSYS 517

   Defines and initializes a device to be used for input spooling or sets
   and reads the directory for a spooled device.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  length of  argument  block	in  the  left  half,  and
		    function code in the right half

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The format of the argument  block  is  different  depending	upon  the
   particular  function  desired.   The  available  functions, along with
   their argument block formats, are as follows:

	Code	  Symbol	      Meaning

	 0	  .SPLDI    Define  an	input	spooling   device.    The
			    argument block is:

			    Word  Symbol	    Meaning

			    0	  .SPLDV  Device  designator   of   input
					  device.

			    1	  .SPLNA  Pointer    to    name    string
					  comprising  the set of files to
					  be input.

			    2	  .SPLGN  Generation  number   of   first
					  file.      This    number    is
					  incremented by 1 each time  the
					  spooled device is opened.

	 1	  .SPLSD    Set the directory of the spooled device.  The
			    argument block is:

			    Word  Symbol	    Meaning

			    0	  .SPLDV  Device  designator  of  spooled
					  device.
   (SPOOL)
   

			    1	  .SPLDR  Directory number.  This  number
					  is   the   logged-in	directory
					  number of the user  who  opened
					  the spooled device.

			    This function requires the	process  to  have
			    WHEEL or OPERATOR capability enabled.

	 2	  .SPLRD    Read the directory	of  the  spooled  device.
			    The argument block is:

			    Word  Symbol	    Meaning

			    0	  .SPLDV  Designator of spooled device.

			    The directory number of the spooled device is
			    returned in word 1 of the argument block.

   To read from a spooled input device, the user first defines	the  name
   of  the  files  comprising  his set of spooled input files.	The files
   have names in the format:

	STR:<SPOOLED-DIRECTORY>DEVICE-DIR#.NAME.1,2,3,...

   The spooled directory is the directory to receive  any  spooled  input
   from  the  device.	The  .SPLSD  function can be used by a privileged
   process to set the directory.  The default directory for  all  of  the
   spooled devices is <SPOOL>.

   The device is the name of the device being used for spooled input.  It
   is the same name that was given on the original GTJFN call.

   The directory number is the logged-in directory  number  of	the  user
   that opened the spooled device.

   The name is the name of the set of files  to  be  input.   The  .SPLDI
   function is used to define this name.

   The generation number begins with the value specified  by  the  .SPLDI
   function and increments by one each time the spooled device is opened.

   Thus, if the input spooler for the card reader (CDR) is reading  files
   for	a  user  whose	directory number is 23, then the files might have
   names like

	<SPOOL>CDR-23.BATCH-SEQUENCE-37.1,2,3,...

   To initialize the spooled card reader, the user would then execute the
   SPOOL  call giving "BATCH-SEQUENCE-37" as the name of the set of files
   to be input and "1" as the beginning generation number.

   SPOOL ERROR MNEMONICS:

   SPLX1:    invalid function
   (SPOOL)
   

   SPLX2:    argument block too small

   SPLX3:    invalid device designator

   SPLX4:    WHEEL or OPERATOR capability required

   SPLX5:    illegal to specify 0 as generation number for first file

   SPLX6:    no directory to write spooled files into


Node: SPRIW	Previous: SPOOL	Next: SSAVE	Up: Top
			     SPRIW     JSYS 243

   Sets the priority word for the specified process.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  process handle

	      AC2:  priority word

   RETURNS     +1:  always

   Refer to the SJPRI monitor call description	for  the  format  of  the
   priority word.

   Generates an illegal instruction interrupt on error conditions below.

   SPRIW ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required


Node: SSAVE	Previous: SPRIW	Next: STAD	Up: Top
			     SSAVE     JSYS 203

   Creates a sharable save format file for the given JFN by copying  (not
   sharing)  pages  from  the given process.  (Refer to Section 2.7.2 for
   the format of a sharable save file.) This monitor  call  is	used  for
   creating  shared  programs.	It saves the file in groups of contiguous
  pages for which the same access is desired.	SSAVE closes and releases
  the given JFN.

   ACCEPTS IN AC1:  process handle in the left half, and JFN in the right
		    half

	      AC2:  one table entry, or  0  in	the  left  half  and  the
		    address of the table in the right half (see below)
   (SSAVE)
   

	      AC3:  flag bits (not yet implemented;  AC3 should be 0)

   RETURNS     +1:  always

   The table has a  one-word  entry  for  each	group  of  pages  and  is
   terminated by a zero word.  Each word has the following format:

	Bit	  Symbol	      Meaning

	0-17	  SS%NNP    Negative of the number of pages in each group
			    (right-justified).

	18	  SS%CPY    Allow copy-on-write access to  the	group  of
			    pages.

	19	  SS%UCA    Limit the access  according  to  the  current
			    access of the user's page.	(See below.)

	20	  SS%RD     Allow read access to the group of pages.

	21	  SS%WR     Allow write access to the group of pages.

	22	  SS%EXE    Allow execute access to the group of pages.

	27-35	  SS%FPN    Number  of	the  first  page  in  the   group
			    (right-justified).

   When B19(SS%UCA)  is  set,  the  access  to	the  group  of	pages  is
   determined  by ANDing the access bits specified in the table word with
   the corresponding access bits for the user's pages (as  determined  by
   the	RPACS  call).	This means that a given access is allowed only if
   both the SSAVE call indicates it and the page currently  has  it.   If
   B19(SS%UCA)	is  not  set, the access granted to the group of pages is
   that indicated by the bits set in the table word.

   The SSAVE call does	not  save  the	accumulators  nor  does  it  save
   nonexistent pages.

   The GET monitor call is used to map a file saved with the  SSAVE  call
   back into a given process.

   Can cause several  software	interrupts  or	process  terminations  on
   certain file conditions.

   Generates an illegal instruction interrupt on error conditions below.

   SSAVE ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   SSAVX1:   illegal to save files on this device
   (SSAVE)
   

   SSAVX2:   page count is not less than or equal to 1000

   SSAVX3:   insufficient system resources (Job Storage Block full)

   SSAVX4:   directory area of EXE file is more than one page

   IOX11:    quota exceeded or disk full

   All I/O errors can also occur.


Node: STAD	Previous: SSAVE	Next: STCMP	Up: Top
			     STAD     JSYS 226

   Sets the system's date.  (Refer to Section 2.8.2.)

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled

   ACCEPTS IN AC1:  day in the left half, and fraction of the day in  the
		    right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The	STAD  call  requires  the  process  to	have  WHEEL  or  OPERATOR
   capability enabled if the system's date is already set.

   The GTAD monitor call can be used to obtain the system's date.

   STAD ERROR MNEMONICS:

   STADX1:   WHEEL or OPERATOR capability required

   STADX2:   invalid date or time


Node: STCMP	Previous: STAD	Next: STDEV	Up: Top
			     STCMP     JSYS 540

   Compares two ASCIZ strings in the caller's address space.   Note  that
   letters  are always considered as upper case, regardless of their case
   within the string.  Therefore, the strings ABC and abc are  considered
   an exact match.

   ACCEPTS IN AC1:  byte pointer to test string

	      AC2:  byte pointer to base string
   (STCMP)
   

   RETURNS     +1:  always, with

		    AC1 containing the compare code:

			B0(SC%LSS) Test string is less than base string.

			B1(SC%SUB) Test  string  is  a	subset	of   base
				   string.

			B2(SC%GTR) Test  string  is  greater  than   base
				   string.

		    AC2 containing base byte pointer, updated  such  that
		    an	 ILDB	instruction   will  reference  the  first
		    nonmatching byte.

   One string is considered less than another string if the  ASCII  value
   of  the  first  nonmatching character in the first string is less than
   the ASCII value of the character in the same position  in  the  second
   string.

   One string is considered a subset of another string	if  both  of  the
   following conditions are true:

	1.  From left to right, the ASCII values  of  the  characters  in
	    corresponding positions are the same.

	2.  The test string is shorter than the base string.

   Two strings are considered equal if the ASCII values of the characters
   in  corresponding  positions  are the same and the two strings are the
   same size.  In this case, the contents of AC1 is 0 on return.


Node: STDEV	Previous: STCMP	Next: STI	Up: Top
			     STDEV     JSYS 120

   Translates the given device name string to  its  corresponding  device
   designator.

   ACCEPTS IN AC1:  byte pointer to the string to be translated

   RETURNS     +1:  failure, error code in AC2

	       +2:  success, device designator (refer to Section 2.4)  in
		    AC2

   The string to be translated is terminated by the  first  space  (ASCII
   code 40), null (ASCII code 0), or colon (ASCII code 72).

   The DEVST monitor call can be used to translate a device designator to
   its corresponding string.
   (STDEV)
   

   STDEV ERROR MNEMONICS:

   STDVX1:   no such device


Node: STI	Previous: STDEV	Next: STIW	Up: Top
			      STI     JSYS 114

   Simulates terminal input.

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
		    enabled

   ACCEPTS IN AC1:  file designator (only terminal designators are legal)

	      AC2:  character to be input, right-justified

   RETURNS     +1:  always

   The character is taken  from  the  accumulator  and	placed	into  the
   specified  terminal's input buffer whether or not the buffer is empty.
   The DIBE call can be used to prevent sending  an  interrupt	character
   (e.g.,  CTRL/C)  before  the program has processed all of the previous
   input.

   The STI monitor call requires the process to have  WHEEL  or  OPERATOR
   capability enabled if the specified terminal either is not assigned or
   opened by the process or is not accepting advice.  (Refer to the TLINK
   bit TT%AAD.)

   The use of this monitor call is not recommended  for  pseudo-terminals
   (PTYs).   The recommended procedure for placing a character in the PTY
   input buffer is to open the PTY for output with OPENF and then perform
   output with the BOUT call.

   Generates an illegal instruction interrupt on error conditions below.

   STI ERROR MNEMONICS:

   TTYX1:    device is not a terminal

   DESX2:    terminal is not available to this job

   DEVX2:    device already assigned to another job

   WHELX1:   WHEEL or OPERATOR capability required

   TTYX01:   line is not active
   (STIW)
   


Node: STIW	Previous: STI	Next: STO	Up: Top
			     STIW     JSYS 174

   Sets the terminal interrupt word (refer  to	Section  2.5.6)  for  the
   entire  job	or  a specific process.  This call declares that terminal
   characters that usually cause an interrupt are instead to be passed to
   the	program as input.  In actuality, the STIW call sets the interrupt
   word mask, thus determining for each of the 36 terminal codes  if  the
   job	or  process  should  receive  an interrupt.  The call's effect is
   different, depending on whether the call is	being  executed  for  the
   entire job or for a specific process in the job.

   When the STIW call is executed for the entire job, codes corresponding
   to the bits on in the mask will cause an interrupt if a process in the
   job has enabled for an interrupt on that code.  If multiple	processes
   have  enabled  that	code,  the  lowest  inferior process receives the
   interrupt.  (If several  processes  at  the	same  lowest  level  have
   enabled   the  code,  the  process  that  receives  the  interrupt  is
   determined by the system.)  If no process has enabled that  code,  the
   character  corresponding  to the code is passed to the program.  Also,
   characters are passed to the program when their corresponding bits are
   off	in the mask, even if a process has enabled that code.  Initially,
   all codes are declared to cause an interrupt (i.e., all  bits  in  the
   mask  are  on), and the program can execute the RTIW call to determine
   the current status.	Thus if the program wishes  to	read  a  terminal
   interrupt character as input, it executes the STIW call for the entire
   job and turns off the mask bit corresponding to the character.

   When the STIW call is executed for a  specific  process  in	the  job,
   codes  corresponding  to  the  bits	on  in the mask are assumed to be
   enabled by the specific process and cause an interrupt if in fact they
   are	enabled.   If  the  process  has  not  enabled	for the code, the
   character corresponding to the  code  is  ignored,  if  it  is  typed.
   Characters  corresponding  to the bits off in the mask are assumed not
   to be enabled by the process.  This use of the STIW call is implicitly
   executed on an ATI call.

   Each time the STIW call is executed for a specific process,	the  mask
   is changed to reflect the bits changed in that process.

   The STIW call sets or clears specific terminal codes for a  particular
   process  without  actually  changing  the channel assignment that each
   code has.  The ATI call is used to set the channel assignment, and the
   DTI call is used to clear the assignment.

   The STIW call requires the process to have SC%CTC  capability  enabled
   to  disable	the  code  for	CTRL/C	interrupts  or	to  give -5 as an
   argument.

   ACCEPTS IN AC1:  B0(ST%DIM) set the deferred terminal  interrupt  mask
			       given in AC3

		    B18-B35    process handle, or -5 for entire job
		    (ST%PRH)
   (STIW)
   

	      AC2:  terminal interrupt word mask.
		    Bit n on means terminal code n is enabled.

	      AC3:  deferred terminal interrupt word mask.
		    Bit n on means terminal code n is deferred.

   RETURNS     +1:  always

   The argument in AC3 is ignored, and no change is made to the  deferred
   interrupt word mask, if B0(ST%DIM) is not set or if the process handle
   in AC1 does not indicate a specific process.

   If multiple processes enable the same interrupt character and any  one
   of  the  processes declares it deferred, the character is deferred for
   all the processes that enabled it.

   The RTIW call can be used to obtain the terminal interrupt word masks.

   STIW ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: STO	Previous: STIW	Next: STPAR	Up: Top
			      STO     JSYS 246

   Simulates terminal output.

   ACCEPTS IN AC1:  file designator (only terminal designators are legal)

   RETURNS     +1:  always, with the character right-justified in AC2

   The character is taken from the specified terminal's output buffer and
   placed in the accumulator.  The process is blocked until the character
   is in the accumulator.

   The use of this monitor call is not recommended  for  pseudo-terminals
   (PTYs).   The  recommended  procedure for reading a character from the
   PTY output buffer is to open the PTY for input  with  OPENF	and  then
   perform input with the BIN call.

   Generates an illegal instruction interrupt on error conditions below.

   STO ERROR MNEMONICS:

   TTYX1:    device is not a terminal
   (STO)
   

   DESX2:    terminal is not available to this job

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: STPAR	Previous: STO	Next: STPPN	Up: Top
			     STPAR     JSYS 217

   Sets the device-related modes for the specified terminal.   The  modes
   that can be set by this call are in the following bits of the JFN mode
   word.  (Refer to Section 2.4.3.1.)

      B1(TT%MFF)      mechanical form feed
      B2(TT%TAB)      mechanical tab
      B3(TT%LCA)      lower case
      B4-B10(TT%LEN)  page length
      B11-B17(TT%WID) page width
      B25(TT%ECM)     echo control
      B30(TT%UOC)     upper-case output control
      B31(TT%LIC)     lower-case input control
      B32-B33(TT%DUM) duplex mode
      B34(TT%PGM)     output page mode

   ACCEPTS IN AC1:  file designator

	      AC2:  JFN mode word

   RETURNS     +1:  always

   The STPAR monitor call is a no-op if the designator is not  associated
   with a terminal.

   The SFMOD monitor call can be used to set program-related modes of the
   JFN	mode  word,  and the RFMOD monitor call can be used to obtain the
   JFN mode word.

   When the page length and width fields are set  with	the  STPAR  call,
   they  have  a maximum range of 127.	The MTOPR call can be used to set
   these fields to values greater than 127.  A nonzero value of less than
   2  for  the length or less than 10 for the width causes STPAR to leave
   the field unchanged.

   STPAR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open
   (STPAR)
   

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: STPPN	Previous: STPAR	Next: STSTS	Up: Top
			     STPPN     JSYS 556

   Translates the  given  directory  name  string  to  its  corresponding
   project-programmer  number  (a  TOPS-10  36-bit directory designator).
   This  project-programmer  number  is  associated  with  the	structure
   containing  the  given  directory  and  is  valid only for the current
   mounting of that structure.	The STPPN  monitor  call  and  the  PPNST
   monitor  call should appear only in programs that require translations
   of project-programmer numbers.  Both calls are temporary calls and may
   not be defined in future releases.

   ACCEPTS IN AC1:  byte pointer to ASCIZ string containing the directory
		    name, a JFN, or a 36-bit directory number

   RETURNS     +1:  always,  with  the	corresponding  project-programmer
		    number in AC2

   Generates an illegal instruction interrupt on error conditions below.

   STPPN ERROR MNEMONICS:

   STRX02:   insufficient system resources

   STRX03:   no such directory name

   STRX04:   ambiguous directory specification

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DESX8:    file is not on disk

   DESX10:   structure is dismounted


Node: STSTS	Previous: STPPN	Next: STTYP	Up: Top
			     STSTS     JSYS 25
   (STSTS)
   

   Sets the status of a file.  (Refer to the GTSTS monitor call  for  the
   format of the JFN status word.)

   ACCEPTS IN AC1:  JFN in the right half

	      AC2:  status word

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The STSTS call is used to set the following bits of the status word:

      B9(GS%ERR)  file may be in error
      B13(GS%HLT) I/O errors are terminating conditions
      B17(GS%FRK) file, if opened, is opened for restricted access

   STSTS ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer


Node: STTYP	Previous: STSTS	Next: SWJFN	Up: Top
			     STTYP     JSYS 302

   Sets the terminal type number for the specified terminal line.  (Refer
   to Section 2.4.3.4.)

   ACCEPTS IN AC1:  file designator (only terminal designators are legal)

	      AC2:  terminal type number

   RETURNS     +1:  always

   The STTYP call sets the bits in the JFN mode word for mechanical  form
   feed and tab, lower case, and page length and width according to their
   settings  in  the  device  characteristics  word.   These   bits   can
   subsequently be changed with the STPAR monitor call.

   The GTTYP monitor call can be used to obtain the terminal type  number
   for a specified line.

   Generates an illegal instruction interrupt on error conditions below.

   STTYP ERROR MNEMONICS:
   (STTYP)
   

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   STYPX1:   invalid terminal type

   TTYX01:   line is not active


Node: SWJFN	Previous: STTYP	Next: SWTRP%	Up: Top
			     SWJFN     JSYS 47

   Swaps  the  association  of	two  JFNs  by  literally  exchanging  all
   information cells of each JFN.

   ACCEPTS IN AC1:  JFN

	      AC2:  another JFN

   RETURNS     +1:  always

   Generates an illegal instruction interrupt on error conditions below.

   SWJFN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   SWJFX1:   illegal to swap same JFN


Node: SWTRP%	Previous: SWJFN	Next: SYERR	Up: Top
			    SWTRP%     JSYS 573

  Provides the ability for a process to intercept arithmetic overflow or
  underflow  conditions efficiently.  Use of the SWTRP% JSYS to trap for
  these conditions is more efficient in some applications than using the
  software interrupt system.

  SWTRP% also allows a process to declare  its  LUUO  block  for  LUUO's
  executed in a non-zero section.

  ACCEPTS IN AC1:  process handle
   (SWTRP%)
   

	      AC2:  function code

  AC3: 	    function dependent argument

  RETURNS     +1:  always

  The functions are as follows:

  Code    Symbol    Function

   0	   .SWART    Set arithmetic trap location
		     AC3 contains the  address	of  the  arithmetic  trap
		     block  (see LUUO block below).  A zero in AC3 clears
		     the arithmetic trap.

   1	   .SWRAT    Read arithmetic trap location
		     Returns the trap block  address  in  AC3  (see  LUUO
		     block  below).   A zero is returned if an arithmetic
		     trap is not set.

   2	   .SWLUT    Set LUUO block address for non-zero sections
		     AC3 contains the 30-bit  address.	 A  zero  in  AC3
		     clears  the  location.   See below for the format of
		     the LUUO block.

   3	   .SWRLT    Read LUUO block address
		     Returns the  30-bit  address  in  AC3.   A  zero  is
		     returned if no block is currently in effect.

		     The LUUO block has the following format:

		      0       12 13 17 18    26 27  30 31 35
		     ========================================
		     ! PC flags !  0  ! opcode !  AC  !  0  !
		     ----------------------------------------
		     !	0  !		  PC+1		    !
		     ----------------------------------------
		     !	0  !	     E of the LUUO	    !
		     ----------------------------------------
		     !	0  !		 New PC 	    !
		     ========================================
		      0   5 6				  35

  An LUUO executed in section	zero  will  store  the	opcode,  AC,  and
  effective address of the LUUO in user location 40 and will execute the
  instruction in user location 41.   An  LUUO	executed  in  a  non-zero
  section  makes  use	of  the  UPT  (user page table).  SWTRP% allows a
  process to store the desired address in the	UPT  so  that  subsequent
  LUUOs  will produce the desired effect.  The address in the UPT points
  to the LUUO block shown above (and stored in  user  space).	 See  the
  Hardware Reference Manual for more information on LUUOs.
   (SYERR)
   


Node: SYERR	Previous: SWTRP%	Next: SYSGT	Up: Top
			     SYERR     JSYS 527

  Places information in the System Error (SYSERR) file.  (Refer  to  the
  TOPS-10 and TOPS-20 SYSERR Manual for information on the SYSERR file.)

   RESTRICTIONS:    requires WHEEL, OPERATOR, or  MAINTENANCE  capability
		    enabled

   ACCEPTS IN AC1:  address of argument block

	      AC2:  length of argument block

   RETURNS     +1:  always

  The first four words of the header block  must  contain  the  standard
  header   information   required   by  SYSERR.   Generates  an  illegal
   instruction interrupt on error conditions below.

   SYERR ERROR MNEMONICS:

   CAPX1:    WHEEL or OPERATOR capability required

   SYEX1:    unreasonable SYSERR block size

   SYEX2:    no buffer space available for SYSERR


Node: SYSGT	Previous: SYERR	Next: TBADD	Up: Top
			     SYSGT     JSYS 16

   Returns the table number, table length, and word 0  of  the	specified
   system  table.   (Refer  to	Section 2.3.2 for the names of the system
   tables.)

   ACCEPTS IN AC1:  SIXBIT table name

   RETURNS     +1:  always, with

		    AC1 containing word 0 of the table

		    AC2 containing the negative of the number of words in
			the  table in the left half, and the table number
			in the right half

   The table number returned can be given to the GETAB monitor call as an
   argument.	However,   because   the   MONSYM  file  includes  symbol
   definitions for the system tables, execution of the SYSGT call is  not
   required to obtain the table number for the GETAB call.

   The contents of AC2 is 0 on return if  the  specified  table  was  not
   found.
   (TBADD)
   


Node: TBADD	Previous: SYSGT	Next: TBDEL	Up: Top
			     TBADD     JSYS 536

   Adds an entry to a standard-formatted  command  table  used	for  user
   program command recognition.  (Refer to the TBLUK call description for
   the format of the command table.)

   ACCEPTS IN AC1:  address of word 0 (header word) of table

	      AC2:  entry to be added to table.  (Refer to the TBLUK call
		    for the format of a table entry.)

   RETURNS     +1:  always, address in the table of the new entry in AC1

   Generates an illegal instruction interrupt on error conditions below.

   TBADD ERROR MNEMONICS:

   TADDX1:   table is full

   TADDX2:   entry is already in table


Node: TBDEL	Previous: TBADD	Next: TBLUK	Up: Top
			     TBDEL     JSYS 535

   Deletes an entry from a standard-formatted command table used for user
   program command recognition.  (Refer to the TBLUK call description for
   the format of the command table.)

   ACCEPTS IN AC1:  address of word 0 (header word) of table

	      AC2:  address of entry to  be  deleted.	This  address  is
		    returned in AC1 on a TBLUK call.

   RETURNS     +1:  always

   Generates an illegal instruction interrupt on error conditions below.

   TBDEL ERROR MNEMONICS:

   TDELX1:   table is empty

   TDELX2:   invalid table entry location


Node: TBLUK	Previous: TBDEL	Next: TEXTI	Up: Top
			     TBLUK     JSYS 537
   (TBLUK)
   

   Compares the specified string  in  the  caller's  address  space  with
   strings indicated by a standard-formatted command table.  This call is
   used  to  implement	a  consistent  style  of  user	program   command
   recognition and abbreviation.  The TBLUK call performs the function of
   string lookup in the table, and the TBADD and TBDEL calls perform  the
   functions of adding to and deleting from the table.

   The command table has the following format:

	Word				   Meaning

	0	       Number  of  actual  entries  (not  including  this
		       entry)  in the table in the left half, and maximum
		       number of entries in the table (not including this
		       entry) in the right half.

	1 through n    Address of an argument in  the  left  half.   This
		       argument  contains  optional bits pertinent to the
		       string followed by the ASCIZ string  itself.   The
		       right  half  of	each table entry is available for
		       use by the user program.

   The argument pointed to by the left half of each table entry can  have
   one	of two formats, depending on the setting of bits 0-7 of the first
   word of the argument.  If bits 0-6 are all off and  B7(CM%FW)  is  on,
   the	string	actually begins in the next word of the argument, and the
   remainder of this word contains data bits relevant to the string.

   Table Entry

	      0 		       17 18			     35
	      !=======================================================!
	      ! 	  ADR		 !	for use by program    !
	      !=======================================================!

   Argument

	      0 	   6 7					     35
	      !=======================================================!
	ADR   !      0	    !1! 	     data bits		      !
	      !-------------------------------------------------------!
	      ! 		   start of string		      !
	      !=======================================================!

   The following bits are currently defined:

      Bit    Symbol			   Meaning

     33     CM%ABR    Consider  this  entry  a  valid	abbreviation  for
		       another	entry  in  the	table.	The right half of
		       this table entry points to  the	entry  for  which
		       this is an abbreviation.  The program can set this
   (TBLUK)
   

		       bit to include entries in the table that are  less
		       than   the   minimum   unique  abbreviation.   For
		       example, this bit can be set to include the  entry
		       ST   (for  START)  in  the  table.   If	TBLUK  is
		       performed for ST, it will be accepted as  a  valid
		       abbreviation even though there may be other entrys
		       beginning with ST.

      34     CM%NOR    Do not recognize this string, even if a string  is
		       specified  that	matches  exactly, and consider an
		       exact match as ambiguous.  A program can set  this
		       bit to include entries that are initial substrings
		       of other entries in the table to enforce a minimum
		       abbreviation  of  these	other  entries	(e.g., to
		       include D and DE in the table to  enforce  DEL  as
		       the minimum abbreviation of DELETE).

       7     CM%FW     Indicate that the remainder of this word is a flag
		       word  containing data bits relevant to the string.
		       This bit must be on to  distinguish  a  flag  word
		       from a null string.

   If any bit of bits 0-6 of the first word of the argument is on  or  if
   B7(CM%FW)  is  off, the string begins in that word.	In this case, the
   data bits do not apply and are assumed to be off.

   Table Entry

	      0 		       17 18			     35
	      !=======================================================!
	      ! 	  ADR		 !			      !
	      !=======================================================!

   Argument

	      0 						     35
	      !=======================================================!
	ADR   ! 		   start of string		      !
	      !=======================================================!

   The addresses in the command table must be  sorted  according  to  the
   alphabetical  order	of  the  strings.   Note  that letters are always
   considered as uppercase.  Therefore,  the  strings  ABC  and  abc  are
   considered  equivalent  strings.   This  order  results  in	efficient
   searching of strings and determination of ambiguous strings.

   The right half of each table entry can be used by the program  for  an
   address  to	a  dispatch  table  for the command or for a pointer to a
   parameter block  for  additional  information  about  the  call.   The
   contents of this half word is ignored by the three table calls.

   ACCEPTS IN AC1:  address of word 0 (header word) of table
   (TBLUK)
   

	      AC2:  byte pointer to string in caller's address space that
		    is to be compared with the string in the table

   RETURNS     +1:  always, with

		    AC1 containing the address of the entry that  matches
			the input string or address where the entry would
			be if it were in the table.

		    AC2 containing recognition bits:

			B0(TL%NOM) The input string does  not  match  any
				   string in the table.
			B1(TL%AMB) The input string matches more than one
				   string   in	 the   table   (i.e.,  is
				   ambiguous).
			B2(TL%ABR) The	 input	 string   is   a    valid
				   abbreviation of a string in the table.
			B3(TL%EXM) The input string  is  an  exact  match
				   with a string in the table.

		    AC3 containing a byte pointer to the remainder of the
			string	in  the  table	if  the  match	was on an
			abbreviation (TL%ABR is  on).	This  string  can
			then be output to complete the command.

   Generates an illegal instruction interrupt on error conditions below.

   TBLUK ERROR MNEMONICS:

   TLUKX1:   internal format of table is incorrect


Node: TEXTI	Previous: TBLUK	Next: TFORK	Up: Top
			     TEXTI     JSYS 524

   Reads input from a terminal or a file into a string	in  the  caller's
   address space.  Input is read until either a specified break character
   is encountered or the byte count is exhausted, whichever occurs first.

   When used for terminal input, the TEXTI  call  handles  the	following
   editing functions:

	1.  Delete the last character input (DELETE).

	2.  Delete back to the last punctuation character (CTRL/W).

	3.  Delete back to the beginning of the current line or,  if  the
	    current  line is empty, back to the beginning of the previous
	    line (CTRL/U).
   (TEXTI)
   

	4.  Retype the current line from its  beginning  or,  if  current
	    line is empty, retype the previous line (CTRL/R).

	5.  Accept the next character without regard to its usual meaning
	    (CTRL/V).

   ACCEPTS IN AC1:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated pointer in word .RDDBP,  appropriate
		    bits set in the left half of word .RDFLG, and updated
		    count in word .RDDBC of the argument block

   The format of the argument block is as follows:

	Word	  Symbol		   Meaning

	 0	  .RDCWB    Count of words following  this  word  in  the
			    argument block.

	 1	  .RDFLG    Flag bits.	(See below.)

	 2	  .RDIOJ    Byte pointer to string, or input JFN  in  the
			    left  half	and  output JFN in the right half
			    (if RD%JFN is on in the  flag  word  .RDFLG).
			    The  input	JFN  is  where the input is being
			    read from, and the output JFN  is  where  any
			    output  generated  from  character editing is
			    placed.

	 3	  .RDDBP    Byte pointer to string  in	caller's  address
			    space   where   input   is	 to   be   placed
			    (destination string pointer).

	 4	  .RDDBC    Number of bytes available in the  destination
			    string (field width).

	 5	  .RDBFP    Byte  pointer  to  the   beginning	 of   the
			    destination  buffer.   This pointer indicates
			    the maximum limit to which the user can  edit
			    back  into the buffer with DELETE, CTRL/W, or
			    CTRL/U.  This buffer is not  separate  (i.e.,
			    is not disjoint) from the destination string.
			    On the first TEXTI, this pointer is  normally
			    the  same  as  the	destination  byte pointer
			    (.RDDBP), but does not have to be  the  same.
			    If	the  count  in word .RDCWB is 4, then the
			    byte pointer in word .RDDBP will be  used  as
			    the pointer to the destination buffer.

	 6	  .RDRTY    Byte  pointer  to  the   beginning	 of   the
			    prompting-text  (CTRL/R  buffer).  This text,
			    along  with  any  text  in	the   destination
			    buffer, is output if the user types CTRL/R on
   (TEXTI)
   

			    his first line of  input.	If  there  is  no
			    CTRL/R text or the user types CTRL/R on other
			    than the first line of input, only	the  text
			    in the destination buffer will be output.
	 6	  .RDRTY    The CTRL/R	buffer	is  useful  for  retyping
		  (Cont.)   characters that preceded  the  user's  input,
			    such  as a prompt from the program.  The text
			    in this buffer cannot be edited by the  user,
			    and  if  the  user deletes back to the end of
			    this buffer, his action is treated as  if  he
			    has deleted all of his input.  This buffer is
			    logically adjacent to the destination buffer,
			    but may be physically disjoint from it.  When
			    the CTRL/R buffer is  disjoint,  it  must  be
			    terminated with a null byte.

	 7	  .RDBRK    Address of a 4-word block of break	character
			    mask  bits.  If a bit is on in the mask, then
			    the corresponding character is  considered	a
			    break  character.	Any bits set in this mask
			    override break characters  set  in	the  flag
			    word.

			    The mask occupies the  leftmost  32  bits  of
			    each  wthereby  allowing  a mask of 128 bits.
			    The  rightmost  4  bits  of  each  word   are
			    ignored.   The  mapping isfrom left to right.
			    The  ASCII	character  set	maps  into   this
			    128-bit mask.

			    If this word  is  zero,  there  is	no  break
			    character set mask defined.

	 10	  .RDBKL    Byte pointer  to  the  backup  limit  in  the
			    destination  buffer.   This pointer indicates
			    the position in  the  destination  buffer  to
			    which  the	user  can edit back without being
			    informed.  This pointer is used  to  indicate
			    to	the  program  that previously parsed text
			    has been edited and may need to  be  reparsed
			    by	the  program.	The pointer can either be
			    equal to the  start  of  the  buffer  pointer
			    (.RDBFP) or to the destination string pointer
			    (.RDDBP) or be between these two pointers.

   Words 5 through 10 (.RDBFP through .RDBKL) in the argument  block  are
   optional.   A  zero in any of the words means that no pointer has been
   given.

   The illustration below is a logical	arrangement  of  the  CTRL/R  and
   destination	buffers, with the placement of the pointers when they are
   given as not being equal.  Remember that the CTRL/R	buffer	does  not
   have  to be adjacent to the destination buffer and that two or more of
   these pointers can be equal.
   (TEXTI)
   

				 destination buffer

					   can be edited

   !=======================================================!
   !  CTRL/R buffer;	  !   Cannot be    !	  !	   !
   !  cannot be edited,   !   edited	   !	  !	   !
   !  but will be output  !		   !	  !	   !
   !  on a CTRL/R	  !		   !	  !	   !
   !=======================================================!

   CTRL/R	  Beginning of	      Backup	   Destination
   buffer	  destination	      limit	   string
   pointer	  buffer pointer      pointer	   pointer
   (.RDRTY)	  (.RDBFP)	      (.RDBKL)	   (.RDDBP)

   The flag bits that can be set in word 1 (.RDFLG) of the argument block
   are as follows:

	Bit	  Symbol	      Meaning

	 0	  RD%BRK    Break on CTRL/Z or ESC.

	 1	  RD%TOP    TOPS-10  character	set.   Break  on  CTRL/G,
			    CTRL/K, CTRL/L, CTRL/Z, ESC, carriage return,
			    line feed.

	 2	  RD%PUN    Break on punctuation:

			    CTRL/A-CTRL/F     ASCII codes 34-37
			    CTRL/H-CTRL/I     ASCII codes 40-57
			    CTRL/N-CTRL/Q     ASCII codes 72-100
			    CTRL/S-CTRL/T     ASCII codes 133-140
			    CTRL/X-CTRL/Y     ASCII codes 173-176

	 3	  RD%BEL    Break on end of  line  (carriage  return  and
			    line feed, or line feed only).

	 4	  RD%CRF    Suppress a carriage return and return a  line
			    feed only.

	 5	  RD%RND    Return to user program if the user	tries  to
			    delete    beyond   the   beginning	 of   the
			    destination buffer.  If this bit is not  set,
			    the  TEXTI call causes the terminal's bell to
			    ring and waits for more input.

	 6	  RD%JFN    JFNs  have	been   given   for   the   source
			    designator	 (word	.RDIOJ	of  the  argument
			    block).  If this bit is not set,  the  source
			    designator is a pointer to a string.
   (TEXTI)
   

	 7	  RD%RIE    Return to user program if the input buffer is
			    empty.   If  this  bit  is not set, the TEXTI
			    call waits for more input.

	 8	  RD%BBG    Not used

	 9	  RD%BEG    Causes  TEXTI  to  return  when  the   .RDBKL
			    pointer is reached and TEXTI is about to wait
			    for more input.

	 10	  RD%RAI    Convert lower-case input to upper-case input.

	 11	  RD%SUI    Suppress the CTRL/U indication if user  types
			    a  CTRL/U  (i.e.,  do  not	print  XXX and on
			    display  terminals,   do   not   delete   the
			    characters from the screen).

   On a successful return, the following  bits	can  be  set  in  word	1
   (.RDFLG) of the argument block:

	Bit	  Symbol		   Meaning

	 12	  RD%BTM    A break character terminated the  input.   If
			    this bit is not set, the input was terminated
			    because the byte count was exhausted.

	 13	  RD%BFE    Control was  returned  to  the  user  program
			    because  the  user tried to delete beyond the
			    beginning  of  the	destination  buffer   and
			    RD%RND was on in the call.

	 14	  RD%BLR    The backup limit for editing was reached.

   TEXTI ERROR MNEMONICS:

   ARGX17:   invalid argument block length

   RDTX1:    invalid string pointer

   IOX11:    quota exceeded or disk full


Node: TFORK	Previous: TEXTI	Next: THIBR	Up: Top
			     TFORK     JSYS 321

   Sets and removes monitor call intercepts (JSYS traps)  for  the  given
   inferior  processes.   When	the process attempts to execute a call on
   which an intercept has been set, it is suspended  before  it  executes
   the	call.	Control is passed to the closest superior process that is
   monitoring the execution of that call.  This control is passed by  the
   superior   receiving   an  interrupt  when  the  inferior  process  is
   suspended.  The superior process can then determine via the RTFRK call
   which  process  caused  the interrupt and how to handle the interrupt.
   (TFORK)
   

   It can use any of the process manipulation  calls  and  then  use  the
   UTFRK  call	to resume the suspended inferior process.  Alternatively,
   the superior can simply decide to resume the inferior and allow it  to
   execute  the  call.	 If  this  is  the case, the next higher superior
   process monitoring the intercepted call  receives  an  interrupt,  and
   control  is	passed	to  that  superior.   If  each	superior  process
   monitoring the call decides to resume the  suspended  process  without
   changing its PC word, then the suspended process is allowed to execute
   the monitor call as it normally would.

  Note that an RFORK should be performed when an interrupt is	received,
  or the inferior process will not trap again.

   ACCEPTS IN AC1:  function code in the left half, and process handle in
		    the right half

	      AC2:  software interrupt channel number in the  left  half,
		    and size (in bits) of the monitor call bit table

	      AC3:  address of monitor call bit table

   RETURN     +1:   always

   The available functions are as follows:

	Code	  Symbol		   Meaning

	 0	  .TFSET    Set monitor call  intercepts  for  the  given
			    process.   The calls that will be intercepted
			    are indicated in the monitor call bit  table.
			    The  given	process  must  be  frozen.   This
			    function  is  illegal  for	an   execute-only
			    process.

	 1	  .TFRAL    Remove all monitor call  intercepts  for  the
			    given  process.   The process must be frozen.
			    This function is illegal for an  execute-only
			    process.

	 2	  .TFRTP    Remove for the given process only the monitor
			    call  intercepts  that  are  indicated in the
			    monitor call bit table.   The  given  process
			    must be frozen.  This function is illegal for
			    an execute-only process.

	 3	  .TFSPS    Set the given software channel as the channel
			    on which to generate the interrupt.

	 4	  .TFRPS    Return in the left half of AC2  the  software
			    channel   on  which  the  interrupt  will  be
			    generated.

	 5	  .TFTST    Test if the caller is to be intercepted  when
			    it	attempts  to  execute  monitor calls.  On
			    successful return AC2 contains -1 if it is to
   (TFORK)
   

			    be	intercepted  or  0  if	it  is	not to be
			    intercepted.

	 6	  .TFRES    Remove intercepts set for all  inferiors  and
			    clear  the	software  channel assigned to the
			    interrupt for monitor call intercepts.

	 7	  .TFUUO    Set  monitor  call	intercepts  for   TOPS-10
			    monitor  calls  (UUOs) for the given process.
			    The process must be frozen.  This function is
			    illegal for an execute-only process.

	 10	  .TFSJU    Set monitor  call  intercepts  for	both  the
			    calls indicated in the monitor call bit table
			    and the TOPS-10 monitor calls.  This function
			    is	a  combination	of  functions  .TFSET and
			    .TFUUO.  The given process	must  be  frozen.
			    This  function is illegal for an execute-only
			    process.

	 11	  .TFRUU    Remove  monitor  call  intercepts	for   the
			    TOPS-10  monitor  calls.   The  given process
			    must be frozen.

  To set monitor call intercepts, the process must  first  issue  .TFSPS
  (code  3).  Then, .TFSET (code 0), .TFUUO (code 7) or .TFSJU (code 10)
  may be issued to set intercepts.

   The process handle in the right half of AC1 must refer to an  inferior
   process  or must be -4 to refer to all inferiors.  When intercepts are
   set for a given process, they also apply to all processes inferior  to
   the	given  process.   When a process is created, it is subject to the
   same intercepts as the process that created it.

   If the software channel is given as	77,  any  intercepts  bypass  the
   given process without causing either an interrupt to its superior or a
   suspended state of the process.

   The monitor call bit table contains a bit  for  each  of  the  TOPS-20
   monitor  calls.   When  a  bit  in  the table is on, the corresponding
   monitor call is to be intercepted when the given process  attempts  to
   execute  it.   If  the bit is off, the corresponding monitor call will
   not be intercepted.	The size of the bit table is 1000(octal) words.

   A process can remove only the intercepts it previously set;	it cannot
   remove intercepts that other processes set.

  When the process being monitored attempts to execute  the  trapped-for
  JSYS,  the  process	and  its inferiors enter a suspended state.  This
  suspended state differs from the normal "frozen" state of a process in
  the following ways:

	1.  The inferiors of the monitored process  are  not  frozen  and
	    continue to operate.
   (TFORK)
   

	2.  The monitored process is resumed with the UTFRK monitor call.
	    RFORK will not resume the process.

	3.  All interrupts for the monitored process are queued  and  are
	    acted upon immediately after the UTFRK monitor call.

  After the suspension of the inferior process, the superior process may
  do one of the following:

	1.  Allow  the	inferior  process  to  resume  execution  of  the
	    intercepted JSYS.

	2.  Make changes in the  working  environment  of  the	suspended
	    process  and  allow  that  process to resume execution of the
	    intercepted JSYS.

	3.  Execute the intercepted  JSYS  on  behalf  of  the	suspended
	    process, and then allow the suspended process to continue.

  The user interface to the monitor call intercept facility is  provided
  for by three JSYS's:

	1.  TFORK  (trap)

	2.  RTFRK (read)

	3.  UTFRK  (untrap)

   Generates an illegal instruction interrupt on error conditions below.

   TFORK ERROR MNEMONICS:

  FRKHX8:   illegal to manipulate an execute-only process

   TFRKX1:   invalid function code

   TFRKX2:   unassigned process handle or not immediate inferior

   TFRKX3:   process not frozen


Node: THIBR	Previous: TFORK	Next: TIME	Up: Top
			     THIBR     JSYS 770
   (THIBR)
   

   Blocks the current process for the specified  elapsed  time	or  until
   awakened  by  a TWAKE monitor call, whichever occurs first.	The THIBR
   call is a temporary call and may not be defined in future releases.

   ACCEPTS IN AC1:  0 in the left half, and maximum number of seconds  to
		    block in the right half

   RETURNS     +1:  never

	       +2:  always, time expired or TWAKE call occurred


Node: TIME	Previous: THIBR	Next: TIMER	Up: Top
			      TIME     JSYS 14

   Returns the amount of time since the system was last restarted.

   RETURNS     +1:  always, time  (in  milliseconds)  right-justified  in
		    AC1,  and  divisor	to convert the time to seconds in
		    AC2.  AC2 always contains  1000;   thus,  it  is  not
		    necessary to examine its contents.

   This is a monotonically increasing number (when the system is running)
   independent of any resets of the time and date.


Node: TIMER	Previous: TIME	Next: TLINK	Up: Top
			     TIMER     JSYS 522

   Controls the amount of time either a  process  within  a  job  or  the
   entire  job	can  run.   An	interrupt  is generated when the time has
   elapsed.

   Only one process in the job is allowed to time the entire job.  If the
   job	is  already  being  timed,  an	error is given if another process
   attempts to time the job.  An error is also given if a  process  other
   than  the one that set the runtime limit of the job attempts to remove
   that limit.

   ACCEPTS IN AC1:  process handle in the left half, and function code in
		    the right half.

	      AC2:  time at which to generate an interrupt.  Refer to the
		    individual	function  descriptions	for  the specific
		    arguments.

	      AC3:  number of the software channel on which  to  generate
		    an interrupt when the time has expired.
   (TIMER)
   

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

	Code	  Symbol			Meaning

	 0	  .TIMRT    Specify the total runtime of the entire  job.
			    This function allows one process within a job
			    to time the entire	job.   AC2  contains  the
			    total  runtime  in	milliseconds that the job
			    can  accumulate  before   an   interrupt   is
			    generated  on  the specified channel.  If AC2
			    contains 0, the limit on the runtime  of  the
			    job  is removed.  The process handle given in
			    AC1 must be .FHJOB (-5).

	 1	  .TIMEL    Specify  an  elapsed  time	after  which   an
			    interrupt is generated for the given process.
			    AC2 contains the number of milliseconds  that
			    can   now  elapse  before  the  interrupt  is
			    generated on the specified channel.

	 2	  .TIMDT    Specify an exact time at which  an	interrupt
			    is	generated  for	the  given  process.  AC2
			    contains  the  internal  format   (refer   to
			    section  2.8.2) of the date and time when the
			    interrupt is to be generated.

	 3	  .TIMDD    Remove any pending	interrupt  requests  that
			    are  to  occur  for  the process at the given
			    time.   AC2  contains  the	internal   format
			    (refer to section 2.8.2) of the date and time
			    of the interrupt request to be removed.

	 4	  .TIMBF    Remove any pending	interrupt  requests  that
			    are to occur for the process before the given
			    time.   AC2  contains  the	internal   format
			    (refer  to	section  2.8.2)  of  the date and
			    time.

	 5	  .TIMAL    Remove all pending	requests  for  the  given
			    process  including	the  runtime limit on the
			    entire job.

   The runtime limit for a job can be obtained via the GETJI monitor call
   (contents  of word .JIRT on return).  If the job's time limit has been
   exceeded, the value returned by the GETJI call will be zero.

   TIMER ERROR MNEMONICS:

   TIMX1:    invalid function

   TIMX2:    invalid process handle
   (TIMER)
   

   TIMX3:    time limit already set

   TIMX4:    illegal to clear time limit

   TIMX5:    invalid software interrupt channel number

   TIMX6:    time has already passed

   TIMX7:    no space available for a clock

   TIMX8:    user clock allocation exceeded

   TIMX9:    no such clock entry found

   TIMX10:   no system date and time


Node: TLINK	Previous: TIMER	Next: TMON	Up: Top
			     TLINK     JSYS 216

   Controls  terminal  linking.   (Refer  to  Section  2.4.3.5	for  more
   information.)

   RESTRICTIONS:    some functions require WHEEL or  OPERATOR  capability
				enabled

   ACCEPTS IN AC1:  B0(TL%CRO)	Clear  link   from   remote   to   object
				designator.   If the remote designator is
				-1,  all  remote  links  to  the   object
				designator are cleared.

		    B1(TL%COR)	Clear  link   from   object   to   remote
				designator.   If the remote designator is
				-1, links from the object to  all  remote
				designators are cleared.

		    B2(TL%EOR)	Establish  link  from  object  to  remote
				designator.

		    B3(TL%ERO)	Establish  link  from  remote  to  object
				designator.

		    B4(TL%SAB)	Examine  B5(TL%ABS)  to   determine   the
				setting of the object designator's accept
				link bit.  If this  bit  is  off,  B5  is
				ignored.

		    B5(TL%ABS)	Set the object designator's  accept  link
				bit.   When  B4(TL%SAB) is on, the object
				designator is accepting links  if  TL%ABS
				is  on	and  refusing  links if TL%ABS is
				off.
   (TLINK)
   

		    B6(TL%STA)	Examine  B7(TL%AAD)  to   determine   the
				setting of the object designator's accept
				advice bit.  If this bit is  off,  B7  is
				ignored.

		    B7(TL%AAD)	Set the object designator's accept advice
				bit.   When  B6(TL%STA) is on, the object
				designator is accepting advice if  TL%AAD
				is  on	and  refusing advice if TL%ADD is
				off.

		    B18-B35	Object designator
		    (TL%OBJ)

	      AC2:  remote designator in the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The object and remote designators must be either  4xxxxx  or  -1.   An
   object designator of -1 indicates the controlling terminal.

   The following restrictions apply if the process does  not  have  WHEEL
   capability enabled:

	1.  The object designator must specify this terminal.

	2.  The object-to-remote link must be specified before or at  the
	    same time as the remote-to-object link.

   If the accept bit of the remote designator is not set, a link from the
   object-to-remote  designator  causes  the  remote designator's bell to
   ring.  If the remote designator does not set the accept bit within  15
   seconds, the TLINK call returns an error.

   When terminals are linked together and a character  is  typed  on  one
   terminal,  the  same  ASCII character code is sent to all terminals in
   the link.  The character always appears in the output buffers  of  all
   terminals  regardless of the current mode of each individual terminal.
   The character is sent according to the data mode and terminal type  of
   the	terminal  that	originates  the  character.   For example, if one
   terminal originates a TAB and has mechanical tabs set,  all	terminals
   in the link receive the ASCII code for a TAB in their output buffers.

   TLINK ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   TLNKX1:   illegal to set remote to object before object to remote

   TLNKX2:   link was not received within 15 seconds

   TLNKX3:   links full
   (TLINK)
   

   TTYX01:   line is not active


Node: TMON	Previous: TLINK	Next: TTMSG	Up: Top
			      TMON     JSYS 7

   Tests various monitor flags.

   ACCEPTS IN AC1:  function code

   RETURNS     +1:  always, value of the function in AC2

   The codes for the functions are as follows:

     Code  Symbol		 Meaning

      0    .SFFAC      FACT file entries are allowed.
      1    .SFCDE      CHECKD found errors.
      2    .SFCDR      CHECKD is running.
      3    .SFMST      Manual start is in progress.
      4    .SFRMT      Remote LOGINs (dataset lines) are allowed.
      5    .SFPTY      PTY LOGINs are allowed.
      6    .SFCTY      CTY LOGINs are allowed.
      7    .SFOPR      Operator is in attendance.
     10    .SFLCL      Local LOGINs (hardwired lines) are allowed.
     11    .SFBTE      Bit table errors found on startup.
     12    .SFCRD      Users   can   change    nonprivileged	directory
		       parameters with the CRDIR monitor call.
     13    .SFNVT      ARPANET terminal LOGINs are allowed.
     21    .SFUSG      USAGE file entries are allowed.
     22    .SFFLO      Disk latency optimization using	the  RH20  backup
		       register  is  enabled.	This feature is not to be
		       enabled unless the M8555 board of the RH20  is  at
		       Revision   Level   D  AND  either  of  the  KL10-C
		       processor  is  at  Revision  Level  10  or  KL10-E
		       processor is at Revision Level 2.
    23    .SFMTA      If set, enables MOUNTR magtape allocation.
     44    .SFNTN      Turn ARPANET on.
     45    .SFNDU      Reinitialize ARPANET if it is down.
     46    .SFNHI      Initialize ARPANET host table.
     47    .SFTMZ      Set the local time zone to the value given in AC2.
     50    .SFLHN      Set the local ARPANET host  number  to  the  value
		       given in AC2.
     51    .SFAVR      Account validation will be running on this system.
     52    .SFSTS      Enable/disable status reporting.
    53    .SFSOK      Get GETOK% defaults

		       For this function, AC2 is set up as follows:

			    AC2:  Flags,,GETOK% function code

		       Flags:
   (TMON)
   

		       Bit Symbol  Meaning

		       1B0 SF%EOK  0 = Disable access checking
					   1 = Enable access checking

		       1B1 SF%DOK  0 = Deny access if checking disabled
						   1 = Allow access if checking disabled

		       See the description of the GETOK% JSYS for  GETOK%
		       function codes.

      54   .SFMCY      Specifies the maximum  offline  expiration  period
		       (tape recycle period) for ordinary files.
      55   .SFRDU      Read date update function
      56   .SFACY      Specifies the maximum  offline  expiration  period
		       for archive files (tape recycle period).
      57   .SFRTW      Sets/clears  the  no-retrieval-wait  flag  in  the
		       monitor.  When set, this specifies that those file
		       retrievals  requests  that  are	waiting  for  the
		       retrieval should fail rather than wait.
      60   .SFTDF      Set tape mount controls

		       Flags:

		       Bit     Symbol	 Meaning

		       1B0     MT%UUT	 Set  =   unload   unrecognizable
					 tapes
					 Clear	=  treat   unrecognizable
					 tapes as unlabeled
      61   .SFWSP      Enable working set preloading

   The SMON monitor call can be used to set various monitor flags.

   Generates an illegal instruction interrupt on error conditions below.

   TMON ERROR MNEMONICS:

   TMONX1:   invalid TMON function


Node: TTMSG	Previous: TMON	Next: TWAKE	Up: Top
			     TTMSG     JSYS 775

   Sends a message to a specified terminal  or	to  all  terminals.   The
   TTMSG  call	is  a  temporary  call	and  may not be defined in future
   releases.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  400000 + TTY number, or -1 to send to all terminals
   (TTMSG)
   

	      AC2:  byte pointer to string in caller's address	space  to
		    be sent

   RETURNS     +1:  always

   The TTMSG monitor call is a no-op if the specified terminal	does  not
   exist.

   Generates an illegal instruction interrupt on error conditions below.

   TTMSG ERROR MNEMONICS:

   GTDIX1:   WHEEL or OPERATOR capability required


Node: TWAKE	Previous: TTMSG	Next: UFPGS	Up: Top
			     TWAKE     JSYS 771

   Wakes the specified job that is blocked because of the execution of	a
   THIBR call.	If more than one process in a job is blocked because of a
   THIBR call, execution  of  the  TWAKE  call	causes	any  one  of  the
   processes  to be awakened.  The TWAKE call is a temporary call and may
   not be defined in future releases.

   ACCEPTS IN AC1:  0 in the left half, and number of job to be  awakened
		    in the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success,  signal  sent.    Job   will   be	 awakened
		    immediately  if blocked by a THIBR call or as soon as
		    next THIBR call is executed.

   TWAKE ERROR MNEMONICS:

   ATACX1:   invalid job number


Node: UFPGS	Previous: TWAKE	Next: USAGE	Up: Top
			     UFPGS     JSYS 525

   Updates pages of the specified file.  This monitor  call  is  used  to
   guarantee  that  a  certain sequence of file pages has been written to
   the disk before any other operation is performed.

   ACCEPTS IN AC1:  JFN in the left half, and file  page  number  of  the
		    first page to be updated in the right half

	      AC2:  flags,,count of number of sequential pages to update
   (UFPGS)
   

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, all modified pages are written to disk.  The
		    FDB is updated, if necessary.

		    FLAGS:

	Bit	Symbol			     Meaning

	 0	UF%NOW	  Allows  performing   a   UFPGS   call   without
			  blocking.  The JSYS will not block even if some
			  pages need to be written to disk.

  If UF%NOW is not set, the UFPGS call causes the process to block until
  all writes to the disk are completed.

   UFPGS ERROR MNEMONICS:

   UFPGX1:   file is not opened for write

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DESX8:    file is not on disk

   LNGFX1:   page table does not exist and file not open for write

   IOX11:    quota exceeded or disk full


Node: USAGE	Previous: UFPGS	Next: USRIO	Up: Top
			     USAGE     JSYS 564

   Controls accounting on the system by writing entries into the system's
   data  file.	 All  entries  to  the data file are made with this call.
   Examples of the types of entries entered into the data file	are  disk
   storage  usage  for	regulated  structures,	input  and output spooler
   usage, job session entry, and date and time changes.

   The file written by the USAGE call is  an  intermediate  binary  file,
   which  is converted by a system program to the final ASCII file.  Each
   entry in the final file is at least	two  records  long,  each  record
   being  defined  as  a  string  of  ASCII  characters terminated with a
   line-feed character.   The  first  record  contains	system	and  file
   information;   its  format  is  the	same for all entries.  Subsequent
   records contain data pertaining to  the  entry;   their  formats  vary
   according to the particular data being entered.
   (USAGE)
   

   Refer  to  the  TOPS-20  USAGE  File  Specification	 for   additional
   information on the system's data file.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  function code

	      AC2:  function argument or  address  of  record  descriptor
		    block

   RETURNS     +1:  always

   The available functions are as follows:

	Code	Symbol			 Meaning

	 0	.USENT	  Write an entry into  the  system's  data  file.
			  AC2	contains   the	 address  of  the  record
			  descriptor block.

	 1	.USCLS	  Close the system's data file,  which	is  named
			  PS:<ACCOUNTS>SYSTEM-DATA.BIN.    No  additional
			  entires are recorded into this file and  a  new
			  SYSTEM-DATA.BIN   is	 opened   for  subsequent
			  entries.

	 2	.USCKP	  Perform  a  checkpoint  of  all   jobs.    Data
			  recorded   during  a	checkpoint  includes  the
			  billable data  (e.g.,  connect  time,  runtime)
			  accumulated  during  the  job session, starting
			  from time of login  or  the  last  SET  ACCOUNT
			  command and ending at the time this function is
			  performed.  The data collected on  a	LOGIN  or
			  SET ACCOUNT command is entered into the session
			  entry in the data file.  The default checkpoint
			  time interval is 10 minutes.

	 3	.USLGI	  Initialize a	checkpoint  entry  for	the  job.
			  This	function  is used internally by the LOGIN
			  monitor call.  AC2 contains the address of  the
			  record descriptor block.

	 4	.USLGO	  Terminate the checkpoint entry for the job  and
			  write  an  entry  into  the system's data file,
			  which  is  named  PS:<ACCOUNTS>SYSTEM-DATA.BIN.
			  This	function  is used internally by the LGOUT
			  monitor call.  AC2 contains the address of  the
			  record descriptor block.

	 5	.USSEN	  Terminate the current session, write	an  entry
			  into	the  system's  data  file, which is named
			  PS:<ACCOUNTS>SYSTEM-DATA.BIN, and initialize	a
			  new	checkpoint   entry  for  the  job.   This
			  function  is	used  internally  by  the   CACCT
			  monitor  call.  AC2 contains the address of the
   (USAGE)
   

			  record descriptor block.

	 6	.USCKI	  Set the checkpoint time interval.  AC2 contains
			  the interval in minutes.

	 7	.USENA	  Install the accounting data base from the  file
			  named  PS:<SYSTEM>ACCOUNTS-TABLE.BIN	into  the
			  running monitor.  The ACTGEN program uses  this
			  file to generate the list of valid accounts.

	 10	.USCAS	  Change accounting shift.   This  function  will
			  perform  a  "session	end"  function	for every
			  active job.

	 11	.USSAS	  Set accounting shifts.   Sets  the  times  when
			  automatic   accounting  shift  changes  are  to
			  occur.  This function takes an argument in  AC2
			  which  is a pointer to a block of the following
			  format:

			       table header

			       table entry

			       ...

			       table entry

			  The table header word contains  the  number  of
			  actual   entries  in	the  table  in	the  left
			  halfword,  and  the  maximum	number	of  table
			  entries  in  the  right  halfword.   Each table
			  entry is one word in the following format:

				   B0-B6       US%DOW Days  of	the  week
					       that   this  entry  is  in
					       effect.	Bit n is  set  if
					       this  entry  is	in effect
					       for day n (0 = Monday).

				   B7-B17      Unused, must be zero.

				   B18-B35     US%SSM Time  of	day  that
					       automatic   shift   change
					       should  occur.	Time   is
					       specified in seconds since
					       midnight.

			  The maximum number  of  table  entries  is  100
			  decimal.

  12		.USRAS	  Read accounting shifts.  This function  returns
			  the  times  of the automatic shift changes that
			  were set with .USSAS.  AC2 contains  a  pointer
			  to  an argument block that is filled in by this
   (USAGE)
   

			  function.  The block has the same format as the
			  .USSAS  block.   Note  that  the right halfword
			  (maximum size) of  the  table  header  must  be
			  specified by the user for .USRAS.

   The record descriptor block, whose address is given in AC2, is set  up
   by  the  UITEM. macro defined in ACTSYM.MAC.  (Refer to Appendix B for
   the definition of the UITEM. macro.)  The names of  all  data  entries
   are generated by this macro.  The USENT. macro is used to generate the
   header of the record descriptor block.

   The format of the data generated by the USAGE call is a list of  items
   describing  the  entries  in  a single record.  This list has a header
   word containing the version numbers and the type of entry.	The  data
   words  follow  this	header with two words per data item.  The list is
   terminated with a zero word.

   Generates an illegal instruction interrupt on error conditions below.

   USAGE ERROR MNEMONICS:

   CAPX1:    WHEEL or OPERATOR capability required

   ARGX02:   invalid function

   ARGX04:   argument block too small

   ARGX05:   argument block too long

   USGX01:   invalid USAGE entry type code

   USGX02:   item not found in argument list

   USGX03:   default item not allowed


Node: USRIO	Previous: USAGE	Next: UTEST	Up: Top
			     USRIO     JSYS 310

   Places the user program into user  I/O  mode  in  order  that  it  can
   execute  various  hardware  I/O  instructions.   The  user IOT flag is
   turned on in the PC of the running process.	 The  program  can  leave
  user  I/O  mode  by executing a JRSTF with a PC in which bit 6 is zero
  (e.g., JRSTF @[.+1]).

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, user IOT flag is set

   USRIO ERROR MNEMONICS:
   (USRIO)
   

   CAPX2:    WHEEL, OPERATOR, or MAINTENANCE capability required


Node: UTEST	Previous: USRIO	Next: UTFRK	Up: Top
			     UTEST     JSYS 563

   Provides a method for determining if every instruction in a section of
   monitor  code actually gets executed.  This monitor call does not test
   the code by executing it;  it confirms that a  test	of  the  code  is
   complete  by  reporting the instructions that were executed during the
   test.

   RESTRICTIONS:    requires WHEEL or OPERATOR capability enabled

   ACCEPTS IN AC1:  function code in the left half,  and  length  of  the
		    argument block in the right half.

	      AC2:  address of the argument block

   RETURNS     +1:  always

   The available functions are as follows:

	Code	Symbol			 Meaning

	 0	.UTSET	  Start testing of the code.

	 1	.UTCLR	  Stop testing of the code and update the bit map
			  in the argument block.

   The format of the argument block is as follows:

	Word	Symbol			 Meaning

	 0	.UTADR	  Address of the beginning of the section of code
			  that is to be tested.

	 1	.UTLEN	  Length of section of code that is to be tested.

	 2	.UTMAP	  Start of bit map representing the  instructions
			  that	are  to be tested in the section of code.
			  This map contains one bit for each location  in
			  the  section.   If  a bit is on in the map, the
			  corresponding instruction is to be tested.   If
			  a  bit is off, the corresponding instruction is
			  not to be tested.

			  Locations that  contain  data  and  that  would
			  cause the section of code to execute improperly
			  if that data were changed should not be tested.

   (UTEST)
   

   Internally, a copy of the code being tested is  placed  in  a  buffer,
   which  is  dynamically locked down during execution of the UTEST call.
   The system allows any monitor routine  to  be  tested  as  long  as	a
   pushdown  stack  pointed  to by AC P (i.e., 17) is set up whenever the
   routine is called.

   After execution of the .UTCLR function, the	bit  map  is  changed  to
   reflect  the instructions that were actually executed during the test.
   If a bit is on in the map, the corresponding instruction was executed.
   If a bit is off, the corresponding instruction was not executed.

   Generates an illegal instruction interrupt on error conditions below.

   UTEST ERROR MNEMONICS:

   CAPX3:    WHEEL capability required

   UTSTX1:   invalid function code

   UTSTX2:   area of code too large to test

   UTSTX3:   UTEST facility in use by another process


Node: UTFRK	Previous: UTEST	Next: VACCT	Up: Top
			     UTFRK     JSYS 323

   Resumes the execution of a process that  is	suspended  because  of	a
   monitor  call  intercept.  The instruction where the execution resumes
   depends on the current PC word of the suspended process.   To  prevent
   the	suspended  process  from executing the call, the superior process
   handling the intercept can change the PC word (via the SFORK or  SFRKV
   call).   Then  on  execution  of the UTFRK call, the suspended process
   continues at the  new  PC.	If  the  superior  process  handling  the
   intercept  does  not change the PC word of the suspended process, then
   the next superior process intercepting that	particular  monitor  call
   will receive the interrupt.

   See the description of the TFORK JSYS  for  more  information  on  the
   monitor call intercept facility.

   ACCEPTS IN AC1:  flag bits in the left half, and process handle in the
		    right half

   RETURNS     +1:  always

   The flag bit that can be given in AC1 is as follows:

	Bit	Symbol			 Meaning

	 0	UT%TRP	  Cause  a  failure  return  for  the	suspended
			  process.    This  return  will  be  either  the
   (UTFRK)
   

			  generation of an illegal instruction	interrupt
			  or   the   processing  of  an  ERJMP	or  ERCAL
			  instruction.

   The UTFRK monitor call is a no-op if

	1.  The process handle given is valid but the  process	specified
	    is not suspended because of a monitor call intercept.

	2.  The caller	is  not  one  of  the  processes  monitoring  the
	    suspended  process	and  therefore is not permitted to resume
	    the process.

   Generates an illegal instruction interrupt on error conditions below.

   UTFRK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: VACCT	Previous: UTFRK	Next: WAIT	Up: Top
			     VACCT     JSYS 566

   Verifies accounts by validating the supplied  account  for  the  given
   user.

   ACCEPTS IN AC1:  36-bit user number, 36-bit directory number, or -1 to
		    validate the account for the current user

	      AC2:  byte pointer to account string

   RETURNS     +1:  always, with updated pointer in AC2

   Generates an illegal instruction interrupt on error conditions below.

   VACCT ERROR MNEMONICS:

   VACCX0:   invalid account

   VACCX1:   account string exceeds 39 characters

   VACCX2:   account has expired

   MONX02:   insufficient system resources (JSB full)
   (VACCT)
   

   DELFX6:   internal format of directory is incorrect

   DIRX1:    invalid directory number

   DIRX3:    internal format of directory is incorrect

   STRX01:   structure is not mounted

   OPNX9:    invalid simultaneous access

   OPNX16:   file has bad index block


Node: WAIT	Previous: VACCT	Next: WFORK	Up: Top
			     WAIT     JSYS 306

   Dismisses the current process indefinitely and does	not  return.   If
   the software interrupt system is enabled for this process, the process
   can be interrupted out of the wait state.  Upon execution of  a  DEBRK
   call,  the  process	continues to wait until the next interrupt unless
   the interrupt routine changes the PC word.  In this case, the  process
   resumes  execution  at  the new PC location.  If the interrupt routine
   changes the PC word, it must set the user-mode bit (bit 5) of  the  PC
   word.  (Refer to Section 2.5.7.)


Node: WFORK	Previous: WAIT	Next: WILD%	Up: Top
			     WFORK     JSYS 163

   Causes the  current	process  to  wait  for	an  inferior  process  to
  terminate  (voluntarily  or	involuntarily).   A process is considered
  terminated if its state is either .RFHLT or	.RFFPT	(refer	to  RFSTS
  JSYS for a description of process status).

   ACCEPTS IN AC1:  inferior process handle, or -4 in the right  half  to
		    wait  for  any  one  of  the  inferior  processes  to
		    terminate

   RETURNS     +1:  always,  when  one	 of   the   specified	processes
		    terminates

   This call returns immediately if the specified process or one  of  the
   inferior processes has already terminated.

   Generates an illegal instruction interrupt on error conditions below.

   WFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle
   (WFORK)
   

   FRKHX2:   illegal to manipulate a superior process


Node: WILD%	Previous: WFORK		Next: ZZZZZ	Up: Top
			     WILD%     JSYS 565

  Compares a possibly wild string against a non-wild string  to  see  if
  the	latter	matches  the  wild string.  For example, "AND" would be a
  legal match for the wild string "A*D".   Likewise  "AND"  would  be	a
  legal  match  for  the  wild  string  "A%%".  The WILD% JSYS will also
  compare a possibly wild file specification  against	a  non-wild  file
  specification.

  ACCEPTS IN AC1:  flags in the left half, function in the right half

	      AC2:  wild argument - JFN or byte pointer to string

	      AC3:  non-wild argument - JFN or byte pointer to string

  RETURNS     +1:  always, with information returned in AC1.

  This call returns immediately if the specified process or one  of  the
  inferior processes has already terminated.

  The available functions are as follows:

	Code	Symbol			 Meaning

	 0	.WLSTR	  Compare a non-wild string against a wild string

			  AC2 contains a byte pointer to  a  wild  string
			  and  AC3  contains a byte pointer to a non-wild
			  string.  The comparison is made without  regard
			  to what kind of characters the strings contain.
			  Thus tabs, spaces,  and  carriage  returns  for
			  example  are	treated just as letters are.  The
			  following flag can be set in AC1:

			  B0(WL%LCD)	Lower case characters are  to  be
					treated  as  distinct  from upper
					case letters.  If this bit is not
					set,  a lower case character will
					match  the  corresponding   upper
					case character.

			  On return, AC1 contains the following flag:

			  B0(WL%NOM)	If set, this bit  indicates  that
   (WILD%)
   

					the non-wild string did not match
					the wild string.

			  B1(WL%ABR)	If set, this bit  indicates  that
					the   non-wild	 string   is  not
					matched, but is  an  abbreviation
					of the wild string.

	 1	.WLJFN	  Compare a non-wild file specification against a
			  wild	file  specification.   AC2 contains a JFN
			  with flags (as returned by GTJFN) for the  wild
			  file and AC3 contains a JFN (without flags) for
			  the non-wild file.  Flags are returned  in  AC1
			  that	 indicate   which   parts   of	the  file
			  specification do not match.  These flags are:

			  B1(WL%DEV)	Device field does not match
			  B2(WL%DIR)	Directory field does not match
			  B3(WL%NAM)	Name field does not match
			  B4(WL%EXT)	File type does not match
			  B5(WL%GEN)	Generation number does not match

  If a JFN is given that is a parse-only JFN, and one of the  fields  is
  not	specified  (such as a file name), that field will be treated as a
  null   field.    Thus   the	  filenames    PS:<DBELL>FOO.BAR.3    and
  PS:<DBELL>.BAR.3 will not match.

  If no flags are specified in AC1, then  the	WILD%  JSYS  will  simply
  compare  the  two strings character by character.  This feature can be
  used to compare two non-wild strings.

  WILD% ERROR MNEMONICS:

  DESX3:    JFN is not assigned

  RDTX1:    Invalid string pointer

  ARGX02:   Invalid function

  ARGX22:   Invalid flags


Node: Ethernet
			Ethernet Help
	The following JSYS's have either been added or modified to
    MONITR in order to run the Ethernet.
	PUPI	PUPO	PUPNM
	OPENF modifications
	MTOPR functions
	GETAB tables
	ATNVT functions
	SMON functions

	In addition, some additional error codes for these JSYS's 
    are as follows:
	    PUPX1:	Block size error
	    PUPX2:	PUP address error
	    PUPX3:	Operation not possible now
	    PUPX4:  JFN open for sequential I/O only
	    PUPX5:	Checksum incorrect
	    PUPX6:	Destination address incorrect
	    PUPX7:	Source address incorrect
	    PUPX8:	JFN does not refer to device PUP:
	    PUPNX1:	Name or address not found
	    PUPNX2:	Recognition invoked and name ambiguous
	    PUPNX3:	Syntax error or illegal address
	    PUPNX4:	Inconsistent values in name expression
	    PUPNX5:	Syntax error in attribute name string
	    PUPNX6:	Attribute name not found
	    ATNX14:	JFNs do not refer to same device
	    ATNX15:	PUP JFNs do not refer to same local port
	    ATNX16:	PUP JFNs do not refer to BSP port
	    ATNX17:	PUP connection not open

	For further documentation, read the individual JSYS calls.

Node: ZZZZZ	Previous: WILD%		Up: Top
				         ZZZZZ
							     APPENDIX A

							     MONSYM.MAC							     

	1		       ;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
	2		       ;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
	3		       ;
	4		       ;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
	5
	7
	8		       ; TEMP DEFINITION OF XHLLI
	9    501000  000000	 OPDEF	XHLLI [HLLI]  ;NOT IN MACRO YET
       10		       ;MONITOR CALL DEFINITIONS AND ERROR MNEMONICS
       11
       12		       ;NOTE:
       13		       ; THE FOLLOWING SYMBOLS ARE RESERVED:
       14		       ;
       15		       ;  SYMBOL  RESERVED BY
       16		       ;  ======  ===========
       17		       ;
       18		       ;  .OF???  RMS-20
       19		       ;  .SZ???  RMS-20
       20		       ;  .PS???  RMS-20
       21
       22		       ;MACRO TO DEFINE JSYS NAMES
       23
       24		       DEFINE DEFJS (NAME,NUM,SECT,XTRA,OLDNEW)<
       25			 OPDEF NAME'% [104B8+NUM]
       26			 IFDEF .PSECT,<
       27			 INTERN NAME'%
       28			 IFIDN <OLDNEW,OLD,
       29			 OPDEF NAME [104B8+NUM]
       30			 IFDEF .PSECT,<
       31			 INTERN NAME
       32
       33			 SALL
       34
       35      000000		 IFNDEF REL,<REL==0  ;ASSEMBLING REL IF NON-0
       36			 IFE REL,<
       37			 UNIVERSAL MONSYM
       38			  IFN REL,<
       39			 TITLE MONSYM
       40			 IFNDEF .PSECT,<
       41			 .DIRECT .XTABM

	  42
       43
       44		       ;JSYS DEFINITIONS WITH 'NIM' AS A FOURTH ARGUMENT ARE CLASSIFIED
       45		       ; AS 'NOT IN MONITOR'
       46
       47		       DEFINE JSLIST <
       48
       49		       DEFJS LOGIN,1,MSEC1,,OLD
       50		       DEFJS CRJOB,2,MSEC1,,OLD
       51		       DEFJS LGOUT,3,MSEC1,,OLD
       52		       DEFJS CACCT,4,MSEC1,,OLD
       53		       DEFJS EFACT,5,MSEC1,,OLD
       54		       DEFJS SMON,6,MSEC1,,OLD
       55		       DEFJS TMON,7,MSEC1,,OLD
       56		       DEFJS GETAB,10,MSEC1,,OLD
       57		       DEFJS ERSTR,11,MSEC1,,OLD
       58		       DEFJS GETER,12,MSEC1,,OLD
       59		       DEFJS GJINF,13,MSEC1,,OLD
       60		       DEFJS TIME,14,MSEC1,,OLD
       61		       DEFJS RUNTM,15,MSEC1,,OLD
       62		       DEFJS SYSGT,16,MSEC1,,OLD
       63		       DEFJS GNJFN,17,MSEC1,,OLD
       64		       DEFJS GTJFN,20,MSEC1,,OLD
       65		       DEFJS OPENF,21,MSEC1,,OLD
       66		       DEFJS CLOSF,22,MSEC1,,OLD
       67		       DEFJS RLJFN,23,MSEC1,,OLD
       68		       DEFJS GTSTS,24,MSEC1,,OLD
       69		       DEFJS STSTS,25,MSEC1,,OLD
       70		       DEFJS DELF,26,MSEC1,,OLD
       71		       DEFJS SFPTR,27,MSEC1,,OLD
       72		       DEFJS JFNS,30,MSEC1,,OLD
       73		       DEFJS FFFFP,31,MSEC1,,OLD
       74		       DEFJS RDDIR,32,MSEC1,,OLD ;OBSOLETE,,OLD
       75		       DEFJS CPRTF,33,,NIM,OLD
       76		       DEFJS CLZFF,34,MSEC1,,OLD
       77		       DEFJS RNAMF,35,MSEC1,,OLD
       78		       DEFJS SIZEF,36,MSEC1,,OLD
       79		       DEFJS GACTF,37,MSEC1,,OLD
       80		       DEFJS STDIR,40,MSEC1,,OLD ;OBSOLETE,,OLD
       81		       DEFJS DIRST,41,MSEC1,,OLD
       82		       DEFJS BKJFN,42,MSEC1,,OLD
       83		       DEFJS RFPTR,43,MSEC1,,OLD
       84		       DEFJS CNDIR,44,,NIM,OLD
       85		       DEFJS RFBSZ,45,MSEC1,,OLD
       86		       DEFJS SFBSZ,46,MSEC1,,OLD
       87		       DEFJS SWJFN,47,MSEC1,,OLD
       88		       DEFJS BIN,50,MSEC1,,OLD
       89		       DEFJS BOUT,51,MSEC1,,OLD
       90		       DEFJS SIN,52,MSEC1,,OLD
       91		       DEFJS SOUT,53,MSEC1,,OLD
       92		       DEFJS RIN,54,MSEC1,,OLD
       93		       DEFJS ROUT,55,MSEC1,,OLD
       94		       DEFJS PMAP,56,MSEC1,,OLD
       95		       DEFJS RPACS,57,MSEC1,,OLD

	  96			  DEFJS SPACS,60,MSEC1,,OLD
       97		       DEFJS RMAP,61,MSEC1,,OLD
       98		       DEFJS SACTF,62,MSEC1,,OLD
       99		       DEFJS GTFDB,63,MSEC1,,OLD
      100		       DEFJS CHFDB,64,MSEC1,,OLD
      101		       DEFJS DUMPI,65,MSEC1,,OLD
      102		       DEFJS DUMPO,66,MSEC1,,OLD
      103		       DEFJS DELDF,67,MSEC1,,OLD
      104		       DEFJS ASND,70,MSEC1,,OLD
      105		       DEFJS RELD,71,MSEC1,,OLD
      106		       DEFJS CSYNO,72,,NIM,OLD
      107		       DEFJS PBIN,73,MSEC1,,OLD
      108		       DEFJS PBOUT,74,MSEC1,,OLD
      109		       DEFJS PSIN,75,,NIM,OLD
      110		       DEFJS PSOUT,76,MSEC1,,OLD
      111		       DEFJS MTOPR,77,MSEC1,,OLD
      112		       DEFJS CFIBF,100,MSEC1,,OLD
      113		       DEFJS CFOBF,101,MSEC1,,OLD
      114		       DEFJS SIBE,102,MSEC1,,OLD
      115		       DEFJS SOBE,103,MSEC1,,OLD
      116		       DEFJS DOBE,104,MSEC1,,OLD
      117		       DEFJS GTABS,105,MSEC1,,OLD ;OBSOLETE
      118		       DEFJS STABS,106,MSEC1,,OLD ;OBSOLETE
      119		       DEFJS RFMOD,107,MSEC1,,OLD
      120		       DEFJS SFMOD,110,MSEC1,,OLD
      121		       DEFJS RFPOS,111,MSEC1,,OLD
      122		       DEFJS RFCOC,112,MSEC1,,OLD
      123		       DEFJS SFCOC,113,MSEC1,,OLD
      124		       DEFJS STI,114,MSEC1,,OLD
      125		       DEFJS DTACH,115,MSEC1,,OLD
      126		       DEFJS ATACH,116,MSEC1,,OLD
      127		       DEFJS DVCHR,117,MSEC1,,OLD
      128		       DEFJS STDEV,120,MSEC1,,OLD
      129		       DEFJS DEVST,121,MSEC1,,OLD
      130		       DEFJS MOUNT,122,MSEC1,,OLD ;OBSOLETE
      131		       DEFJS DSMNT,123,,,OLD  ;OBSOLETE
      132		       DEFJS INIDR,124,MSEC1,,OLD ;OBSOLETE
      133		       DEFJS SIR,125,MSEC1,,OLD
      134		       DEFJS EIR,126,MSEC1,,OLD
      135		       DEFJS SKPIR,127,MSEC1,,OLD
      136		       DEFJS DIR,130,MSEC1,,OLD
      137		       DEFJS AIC,131,MSEC1,,OLD
      138		       DEFJS IIC,132,MSEC1,,OLD
      139		       DEFJS DIC,133,MSEC1,,OLD
      140		       DEFJS RCM,134,MSEC1,,OLD
      141		       DEFJS RWM,135,MSEC1,,OLD
      142		       DEFJS DEBRK,136,MSEC1,,OLD
      143		       DEFJS ATI,137,MSEC1,,OLD
      144		       DEFJS DTI,140,MSEC1,,OLD
      145		       DEFJS CIS,141,MSEC1,,OLD
      146		       DEFJS SIRCM,142,MSEC1,,OLD
      147		       DEFJS RIRCM,143,MSEC1,,OLD
      148		       DEFJS RIR,144,MSEC1,,OLD
      149		       DEFJS GDSTS,145,MSEC1,,OLD

	 150			  DEFJS SDSTS,146,MSEC1,,OLD
      151		       DEFJS RESET,147,MSEC1,,OLD
      152		       DEFJS RPCAP,150,MSEC1,,OLD
      153		       DEFJS EPCAP,151,MSEC1,,OLD
      154		       DEFJS CFORK,152,MSEC1,,OLD
      155		       DEFJS KFORK,153,MSEC1,,OLD
      156		       DEFJS FFORK,154,MSEC1,,OLD
      157		       DEFJS RFORK,155,MSEC1,,OLD
      158		       DEFJS RFSTS,156,MSEC1,,OLD
      159		       DEFJS SFORK,157,MSEC1,,OLD
      160		       DEFJS SFACS,160,MSEC1,,OLD
      161		       DEFJS RFACS,161,MSEC1,,OLD
      162		       DEFJS HFORK,162,MSEC1,,OLD
      163		       DEFJS WFORK,163,MSEC1,,OLD
      164		       DEFJS GFRKH,164,MSEC1,,OLD
      165		       DEFJS RFRKH,165,MSEC1,,OLD
      166		       DEFJS GFRKS,166,MSEC1,,OLD
      167		       DEFJS DISMS,167,MSEC1,,OLD
      168		       DEFJS HALTF,170,MSEC1,,OLD
      169		       DEFJS GTRPW,171,MSEC1,,OLD
      170		       DEFJS GTRPI,172,MSEC1,,OLD
      171		       DEFJS RTIW,173,MSEC1,,OLD
      172		       DEFJS STIW,174,MSEC1,,OLD
      173		       DEFJS SOBF,175,MSEC1,,OLD
      174		       DEFJS RWSET,176,MSEC1,,OLD
      175		       DEFJS GETNM,177,MSEC1,,OLD
      176		       DEFJS GET,200,MSEC1,,OLD
      177		       DEFJS SFRKV,201,MSEC1,,OLD
      178		       DEFJS SAVE,202,MSEC1,,OLD
      179		       DEFJS SSAVE,203,MSEC1,,OLD
      180		       DEFJS SEVEC,204,MSEC1,,OLD
      181		       DEFJS GEVEC,205,MSEC1,,OLD
      182		       DEFJS GPJFN,206,MSEC1,,OLD
      183		       DEFJS SPJFN,207,MSEC1,,OLD
      184		       DEFJS SETNM,210,MSEC1,,OLD
      185		       DEFJS FFUFP,211,MSEC1,,OLD
      186		       DEFJS DIBE,212,MSEC1,,OLD
      187		       DEFJS FDFRE,213,,NIM,OLD
      188		       DEFJS GDSKC,214,MSEC1,,OLD
      189		       DEFJS LITES,215,MSEC1,,OLD ;OBSOLETE
      190		       DEFJS TLINK,216,MSEC1,,OLD
      191		       DEFJS STPAR,217,MSEC1,,OLD
      192		       DEFJS ODTIM,220,MSEC1,,OLD
      193		       DEFJS IDTIM,221,MSEC1,,OLD
      194		       DEFJS ODCNV,222,MSEC1,,OLD
      195		       DEFJS IDCNV,223,MSEC1,,OLD
      196		       DEFJS NOUT,224,MSEC1,,OLD
      197		       DEFJS NIN,225,MSEC1,,OLD
      198		       DEFJS STAD,226,MSEC1,,OLD
      199		       DEFJS GTAD,227,MSEC1,,OLD
      200		       DEFJS ODTNC,230,MSEC1,,OLD
      201		       DEFJS IDTNC,231,MSEC1,,OLD
      202		       DEFJS FLIN,232,MSEC1,,OLD
      203		       DEFJS FLOUT,233,MSEC1,,OLD

	 204			  DEFJS DFIN,234,MSEC1,,OLD
      205		       DEFJS DFOUT,235,MSEC1,,OLD
      206
      207		       DEFJS CRDIR,240,MSEC1,,OLD
      208		       DEFJS GTDIR,241,MSEC1,,OLD
      209		       DEFJS DSKOP,242,MSEC1,,OLD
      210		       DEFJS SPRIW,243,MSEC1,,OLD
      211		       DEFJS DSKAS,244,MSEC1,,OLD
      212		       DEFJS SJPRI,245,MSEC1,,OLD
      213		       DEFJS STO,246,MSEC1,,OLD
      214		       DEFJS ARCF,247,MSEC1,,OLD  ;ARCHIVE SYSTEM JSYS
      215		       DEFJS ASNDP,260,,NIM,OLD
      216		       DEFJS RELDP,261,,NIM,OLD
      217		       DEFJS ASNDC,262,,NIM,OLD
      218		       DEFJS RELDC,263,,NIM,OLD
      219		       DEFJS STRDP,264,,NIM,OLD
      220		       DEFJS STPDP,265,,NIM,OLD
      221		       DEFJS STSDP,266,,NIM,OLD
      222		       DEFJS RDSDP,267,,NIM,OLD
      223		       DEFJS WATDP,270,,NIM,OLD
      224
      225		       DEFJS GTNCP,272,MSEC1,,OLD	;TOPS20AN
      226		       DEFJS GTHST,273,MSEC1,,OLD	;TOPS20AN
      227		       DEFJS ATNVT,274,MSEC1,,OLD	;TOPS20AN
      228		       DEFJS CVSKT,275,MSEC1,,OLD	;TOPS20AN
      229		       DEFJS CVHST,276,MSEC1,,OLD	;TOPS20AN
      230		       DEFJS FLHST,277,MSEC1,,OLD	;TOPS20AN
      231
      232		       DEFJS GCVEC,300,MSEC1,,OLD
      233		       DEFJS SCVEC,301,MSEC1,,OLD
      234		       DEFJS STTYP,302,MSEC1,,OLD
      235		       DEFJS GTTYP,303,MSEC1,,OLD
      236		       DEFJS BPT,304,MSEC1,,OLD ;OBSOLETE
      237		       DEFJS GTDAL,305,MSEC1,,OLD
      238		       DEFJS WAIT,306,MSEC1,,OLD
      239		       DEFJS HSYS,307,MSEC1,,OLD
      240		       DEFJS USRIO,310,MSEC1,,OLD
      241		       DEFJS PEEK,311,MSEC1,,OLD
      242		       DEFJS MSFRK,312,MSEC1,,OLD
      243		       DEFJS ESOUT,313,MSEC1,,OLD
      244		       DEFJS SPLFK,314,MSEC1,,OLD
      245		       DEFJS ADVIS,315,,NIM,OLD
      246		       DEFJS JOBTM,316,,NIM,OLD
      247		       DEFJS DELNF,317,MSEC1,,OLD
      248		       DEFJS SWTCH,320,MSEC1,,OLD ;OBSOLETE
      249		       DEFJS TFORK,321,MSEC1,,OLD
      250		       DEFJS RTFRK,322,MSEC1,,OLD
      251		       DEFJS UTFRK,323,MSEC1,,OLD
      252		       DEFJS SCTTY,324,MSEC1,,OLD
      253
      254		       DEFJS SETER,336,MSEC1,,OLD
      255
      256
      257		       ;NEW (NOT IN BBN TENEX) JSYS'S ADDED STARTING AT 500

	 258
      259		       DEFJS RSCAN,500,MSEC1,,OLD
      260		       DEFJS HPTIM,501,MSEC1,,OLD
      261		       DEFJS CRLNM,502,MSEC1,,OLD
      262		       DEFJS INLNM,503,MSEC1,,OLD
      263		       DEFJS LNMST,504,MSEC1,,OLD
      264		       DEFJS RDTXT,505,MSEC1,,OLD ;OBSOLETED BY RDTTY AND TEXTI
      265		       DEFJS SETSN,506,MSEC1,,OLD
      266		       DEFJS GETJI,507,MSEC1,,OLD
      267		       DEFJS MSEND,510,MSEC1,,OLD
      268		       DEFJS MRECV,511,MSEC1,,OLD
      269		       DEFJS MUTIL,512,MSEC1,,OLD
      270		       DEFJS ENQ,513,MSEC1,,OLD
      271		       DEFJS DEQ,514,MSEC1,,OLD
      272		       DEFJS ENQC,515,MSEC1,,OLD
      273		       DEFJS SNOOP,516,MSEC1,,OLD
      274		       DEFJS SPOOL,517,MSEC1,,OLD
      275		       DEFJS ALLOC,520,MSEC1,,OLD
      276		       DEFJS CHKAC,521,MSEC1,,OLD
      277		       DEFJS TIMER,522,MSEC1,,OLD
      278		       DEFJS RDTTY,523,MSEC1,,OLD
      279		       DEFJS TEXTI,524,MSEC1,,OLD
      280		       DEFJS UFPGS,525,MSEC1,,OLD
      281		       DEFJS SFPOS,526,MSEC1,,OLD
      282		       DEFJS SYERR,527,MSEC1,,OLD
      283		       DEFJS DIAG,530,MSEC1,,OLD
      284		       DEFJS SINR,531,MSEC1,,OLD
      285		       DEFJS SOUTR,532,MSEC1,,OLD
      286		       DEFJS RFTAD,533,MSEC1,,OLD
      287		       DEFJS SFTAD,534,MSEC1,,OLD
      288		       DEFJS TBDEL,535,MSEC1,,OLD
      289		       DEFJS TBADD,536,MSEC1,,OLD
      290		       DEFJS TBLUK,537,MSEC1,,OLD
      291		       DEFJS STCMP,540,MSEC1,,OLD
      292		       DEFJS SETJB,541,MSEC1,,OLD
      293		       DEFJS GDVEC,542,MSEC1,,OLD
      294		       DEFJS SDVEC,543,MSEC1,,OLD
      295		       DEFJS COMND,544,MSEC1,,OLD
      296		       DEFJS PRARG,545,MSEC1,,OLD
      297		       DEFJS GACCT,546,MSEC1,,OLD
      298		       DEFJS LPINI,547,MSEC1,,OLD
      299		       DEFJS GFUST,550,MSEC1,,OLD
      300		       DEFJS SFUST,551,MSEC1,,OLD
      301		       DEFJS ACCES,552,MSEC1,,OLD
      302		       DEFJS RCDIR,553,MSEC1,,OLD
      303		       DEFJS RCUSR,554,MSEC1,,OLD
      304		       DEFJS MSTR,555,MSEC1,,OLD
      305		       DEFJS STPPN,556,MSEC1,,OLD
      306		       DEFJS PPNST,557,MSEC1,,OLD
      307		       DEFJS PMCTL,560,MSEC1,,OLD
      308		       DEFJS PLOCK,561,MSEC1,,OLD
      309		       DEFJS BOOT,562,MSEC1,,OLD
      310		       DEFJS UTEST,563,MSEC1,,OLD
      311		       DEFJS USAGE,564,MSEC1,,OLD

	 312			  DEFJS WILD,565,MSEC1
      313		       DEFJS VACCT,566,MSEC1,,OLD
      314		       DEFJS NODE,567,MSEC1,,OLD
      315		       DEFJS ADBRK,570,MSEC1,,OLD
      316		       DEFJS SINM,571,MSEC1
      317		       DEFJS SOUTM,572,MSEC1
      318		       DEFJS SWTRP,573,MSEC1
      319		       DEFJS GETOK,574,MSEC1
      320		       DEFJS RCVOK,575,MSEC1
      321		       DEFJS GIVOK,576,MSEC1
      322		       DEFJS SKED,577,MSEC1  ;SCHEDULER CONTROL JSYS
      323		       DEFJS MTU,600,MSEC1  ;MTU JSYS
      324
      325		       ;TEMPORARY JSYS DEFINITIONS
      326
      327		       DEFJS SNDIM,750,MSEC1,,OLD	;TOPS20AN
      328		       DEFJS RCVIM,751,MSEC1,,OLD	;TOPS20AN
      329		       DEFJS ASNSQ,752,MSEC1,,OLD	;TOPS20AN
      330		       DEFJS RELSQ,753,MSEC1,,OLD	;TOPS20AN
      331
      332		       DEFJS METER,766,MSEC1  ;METER JSYS. FOR KL ONLY
      333		       DEFJS SMAP,767,MSEC1,NIM ;RESERVED FOR FUTURE
      334		       DEFJS THIBR,770,MSEC1,,OLD
      335		       DEFJS TWAKE,771,MSEC1,,OLD
      336		       DEFJS MRPAC,772,MSEC1,,OLD
      337		       DEFJS SETPV,773,,NIM,OLD
      338		       DEFJS MTALN,774,MSEC1,,OLD
      339		       DEFJS TTMSG,775,MSEC1,,OLD
      340		       DEFJS MDDT,777,MSEC1
      341
      342			 ;;; END OF DEFINE JSLIST
      343
      344		       ;NOW EXPAND THE JSYS DEFINITIONS
      345
      346		       JSLIST
      347
      348		       ;ERROR CONDITION INSTRUCTIONS.  THESE ARE NOP'S UNLESS  IMMEDIATELY
      349		       ;FOLLOWING A JSYS WHICH FAILS.
      350
      351    320700  000000	 OPDEF ERJMP [JUMP 16,0]  ;JUMP ON ERROR
      352    320740  000000	 OPDEF ERCAL [JUMP 17,0]  ;CALL ON ERROR (SIMULATE PUSHJ 17,ADR)
      353			  IFNDEF FOR,<
      354			  IFDEF .PSECT,<
      355		       INTERN ERJMP,ERCAL
      356
      357
      358		       DEFINE GOPDEF (OP,DEF)<
      359			 OPDEF OP [DEF]
      360			  IFNDEF FOR,<
      361			  IFDEF .PSECT,<
      362			 INTERN OP
      363
      364    400000  000000	 IFIW==:1B0   ;INSTRUCTION FORMAT INDIRECT WORD
      365      000000		 EFIW==:0   ;EXTENDED FORMAT INDIRECT WORD

	 366
      367		       ;THE NO-OPERATION INSTRUCTION (MAY CHANGE FROM PROCESSOR TO PROCESSOR)
      368
      369		       GOPDEF NOP,<TRN 0,0
      370		       .NODDT NOP
      371
      372		       ;SPECIAL LOSEG SYMBOLS
      373
      374      000075		 .JBHSO==:75   ; 0 ,, HIGHSEG ORIGIN PAGE NUMBER
      375      000112		 .JBEDV==:112	;POINTER TO EXEC DATA VECTOR
      376      000000		  .EDCNT==:0  ;'EDV',,COUNT (INCLUDES THIS WORD)
      377      000001		  .EDHSB==:1  ;POINTER TO HIDDEN SYMBOL MAP SWITCHING BLOCK
      378      000002		  .EDSYM==:2  ;.JBSYM IN SYMBOL SPACE
      379      000003		  .EDUSY==:3  ;.JBUSY IN SYMBOL SPACE
      380      000004		  .EDHSF==:4  ;POINTER TO SYMBOLS HIDDEN FLAG WORD
      381
      382		       ;*****************************************
      383		       ;JSYS SPECIFIC ARGUMENTS
      384		       ;THE FOLLOWING ARE ORDERED ALPHABETICALLY BY JSYS NAME
      385		       ;*****************************************
      386
      387
      388		       ;ACCES - ACCESS A DIRECTORY (E.G., BY CONNECTING)
      389
      390    400000  000000	 AC%CON==:1B0	;CONNECT TO THE SPECIFIED DIRECTORY
      391    200000  000000	 AC%OWN==:1B1	;GAIN OWNERSHIP
      392    100000  000000	 AC%REM==:1B2	;REMOVE OWNERSHIP
      393
      394		       ;OFFSETS IN ARGUMENT BLOCK
      395
      396      000000		 .ACDIR==:0   ;DIRECTORY DESIGNATOR
      397      000001		 .ACPSW==:1   ;POINTER TO PASSWORD STRING
      398      000002		 .ACJOB==:2   ;JOB NUMBER (-1 FOR SELF)
      399
      400
      401		       ;ADBRK - Address break JSYS function codes and bits
      402
      403		       ;FUNCTION CODES
      404
      405      000000		 .ABSET==:0   ;SET USER ADDRESS BREAK
      406      000001		 .ABRED==:1   ;READ USER ADDRESS BREAK
      407      000002		 .ABCLR==:2   ;CLEAR USER ADDRESS BREAK
      408      000003		 .ABGAD==:3   ;GET ADDRESS OF TRAPPED INSTRUCTION
      409
      410		       ;FUNCTION BITS FOR FUNCTION .ABSET
      411
      412    400000  000000	 AB%RED==:1B0	;READ
      413    200000  000000	 AB%WRT==:1B1	;WRITE
      414    100000  000000	 AB%XCT==:1B2	;EXECUTE
      415
      416
      417		       ;ALLOC JSYS FUNCTION CODES
      418
      419      000000		 .ALCAL==:0   ;ALLOCATE A DEVICE

	 420
      421
      422		       ; ARCF
      423
      424      000000		 .ARRAR==:0   ; Request file archive (user)
      425      000000		  .ARCLR==:0  ; Clear the request
      426      000001		  .ARSET==:1  ; Set the request
      427		       ;  AR%NDL can be specified in AC2, defined elsewhere
      428      000001		 .ARRIV==:1   ; Request file migration (system)
      429      000002		 .AREXM==:2   ; File exempt from migration (system)
      430      000003		 .ARRFR==:3   ; Request file's contents be restored to disk
      431    400000  000000	    AR%NMS==:1B0   ; Request no msg on restoration
      432    200000  000000	    AR%WAT==:1B1   ; Wait for file to be restored to disk
      433      000004		 .ARDIS==:4   ; Clear archive status for file
      434    400000  000000	   AR%CR1==:1B0   ; Clear 1st run info
      435    200000  000000	   AR%CR2==:1B1   ; Clear 2nd run info
      436      000005		 .ARSST==:5   ; Set archive status for file
      437      000000		   .AROFL==:0	; Flags
      438    400000  000000	     AR%O1==:1B0   ; Set run 1 info
      439    200000  000000	     AR%O2==:1B1   ; Set run 2 info
      440    100000  000000	     AR%OFL==:1B2  ; Flush contents of file
      441    040000  000000	     AR%ARC==:1B3  ; Set FB%ARC (archive the file)
      442    020000  000000	     AR%CRQ==:1B4  ; Clear archive/migration request
      443      000001		   .ARTP1==:1	; Tape 1 ID
      444      000002		   .ARSF1==:2	; XWD TSN 1, TFN 1
      445    777777  000000	     AR%TSN==:777777B17  ; Tape saveset number
      446      777777		     AR%TFN==:777777B35  ; Tape file number
      447      000003		   .ARTP2==:3	; Tape 2 ID
      448      000004		   .ARSF2==:4	; XWD TSN 2, TFN 2
      449		       ;;;    AR%TSN==:777777B17 ; Tape saveset number
      450		       ;;;    AR%TFN==:777777B35 ; Tape file number
      451      000005		   .ARODT==:5	; Date and time
      452      000006		   .ARPSZ==:6	; Number of pages in the file (.ARGST only)
      453      000006		 .ARRST==:6   ; Restore contents to archived file
      454      000007		 .ARGST==:7   ; Get tape info for file (blk as for ARSST)
      455      000010		 .ARRFL==:10   ; Retrieve failed
      456      000011		 .ARNAR==:11   ; Set/clear resist archive
      457
      458		       ; Function  reason codes for IPCF msgs					  
      459
      460      000000		 .RETM==:0   ; Send retrieve message
      461      000000		   .RETR==:0   ; Normal retrieve
      462      000001		   .RETRW==:1	; User waiting for retrieve
      463      000001		 .NOTM==:1   ; Send notification message
      464      000000		   .FLXP==:0   ; Archive file expunged
      465      000001		   .ACLR==:1   ; Archive status cleared
      466
      467		       ;ATNVT	     ;TOPS20AN
      468
      469    100000  000000	 AN%NTP==:1B2	    ;TOPS20AN ;NEW TELNET PROTOCOL
      470
      471
      472		       ;ATACH
      473

	 474	400000	000000	    AT%CCJ==:1B0   ;C JOB WHEN ATTACHED
      475    200000  000000	 AT%NAT==:1B1	;NO ATTACH
      476    100000  000000	 AT%TRM==:1B2	;ATTACH JOB TO TERMINAL IN REGISTER 4
      477      777777		 AT%JOB==:777777B35  ;JOB NUMBER
      478
      479
      480
      481		       ;BOOT
      482
      483      000000		 .BTROM==:0   ;ACTIVATE ROM BOOT
      484      000000		  .BTDTE==:0  ;DTE-20 NUMBER
      485      000001		 .BTLDS==:1   ;LOAD SECONDARY BOOTSTRAP PROGRAM
      486      000001		  .BTERR==:1  ;ERROR FLAGS
      487      000002		  .BTSEC==:2  ;ADDRESS OF SECONDARY BOOTSTRAP PROGRAM
      488      000002		 .BTLOD==:2   ;LOAD MEMORY (OBSOLETE)
      489      000002		 .BTSMP==:2   ;SEND MOP MESSAGE
      490      000003		  .BTFLG==:3  ;FLAGS
      491    400000  000000	   BT%BEL==:1B0 ;SEND TO -11 DOORBELL AFTER SETUP
      492      000004		  .BTCNT==:4  ;NUMBER OF BYTES TO BE TRANSFERRED
      493      000005		  .BTLPT==:5  ;BYTE POINTER TO DATA TO BE LOADED
      494      000003		 .BTDMP==:3   ;DUMP MEMORY
      495      000005		  .BTDPT==:5  ;BYTE POINTER TO DESTINATION OF DUMPED DATA
      496      000004		 .BTIPR==:4   ;INITIALIZE COMMUNICATIONS PROTOCOL
      497      000001		  .BTPRV==:1  ;PROTOCOL VERSION NUMBER
      498      000005		 .BTTPR==:5   ;TERMINATE COMMUNICATIONS PROTOCOL
      499      000006		 .BTSTS==:6   ;RETURN PROTOCOL STATUS
      500      000001		  .BTCOD==:1  ;STATUS CODE
      501      000007		 .BTBEL==:7   ;WAIT FOR DOORBELL
      502      000010		 .BTRMP==:10   ;READ MOP MESSAGE
      503      000005		  .BTMPT==:5  ;POINTER TO DESTINATION FOR MOP MESSAGE
      504      000011		 .BTKML==:11   ;LOAD KMC11
      505      000000		  .BTKMC==:0  ;KMC11 ADDRESS
      506      000001		  .BTKER==:1  ;ERROR FLAGS
      507    400000  000000	   BT%CVE==:1B0 ;CRAM VERIFY ERROR (RH IS BAD DATA)
      508    200000  000000	   BT%DVE==:1B1 ;DRAM VERIFY ERROR (RH IS BAD DATA)
      509    100000  000000	   BT%RVE==:1B2 ;REG VERIFY ERROR (RH IS BAD DATA)
      510      000002		  .BTKCC==:2  ;COUNT OF CRAM DATA
      511      000003		  .BTKCP==:3  ;POINTER TO CRAM DATA (16 BIT DATA)
      512      000004		  .BTKDC==:4  ;COUNT OF DRAM DATA
      513      000005		  .BTKDP==:5  ;POINTER TO DRAM DATA (8 BIT DATA)
      514      000006		  .BTKRC==:6  ;COUNT OF REGISTER DATA
      515      000007		  .BTKRP==:7  ;POINTER TO REGISTER DATA (16 BIT DATA)
      516      000010		  .BTKSA==:10  ;RH IS STARTING ADDRESS
      517    400000  000000	   BT%KSA==:1B0 ;IS SET RH WANT TO START KMC11
      518      000012		 .BTKMD==:12   ;DUMP KMC11
      519      000013		 .BTRLC==:13   ;RETURN LINE COUNTERS
      520      000000		  .BTPRT==:0  ;PORT NUMBER
      521    400000  000000	   BT%ZRO==:1B0 ;CLEAR COUNTERS AFTER READING
      522      000001		  .BTZTM==:1  ;TIME SINCE COUNTERS HAVE BEEN ZEROED
      523      000002		  .BTSCC==:2  ;STATUS COUNT COUNT
      524      000003		  .BTSCP==:3  ;STATUS COUNT POINTER
      525      000004		  .BTRCC==:4  ;RECEIVE COUNT COUNT
      526      000005		  .BTRCP==:5  ;RECEIVE COUNT POINTER
      527      000006		  .BTTCC==:6  ;TRANSMIT COUNT COUNT

	 528	  000007	     .BTTCP==:7  ;TRANSMIT COUNT POINTER
      529      000014		 .BTCLI==:14   ;CONVERT LINEID TO PORT NUMBER
      530      000001		  .BTLID==:1  ;POINTER TO ASCIZ LINE-ID
      531      000015		 .BTCPN==:15   ;CONVERT PORT NUMBER TO LINE-ID
      532      000016		 .BTSTA==:16   ;SET STATION POLLING STATUS
      533      000017		 .BTSSP==:17   ;SET LINE STARTUP PRIORITY
      534      000001		  .BTPRI==:1  ;PRIORITY VALUE
      535      000020		 .BTSTP==:20   ;SET STATION POLLING PRIORITY
      536      000021		 .BTSDD==:21   ;SEND DDCMP MESSAGE
      537      000001		  .BTMSG==:1  ;ADDR OF MESSAGE
      538      000002		  .BTLEN==:2  ;BYTE COUNT OF MESSAGE
      539      000022		 .BTRDD==:22   ;RECEIVE A MESSAGE FROM DDCMP
      540      000001		  .BTSUP==:1  ;STATION CAME UP
      541      000002		  .BTSDW==:2  ;STATION WENT DOWN
      542      000003		  .BTCMP==:3  ;XMIT COMPLETE
      543      000004		  .BTSSF==:4  ;STARTUP FAILED
      544    400000  000000	   BT%CTL==:1B0 ;CONTROL MESSAGE
      545      000023		 .BTCHN==:23   ;ASSIGN A SOFTWARE INTERRUPT CHANNEL
      546      000001		  .BTESI==:1  ;CHANNEL NUMBER
      547
      548		       ;CFORK
      549
      550    400000  000000	 CR%MAP==:1B0	;SET MAP FOR NEW FORK TO POINT TO
      551			    ; THIS PROCESS
      552    200000  000000	 CR%CAP==:1B1	;MAKE CAPABILITIES IDENTICAL
      553    040000  000000	 CR%ACS==:1B3	;SET ACS FROM BLOCK
      554    020000  000000	 CR%ST==:1B4   ;START PROCESS AT PC
      555      777777		 CR%PCV==:777777B35  ;VALUE OF PC
      556
      557
      558		       ;CHFDB
      559
      560    400000  000000	 CF%NUD==:1B0	;NO UPDATE DIRECTORY
      561    000777  000000	 CF%DSP==:777B17   ;FDB DISPLACEMENT
      562      777777		 CF%JFN==:777777B35  ;JFN
      563
      564
      565
      566		       ;CHKAC JSYS DEFINITIONS
      567
      568		       ;CHKAC FLAG DEFINITIONS
      569
      570    400000  000000	 CK%JFN==:1B0	;JFN IS GIVEN AS AN ARGUMENT
      571
      572		       ;CHKAC ARGUMENT BLOCK OFFSET VALUES
      573
      574      000000		 .CKAAC==:0   ;ACCESS CODE
      575      000001		 .CKALD==:1   ;LOGGED IN USER NUMBER OF USER
      576      000002		 .CKACD==:2   ;CONNECTED DIR NUMBER OF USER
      577      000003		 .CKAEC==:3   ;ENABLED CAPABILITIES OF USER BEING CHK'D
      578      000004		 .CKAUD==:4   ;DIR NUMBER OF DIRECTORY CONTAINING FILE
      579      000005		 .CKAPR==:5   ;PROTECTION OF FILE
      580
      581		       ;CHKAC ACCESS CODES

	 582
      583      000000		 .CKARD==:0   ;READ AN EXISTING FILE
      584      000001		 .CKAWT==:1   ;WRITE AN EXISTING FILE
      585      000001		 .CKAWR==:1   ; (ANOTHER NAME FOR ABOVE)
      586      000002		 .CKAEX==:2   ;EXECUTE AN EXISTING FILE
      587      000003		 .CKAAP==:3   ;APPEND TO AN EXISTING FILE
      588      000004		 .CKADL==:4   ;GET DIR LISTING OF AN EXISTING FILE
      589      000006		 .CKADR==:6   ;READ THE DIRECTORY
      590      000007		 .CKAOF==:7   ;OPEN FILES IN DIR (NOT IMPLEMENTED)
      591      000010		 .CKACN==:10   ;CONNECT TO A DIR
      592      000011		 .CKACF==:11   ;CREATE FILES IN DIR
      593
      594
      595		       ;CLOSF
      596
      597    400000  000000	 CO%NRJ==:1B0	;NO RELEASE JFN
      598    200000  000000	 CO%WCL==:1B1	    ;TOPS20AN ;WAIT UNTIL MATCHING CLS IS RECEIVED
      599      777777		 CO%JFN==:777777B35  ;JFN
      600
      601
      602		       ;CLZFF
      603
      604    400000  000000	 CZ%NIF==:1B0	;NO INFERIOR FORK FILES
      605    200000  000000	 CZ%NSF==:1B1	;NO SELF FORK FILES
      606    100000  000000	 CZ%NRJ==:1B2	;NO RELEASE JFN
      607    040000  000000	 CZ%NCL==:1B3	;NO CLOSE FILE
      608    020000  000000	 CZ%UNR==:1B4	;UNRESTRICT
      609    010000  000000	 CZ%ARJ==:1B5	;ALWAYS RELEASE JFN
      610    004000  000000	 CZ%ABT==:1B6	;ABORT
      611    002000  000000	 CZ%NUD==:1B7	;NO UPDATE DIRECTORY
      612      777777		 CZ%PRH==:777777B35  ;PROCESS HANDLE
      613
      614
      615
      616		       ;CNDIR
      617
      618    400000  000000	 CN%CKP==:1B0	;CHECK PASSWORD ONLY
      619    200000  000000	 CN%NOC==:1B1	;NO CONNECT
      620    100000  000000	 CN%JOB==:1B2	;DOING CONNECT FOR ANOTHER JOB
      621      777777		 CN%DIR==:777777B35  ;DIRECTORY NUMBER
      622
      623
      624		       ;COMND
      625
      626		       ;COMND - COMMAND STATE BLOCK
      627
      628      000000		 .CMFLG==:0   ;USER FLAGS,,REPARSE DISPATCH ADDRESS
      629      000001		 .CMIOJ==:1   ;INJFN,,OUTJFN
      630      000002		 .CMRTY==:2   ;R BUFFER POINTER
      631      000003		 .CMBFP==:3   ;PTR TO TOP OF BUFFER
      632      000004		 .CMPTR==:4   ;PTR TO NEXT INPUT TO BE PARSED
      633      000005		 .CMCNT==:5   ;COUNT OF SPACE LEFT IN BUFFER AFTER PTR
      634      000006		 .CMINC==:6   ;COUNT OF CHARACTERS FOLLOWING PTR
      635      000007		 .CMABP==:7   ;ATOM BUFFER POINTER

	 636	  000010	    .CMABC==:10   ;ATOM BUFFER SIZE
      637      000011		 .CMGJB==:11   ;ADR OF GTJFN ARG BLOCK
      638      777777		  CM%GJB==:777777  ;ADR OF GTJFN ARG BLOCK
      639
      640		       ;COMND - FUNCTION DESCRIPTOR BLOCK
      641
      642      000000		 .CMFNP==:0   ;FUNCTION AND POINTER
      643    777000  000000	   CM%FNC==:777B8  ;FUNCTION CODE
      644    000777  000000	   CM%FFL==:777B17  ;FUNCTION-SPECIFIC FLAGS
      645      777777		   CM%LST==:777777  ;LIST POINTER TO OTHER BLOCKS
      646      000001		 .CMDAT==:1   ;DATA FOR FUNCTION
      647      000002		 .CMHLP==:2   ;HELP TEXT POINTER
      648      000003		 .CMDEF==:3   ;DEFAULT STRING POINTER
      649      000004		 .CMBRK==:4   ;FIELD BREAK MASK POINTER
      650
      651		       ;COMND - FLAGS IN .CMFLG
      652
      653    400000  000000	 CM%ESC==:1B0	;ESC SEEN
      654    200000  000000	 CM%NOP==:1B1	;NO PARSE
      655    100000  000000	 CM%EOC==:1B2	;END OF COMMAND SEEN
      656    040000  000000	 CM%RPT==:1B3	;REPEAT PARSE NEEDED
      657    020000  000000	 CM%SWT==:1B4	;SWITCH TERMINATED WITH ":"
      658    010000  000000	 CM%PFE==:1B5	;PREVIOUS FIELD ENDED WITH ESC
      659    004000  000000	 CM%RAI==:1B6	;RAISE INPUT
      660    002000  000000	 CM%XIF==:1B7	;EXCLUDE INDIRECT FILES
      661    001000  000000	 CM%WKF==:1B8	;WAKEUP AFTER EACH FIELD
      662
      663		       ;FUNCTION BLOCK FLAGS (IN WORD .CMFNP)
      664
      665    000020  000000	 CM%BRK==:1B13	 ;BREAK MASK PRESENT
      666    000010  000000	 CM%PO==:1B14	;PARSE-ONLY
      667    000004  000000	 CM%HPP==:1B15	 ;HELP POINTER PRESENT
      668    000002  000000	 CM%DPP==:1B16	 ;DEFAULT POINTER PRESENT
      669    000001  000000	 CM%SDH==:1B17	 ;SUPPRESS DEFAULT HELP MESSAGE
      670
      671		       ;FLAGS FOR CMDIR FUNCTION
      672
      673    400000  000000	 CM%DWC==:1B0	;DIRECTORY WILD CARDING ALLOWED
      674
      675		       ;FLAGS FOR CMTAD FUNCTION
      676
      677    400000  000000	 CM%IDA==:1B0	;INPUT DATE
      678    200000  000000	 CM%ITM==:1B1	;INPUT TIME
      679    100000  000000	 CM%NCI==:1B2	;NO CONVERT TO INTERNAL
      680
      681		       ;FLAGS IN KEYWORD TABLE (FIRST WORD OF STRING IF B0-6 = 0)
      682
      683      000001		 CM%INV==:1B35	 ;INVISIBLE
      684      000002		 CM%NOR==:1B34	 ;NO-RECOGNIZE (PLACEHOLDER)
      685      000004		 CM%ABR==:1B33	 ;ABBREVIATION FOR ANOTHER ENTRY
      686    002000  000000	 CM%FW==:1B7   ;FLAG WORD (MUST ALWAYS BE ON)
      687
      688
      689		       ;COMND - FUNCTION CODES

	 690
      691      000000		 .CMKEY==:0   ;KEYWORD
      692      000001		 .CMNUM==:1   ;NUMBER
      693      000002		 .CMNOI==:2   ;NOISE WORD
      694      000003		 .CMSWI==:3   ;SWITCH
      695      000004		 .CMIFI==:4   ;INPUT FILE
      696      000005		 .CMOFI==:5   ;OUTPUT FILE
      697      000006		 .CMFIL==:6   ;GENERAL FILESPEC
      698      000007		 .CMFLD==:7   ;ARBITRARY FIELD
      699      000010		 .CMCFM==:10   ;CONFIRM
      700      000011		 .CMDIR==:11   ;DIRECTORY NAME
      701      000012		 .CMUSR==:12   ;USER NAME
      702      000013		 .CMCMA==:13   ;COMMA
      703      000014		 .CMINI==:14   ;INIT LINE
      704      000015		 .CMFLT==:15   ;FLOATING POINT NUMBER
      705      000016		 .CMDEV==:16   ;DEVICE NAME
      706      000017		 .CMTXT==:17   ;TEXT TO ACTION CHAR
      707      000020		 .CMTAD==:20   ;TIME AND DATE
      708      000021		 .CMQST==:21   ;QUOTED STRING
      709      000022		 .CMUQS==:22   ;UNQUOTED STRING
      710      000023		 .CMTOK==:23   ;TOKEN
      711      000024		 .CMNUX==:24   ;NUMBER DELIMITED BY NON-DIGIT
      712      000025		 .CMACT==:25   ;ACCOUNT
      713      000026		 .CMNOD==:26   ;NODE NAME
      714
      715		       ;DEFINE BREAK MASKS
      716
      717			 BRINI.   ;INITIALIZE BREAK MASK FOR STANDARD FIELD
      718			 BRKCH. (0,37)	;ALL CONTROL CHARACTERS
      719			 BRKCH. (40,54)  ;SPACE THROUGH COMMA
      720			 BRKCH. (56,57)  ;DOT AND SLASH
      721			 BRKCH. (72,77)  ;COLON THROUGH QUESTION MARK
      722			 BRKCH. (100)  ;ATSIGN
      723			 BRKCH. (133,140) ;OPEN BRACKET THROUGH ACCENT GRAVE
      724			 BRKCH. (173,177) ;CLOSE BRACKET THROUGH TILDE
      725
      726    777777  777760	 FLDB0.==W0.   ;STANDARD FIELD BREAK MASK
      727    777754  001760	 FLDB1.==W1.
      728    400000  000760	 FLDB2.==W2.
      729    400000  000760	 FLDB3.==W3.
      730
      731		       ;KEYWORD BREAK SET.  SAME AS STANDARD FIELD FOR NOW
      732
      733    777777  777760	 KEYB0.==FLDB0.
      734    777754  001760	 KEYB1.==FLDB1.
      735    400000  000760	 KEYB2.==FLDB2.
      736    400000  000760	 KEYB3.==FLDB3.
      737
      738		       ;USERNAME BREAK SET.  BREAKS ON EVERYTHING EXCEPT DOT AND ALPHABETICS.
      739
      740			 UNBRK. "."  ;MODIFY FIELD BREAK SET INTO USER BREAK SET.  DON'T BREAK O
      741		       N DOT
      742			 UNBRK. "%"  ;DON'T BREAK ON PERCENT
      743			 UNBRK. "*"  ;STAR

	 744
      745    777777  777760	 USRB0.==W0.
      746    767544  001760	 USRB1.==W1.
      747    400000  000760	 USRB2.==W2.
      748    400000  000760	 USRB3.==W3.
      749
      750		       ;ACCOUNT MASK CURRENTLY THE SAME AS USER MASK
      751
      752    777777  777760	 ACTB0.==USRB0.
      753    767544  001760	 ACTB1.==USRB1.
      754    400000  000760	 ACTB2.==USRB2.
      755    400000  000760	 ACTB3.==USRB3.
      756
      757		       ;FILESPEC FIELD - FILESPEC PUNCTUATION CHARACTERS
      758		       ;ARE LEGAL ( :, <, , ., ;)
      759
      760			 UNBRK. ":"  ;MODIFY USERNAME BREAK SET INTO FILE BREAK SET.  DON'T BREA
      761		       K ON THESE
      762			 UNBRK. "<"
      763			 UNBRK. ""
      764			 UNBRK. "["
      765			 UNBRK. "]"
      766			 UNBRK. ";"
      767			 UNBRK. "$"  ;ALLOW DOLLARSIGN! (I NEVER KNEW THAT BEFORE)
      768
      769    777777  777760	 FILB0.==W0.
      770    747544  000120	 FILB1.==W1.
      771    400000  000260	 FILB2.==W2.
      772    400000  000760	 FILB3.==W3.
      773
      774		       ;READ DEVICE NAME
      775
      776		       BRINI. FLDB0.,FLDB1.,FLDB2.,FLDB3. ;VERY SIMILAR TO STANDARD FIELD
      777		       UNBRK. "$"   ;ALLOW DOLLARSIGN IN DEVICE NAME (LIKE FILESPEC)
      778		       UNBRK. ""   ;UNDERSCORE TOO
      779
      780    777777  777760	 DEVB0.==W0.
      781    757754  001760	 DEVB1.==W1.
      782    400000  000740	 DEVB2.==W2.
      783    400000  000760	 DEVB3.==W3.
      784
      785		       ;READ TO END OF LINE
      786
      787			 BRINI.   ;INITIALIZE END OF LINE BREAK SET
      788			 BRKCH. .CHLFD	;BREAK ON LINEFEED
      789			 BRKCH. .CHCRT	;AND CARRIAGE RETURN
      790
      791    000220  000000	 EOLB0.==W0.
      792      000000		 EOLB1.==W1.
      793      000000		 EOLB2.==W2.
      794      000000		 EOLB3.==W3.
      795
      796
      797		       ;CRDIR

	 798
      799    400000  000000	 CD%LEN==:1B0	;FLAGS ,, LENGTH OF CRDIR BLOCK
      800    200000  000000	 CD%PSW==:1B1	;SET PASSWORD STRING
      801    100000  000000	 CD%LIQ==:1B2	;SET LOGGED IN QUOTA
      802    040000  000000	 CD%PRV==:1B3	;SET PRIVILEGES
      803    020000  000000	 CD%MOD==:1B4	;SET MODE BITS
      804    010000  000000	 CD%LOQ==:1B5	;SET LOGGED OUT QUOTA
      805    004000  000000	 CD%NUM==:1B6	;SET DIRECTORY NUMBER FROM PARAM BLK
      806    002000  000000	 CD%FPT==:1B7	;SET DEFAULT FILE PROTECTION
      807    001000  000000	 CD%DPT==:1B8	;SET DIRECTORY PROTECTION
      808    000400  000000	 CD%RET==:1B9	;SET DEFAULT RETENTION COUNT
      809    000200  000000	 CD%LLD==:1B10	 ;SET LAST LOGIN DATE
      810    000100  000000	 CD%UGP==:1B11	 ;SET USER GROUPS
      811    000040  000000	 CD%DGP==:1B12	 ;SET DIRECTORY GROUPS
      812    000020  000000	 CD%SDQ==:1B13	 ;SET SUBDIRECTORY QUOTA
      813    000010  000000	 CD%CUG==:1B14	 ;SET CREATABLE USER GROUPS
      814    000004  000000	 CD%DAC==:1B15	 ;SET DEFAULT ACCOUNT
      815    000001  000000	 CD%DEL==:1B17	 ;DELETE DIRECTORY
      816      777777		 CD%APB==:777777B35  ;ADDRESS OF PARAMETER BLOCK
      817      000000		 .CDLEN==:0   ;LENGTH OF ARGUMENT BLOCK
      818    400000  000000	  CD%NSQ==:1B0	;DO NOT UPDATE QUOTAS OF SUPERIOR DIR
      819    200000  000000	  CD%NCE==:1B1	;DO NOT CHANGE PARAMETERS OF EXISTING DIRS
      820    100000  000000	  CD%NED==:1B2	; Set def online exp from .CDDNE
      821    040000  000000	  CD%FED==:1B3	; Set def offline exp from .CDDFE
      822      000001		 .CDPSW==:1   ;POINTER TO PASSWORD STRING
      823      000002		 .CDLIQ==:2   ;LOGGED IN QUOTA
      824      000003		 .CDPRV==:3   ;PRIVILEGE WORD
      825      000004		 .CDMOD==:4   ;MODE WORD
      826    400000  000000	  CD%DIR==:1B0	;DIRECTORY NAME FOR CNDIR ONLY (FILES ONLY)
      827    200000  000000	  CD%ANA==:1B1	;ALPHANUMERIC ACCOUNTS
      828    100000  000000	  CD%RLM==:1B2	;REPEAT LOGIN MESSAGES
      829    002000  000000	  CD%DAR==:1B7	; Archived online expired files
      830      000005		 .CDLOQ==:5   ;LOGGED OUT QUOTA
      831      000006		 .CDNUM==:6   ;DIRECTORY NUMBER
      832      000007		 .CDFPT==:7   ;DEFAULT FILE PROTECTION
      833      000010		 .CDDPT==:10   ;DIRECTORY PROTECTION
      834      000011		 .CDRET==:11   ;DEFAULT RETENTION COUNT
      835      000012		 .CDLLD==:12   ;LAST LOGIN DATE
      836      000013		 .CDUGP==:13   ;USER GROUPS
      837      000014		 .CDDGP==:14   ;DIRECTORY GROUPS
      838      000015		 .CDSDQ==:15   ;MAXIMUM NUMBER OF SUBDIRECTORIES
      839      000016		 .CDCUG==:16   ;POINTER TO CREATABLE USER GROUP LIST
      840      000017		 .CDDAC==:17   ;POINTER TO DEFAULT ACCOUNT
      841      000020		 .CDDNE==:20   ; Default online expiration
      842      000021		 .CDDFE==:21   ; Default offline expiration
      843
      844
      845
      846		       ;CRJOB
      847
      848    400000  000000	 CJ%LOG==:1B0	;ATTEMPT TO LOG IN THE NEW JOB
      849    200000  000000	 CJ%NAM==:1B1	;USE NAME AND PSWD IN ARG BLK
      850    140000  000000	 CJ%ACT==:3B3	;WHERE TO GET ACCOUNT
      851      000000		  .CJUCA==:0  ;USE CURRENT ACCT OF CREATOR

	 852	  000001	     .CJUAA==:1  ;USE ACCOUNT IN ARG BLOCK
      853      000002		  .CJUDA==:2  ;USE DEFAULT ACCOUNT OF NEW USER
      854    020000  000000	 CJ%ETF==:1B4	;PUT EXEC IN TOP FORK
      855    010000  000000	 CJ%FIL==:1B5	;GET FILE IN ARG BLOCK
      856    004000  000000	 CJ%ACS==:1B6	;LOAD THE ACS FROM ARG BLOCK
      857    002000  000000	 CJ%OWN==:1B7	;RETAIN OWNERSHIP OF NEW JOB
      858    001000  000000	 CJ%WTA==:1B8	;NEW JOB WAITS TIL ATTACHED
      859    000400  000000	 CJ%NPW==:1B9	;NO PASSWORD CHECK AT LOGIN TIME
      860    000200  000000	 CJ%NUD==:1B10	 ;NO UPDATE OF LAST-LOGIN DATE
      861    000100  000000	 CJ%SPJ==:1B11	 ;DO SPJFN IN NEW JOB FROM ARG BLK
      862    000040  000000	 CJ%CAP==:1B12	 ;PASS ENABLED CAPABILITIES AS ALLOWED
      863    000020  000000	 CJ%CAM==:1B13	 ;CAPABILITY MASK AT LOGIN
      864    000010  000000	 CJ%SLO==:1B14	 ;SIGNAL (IPCF) AT LOGOUT TIME
      865    000001  000000	 CJ%DSN==:1B17	 ;DISOWN EXISTING JOB # IN 3
      866
      867      000000		 .CJNAM==:0   ;NAME STRING POINTER
      868      000001		 .CJPSW==:1   ;PASSWORD STRING POINTER
      869      000002		 .CJACT==:2   ;ACCOUNT DESIGNATOR/STRING
      870      000003		 .CJFIL==:3   ;FILE NAME STRING POINTER
      871      000004		 .CJSFV==:4   ;SFRKV OFFSET
      872      000005		 .CJTTY==:5   ;TTY DESIGNATOR, OR NULL DESIGNATOR
      873      000006		 .CJTIM==:6   ;TIME LIMIT
      874      000007		 .CJACS==:7   ;ADDRESS OF 16. WORDS OF AC'S
      875      000010		 .CJEXF==:10   ;EXEC FLAGS, FOR EXEC AC1
      876      000011		 .CJPRI==:11   ;PRIMARY JFN'S FOR SPJFN IN NEW JOB
      877      000012		 .CJCPU==:12   ;CPU LIMIT (0 IF NONE)
      878      000013		 .CJCAM==:13   ;CAPABILITY MASK TO APPLY TO LOGIN
      879      000014		 .CJSLO==:14   ;PID TO SIGNAL AT LOGOUT TIME
      880
      881      002545		 CR%PRA==:2545	 ;MAGIC # FOR EXEC/CRJOB LINKAGE VIA PRARG
      882
      883
      884		       ;CRLNM
      885
      886      000000		 .CLNJ1==:0   ;DELETE 1 LOGICAL NAME FROM JOB
      887      000001		 .CLNS1==:1   ;DELETE 1 LOGICAL NAME FROM SYSTEM
      888      000002		 .CLNJA==:2   ;DELETE ALL JOB WIDE LOGICAL NAMES
      889      000003		 .CLNSA==:3   ;DELETE ALL SYSTEM LOGICAL NAMES
      890      000004		 .CLNJB==:4   ;CREATE A JOB WIDE LOGICAL NAME
      891      000005		 .CLNSY==:5   ;CREATE A SYSTEM WIDE LOGICAL NAME
      892
      893
      894		       ;DELDF
      895
      896    400000  000000	 DD%DTF==:1B0	;DELETE TEMPORARY FILES
      897    200000  000000	 DD%DNF==:1B1	;DELETE NONEXISTENT FILES
      898    100000  000000	 DD%RST==:1B2	;REBUILD THE SYMBOL TABLE
      899    040000  000000	 DD%CHK==:1B3	;CHECK THE DIR FOR CONSISTENCY ONLY
      900
      901
      902		       ;DELF
      903
      904    400000  000000	 DF%NRJ==:1B0	;DON'T RELEASE JFN
      905    200000  000000	 DF%EXP==:1B1	;EXPUNGE CONTENTS

	 906	100000	000000	    DF%FGT==:1B2   ;FORGET (EXPUNGE W/O DEASSIGNING ADDRESSES)
      907    040000  000000	 DF%DIR==:1B3	;DELETE, FORGET, AND EXPUNGE A DIRECTORY
      908			    ; FILE.  (ONLY IF E-CREATE KILL FAILED)
      909    020000  000000	 DF%ARC==:1B4	; Delete of archive status file allowed
      910    010000  000000	 DF%CNO==:1B5	; Delete only contents of file
      911			    ;  Immediate expunge implied
      912
      913      777777		 DF%JFN==777777B35  ;JFN
      914
      915
      916		       ;DIAG JSYS DEFINITIONS
      917
      918    700000  000000	 DG%ADT==:7B2	;ADDRESS TYPE FIELD
      919    077400  000000	 DG%DVC==:177B9   ;DEVICE CODE FIELD
      920      000130		  .DGRH0==:130	;MBC0
      921      000137		  .DGRH7==:137	;MBC7
      922      007700		 DG%UNI==:77B29   ;UNIT NUMBER
      923      000077		 DG%SUN==:77B35   ;SUBUNIT NUMBER
      924
      925		       ;DIAG JSYS FUNCTION CODES
      926
      927      000001		 .DGACU==:1   ;ASSIGN DEVICE
      928      000002		 .DGACH==:2   ;ASSIGN CONTROLLER AND ALL DEVICES
      929      000003		 .DGRCH==:3   ;RELEASE DEVICE(S)
      930      000004		 .DGSCP==:4   ;SETUP CHANNEL PROGRAM
      931      000005		 .DGRCP==:5   ;RELEASE CHANNEL PROGRAM
      932      000006		 .DGGCS==:6   ;GET CHANNEL STATUS
      933
      934		       ;DIAG NEW CONTROL FUNCTIONS
      935
      936      000100		 .DGGEM==:100	;LEAVE LARGE HOLE FOR MORE RH20 FUNCTIONS
      937			    ;GET MEM (FOR TGHA)
      938      000101		 .DGREM==:101	;RELEASE MEM (FOR TGHA)
      939      000102		 .DGPDL==:102	;UNIT ONLINE
      940
      941
      942		       ;DSKAS
      943
      944    400000  000000	 DA%DEA==:1B0	;DEASSIGN DISK ADDRESS
      945    200000  000000	 DA%ASF==:1B1	;ASSIGN FREE PAGE
      946    100000  000000	 DA%CNV==:1B2	;CONVERT SOFTWARE TO HARDWARE ADDRESS
      947    040000  000000	 DA%HWA==:1B3	;HARDWARE ADDRESS GIVEN
      948    020000  000000	 DA%INI==:1B4	;INITIALIZE THE BIT TABLE
      949    010000  000000	 DA%WRT==:1B5	;WRITE THE BIT TABLE FILE
      950      777777		 DA%ADR==:777777B35  ;DISK ADDRESS
      951
      952
      953
      954		       ;DVCHR, DEVUNT AND DVCH1 BIT DEFINITIONS
      955
      956    400000  000000	 DV%OUT==:1B0	;DEVICE CAN DO OUTPUT
      957    200000  000000	 DV%IN==:1B1   ;DEVICE CAN DO INPUT
      958    100000  000000	 DV%DIR==:1B2	;DEVICE HAS A DIRECTORY
      959    040000  000000	 DV%AS==:1B3   ;DEVICE IS ASSIGNABLE

	 960	020000	000000	    DV%MDD==:1B4   ;DEVICE IS A MULTIPLE DIRECTORY DEVICE
      961    010000  000000	 DV%AV==:1B5   ;DEVICE IS AVAILABLE TO THIS JOB
      962    004000  000000	 DV%ASN==:1B6	;DEVICE IS ASSIGNED BY ASND
      963    002000  000000	 DV%MDV==:1B7	;RESERVED (HISTORICAL)
      964    001000  000000	 DV%MNT==:1B8	;DEVICE IS MOUNTED
      965    000777  000000	 DV%TYP==:777B17   ;DEVICE TYPE FIELD
      966      400000		 DV%PSD==:1B18	 ;PSEUDO DEVICE
      967      077777		 DV%UNT==:77777   ;UNIT MASK
      968      177777		 DV%MOD==:177777B35  ;DEVICE DATA MODE
      969      000001		 DV%M0==:1B35	;DEVICE CAN BE OPENED IN MODE 0
      970      000002		 DV%M1==:1B34	;DEVICE CAN BE OPENED IN MODE 1
      971      000004		 DV%M2==:1B33	;DEVICE CAN BE OPENED IN MODE 2
      972      000010		 DV%M3==:1B32	;DEVICE CAN BE OPENED IN MODE 3
      973      000020		 DV%M4==:1B31	;DEVICE CAN BE OPENED IN MODE 4
      974      000040		 DV%M5==:1B30	;DEVICE CAN BE OPENED IN MODE 5
      975      000100		 DV%M6==:1B29	;DEVICE CAN BE OPENED IN MODE 6
      976      000200		 DV%M7==:1B28	;DEVICE CAN BE OPENED IN MODE 7
      977      000400		 DV%M10==:1B27	 ;DEVICE CAN BE OPENED IN MODE 10
      978      001000		 DV%M11==:1B26	 ;DEVICE CAN BE OPENED IN MODE 11
      979      002000		 DV%M12==:1B25	 ;DEVICE CAN BE OPENED IN MODE 12
      980      004000		 DV%M13==:1B24	 ;DEVICE CAN BE OPENED IN MODE 13
      981      010000		 DV%M14==:1B23	 ;DEVICE CAN BE OPENED IN MODE 14
      982      020000		 DV%M15==:1B22	 ;DEVICE CAN BE OPENED IN MODE 15
      983      040000		 DV%M16==:1B21	 ;DEVICE CAN BE OPENED IN MODE 16
      984      100000		 DV%M17==:1B20	 ;DEVICE CAN BE OPENED IN MODE 17
      985    400000  000000	 D1%SPL==:1B0	;DEVICE IS SPOOLED
      986    200000  000000	 D1%ALC==:1B1	;DEVICE IS UNDER CONTROL OF ALLOCATOR
      987    100000  000000	 D1%VVL==:1B2	;VOLUME VALID
      988    040000  000000	 D1%NIU==:1B3	;DEVICE SLOT IS NOT IN USE (FOR STRUCTURES
      989			    ; NOT YET MOUNTED)
      990    020000  000000	 D1%INI==:1B4	;DEVICE IS BEING INITIALIZED (STRUCTURE
      991			    ; IS AVAILABLE ONLY TO THE FORK WHOSE NUMBER
      992			    ; IS STORED IN SDBSTS)
      993
      994
      995
      996		       ;DEVICE TYPE DEFINITIONS
      997
      998      000000		 .DVDSK==:0   ;DISK
      999      000002		 .DVMTA==:2   ;MAGTAPE
     1000      000003		 .DVDTA==:3   ;DECTAPE
     1001      000004		 .DVPTR==:4   ;PAPER TAPE READER
     1002      000005		 .DVPTP==:5   ;PAPER TAPE PUNCH
     1003      000006		 .DVDSP==:6   ;DISPLAY
     1004      000007		 .DVLPT==:7   ;LINE PRINTER
     1005      000010		 .DVCDR==:10   ;CARD READER
     1006      000011		 .DVFE==:11   ;FRONT END DEVICE
     1007      000012		 .DVTTY==:12   ;TERMINAL
     1008      000013		 .DVPTY==:13   ;PTY
     1009      000015		 .DVNUL==:15   ;NULL DEVICE
     1010      000016		 .DVNET==:16   ;ARPA NETWORK
     1011      000017		 .DVPLT==:17   ;PLOTTER
     1012      000021		 .DVCDP==:21   ;CARD PUNCH
     1013      000022		 .DVDCN==:22   ;DECNET ACTIVE COMPONENT

	1014	  000023	    .DVSRV==:23   ;DECENT PASSIVE COMPONENT
     1015      000024		 .DVATS==:24   ;APPLICATIONS TERMINAL SERVICE
     1016
     1017
     1018		       ;DSKOP
     1019
     1020    400000  000000	 DOP%SA==:1B0	;SOFTWARE ADDRESS
     1021    600000  000000	 DOP%AT==:3B1	;ADDRESS TYPE FIELD
     1022      000001		  .DOPPU==:1   ;PHYSICAL CHANNEL AND UNIT
     1023    174000  000000	   DOP%CN==:37B6   ;CHANNEL NUMBER
     1024    003740  000000	   DOP%UN==:77B12  ;UNIT NUMBER
     1025    000037  777777	   DOP%UA==:37777777  ;UNIT ADDRESS
     1026      000002		  .DOPSR==:2   ;STRUCTURE AND RELATIVE ADDRESS
     1027    177600  000000	   DOP%SN==:777B10  ;STRUCTURE NUMBER
     1028    000177  777777	   DOP%RA==:177777777  ;RELATIVE ADDRESS
     1029    000200  000000	 DOP%EO==:1B10	 ;ERROR IF UNIT OFFLINE
     1030    000100  000000	 DOP%IL==:1B11	 ;INHIBIT ERROR LOGGING
     1031    000040  000000	 DOP%IR==:1B12	 ;INHIBIT ERROR RECOVERY
     1032    000010  000000	 DOP%WR==:1B14	 ;WRITE
     1033      777777		 DOP%CT==:777777B35  ;WORD COUNT
     1034
     1035
     1036		       ;DUMPI/DUMPO
     1037
     1038    400000  000000	 DM%NWT==:1B0	;NO WAIT FOR COMPLETION
     1039    200000  000000	 DM%FIN==:1B1	;FINISH PREVIOUS REQUEST
     1040			    ;***NOT INPLEMENTED YET***
     1041      777777		 DM%PTR==:777777B35  ;POINTER TO COMMAND LIST
     1042
     1043
     1044
     1045		       ;DEFINE DECNET DISCONNECT CODES. THESE ARE STIPULATED BY THE NSP SPEC
     1046		       ;AND MAY HAVE MEANININGS NOT IMPLIED BY THE COMMENTS
     1047
     1048      000000		 .DCX0==:0   ;NO SPECIAL ERROR
     1049      000001		 .DCX1==:1   ;RESOURCE ALLOCATION FAILURE
     1050      000002		 .DCX2==:2   ;DESTINATION NODE DOES NOT EXIST
     1051      000003		 .DCX3==:3   ;NODE SHUTTING DOWN
     1052      000004		 .DCX4==:4   ;DESTINATION PROCESS DOES NOT EXIST
     1053      000005		 .DCX5==:5   ;INVALID NAME FIELD
     1054      000006		 .DCX6==:6   ;DESTINATION PROCESS QUEUE OVERFLOW
     1055      000007		 .DCX7==:7   ;UNSPECIFIED ERROR
     1056      000010		 .DCX8==:D8   ;THIRD PARTY ABORTED LINK
     1057      000011		 .DCX9==:D9   ;USER ABORT (ASYNCHRONOUS DISCONNECT)
     1058      000013		 .DCX11==:D11	;UNDEFINED ERROR CODE
     1059      000025		 .DCX21==:D21	;CI WITH ILLEGAL DESTINATION ADDRESS
     1060      000026		 .DCX22==:D22	;CC WITH ILLEGAL DESTINATION ADDRESS
     1061      000027		 .DCX23==:D23	;CI OR CC WITH ZERO SOURCE ADDRESS
     1062      000030		 .DCX24==:D24	;FLOW CONTROL VIOLATION
     1063      000040		 .DCX32==:D32	;TOO MANY CONNECTIONS TO NODE
     1064      000041		 .DCX33==:D33	;TOO MANY CONNECTIONS TO DEST. PROCESS
     1065      000042		 .DCX34==:D34	;ACCESS NOT PERMITTED
     1066      000043		 .DCX35==:D35	;LOGICAL LINK SERVICES MISMATCH
     1067      000044		 .DCX36==:D36	;INVALID ACCOUNT

	1068	  000045	    .DCX37==:D37   ;SEGSIZE TOO SMALL
     1069      000046		 .DCX38==:D38	;PROCESS ABORTED
     1070      000047		 .DCX39==:D39	;NO PATH TO DESTINATION NODE
     1071      000050		 .DCX40==:D40	;LINK ABORTED DUE TO DATA LOSS
     1072      000051		 .DCX41==:D41	;DESTINATION PROCESS DOES NOT EXIST
     1073      000052		 .DCX42==:D42	;CONFIRMATION IF DI
     1074      000053		 .DCX43==:D43	;IMAGE DATA FIELD TOO LONG
     1075
     1076
     1077		       ;EFACT - FACT FILE ENTRY DEFINITIONS
     1078
     1079      000000		 .EFHDR==:0   ;HEADER WORD
     1080    777000  000000	  EF%COD==:777B8  ;ENTRY TYPE CODE
     1081    000777  000000	  EF%JOB==:777B17  ;JOB NUMBER
     1082      777700		  EF%LIN==:7777B29 ;LINE NUMBER
     1083      000077		  EF%SIZ==:77B35  ;ENTRY SIZE
     1084      000001		 .EFUSR==:1   ;USER NUMBER WORD
     1085      000002		 .EFTAD==:2   ;TIME AND DATE OF ENTRY
     1086
     1087		       ; FACT FILE ENTRY TYPE CODES
     1088
     1089      000501		 .EFLGI==:501	;LOGIN
     1090      000141		 .EFLGO==:141	;LOGOUT
     1091      000502		 .EFCAC==:502	;CHANGE ACCOUNT
     1092      000142		 .EFATT==:142	;CONSOLE ATTACH
     1093      000143		 .EFDET==:143	;CONSOLE DETACH
     1094      000201		 .EFCHK==:201	;CHECKPOINT
     1095      000540		 .EFSDU==:540	;START DISK-UTILIZATION ENTRIES
     1096      000601		 .EFDSK==:601	;DISK SPACE UTILIZATION
     1097      000741		 .EFTIM==:741	;TIME SET
     1098      000740		 .EFRES==:740	;SYSTEM RESTARTED
     1099      000401		 .EFLPT==:401	;LINE PRINTER USAGE
     1100      000402		 .EFCDR==:402	;CARD READER USAGE
     1101
     1102
     1103		       ;ENQ/DEQ BIT DEFINITIONS AND FUNCTION CODES
     1104
     1105		       ;FUNCTION CODES
     1106
     1107      000000		 .ENQBL==:0   ;ENQ BLOCK OPTION
     1108      000001		 .ENQAA==:1   ;ENQ ALLOCATE ONLY IF AVAILABLE
     1109      000002		 .ENQSI==:2   ;ENQ SOFTWARE INTERRUPT WHEN LOCKED
     1110      000003		 .ENQMA==:3   ;ENQ MODIFY ACCESS
     1111      000000		 .DEQDR==:0   ;DEQ RESOURCE
     1112      000001		 .DEQDA==:1   ;DEQ ALL RESOURCES OF THIS FORK
     1113      000002		 .DEQID==:2   ;DEQ THIS ID NUMBER
     1114      000000		 .ENQCS==:0   ;ENQC STATUS
     1115      000001		 .ENQCG==:1   ;ENQC GET ENQ/DEQ QUOTA FOR A JOB
     1116      000002		 .ENQCC==:2   ;ENQC CHANGE ENQ/DEQ QUOTA FOR A JOB
     1117      000003		 .ENQCD==:3   ;ENQC DUMP LOCKS AND QUEUE ENTRIES
     1118
     1119
     1120
     1121		       ;BIT DEFINITIONS

	1122
     1123    400000  000000	 EN%SHR==:1B0	;SHARABLE REQUEST
     1124    200000  000000	 EN%BLN==:1B1	;BYPASS LEVEL NUMBER
     1125    100000  000000	 EN%NST==:1B2	;ALLOW NESTING
     1126    040000  000000	 EN%LTL==:1B3	;LONG TERM LOCK
     1127    000777  000000	 EN%LVL==:777B17   ;LEVEL NUMBER
     1128      777777		 EN%JOB==:777777B35  ;JOB NUMBER
     1129    400000  000000	 EN%QCE==:1B0	;ERROR CODE IN RH OF STATUS WORD
     1130    400000  000000	 EN%QCL==:1B0	;LOCK DUMP (.ENQCD ONLY)
     1131    200000  000000	 EN%QCO==:1B1	;THIS FORK OWNS THE LOCK
     1132    100000  000000	 EN%QCQ==:1B2	;THIS FORK IS IN THE QUEUE FOR THIS LOCK
     1133    100000  000000	 EN%QCT==:1B2	;LOCK CONTAINS A TEXT STRING
     1134    040000  000000	 EN%QCX==:1B3	;THE LOCK IS LOCKED EXCLUSIVELY
     1135    020000  000000	 EN%QCB==:1B4	;USER IS BLOCKED FOR LOCK
     1136
     1137
     1138		       ;ENQ/DEQ ARGUMENT BLOCK DATA STRUCTURE
     1139
     1140      000000		 .ENQLN==:0   ;# OF LOCKS ,, LENGTH OF ARGUMENT BLOCK
     1141    770000  000000	  .ENHLN==:77B5  ;LENGTH OF HEADER AREA
     1142    007777  000000	  .ENNLK==:7777B17 ;NUMBER OF LOCKS
     1143      777777		  .ENALN==:777777B35 ;LENGTH OF ARGUMENT BLOCK
     1144      000001		 .ENQID==:1   ;PSI CHANNEL # ,, REQUEST ID
     1145      000002		 .ENQLV==:2   ;FLAGS  LEVEL NUMBER ,, JFN, -1, -2, OR -3						     
     1146      000003		 .ENQUC==:3   ;STRING POINTER OR USER CODE
     1147      000004		 .ENQRS==:4   ;# OF RESOURCES IN POOL ,, # OF RESOURCES WANTED
     1148      000005		 .ENQMS==:5   ;ADDRESS OF RESOURCE BLOCK
     1149
     1150
     1151
     1152		       ;ENQC DUMP DATA STRUCTURE
     1153
     1154      000000		 .ENQDF==:0   ;FLAGS + LEVEL # ,, OFN, 400000+JOB #, -2, OR -3
     1155			    ;OR:  FLAGS + PSI # ,, JOB # OF Q-ENTRY CREATOR
     1156
     1157      000001		 .ENQDR==:1   ;TOTAL RESOURCES IN POOL ,, RESOURCES REMAINING
     1158      000002		 .ENQDT==:2   ;TIME STAMP OF LAST REQUEST LOCKED
     1159      000003		 .ENQDC==:3   ;USER CODE OF LOCK OR START OF TEXT STRING
     1160
     1161      000001		 .ENQDI==:1   ;GROUP # OR # REQUESTED ,, ENQ ID
     1162
     1163
     1164		       ;FLOUT/DFOUT
     1165		       ;FORMAT CONTROL WORD
     1166
     1167    600000  000000	 FL%SGN==:3B1	;FIRST FIELD SIGN CONTROL
     1168      000000		  .FLDIG==:0   ;DIGIT
     1169      000001		  .FLSPC==:1   ;SPACE
     1170      000002		  .FLPLS==:2   ;PLUS SIGN
     1171      000003		  .FLSPA==:3   ;SPACE
     1172    140000  000000	 FL%JUS==:3B3	;FIRST FIELD JUSTIFICATION CONTROL
     1173      000000		  .FLLSP==:0   ;LEADING SPACES
     1174      000001		  .FLLZR==:1   ;LEADING ZEROS
     1175      000002		  .FLLAS==:2   ;LEADING ASTERISKS

	1176	  000003	     .FLTSP==:3   ;TRAILING SPACES
     1177    020000  000000	 FL%ONE==:1B4	;FIRST FIELD NONBLANK
     1178    010000  000000	 FL%DOL==:1B5	;DOLLAR SIGN PREFIX
     1179    004000  000000	 FL%PNT==:1B6	;DECIMAL POINT
     1180    003000  000000	 FL%EXP==:3B8	;THIRD FIELD EXPONENT CONTROL
     1181      000000		  .FLEXN==:0   ;NO EXPONENT
     1182      000001		  .FLEXE==:1   ;E EXPONENT PREFIX
     1183      000002		  .FLEXD==:2   ;D EXPONENT PREFIX
     1184      000003		  .FLEXM==:3   ;*10 EXPONENT PREFIX
     1185    000600  000000	 FL%ESG==:3B10	 ;EXPONENT SIGN CONTROL
     1186      000000		  .FLDGE==:0   ;DIGIT
     1187      000001		  .FLPLE==:1   ;PLUS SIGN
     1188      000002		  .FLSPE==:2   ;SPACE
     1189      000003		  .FLDGT==:3   ;DIGIT
     1190    000100  000000	 FL%OVL==:1B11	 ;COLUMN OVERFLOW
     1191    000037  000000	 FL%RND==:37B17   ;DIGIT POSITION FOR ROUNDING
     1192      770000		 FL%FST==:77B23   ;FIRST FIELD WIDTH
     1193      007700		 FL%SND==:77B29   ;SECOND FIELD WIDTH
     1194      000077		 FL%THD==:77B35   ;THIRD FIELD WIDTH
     1195
     1196
     1197
     1198		       ;GDSTS
     1199
     1200		       ;SEE MTOPR FOR CARD READER AND LINE PRINTER STATUS BITS
     1201		       ;SEE GENERAL FIELD AND VALUE SECTION FOR MAGTAPE STATUS BITS
     1202		       ;SEE TOPS20AN SECTION FOR NETWORK STATUS BITS
     1203
     1204    740000  000000	 .GDFSM==:17B3	     ;TOPS20AN ;FINITE MACHINE STATE
     1205
     1206
     1207		       ;GET
     1208
     1209      200000		 GT%ADR==:1B19	 ;USE ADDRESS LIMITS IN AC2
     1210      100000		 GT%PRL==:1B20	 ;PRELOAD PAGES
     1211      040000		 GT%NOV==:1B21	 ;DON'T OVERLAY EXISTING PAGES
     1212      020000		 GT%FL2==:1B22	 ;IF ON, AC3 CONTAINS FLAGS
     1213    400000  000000	  G2%FCH==:1B0	;MAKE FAST-CACHE ENTRY
     1214
     1215
     1216
     1217		       ;GETAB - TABLE INDICES
     1218
     1219      000000		 .JOBTT==:0   ;JOB NUMBER TO TTY NUMBER
     1220      000001		 .JOBRT==:1   ;JOB RUNTIME
     1221      000002		 .TICKP==:2   ;TICKS PER SECOND
     1222      000003		 .JOBDI==:3   ;JOB NUMBER TO DIRECTORY NUMBERS (OBS)
     1223      000004		 .TTYJO==:4   ;TTY NUMBER TO JOB NUMBER
     1224      000005		 .NCPGS==:5   ;NUMBER PHYSICAL CORE PAGES
     1225      000006		 .DEVNA==:6   ;DEVICE NAME
     1226      000007		 .DEVCH==:7   ;DEVICE CHARACTERISTICS
     1227      000010		 .DEVUN==:10   ;DEVICE UNIT NUMBERS
     1228      000011		 .DSKER==:11   ;DISK ERROR WORDS
     1229      000012		 .DRMER==:12   ;DRUM ERROR WORDS

	1230	  000013	    .SYSVE==:13   ;VERSION TEXT
     1231      000014		 .SYSTA==:14   ;STATISTICS
     1232      000015		 .QTIME==:15   ;SCHED QUEUE TIMES
     1233      000016		 .JOBNA==:16   ;JOB NUMBER TO PROGRAM NAME
     1234      000017		 .SNAME==:17   ;SUBSYSTEM NAME
     1235      000020		 .STIME==:20   ; " TIME
     1236      000021		 .SPFLT==:21   ; " PAGE FAULTS
     1237      000022		 .SSIZE==:22   ; " SIZE INTEGRAL
     1238      000023		 .SNBLK==:23   ; " NUMBER WAKEUPS
     1239      000024		 .DBUGS==:24   ;DBUGSW, DCHKSW
     1240      000025		 .LOGDE==:25   ;LOG, JOB 0 DESIGNATORS
     1241      000026		 .PTYPA==:26   ;PTY PARAMETERS
     1242      000027		 .SYMTA==:27   ;GTTAB SYMBOL TABLE
     1243      000030		 .DWNTI==:30   ;HSYS VARIABLES
     1244      000031		 .JOBPN==:31   ;JOB NUMBER TO PROGRAM NAME
     1245      000032		 .BLDTD==:32   ;MONITOR BUILD TIME AND DATE
     1246      000033		 .LSTDR==:33   ;LAST DIR NUMBER ASSIGNED (OBS)
     1247      000034		 .APRID==:34   ;APR SERIAL NUMBER
     1248      000035		 .HQLAV==:35   ;HIGH QUEUE LOAD AVERAGES
     1249      000036		 .LQLAV==:36   ;LOW QUEUE LOAD AVERAGES
     1250      000037		 .NETRD==:37	   ;TOPS20AN ;ARPANET STATUS
     1251      000040		 .IMPHR==:40	   ;TOPS20AN ;HOST READY
     1252      000041		 .HSTST==:41	   ;TOPS20AN ;DEAD HOST STATUS
     1253      000042		 .HSTNA==:42	   ;TOPS20AN ;HOST NAMES
     1254      000043		 .HOSTN==:43	   ;TOPS20AN ;HOST NAME INDEX
     1255      000044		 .NETLS==:44	   ;TOPS20AN ;LOCAL SOCKET
     1256      000045		 .NETFS==:45	   ;TOPS20AN ;FOREIGN SOCKET
     1257      000046		 .NETAW==:46	   ;TOPS20AN ;ARPA CONNECTION ADDRESS
     1258      000047		 .NETBA==:47	   ;TOPS20AN ;BIT ALLOCATION
     1259      000050		 .NETST==:50	   ;TOPS20AN ;CONNECTION STATUS
     1260      000051		 .NETBU==:51	   ;TOPS20AN ;ARPANET BUFFERS
     1261      000052		 .NETBT==:52	   ;TOPS20AN ;BYTE COUNT STATISTICS
     1262      000053		 .IMPL1==:53	   ;TOPS20AN ;IMP LINK TABLE ONE
     1263      000054		 .IMPL2==:54	   ;TOPS20AN ;IMP LINK TABLE TWO
     1264      000055		 .IMPL3==:55	   ;TOPS20AN ;IMP LINK TABLE THREE
     1265      000056		 .IMPL4==:56	   ;TOPS20AN ;IMP LINK TABLE FOUR
     1266      000057		 .LHOST==:57	   ;TOPS20AN ;LOCAL HOST NUMBER
     1267      000060		 .JBONT==:60   ;OWNING JOB
     1268      000061		 .NSWPG==:61   ;DEFAULT SWAPPING PAGES
     1269
     1270
     1271
     1272		       ;GETJI
     1273
     1274      000000		 .JIJNO==:0   ;JOB NUMBER
     1275      000001		 .JITNO==:1   ;TERMINAL NUMBER
     1276      000002		 .JIUNO==:2   ;USER NUMBER
     1277      000003		 .JIDNO==:3   ;DIRECTORY NUMBER
     1278      000004		 .JISNM==:4   ;SUBSYS NAME
     1279      000005		 .JIPNM==:5   ;PROGRAM NAME
     1280      000006		 .JIRT==:6   ;RUN TIME
     1281      000007		 .JICPJ==:7   ;CONTROLLING PTY JOB NUMBER
     1282      000010		 .JIRTL==:10   ;RUN TIME LIMIT (SET BY TIMER JSYS)
     1283      000011		 .JIBAT==:11   ;CONTROLLED BY BATCH

	1284	  000012	    .JIDEN==:12   ;MAGTAPE DEFAULT DENSITY
     1285      000013		 .JIPAR==:13   ;MAGTAPE DEFAULT PARITY
     1286      000014		 .JIDM==:14   ;MAGTAPE DEFAULT DATA MODE
     1287      000015		 .JIRS==:15   ;MAGTAPE DEFAULT RECORD SIZE
     1288      000016		 .JIDFS==:16   ;DEFERRED SPOOLING
     1289      000017		 .JILNO==:17   ;LOGGED-IN DIRECTORY NUMBER
     1290      000020		 .JISRM==:20   ;POINTER TO JOB SESSION REMARK
     1291      000021		 .JILLN==:21   ;LAST LOGIN DATE  TIME								
     1292      000022		 .JISRT==:22   ;JOB RUNTIME AT START OF THIS ACCOUNTING SESSION
     1293      000023		 .JISCT==:23   ;JOB CONSOLE TIME AT START OF THIS SESSION
     1294      000024		 .JIT20==:24   ;-1 IF AT TOPS20 COMMAND LEVEL
     1295      000025		 .JISTM==:25   ;DATE  TIME JOB WAS INITIALIZED						     
     1296      000026		 .JIBCH==:26   ;BATCH STREAM AND FLAGS
     1297    600000  000000	  OB%WTO==3B1  ;WRITE TO OPERATOR CAPABILITIES
     1298      000000		      .OBALL==0  ;WTO AND WTOR ALLOWED
     1299      000001		      .OBNWR==1  ;NO WTOR ALLOWED
     1300      000002		      .OBNOM==2  ;NO MESSAGE ALLOWED
     1301    000177  000000	  OB%BSN==177B17  ;BATCH-STREAM NUMBER
     1302      000027		 .JILLO==:27   ;LOGICAL LOCATION (NODE NAME)
     1303
     1304      000027		 .JIMAX==:.JILLO   ;CURRENT HIGHEST GETJI OFFSET
     1305
     1306
     1307		       ;GFRKS
     1308
     1309    400000  000000	 GF%GFH==:1B0	;GET RELATIVE FORK HANDLES
     1310    200000  000000	 GF%GFS==:1B1	;GET FORK STATUS
     1311
     1312
     1313		       ;GFUST
     1314
     1315      000000		 .GFAUT==:0   ;GET FILE AUTHOR
     1316      000001		 .GFLWR==:1   ;GET FILE LAST WRITER
     1317
     1318		       ;GTHST	 ;TOPS20AN
     1319
     1320      000000		 .GTHSZ==:0   ;HOST TABLE SIZES
     1321      000001		 .GTHIX==:1   ;INDEX TO STRING CONVERSION
     1322      000002		 .GTHNS==:2   ;NUMBER TO STRING CONVERSION
     1323      000003		 .GTHSN==:3   ;STRING TO NUMBER CONVERSION
     1324      000004		 .GTHHN==:4   ;HOST NUMBER TO STATUS
     1325      000005		 .GTHHI==:5   ;HOST INDEX TO STATUS
     1326
     1327		       ;GETOK DEFINITIONS
     1328      000001		 .GOASD==:1   ;ASSIGN DEVICE
     1329      000000		   .GEERB==:0	;ERROR BLOCK ADDRESS
     1330      000001		   .GEADD==:1	;DEVICE DESIGNATOR
     1331      000002		 .GOCAP==:2   ;ENABLE CAPABILITIES
     1332      000001		   .GENCP==:1	;NEW CAPABILITIES
     1333      000003		 .GOCJB==:3   ;ALLOW CRJOB JSYS
     1334      000004		 .GOLOG==:4   ;ALLOW LOGINS
     1335      000001		   .GELUN==:1	;USER NUMBER
     1336      000005		 .GOCFK==:5   ;ALLOW CFORK JSYS
     1337      000001		   .GEFCT==:1	;NUMBER OF FORKS
     1338      000006		    .GOTBR==:6	 ;ALLOW SET TERMINAL BAUD RATE
     1339      000001		   .GELIN==:1	;LINE NUMBER
     1340      000002		   .GESPD==:2	;SPEED
     1341      000007		 .GOLGO==:7   ;ALLOW LOGOUT
     1342      000001		   .GEUSD==:1	;PAGES USED
     1343      000002		   .GEQUO==:2	;QUOTA
     1344      000003		   .GERLG==:3	;USER REQUESTING LOGOUT
     1345      000010		 .GOENQ==:10   ;ALLOW SET ENQ QUOTA
     1346      000001		   .GEEQU==:1	;DESIRED QUOTA
     1347      000002		   .GEEUN==:2	;JOB NUMBER
     1348      000011		 .GOCRD==:11   ;ALLOW CREDIR
     1349      000012		 .GOSMT==:12   ;ALLOW SMOUNT
     1350      000001		   .GESDE==:1	;DEVICE DESIGNATOR
     1351
     1352      000013		 .GOMDD==:13   ;ALLOW MDDT ENTRY
     1353      000014		 .GOCLS==:14   ;VERIFY CLASS ASSIGNMENT FOR A JOB
     1354      000001		    .GEJOB==:1	 ;JOB #
     1355      000002		    .GECLS==:2	 ;CLASS DESIRED
     1356      000015		 .GOCL0==:15   ;SET CLASS AT LOGIN
     1357      000016		 .GOMTA==:16   ;MT ACCESS REQUEST
     1358
     1359      000001		    .GEACC==:1	 ;ACCESS CODE FROM HDR1
     1360      000002		    .GEUSN==:2	 ;USER NUMBER
     1361      000003		    .GEUNT==:3	 ;MT UNIT NUMBER
     1362      000004		    .GEACD==:4	 ;DESIRED ACCESS (BITS)
     1363      000005		    .GELTP==:5	 ;LABEL TYPE
     1364
     1365
     1366      000024		 .GOKMZ==:D20	;MAX ARGUMENT BLOCK SIZE FOR GETOK REQUEST
     1367		       ;ERROR BLOCK ADDRESS OFFSETS
     1368
     1369      000000		 .GESIZ==:0   ;SIZE OF THIS BLOCK
     1370      000001		 .GEERN==:1   ;ERROR NUMBER
     1371      000002		 .GEPTR==:2   ;POINTER TO ERROR STRING
     1372      000003		 .GEBSZ==:3   ;STRING SIZE
     1373
     1374		       ;GTJFN DEFINITIONS
     1375
     1376		       ;FLAGS PROVIDED TO GTJFN ON CALL
     1377
     1378    400000  000000	 GJ%FOU==:1B0	;FILE IS FOR OUTPUT USE
     1379    200000  000000	 GJ%NEW==:1B1	;NEW FILE ONLY
     1380    100000  000000	 GJ%OLD==:1B2	;OLD FILE ONLY
     1381    040000  000000	 GJ%MSG==:1B3	;PRINT AN APPROPRIATE MESSAGE
     1382    020000  000000	 GJ%CFM==:1B4	;CONFIRMATION IS REQUIRED
     1383    010000  000000	 GJ%TMP==:1B5	;TEMPORARY
     1384    004000  000000	 GJ%NS==:1B6   ;DONT SEARCH SEARCH LISTS
     1385    002000  000000	 GJ%ACC==:1B7	;NO ACCESS BY OTHER FORKS
     1386    001000  000000	 GJ%DEL==:1B8	;IGNORE "DELETED" BIT
     1387    000600  000000	 GJ%JFN==:3B10	 ;JFN USE FIELD
     1388      000000		 .GJDNU==:0   ;DO NOT USE JFN PROVIDED
     1389      000002		 .GJERR==:2   ;ERROR IF CANNOT USE JFN PROVIDED
     1390      000003		 .GJALT==:3   ;USE ALTERNATE IF CANNOT USE GIVEN JFN
     1391    000100  000000	 GJ%IFG==:1B11	 ;ACCEPT INPUT FILE GROUP DESCRIPTORS

     1393    000020  000000	 GJ%FLG==:1B13	 ;RETURN FLAGS
     1394    000010  000000	 GJ%PHY==:1B14	 ;PHYSICAL DEVICE ONLY
     1395    000004  000000	 GJ%XTN==:1B15	 ;EXTENDED FORMAT (E+11 EXISTS)
     1396    000002  000000	 GJ%FNS==:1B16	 ;ACCUMULATOR 2 CONTAINS JOB FILE NUMBERS
     1397    000001  000000	 GJ%SHT==:1B17	 ;SHORT CALL FORMAT
     1398
     1399		       ;FLAGS PROVIDED TO GTJFN (IN SECOND FLAG WORD)
     1400
     1401    400000  000000	 G1%RND==:1B0	;RETURN ON NULL(IN ALTERNATE FLAG WORD)
     1402    200000  000000	 G1%RBF==:1B1	;R BUFFER IS DISJOINT (OBSOLETE)
     1403    100000  000000	 G1%NLN==:1B2	;NO LONG NAMES
     1404    040000  000000	 G1%RCM==:1B3	;RETURN CONFIRM MESSAGE
     1405    020000  000000	 G1%RIE==:1B4	;RETURN WHEN MAIN STRING IS EMPTY
     1406    010000  000000	 G1%IIN==:1B5	; Ignore invisible status
     1407
     1408
     1409
     1410		       ;FLAGS RETURNED BY GTJFN
     1411
     1412    400000  000000	 GJ%DEV==:1B0	;ASTERISK WAS GIVEN FOR DEVICE
     1413    200000  000000	 GJ%UNT==:1B1	;ASTERISK WAS GIVEN FOR UNIT
     1414    100000  000000	 GJ%DIR==:1B2	;ASTERISK WAS GIVEN FOR DIRECTORY
     1415    040000  000000	 GJ%NAM==:1B3	;ASTERISK WAS GIVEN FOR NAME
     1416    020000  000000	 GJ%EXT==:1B4	;ASTERISK WAS GIVEN FOR EXTENSION
     1417    010000  000000	 GJ%VER==:1B5	;ASTERISK WAS GIVEN FOR GENERATION
     1418    004000  000000	 GJ%UHV==:1B6	;USE HIGHEST GENERATION
     1419    002000  000000	 GJ%NHV==:1B7	;USE NEXT HIGHER GENERATION
     1420    001000  000000	 GJ%ULV==:1B8	;USE LOWEST GENERATION
     1421    000400  000000	 GJ%PRO==:1B9	;PROTECTION GIVEN
     1422    000200  000000	 GJ%ACT==:1B10	 ;ACCOUNT GIVEN
     1423    000100  000000	 GJ%TFS==:1B11	 ;TEMPORARY FILE SPECIFIED (;T)
     1424    000040  000000	 GJ%GND==:1B12	 ;COMPLEMENT OF GJ%DEL ON CALL
     1425    000001  000000	 GJ%GIV==:1B17	 ; Comp of G1%IIV
     1426
     1427		       ;GTJFN TABLE OFFSETS
     1428
     1429      000000		 .GJGEN==:0   ;FLAGS ,, GENERATION
     1430      000000		 .GJDEF==:<Z 0	 ;DEFAULT GENERATION
     1431      777777		 .GJNHG==:<Z -1   ;NEXT HIGHER GENERATION
     1432      777776		 .GJLEG==:<Z -2   ;LOWEST EXISTING GENERATION
     1433      777775		 .GJALL==:<Z -3   ;ALL GENERATIONS (I.E., ;*)
     1434      000001		 .GJSRC==:1   ;SOURCE JFN ,, OUTPUT JFN
     1435      000002		 .GJDEV==:2   ;DEFAULT DEVICE
     1436      000003		 .GJDIR==:3   ;DEFAULT DIRECTORY
     1437      000004		 .GJNAM==:4   ;DEFAULT NAME
     1438      000005		 .GJEXT==:5   ;DEFAULT EXTENSTION
     1439      000006		 .GJPRO==:6   ;DEFAULT PROTECTION
     1440      000007		 .GJACT==:7   ;DEFAULT ACCOUNT
     1441      000010		 .GJJFN==:10   ;DESIRED JFN
     1442      000011		 .GJF2==:11   ;SECOND GROUP FLAGS,,COUNT
     1443      000012		 .GJCPP==:12   ;COPY BUFFER POINTER
     1444      000013		 .GJCPC==:13   ;COPY BUFFER COUNT
     1445      000014		 .GJRTY==:14   ;RETYPE (R) POINTER

     1447      000016		 .GJATR==:16   ;POINTER TO ARBITRARY ATTRIBUTE BLOCK
     1448
     1449		       ;GNJFN - FLAGS RETURNED
     1450
     1451    000020  000000	 GN%STR==:1B13	 ;STRUCTURE CHANGED
     1452    000010  000000	 GN%DIR==:1B14	 ;DIRECTORY CHANGED
     1453    000004  000000	 GN%NAM==:1B15	 ;NAME CHANGED
     1454    000002  000000	 GN%EXT==:1B16	 ;EXTENSION CHANGED
     1455
     1456		       ;GTNCP	 ;TOPS20AN
     1457
     1458      000000		 .GTNSZ==:0   ;SIZE OF TABLE
     1459      000001		 .GTNIX==:1   ;NCP INDEX
     1460      000002		 .GTNNI==:2   ;NVT INPUT
     1461      000003		 .GTNNO==:3   ;NVT OUTPUT
     1462      000004		 .GTNJF==:4   ;JFN
     1463
     1464      000000		 .NCIDX==:0   ;NCP INDEX
     1465      000001		 .NCFHS==:1   ;FOREIGN HOST
     1466      000002		 .NCLSK==:2   ;LOCAL SOCKET
     1467      000003		 .NCFSK==:3   ;FOREIGN SOCKET
     1468      000004		 .NCFSM==:4   ;FINITE STATE MACHINE STATE
     1469      000005		 .NCLNK==:5   ;LINK
     1470      000006		 .NCNVT==:6   ;NVT, -1 IF NOT A TELNET CONNECTION
     1471      000007		 .NCSIZ==:7   ;BYTE SIZE OF CONNECTION
     1472      000010		 .NCMSG==:10   ;MSG ALLOC
     1473      000011		 .NCBAL==:11   ;BIT ALLOC
     1474      000012		 .NCDAL==:12   ;DESIRED ALLOC
     1475      000013		 .NCBTC==:13   ;BITS XFERRED
     1476      000014		 .NCBPB==:14   ;BYTES/BUFFER
     1477      000015		 .NCCLK==:15   ;TIME-OUT COUNTDOWN
     1478      000016		 .NCSTS==:16   ;CONNECTION STATUS
     1479
     1480
     1481		       ;GTRPW
     1482
     1483    400000  000000	 PF%USR==:1B0	;PAGE FAIL WORD - USER MODE REFERENCE
     1484    010000  000000	 PF%WRT==:1B5	; " - WRITE REFERENCE
     1485    000010  000000	 TSW%RD==:1B14	 ;TRAP STATUS WORD - READ
     1486    000004  000000	 TSW%WT==:1B15	 ; " - WRITE
     1487    000004  000000	 TSW%WR==:1B15	 ; (ANOTHER NAME FOR ABOVE)
     1488    000002  000000	 TSW%EX==:1B16	 ; " - EXECUTE
     1489    000001  000000	 TSW%MN==:1B17	 ; " - MONITOR MODE REFERENCE
     1490
     1491
     1492		       ;GTSTS BITS RETURNED IN 2
     1493
     1494    400000  000000	 GS%OPN==:1B0	;FILE IS OPEN
     1495    200000  000000	 GS%RDF==:1B1	;IF OPEN, FILE IS OPEN FOR READ
     1496    100000  000000	 GS%WRF==:1B2	;IF OPEN, FILE IS OPEN FOR WRITE
     1497    040000  000000	 GS%XCF==:1B3	;IF OPEN, FILE IS OPEN FOR EXECUTE
     1498    020000  000000	 GS%RND==:1B4	;OK TO RESET BYTE POINTER
     1499			    ; (FILE IS NOT APPEND)

     1501			    ; (NOT IMPLEMENTED -- OBSOLETE)
     1502    004000  000000	 GS%CAL==:1B6	;OK TO CALL AS A PROCEDURE
     1503			    ; (NOT IMPLEMENTED -- OBSOLETE)
     1504    002000  000000	 GS%LNG==:1B7	;FILE IS LONG
     1505    001000  000000	 GS%EOF==:1B8	;AT END OF FILE ON READ
     1506    000400  000000	 GS%ERR==:1B9	;FILE MAY BE IN ERROR
     1507    000200  000000	 GS%NAM==:1B10	 ;FILE HAS A NAME (JFN EXISTS)
     1508    000100  000000	 GS%AST==:1B11	 ;ONE OR MORE FIELDS OF NAME
     1509			    ; IS WILD
     1510    000040  000000	 GS%ASG==:1B12	 ;JFN IS BEING ASSIGNED
     1511    000020  000000	 GS%HLT==:1B13	 ;TERMINATE ON I/O ERROR
     1512    000001  000000	 GS%FRK==:1B17	 ;FILE IS RESTRICTED TO SOME FORK
     1513      000017		 GS%MOD==:17B35   ;DATA MODE
     1514      000000		  .GSNRM==:0  ;NORMAL MODE
     1515      000010		  .GSIMG==:10  ;IMAGE (BINARY) MODE
     1516      000017		  .GSDMP==:17  ;DUMP MODE
     1517
     1518
     1519
     1520		       ;HPTIM
     1521
     1522      000000		 .HPELP==:0   ;ELAPSED TIME
     1523      000001		 .HPRNT==:1   ;RUN TIME
     1524
     1525
     1526		       ;IDCNV (ALSO IDTNC AND ODCNV)
     1527
     1528    400000  000000	 IC%DSA==:1B0	;DAYLIGHT SAVINGS IF APPROPRIATE
     1529    200000  000000	 IC%ADS==:1B1	;APPLY DAYLIGHT SAVINGS
     1530    100000  000000	 IC%UTZ==:1B2	;USE TIME ZONE GIVEN
     1531    040000  000000	 IC%JUD==:1B3	;USE JULIAN DATE CONVERSION
     1532    000077  000000	 IC%TMZ==:77B17   ;TIME ZONE
     1533      777777		 IC%TIM==777777B35  ;LOCAL TIME
     1534
     1535
     1536		       ;IDTIM  IDTNC				      _
     1537
     1538    400000  000000	 IT%NDA==:1B0	;NO DATE
     1539    200000  000000	 IT%NNM==:1B1	;NO NUMERIC MONTH
     1540    100000  000000	 IT%SNM==:1B2	;SECOND NUMBER IS MONTH
     1541    040000  000000	 IT%ERR==:1B3	;ERROR IF NUMBERS ARE NOT IN SPECIFIED
     1542			    ; ORDER
     1543    004000  000000	 IT%NTI==:1B6	;NO TIME
     1544    002000  000000	 IT%NIS==:1B7	;NO SECONDS
     1545    001000  000000	 IT%AIS==:1B8	;ALWAYS INCLUDE SECONDS
     1546    000400  000000	 IT%NAC==:1B9	;NO COLON ALLOWED BETWEEN HH AND MM
     1547    000200  000000	 IT%AAC==:1B10	 ;ALWAYS ALLOW COLON
     1548    000100  000000	 IT%AMS==:1B11	 ;ALWAYS INTERPRET ONE COLON AS HHMM:SS
     1549    000040  000000	 IT%AHM==:1B12	 ;ALWAYS INTERPRET ONE COLON AS HH:MM
     1550    000010  000000	 IT%N24==:1B14	 ;NO 24-HOUR FORMAT
     1551    000004  000000	 IT%NTM==:1B15	 ;NO TIME MODIFIER (AM, PM)
     1552    000002  000000	 IT%NTZ==:1B16	 ;NO TIME ZONE
     1553

     1555		       ;.IMOPR - MONITOR ROUTINE USED BY MDDT AND SNOOP.  THIS IS NOT
     1556		       ;A JSYS SO THAT CALLS ARE FAST.
     1557
     1558      000001		 .IMALC==:1   ;ALLOCATE PAGES FOR USE IN MAPPING SYMBOLS
     1559      000002		 .IMMAP==:2   ;MAP PAGES OF THE SYMBOL TABLE
     1560      000003		 .IMUMP==:3   ;UNMAP PAGES OF THE SYMBOL TABLE
     1561
     1562
     1563		       ;INLNM
     1564
     1565      000000		 .INLJB==:0   ;GET JOB WIDE LOGICAL NAME FROM INDEX
     1566      000001		 .INLSY==:1   ;GET SYSTEM LOGICAL NAME FROM INDEX
     1567
     1568		       ;IPCF BIT DEFINITIONS AND DATA STRUCTURES
     1569
     1570		       ;PACKET FORMAT
     1571
     1572      000000		 .IPCFL==:0   ;FLAGS WORD
     1573    400000  000000	 IP%CFB==:1B0	;DON'T BLOCK READ
     1574    200000  000000	 IP%CFS==:1B1	;INDIRECT SENDER'S PID
     1575    100000  000000	 IP%CFR==:1B2	;INDIRECT RECEIVER'S PID
     1576    040000  000000	 IP%CFO==:1B3	;OVERDRAW SEND
     1577    020000  000000	 IP%TTL==:1B4	;TRUNCATE ON TOO LARGE MESSAGE
     1578    010000  000000	 IP%CPD==:1B5	;CREATE A PID ON THE SEND
     1579    004000  000000	 IP%JWP==:1B6	;MAKE THE CREATED PID BE JOB WIDE
     1580    002000  000000	 IP%NOA==:1B7	;NO ACCESS OF PID BY OTHER FORKS
     1581      400000		 IP%CFP==:1B18	 ;SENDER IS PRIV'D AND IS ENVOKING PRIVS
     1582      200000		 IP%CFV==:1B19	 ;PAGE TRANSFER MODE
     1583      100000		 IP%CFZ==:1B20	 ;ZERO LENGTH MESSAGE WAS SENT
     1584      040000		 IP%INT==:1B21	 ; Internal call - unavailable to users
     1585      007700		 IP%CFE==:77B29   ;ERROR FIELD
     1586
     1587		       ;ERRORS SENT BY INFO
     1588
     1589      000015		  .IPCPI==:15	;INSUFFICIENT PRIVILEGE
     1590      000016		  .IPCUF==:16	;ILLEGAL FUNCTION
     1591      000067		  .IPCSN==:67	;SEND INFO YOUR NAME
     1592      000072		  .IPCFF==:72	;INFO FREE SPACE EXHAUSTED
     1593      000074		  .IPCBP==:74	;PID HAS NO NAME OR IS ILLEGAL
     1594      000075		  .IPCDN==:75	;DUPLICATE NAME
     1595      000076		  .IPCNN==:76	;UNKNOWN NAME
     1596      000077		  .IPCEN==:77	;ILLEGAL NAME
     1597      000066		  .IPCKM==:66	;NOTIFICATION THAT PID HAS BEEN DELETED
     1598      000070		 IP%CFC==:7B32	 ;SYSTEM SENDER CODE
     1599      000001		  .IPCCC==:1   ;SENT BY [SYSTEM]IPCF
     1600      000002		  .IPCCF==:2   ;SENT BY SYSTEM WIDE [SYSTEM]INFO
     1601      000003		  .IPCCP==:3   ;SENT BY RECEIVER'S [SYSTEM]INFO
     1602      000007		 IP%CFM==:7B35	 ;SPECIAL MESSAGE RETURN FIELD
     1603      000001		  .IPCFN==:1   ;MESSAGE WAS NOT DELIVERED
     1604      000001		 .IPCFS==:1   ;PID OF SENDER
     1605      000002		 .IPCFR==:2   ;PID OF RECEIVER
     1606      000003		 .IPCFP==:3   ;POINTER TO MESSAGE BLOCK
     1607      000004		 .IPCFD==:4   ;LOGGED IN DIR OF SENDER

     1609      000006		 .IPCSD==:6   ;CONNECTED DIRECTORY NUMBER OF SENDER
     1610      000007		 .IPCAS==:7   ;POINTER TO ACCOUNT STRING OF SENDER
     1611      000010		 .IPCLL==:10   ;POINTER TO LOGICAL LOCATION OF SENDER
     1612
     1613      000026		 .IPCSU==:26   ;SPOOL MESSAGE CODE FROM IPCC
     1614      000027		 .IPCSL==:27   ;LOGOUT MESSAGE CODE FROM IPCC
     1615      000030		 .IPCSA==:30   ;RESOURCE ALLOCATOR MESSAGE CODE
     1616      000031		 .IPCDS==:31   ;STRUCTURE DISMOUNT MESSAGE CODE FROM IPCC
     1617      000032		 .IPCLI==:32   ;LOGIN MESSAGE CODE FROM IPCC
     1618      000033		 .IPCLO==:33   ;LOGOUT MESSAGE TO CREATOR FROM IPCC
     1619      000034		 .IPCKP==:34   ;DELETED PID MESSAGE FROM IPCC
     1620      000035		 .IPCCA==:35   ;CREATE AN APPLICATION (RESERVED FOR TPS USE)
     1621      000036		 .IPCTR==:36   ;REQUEST FROM TAPE
     1622      000037		 .IPCMS==:37   ;STRUCTURE MOUNT MESSAGE CODE FROM IPCC
     1623      000040		 .IPCRS==:40   ;STRUCTURE REMOVAL MSSG CODE FROM IPCC
     1624      000041		 .IPCSR==:41   ; Archive message code from IPCC
     1625
     1626      000015		 .IPCSS==:15   ;IPCC REQUEST TO INFO TO DELETE PIDS
     1627
     1628
     1629		       ;[SYSTEM] INFO DEFINITIONS
     1630
     1631      000000		 .IPCI0==:0   ;CODE,,FUNCTION
     1632      000001		 .IPCIW==:1   ;FIND PID FOR NAME
     1633      000002		 .IPCIG==:2   ;FIND NAME FOR PID
     1634      000003		 .IPCII==:3   ;ASSIGN NAME TO PID
     1635      000004		 .IPCIJ==:4   ;ASSIGN NAME TO PID
     1636      000005		 .IPCIK==:5   ;NOTIFY WHEN SPECIFIED PID IS KILLED
     1637      000015		 .IPCIS==:15   ;MONITOR DROP PID FUNCTION
     1638      000001		 .IPCI1==:1   ;PID TO GET A COPY OF REPLY
     1639      000002		 .IPCI2==:2   ;START OF DATA
     1640
     1641
     1642		       ;JFNS
     1643
     1644    700000  000000	 JS%DEV==7B2   ;DEVICE	FIELD OUTPUT CONTROL
     1645    070000  000000	 JS%DIR==:7B5	;DIRECTORY FIELD OUTPUT CONTROL
     1646    007000  000000	 JS%NAM==:7B8	;NAME FIELD OUTPUT CONTROL
     1647    000700  000000	 JS%TYP==:7B11	 ;FILE TYPE FIELD OUTPUT CONTROL
     1648    000070  000000	 JS%GEN==:7B14	 ;GENERATION FIELD OUTPUT CONTROL
     1649    000007  000000	 JS%PRO==:7B17	 ;PROTECTION FIELD OUTPUT CONTROL
     1650      700000		 JS%ACT==:7B20	 ;ACCOUNT FIELD OUTPUT CONTROL
     1651			 ;VALUES FOR ABOVE 7 FIELDS:
     1652      000000		  .JSNOF==:0  ;NEVER OUTPUT FIELD
     1653      000001		  .JSAOF==:1  ;ALWAYS OUTPUT FIELD
     1654      000002		  .JSSSD==:2  ;SUPPRESS IF SYSTEM DEFAULT
     1655      040000		 JS%TMP==:1B21	 ;RETURN ;T IF TEMP FILE
     1656      020000		 JS%SIZ==:1B22	 ;RETURN SIZE
     1657      010000		 JS%CDR==:1B23	 ;RETURN CREATION DATE
     1658      004000		 JS%LWR==:1B24	 ;RETURN LAST WRITE
     1659      002000		 JS%LRD==:1B25	 ;RETURN LAST READ
     1660      001000		 JS%PTR==:1B26	 ;AC 2 HOLDS STRING POINTER NOT JFN
     1661      000400		 JS%ATR==:1B27	 ;RETURN ATTRIBUTES

     1663      000100		 JS%OFL==:1B29	 ;RETURN ;OFF-LINE IF OFFLINE FILE
     1664      000010		 JS%PSD==:1B32	 ;PUNCTUATE SIZE AND DATE
     1665      000004		 JS%TBR==:1B33	 ;TAB BEFORE FIELDS RETURNED
     1666      000002		 JS%TBP==:1B34	 ;TAB BEFORE POSSIBLE FIELDS
     1667      000001		 JS%PAF==:1B35	 ;PUNCTUATE ALL FIELDS
     1668
     1669
     1670		       ;LNMST
     1671
     1672      000000		 .LNSJB==:0   ;GET JOB WIDE DEFINITION OF A LN
     1673      000001		 .LNSSY==:1   ;GET SYSTEM DEFINITION OF A LOGICAL NAME
     1674
     1675
     1676		       ;LOCK
     1677
     1678    400000  000000	 LK%CNT==:1B0	;USE COUNT IN AC3
     1679    200000  000000	 LK%PHY==:1B1	;USE AC1 AS PHYSICAL PAGE NUMBER
     1680    100000  000000	 LK%NCH==:1B2	;MAP PAGES CACHE INHIBITED
     1681    040000  000000	 LK%AOL==:1B3	;ALLOW LOCKING IN OFFLINE PAGES
     1682
     1683
     1684
     1685		       ;METER JSYS DEFS.
     1686
     1687      000001		 .MEREA==:1   ;READ EBOX TICKS
     1688      000002		 .MERMA==:2   ;READ MBOX TICKS
     1689
     1690		       ;MSTR
     1691
     1692      000000		 .MSRNU==:0   ;READ STATUS OF NEXT DISK UNIT
     1693      000001		 .MSRUS==:1   ;READ STATUS OF A DISK UNIT
     1694      000000		   .MSRCH==:0	;CHANNEL NUMBER
     1695      000001		   .MSRCT==:1	;CONTROLLER NUMBER
     1696      000002		   .MSRUN==:2	;UNIT NUMBER
     1697      000003		   .MSRST==:3	;STATUS
     1698    400000  000000	     MS%MNT==:1B0  ;THIS UNIT IS PART OF A MOUNTED STRUCTURE
     1699    200000  000000	     MS%16B==:1B1  ;THIS UNIT WRITTEN IN 16-BIT MODE
     1700			    ; (RESERVED FOR FUTURE)
     1701    100000  000000	     MS%DIA==:1B2  ;THIS UNIT IS CURRENTLY IN USE BY AN
     1702			    ;  ON-LINE DIAGNOSTIC
     1703    040000  000000	     MS%OFL==:1B3  ;THIS UNIT IS OFF-LINE
     1704    020000  000000	     MS%ERR==:1B4  ;THERE WAS AN ERROR READING THIS UNIT
     1705    010000  000000	     MS%BBB==:1B5  ;ONE OF THE BAT BLOCKS IS BAD
     1706    004000  000000	     MS%HBB==:1B6  ;ONE OF THE HOME BLOCKS IS BAD
     1707    002000  000000	     MS%WLK==:1B7  ;UNIT IS WRITE-LOCKED
     1708    000777  000000	     MS%TYP==:777B17  ;DISK TYPE CODE
     1709		       ; DEFINED THE SAME AS .UTTXX IN PHYPAR
     1710      000001		     .MSRP4==:1   ;RP04
     1711      000005		     .MSRP5==:5   ;RP05
     1712      000006		     .MSRP6==:6   ;RP06
     1713      000007		     .MSRP7==:7   ;RP07
     1714      000011		     .MSRM3==:11   ;RM03
     1715      000004		   .MSRSN==:4	;STRUCTURE NAME

     1717      000006		   .MSRNS==:6	;UNIT # IN STRUCTURE,,# OF UNITS IN STRUCTURE
     1718      000007		   .MSRSW==:7	;NUMBER OF PAGES FOR SWAPPING
     1719      000010		   .MSRUI==:10	 ;UNIT ID
     1720      000013		   .MSROI==:13	 ;OWNER ID
     1721      000016		   .MSRFI==:16	 ;FILE-SYSTEM ID
     1722      000021		   .MSRSP==:21	 ;NUMBER OF SECTORS PER PAGE
     1723      000022		   .MSRSC==:22	 ;NUMBER OF SECTORS PER CYLINDER
     1724      000023		   .MSRPC==:23	 ;NUMBER OF PAGES PER CYLINDER
     1725      000024		   .MSRCU==:24	 ;NUMBER OF CYLINDERS PER UNIT
     1726      000025		   .MSRSU==:25	 ;NUMBER OF SECTORS PER UNIT
     1727      000026		   .MSRBT==:26	 ;NUMBER OF BIT-WORDS IN BIT TABLE PER CYLINDER
     1728      000027		   .MSRLN==:27	 ;MAX LENGTH OF ARGUMENT BLOCK IN WORDS
     1729
     1730      000002		 .MSMNT==:2   ;MOUNT A STRUCTURE
     1731      000000		   .MSTNM==:0	;NAME OF STRUCTURE
     1732      000001		   .MSTAL==:1	;ALIAS NAME
     1733      000002		   .MSTNU==:2	;NUMBER OF UNITS IN STRUCTURE
     1734      000002		   .MSTFL==:2	;FLAGS (LHS)
     1735    777777  000000	     MS%FLG==:777777,,0  ;MASK FOR .MSTFL
     1736    400000  000000	     MS%NFH==:1B0  ;NO FIX BAD HOME BLOCK
     1737    200000  000000	     MS%NFB==:1B1  ;NO FIX BAD BAT BLOCK
     1738    100000  000000	     MS%XCL==:1B2  ;MOUNT FOR EXCLUSIVE USE BY JOB
     1739    040000  000000	     MS%IGN==:1B3  ;IGNORE ERRORS
     1740      000003		   .MSTUI==:3	;START OF UNIT INFORMATION
     1741      000000		     .MSTCH==:0   ;CHANNEL NUMBER
     1742      000001		     .MSTCT==:1   ;CONTROLLER NUMBER
     1743      000002		     .MSTUN==:2   ;UNIT NUMBER
     1744      000003		     .MSTNO==:3   ;# OF ARGUMENT WORDS/UNIT
     1745
     1746      000003		 .MSDIS==:3   ;DISMOUNT A STRUCTURE
     1747      000000		   .MSDNM==:0	;NAME OF STRUCTURE
     1748
     1749      000004		 .MSGSS==:4   ;GET STATUS OF A STRUCTURE
     1750      000000		   .MSGSN==:0	;STRUCTURE NAME (ALIAS)
     1751      000001		   .MSGST==:1	;STATUS
     1752    400000  000000	     MS%PS==:1B0   ;STRUCTURE IS A PUBLIC STRUCTURE
     1753    200000  000000	     MS%DIS==:1B1  ;STRUCTURE IS BEING DISMOUNTED
     1754    100000  000000	     MS%DOM==:1B2  ;STRUCTURE IS DOMESTIC
     1755    040000  000000	     MS%PPS==:1B3  ;STRUCTURE IS THE PRIMARY PUBLIC STRUCTURE
     1756    020000  000000	     MS%INI==:1B4  ;STRUCTURE IS BEING INITIALIZED
     1757    010000  000000	     MS%LIM==:1B5  ;STRUCTURE LIMITED TO 2050 SIZES
     1758    004000  000000	     MS%NRS==:1B6  ;STRUCTURE IS NOT REGULATED
     1759      000002		   .MSGNU==:2	;NUMBER OF UNITS IN STRUCTURE
     1760      000003		   .MSGMC==:3	;MOUNT COUNT
     1761      000004		   .MSGFC==:4	;OPEN FILE COUNT
     1762      000005		   .MSGSI==:5	;STRUCTURE ID
     1763      000006		   .MSGLN==:6	;LENGTH OF ARGUMENT BLOCK
     1764
     1765      000005		 .MSSSS==:5   ;SET STATUS OF A STRUCTURE
     1766      000000		   .MSSSN==:0	;STRUCTURE NAME
     1767      000001		   .MSSST==:1	;NEW STATUS BITS
     1768      000002		   .MSSMW==:2	;MASK WORD OF BITS TO BE CHANGED
     1769      000003		   .MSSLN==:3	;LENGTH OF ARGUMENT BLOCK

     1771      000006		 .MSINI==:6   ;INITIALIZE A STRUCTURE
     1772      000000		   .MSINM==:0	;NAME OF STRUCTURE
     1773      000001		   .MSIAL==:1	;ALIAS NAME
     1774      000002		   .MSINU==:2	;NUMBER OF UNITS IN STRUCTURE
     1775      000002		   .MSIFL==:2	;FLAGS (LHS)
     1776			    ;FLAGS DEFINED IN .MSMNT FUNCTION
     1777    000077  000000	     MS%FCN==:77B17  ;FUNCTION CODE
     1778      000001		       .MSCRE==:1  ;CREATE NEW FILE SYSTEM
     1779      000002		       .MSRRD==:2  ;RECONSTRUCT THE ROOT-DIRECTORY
     1780      000003		       .MSWHB==:3  ;WRITE THE HOME BLOCKS
     1781      000004		       .MSRIX==:4   ;REBUILD INDEX TABLE (IDXFIL)
     1782      000003		   .MSISU==:3	;START OF UNIT INFORMATION
     1783      000000		     .MSICH==:0   ;CHANNEL NUMBER
     1784      000001		     .MSICT==:1   ;CONTROLLER NUMBER
     1785      000002		     .MSIUN==:2   ;UNIT NUMBER
     1786      000003		     .MSINO==:3   ;# OF ARGUMENT WORDS/UNIT
     1787      000006		   .MSIST==:6	;STATUS WORD
     1788      000007		   .MSISW==:7	;NUMBER OF PAGES FOR SWAPPING ON THIS UNIT
     1789      000010		   .MSIFE==:10	 ;NUMBER OF PAGES FOR FRONT-END FILE SYSTEM
     1790      000011		   .MSIUI==:11	 ;UNIT ID
     1791      000014		   .MSIOI==:14	 ;OWNER ID
     1792      000017		   .MSIFI==:17	 ;FILE SYSTEM ID
     1793      000022		   .MSIFB==:22	 ;NUMBER OF PAGES FOR  BOOTSTRAP.BIN (OPTIONAL)
     1794
     1795      000007		 .MSIMC==:7   ;INCREMENT MOUNT COUNT
     1796      000010		 .MSDMC==:10   ;DECREMENT MOUNT COUNT
     1797      000000		   .MSDEV==:0	;DEVICE DESIGNATOR OR STRUCTURE
     1798      000001		   .MSJOB==:1	;JOB NUMBER FOR WHICH TO CHANGE COUNT
     1799
     1800      000011		 .MSGSU==:11   ;GET STRUCTURE USERS
     1801      000000		   .MSUAL==:0	;POINTER TO ALIAS OF STRUCTURE
     1802      000001		   .MSUFL==:1	;FLAGS,,# OF ITEMS RETURNED
     1803    400000  000000	     MS%GTA==:1B0  ;GET USERS WHO HAVE ACCESSED STRUCTURE
     1804    200000  000000	     MS%GTM==:1B1  ;GET USERS WHO HAVE MOUNTED STRUCTURE
     1805    100000  000000	     MS%GTC==:1B2  ;GET USERS WHO ARE CONNECTED TO STRUCTURE
     1806      000002		   .MSUJ1==:2	;FIRST JOB NUMBER RETURNED
     1807
     1808      000012		 .MSHOM==:12   ;MODIFY HOMEBLOCK WORD
     1809      000000		   .MSHNM==:0	;POINTER TO ALIAS, OR DESIGNATOR FOR ALIAS
     1810      000001		   .MSHOF==:1	;OFFSET INTO HOMEBLOCK OF WORD BEING CHANGED
     1811      000002		   .MSHVL==:2	;NEW VALUES FOR BITS BEING CHANGED
     1812      000003		   .MSHMK==:3	;MASK DECLARING WHICH BITS BEING CHANGED
     1813
     1814      000013		 .MSICF==:13   ;INCREMENT MOUNT COUNT ON A FORK BASIS
     1815      000014		 .MSDCF==:14   ;DECREMENT MOUNT COUNT ON A FORK BASIS
     1816      000000		   .MSDEV==:0	;DEVICE DESIGNATOR OR STRUCTURE
     1817
     1818      000015		 .MSOFL==:15   ;ENABLE PSI INTERRUPTS INTERRUPTS FOR
     1819			    ; DISK (FOR DEVICE ALLOCATOR)
     1820      000000		   .MSCHN==:0	;CHANNEL ON WHICH TO RECEIVE INTERRUPT
     1821
     1822
     1823      000016		 .MSIIC==:16   ;IGNORE INCREMENT CHECK FOR STRUCTURE USE

     1825		       ;MTOPR - FUNCTION CODES
     1826
     1827      000000		 .MOCLE==:0   ;CLEAR ERRORS
     1828      000031		 .MONOP==:31   ;NOP (WAIT FOR ACTIVITY TO STOP)
     1829      000001		 .MOREW==:1   ;REWIND
     1830      000003		 .MOEOF==:3   ;WRITE EOF
     1831      000004		 .MODTE==:4   ;ASSIGN FE DEVICE TO A DTE
     1832      000006		 .MOFWR==:6   ;FORWARD SPACE RECORD
     1833      000007		 .MOBKR==:7   ;BACKSPACE RECORD
     1834      000011		 .MORUL==:11   ;REWIND AND UNLOAD
     1835      000013		 .MOERS==:13   ;ERASE TAPE
     1836      000016		 .MOFWF==:16   ;FORWARD SPACE FILE
     1837      000017		 .MOBKF==:17   ;BACKSPACE FILE
     1838      000026		 .MOSPD==:26   ;SET TTY SPEED (FOR KL ONLY)
     1839      000027		 .MORSP==:27   ;READ LINE SPEED (FOR KL ONLY)
     1840    400000  000000	    MO%RMT==:1B0   ;FLAG TO SAY LINE IS REMOTE
     1841    200000  000000	    MO%AUT==:1B1   ;FLAG TO SAY LINE IS "AUTO" SPEED
     1842			    ; (RSX20F ONLY)
     1843      000002		 .MOSDR==:2   ;SET READ DIRECTION
     1844      000026		 .MORDR==:26   ;READ READ DIRECTION
     1845      000010		 .MOEOT==:10   ;SKIP TO LOGICAL END OF TAPE
     1846      000005		 .MOSRS==:5   ;SET RECORD SIZE
     1847      000015		 .MORRS==:15   ;READ RECORD SIZE
     1848      000024		 .MOSDN==:24   ;SET DENSITY
     1849      000012		 .MORDN==:12   ;READ DENSITY
     1850      000004		 .MOSDM==:4   ;SET DATA MODE
     1851      000014		 .MORDM==:14   ;READ DATA MODE
     1852      000020		 .MOSPR==:20   ;SET PARITY
     1853      000021		 .MORPR==:21   ;READ PARITY
     1854      000022		 .MONRB==:22   ;GET NUMBER OF REMAINING BYTES IN RECORD
     1855      000023		 .MOFOU==:23   ;FORCE OUT RECORD
     1856      000025		 .MOINF==:25   ;GET INFORMATION ABOUT TAPE
     1857      000000		    .MOICT==:0	 ;COUNT OF ARGUMENTS TO BE RETURNED
     1858      000001		    .MOITP==:1	 ;MAGTAPE TYPE CODE
     1859		       ; DEFINED THE SAME AS .UTTXX IN PHYPAR
     1860      000003		       .MTT45==:3  ;MAGTAPE TYPE TU45
     1861      000013		       .MTT77==:13  ;MAGTAPE TYPE TU77
     1862      000015		       .MTT78==:15  ;MAGTAPE TYPE TU78
     1863      000017		       .MTT70==:17  ;MAGTAPE TYPE TU70
     1864      000020		       .MTT71==:20  ;MAGTAPE TYPE TU71
     1865      000021		       .MTT72==:21  ;MAGTAPE TYPE TU72
     1866      000022		       .MTT73==:22  ;RESERVED FOR 200 IPS STC GCR DRIVE
     1867      000002		    .MOIID==:2	 ;MAGTAPE REEL ID
     1868      000003		    .MOISN==:3	 ;CHAN,CONTROLLER,UNIT ,, SERIAL #
     1869      000004		    .MOIRD==:4	 ;# OF READS DONE
     1870      000005		    .MOIWT==:5	 ;# OF WRITES DONE
     1871      000006		    .MOIRC==:6	 ;RECORD # FROM BOT
     1872      000007		    .MOIFC==:7	 ;FILE COUNT ON TAPE
     1873      000010		    .MOISR==:10   ;# OF SOFT READ ERRORS
     1874      000011		    .MOISW==:11   ;# OF SOFT WRITE ERRORS
     1875      000012		    .MOIHR==:12   ;# OF HARD READ ERRORS
     1876      000013		    .MOIHW==:13   ;# OF HARD WRITE ERRORS
     1877      000014		    .MOIRF==:14   ;# RECORDS READ

     1879      000032		 .MOLOC==:32   ;ATTACH MT TO MTA
     1880      000000		  .MOCNT==:0  ;OFFSET FOR COUNT
     1881      000001		  .MOMTN==:1  ;OFFSET FOR MT NUMBER
     1882      000002		  .MOLBT==:2  ;LABEL TYPE (.LTxxx)
     1883      000003		  .MODNS==:3  ;DENSITY (.SJDxx)
     1884      000004		  .MOAVL==:4  ;ADDRESS OF VOLUME LABELS
     1885      000005		  .MONVL==:5  ;# OF VOLUME LABELS (VOL1 + UVLSs)
     1886      000006		  .MOCVN==:6  ;CURRENT VOLUME NUMBER WITHIN SET
     1887      000007		  .MOVSN==:7  ;VOLUME SET NAME
     1888      000037		 .MOSTA==:37   ;CURRENT MAGTAPE STATUS
     1889      000001		   .MODDN==:1	;1ST WORD OF .MOSTA DENSITIES CAPABLE
     1890
     1891    200000  000000	     SJ%CP2==:1B1  ;200 BPI
     1892    100000  000000	     SJ%CP5==:1B2  ;556 BPI
     1893    040000  000000	     SJ%CP8==:1B3  ;800 BPI
     1894    020000  000000	     SJ%C16==:1B4  ;1600 BPI
     1895    010000  000000	     SJ%C62==:1B5  ;6250 BPI
     1896
     1897      000002		   .MODDM==:2	;2ND WORD OF .MOSTA DATA MODES CAPABLE
     1898    200000  000000	     SJ%CMC==:1B1  ;CORE DUMP MODE
     1899    100000  000000	     SJ%CM6==:1B2  ;SIXBIT
     1900    040000  000000	     SJ%CMA==:1B3  ;ANSI ASCII
     1901    020000  000000	     SJ%CM8==:1B4  ;INDUSTRY COMPATABLE
     1902    010000  000000	     SJ%CMH==:1B5  ;HIGH DENSITY MODE
     1903      000003		   .MOTRK==:3	;3RD WORD OF .MOSTA NUMBER OF TRACKS
     1904    200000  000000	     SJ%7TR==:1B1  ;7 TRACK DRIVE
     1905    100000  000000	     SJ%9TR==:1B2  ;9 TRACK DRIVE
     1906
     1907      000004		   .MOCST==:4	;4TH WORD OF .MOSTA TAPE STATUS
     1908    400000  000000	     SJ%OFS==:1B0  ;OFF LINE
     1909    200000  000000	     SJ%MAI==:1B1  ;MAINTENANCE MODE ENABLED
     1910    100000  000000	     SJ%MRQ==:1B2  ;MAINTENANCE MODE REQUESTED
     1911    040000  000000	     SJ%BOT==:1B3  ;BOT
     1912    020000  000000	     SJ%REW==:1B4  ;REWINDING
     1913    010000  000000	     SJ%WLK==:1B5  ;WRITE LOCKED
     1914
     1915      000005		   .MODVT==:5	;5TH WORD OF .MOSTA DEVICE TYPE
     1916
     1917		       ; DEFINITIONS FOR THIS ARE SAME AS USED IN .MTALN
     1918      000040		 .MOOFL==:40   ;PSI FOR MAGTAPES
     1919      000042		 .MOPST==:42   ;PSI FOR EOT ON MT'S
     1920		       ; T3/ PSI ASSIGNMENT (-1 = CLEAR)
     1921      000001		 .MORVS==:.MOREW   ;REWIND VOLUME SET
     1922      000043		 .MORVL==:43   ;REWIND CURRENT VOLUME
     1923      000044		 .MOVLS==:44   ;VOLUME SWITCH FOR UNLABELED TAPES
     1924      000045		 .MONTR==:45   ;SET/CLEAR NO TRANSLATE FLAG
     1925		       ; T3/ -1 = DON'T CONVERT EBCDIC TO ASCII
     1926		       ; T3/0= CONVERT
     1927      000046		 .MORDL==:46   ;READ USER LABELS
     1928		       ; T2/ GETS LABEL I.D.
     1929		       ; T3/ SP TO WHERE 76 CHARCTERS ARE TO BE PLACED
     1930      000047		 .MOWUL==:47   ;WRITE USER LABELS
     1931		       ; T2/ LABEL I.D.

     1933      000050		 .MORLI==:50   ;READ LABEL INFORMATION FOR MT
     1934      000001		  .MOMTP==:1  ;TYPE OF LABEL
     1935      000002		  .MOMVN==:2  ;VOLUME NAME
     1936      000003		  .MOMOW==:3  ;OWNER
     1937      000004		  .MOMFM==:4  ;FORMAT OF TAPE FILE
     1938      000005		  .MOMRL==:5  ;RECORD LENGTH
     1939      000006		  .MOMBL==:6  ;BLOCK LENGTH
     1940      000007		  .MOMCD==:7  ;CREATION DATE
     1941      000010		  .MOMED==:10  ;EXPIRATION DATE
     1942      000011		  .MOMFI==:11  ;FILE NAME
     1943      000012		  .MOMGN==:12  ;GENERATION NUMBER
     1944      000013		  .MOMGV==:13  ;GENERATION VERSION NUMBER
     1945      000014		  .MOVMB==:14  ;VALUE OF MODE BYTE
     1946      000051		 .MOSMV==:51   ;SET MODE VALUE
     1947      000000		  .TPFST==:0  ;STREAM MODE
     1948      000001		  .TPFCP==:1  ;ALL FORMATTING CONTROLS PRESENT
     1949      000002		  .TPFFC==:2  ;FORTRAN CONTROLS PRESENT
     1950      000003		  .TPFNC==:3  ;NO CONTROLS PRESENT
     1951      000003		  .TPFMX==:3  ;MAX VALUE OF FIELD
     1952      000052		 .MOSDS==:52   ;SET DEFERRED VOLUME-SWITCH MODE
     1953      000027		 .MOPSI==:27   ;SET ERROR PSI FOR LPT AND CDR
     1954    400000  000000	    MO%MSG==:1B0   ;SUPPRESS STANDARD CTY MESSAGES
     1955      000027		 .MOSID==:27   ;SET REEL I.D.
     1956      000030		 .MOIEL==:30   ;INHIBIT ERROR LOGGING
     1957      000045		 .MOSHV==:45   ;SET HDR1 AND HDR2 VALUES FOR MT
     1958      000001		  .MOFMT==:1  ;OFFSET FOR FORMAT
     1959      000002		  .MOEPD==:2  ;EXPIRATION DATE
     1960      000003		  .MOBSZ==:3  ;BLOCK SIZE
     1961      000004		  .MORSZ==:4  ;RECORD SIZE
     1962
     1963		       ;DEF FOR IPCF MESSAGE SENT ON A VOLUME SWITCH OR OTHER CONDITION
     1964		       ;MESSAGE CODE IS .IPCTR. OFFSETS THAT FOLLOW ARE
     1965		       ;RELATIVE TO WORD CONTAINING .IPCTR.
     1966
     1967      000000		 .VMCOD==:0   ;CODE FOR THIS MESSAGE
     1968			    ; IS SUBCODE OF .IPCTR FUNCTION
     1969      000001		  .VMABT==:1  ;ABORT CLOSE
     1970      000002		  .VMICN==:2  ;INTERNAL ERROR (HOPEFULLY NOT USED)
     1971      000003		  .VMERR==:3  ;LABEL R/W ERROR
     1972      000004		  .VMVSM==:4  ;VOLUME SWITCH
     1973      000005		  .VMSTS==:5  ;UNIT STATUS CHANGE (NOT USED YET)
     1974      000006		  .VMUNL==:6  ;UNIT UNLOAD
     1975      000007		  .VMREW==:7  ;REWIND
     1976      000001		 .VSMTN==:1   ;MT NUMBER
     1977      000002		 .VSFLG==:2   ;FLAGS
     1978    777777  000000	  VS%FLG==:-1B17   ;FLAGS PART OF WORD
     1979    400000  000000	  VS%WRT==:1B0	;WRITE PREVIOUS VOLUME WAS OPENED FOR WRITE
     1980      777777		  VS%COD==:777777  ;CODE
     1981      000001		  .VSMNV==:1  ;MOUNT NTH VOLUME
     1982      000002		  .VSFST==:2  ;MOUNT FIRST VOLUME
     1983      000003		  .VSLST==:3  ;MOUNT LAST VOLUME
     1984      000004		  .VSMRV==:4  ;MOUNT RELATIVE VOLUME NUMBER (SIGNED)
     1985      000005		  .VSFLS==:5  ;FORCE LABELED TAPE VOLUME-SWITCH

     1987
     1988      000032		 .MOLVF==:32   ;LOAD DEVICE'S VFU
     1989      000033		 .MORVF==:33   ;READ VFU FILE NAME
     1990      000034		 .MOLTR==:34   ;LOAD TRANSLATION RAM
     1991      000035		 .MORTR==:35   ;READ RAM FILE NAME
     1992      000036		 .MOSTS==:36   ;SET SOFTWARE STATUS
     1993      000037		 .MORST==:37   ;READ SOFTWARE STATUS
     1994      000001		    MO%LPC==1	;PAGE COUNTER OVERFLOW
     1995      000002		    MO%LCI==2	;CHARACTER INTERRUPT (HARD ERROR)
     1996      000004		    MO%LVF==4	;VFU ERROR.  PAPER MUST BE RE-ALIGNED
     1997      000020		    MO%LVU==20	 ;LINE PRINTER HAS OPTICAL VFU
     1998      000040		    MO%RPE==40	 ;RAM PARITY ERROR
     1999
     2000      000001		    MO%RCK==:1	 ;READ CHECK
     2001      000002		    MO%PCK==:2	 ;PICK CHECK
     2002      000004		    MO%SCK==:4	 ;STACK CHECK
     2003      000010		    MO%HEM==:10   ;HOPPER EMPTY
     2004      000020		    MO%SFL==:20   ;STACKER FULL
     2005
     2006    000001  000000	    MO%FNX==:1B17  ;NON-EXISTENT DEVICE
     2007    000002  000000	    MO%OL==:1B16   ;DEVICE IS OFF-LINE
     2008    000004  000000	    MO%HE==:1B15   ;HARDWARE ERROR
     2009    000010  000000	    MO%SER==:1B14  ;SOFTWARE ERROR
     2010    000020  000000	    MO%IOP==:1B13  ;I/O IN PROGRESS
     2011    000040  000000	    MO%EOF==:1B12  ;END OF FILE
     2012		       ;  1B11	  ;RESERVED
     2013    000200  000000	    MO%FER==:1B10  ;FATAL ERROR
     2014    400000  000000	    MO%LCP==:1B0   ;LOWER CASE PRINTER
     2015    200000  000000	    MO%RLD==:1B1   ;FRONT-END WAS RELOADED
     2016      000040		 .MOFLO==:40   ;FLUSH OUTPUT
     2017
     2018		       ;SEE SETJB FOR VARIOUS ARGUMENT VALUES
     2019
     2020      000034		 .MOSNT==:34   ;SET TTY NON-TERMINAL STATUS
     2021      000001		    .MOSMN==:1	 ;NO SYSTEM MESSAGES(I.E. SUPPRESS)
     2022      000000		    .MOSMY==:0	 ;YES SYSTEM MESSAGES(DEFAULT)
     2023      000035		 .MORNT==:35   ;READ TTY NON-TERMINAL STATUS
     2024
     2025		       ;PTY MTOPR NUMBERS
     2026
     2027      000024		 .MOAPI==:24   ;ASSIGN PTY INTERRUPT CHANNELS
     2028    400000  000000	    MO%WFI==:1B0   ;ENABLE WAITING FOR INPUT
     2029    200000  000000	    MO%OIR==:1B1   ;ENABLE OUTPUT IS WAITING
     2030    000077  000000	    MO%SIC==:77B17  ;SOFTWARE INTERRUPT CHANNEL
     2031      000025		 .MOPIH==:25   ;TEST PTY INPUT HUNGRY
     2032      000000		    .MONWI==:0	 ;NOT WAITING FOR INPUT
     2033    777777  777777	    .MOWFI==:-1   ;WAITING FOR INPUT
     2034      000026		 .MOBAT==:26   ;SET BATCH BIT
     2035      000001		   .MOJCB==:1	;JOB CONTROLLED BY BATCH
     2036      000000		   .MONCB==:0	;JOB NOT CONTROLLED BY BATCH
     2037
     2038
     2039		       ;TTY MODE DEFINITIONS

     2041      000030		 .MORLW==:30   ;READ WIDTH
     2042      000031		 .MOSLW==:31   ;SET WIDTH
     2043      000032		 .MORLL==:32   ;READ LENGTH
     2044      000033		 .MOSLL==:33   ;SET LENGTH
     2045      000036		 .MOSIG==:36   ;SET "IGNORE INPUT WHEN INACTIVE" BIT
     2046      000037		 .MORBM==:37   ;READ 128 CHARACTER BREAK MASK
     2047
     2048    776117  777740	  MO%WN1==:776117,,777740 ;BIT DEFINITIONS FOR NON-FORMATTING CONTROL
     2049      000000		  MO%WN2==:0  ;FOR ASCII CODES 40-777
     2050      000000		  MO%WN3==:0  ;FOR ASCII CODES 100-137
     2051      000020		  MO%WN4==:20  ;FOR ASCII CODES 137-177
     2052
     2053    001260  000420	  MO%WF1==:001260,,000420 ;FORMATTING CONTROL BITS
     2054      000000		  MO%WF2==:0  ;FOR ASCII CODES 40-77
     2055      000000		  MO%WF3==:0  ;FOR ASCII CODES 100-137
     2056      000020		  MO%WF4==:20  ;FOR ASCII CODES 140-177
     2057
     2058    000400  000400	  MO%WP1==:000400,,400 ;PUNCTUATION BIT DEFINITIONS
     2059    777774  001760	  MO%WP2==:777774,,001760 ; FOR ASCII CODES 40-77
     2060    400000  000760	  MO%WP3==:400000,,000760 ; FOR ASCII CODES 100-137
     2061    400000  000760	  MO%WP4==:400000,,000760 ; FOR ASCII CODES 140-177
     2062
     2063      000400		  MO%WA1==:400	;ALPHANUMERICS DEFINITIONS
     2064    000003  776000	  MO%WA2==:000003,,776000 ; FOR ASCII CODES 40-77
     2065    377777  777000	  MO%WA3==:377777,,777000 ; FOR ASCII CODES 100-137
     2066    377777  777020	  MO%WA4==:377777,,777020 ; FOR ASCII CODES 140-177
     2067      000040		 .MOSBM==:40   ;SET 128 CHARACTER BREAK MASK
     2068      000041		 .MORFW==:41   ;READ FIELD WIDTH
     2069      000042		 .MOSFW==:42   ;SET FIELD WIDTH
     2070      000043		 .MOXOF==:43   ;SET/CLEAR XOFF/XON HANDLING
     2071      000000		  .MOOFF==:0  ;TURN OFF XON/XOFF PROCESSING
     2072      000001		  .MOONX==:1  ;TURN ON XON/XOFF PROCESSING
     2073      000044		 .MORXO==:44   ;READ VALUE OF XOFF BIT
     2074      000045		 .MOSLC==:45   ;SET LINE COUNTER
     2075      000046		 .MORLC==:46   ;READ LINE COUNTER
     2076      000047		 .MOSLM==:47   ;SET LINE COUNTER MAXIMUM
     2077      000050		 .MORLM==:50   ;READ LINE COUNTER MAXIMUM
     2078      000051		 .MOTPS==:51   ;PSI FOR NON-CONTROLLING TERMINAL
     2079
     2080		       ;NET MTOPR NUMBERS
     2081
     2082      000020		 .MOACP==:20	   ;TOPS20AN ;ACCEPT CONNECTION ON SOCKET
     2083      000021		 .MOSND==:21	   ;TOPS20AN ;SEND ALL CURENTLY BUFFERED BYTES
     2084      000022		 .MOSIN==:22	   ;TOPS20AN ;SEND INS/INR COMMAND
     2085      000024		 .MOAIN==:24	   ;TOPS20AN ;ASSIGN INS/INR AND FSM PSI CHANNELS
     2086    770000  000000	    MO%NIN==:77B5      ;TOPS20AN ;INS/INR SOFTWARE INTERRUPT CHANNEL
     2087    000077  000000	    MO%FSM==:77B17     ;TOPS20AN ;FSM CHANGE OF STATE INTERRUPT CHANNEL
     2088
     2089
     2090		       ;DEFINITIONS FOR DECNET
     2091
     2092      000024		 .MOACN==:24   ;ASSIGN CONNECT INTERRUPT CHANNEL
     2093    777000  000000	    MO%CDN==:777B8  ;CONNECT INTERRUPT CHANNEL

     2095      777000		    MO%DAV==:777B26  ;DATA AVAILABLE CHANNEL
     2096      000777		      .MONCI==:777  ;NO CHANGE
     2097      000776		      .MOCIA==:776  ;CLEAR INTERRUPT ASSIGNMENT
     2098
     2099      000025		 .MORLS==:25   ;READ LINK STATUS
     2100    400000  000000	    MO%CON==:1B0   ;LINK IS CONNECTED
     2101    200000  000000	    MO%SRV==:1B1   ;LINK IS A SERVER
     2102    100000  000000	    MO%WFC==:1B2   ;WAITING FOR A CONNECT
     2103    040000  000000	    MO%WCC==:1B3   ;WAITING FOR THIS LINK TO CONFIRM
     2104    020000  000000	    MO%EOM==:1B4   ;EOM PRESENT IN INPUT BUFFER
     2105    010000  000000	    MO%ABT==:1B5   ;CONNECTION ABORTED
     2106    004000  000000	    MO%SYN==:1B6   ;SYNCH DI RECIEVED
     2107    002000  000000	    MO%INT==:1B7   ;INT MESSAGE AVAILABLE
     2108    001000  000000	    MO%LWC==:1B8   ;LINK WAS CONNECTED
     2109      000026		 .MORHN==:26   ;READ HOST NAME
     2110      000027		 .MORTN==:27   ;READ TASK NAME
     2111      000030		 .MORUS==:30   ;READ USER DATA
     2112      000031		 .MORPW==:31   ;READ PASSWORD
     2113      000032		 .MORAC==:32   ;READ ACCOUNT
     2114      000033		 .MORDA==:33   ;READ OPTIONAL DATA
     2115      000034		 .MORCN==:34   ;READ CONNECT OBJECT NUMBER
     2116      000035		 .MORIM==:35   ;READ INTERRUPT MESSAGE
     2117      000036		 .MOSIM==:36   ;SEND INTERRUPT MESSAGE
     2118      000037		 .MOROD==:37   ;READ OBJ-DESC OF CONNECTION
     2119      000040		 .MOCLZ==:40   ;CLOSE/REJECT A CONNECTION
     2120      000041		 .MOCC==:41   ;ACCEPT A CONNECTION
     2121      000042		 .MORSS==:42   ;READ SEGMENT SIZE
     2122
     2123		       ;DEFINITIONS FOR ATS
     2124
     2125		       ;FUNCTION CODES FOR MTOPR ARE IN COLUMN 1
     2126
     2127      000001		 .MOAMO==:1   ;SET MODE WORD
     2128      000001		  .MOAMM==:1  ;MESSAGE MODE
     2129      000002		  .MOADM==:2  ;DATA MODE
     2130      000002		 .MOAAT==:2   ;ACQUIRE TERMINAL
     2131    400000  000000	  MO%AER==:1B0	;HTN FIELD CONTAINS AN ERROR CODE
     2132      000003		 .MOASI==:3   ;ENABLE INTERRUPTS
     2133    777000  000000	  MO%IFL==:777B8  ;FUNCTION TO BE PERFORMED
     2134      000000		    .MOAAI==:0	;ASSIGN INTERRUPT CHANNEL
     2135      000001		    .MOADI==:1	;DEASSIGN INTERRUPT CHANNEL
     2136    000777  000000	  MO%IEV==:777B17  ;EVENT BEING ASSIGNED OR DEASSIGNED
     2137      000000		    .MOADT==:0	;DATA ARRIVAL
     2138      000001		    .MOAST==:1	;STATUS ARRIVAL
     2139      777777		  MO%ACH==:777777B35 ;CHANNEL NUMBER
     2140      000004		 .MORCD==:4   ;GET STATUS
     2141      000777		  MO%WDV==:777B35  ;WHICH DEVICES TO REPORT ON
     2142      000000		    .MOALD==:0	;ALL TERMINALS
     2143      000001		    .MOCHG==:1	;TERMINALS WHOSE STATUS HAS CHANGED
     2144      000002		    .MOLST==:2	;TERMINALS SPECIFIED IN LIST
     2145    400000  000000	  MO%ARM==:1B0	;ASK THE RESOURCE MANAGER
     2146    200000  000000	  MO%MDA==:1B1	;MORE DATA AVAILABLE FOR THIS JFN
     2147    400000  000000	   AT%OPN==:1B0 ;HTN IS OPEN AND USABLE

     2149    100000  000000	   AT%DHT==:1B2 ;DEASSIGNING HTN
     2150    040000  000000	   AT%TXF==:1B3 ;TERMINAL IS XOFF'D
     2151    020000  000000	   AT%UND==:1B4 ;DEVICE REQUESTED IS UNDEFINED
     2152    010000  000000	   AT%NAV==:1B5 ;DEVICE REQUESTED IS NOT AVAILABLE
     2153    004000  000000	   AT%OFL==:1B6 ;DEVICE REQUESTED IS OFFLINE
     2154    002000  000000	   AT%FUL==:1B7 ;SERVER IS FULL
     2155    001000  000000	   AT%UNS==:1B8 ;DEVICE TYPE IS UNSUPPORTED
     2156    000400  000000	   AT%REJ==:1B9 ;NODE NRM REJECTED THE REQUEST
     2157    000200  000000	   AT%MIE==:1B10 ;MONITOR INTERNAL ERROR (NODE OR HOST)
     2158    000100  000000	   AT%STF==:1B11 ;VT62 START-UP FAILED
     2159    000040  000000	   AT%CRJ==:1B12 ;CONNECTION WAS REJECTED
     2160    000020  000000	   AT%NDP==:1B13 ;DATA PIPE IS NOT OPEN
     2161      777777		   AT%SER==:777777B35 ;STATUS REPORT ERROR CODE (18 BITS)
     2162      000005		 .MOADE==:5   ;DEASSIGN TERMINAL
     2163    400000  000000	  MO%AAB==:1B0	;DON'T SEND REMAINING DATA
     2164
     2165		       ;DEFS FOR MTU JSYS
     2166
     2167		       ;FUNCTIONS:
     2168
     2169      000001		 .MTNVV==:1   ;SET NO VOLUME VALID
     2170      000000		  .MTCNT==:0  ;COUNT WORD
     2171      000001		  .MTCOD==:1  ;ERROR CODE
     2172      000002		  .MTPTR==:2  ;SP TO OPERATOR RESPONSE
     2173
     2174      000002		 .MTRAL==:2   ;READ ALL LABELS
     2175      000001		  .MTVL1==:1  ;SP TO VOL1 AREA
     2176      000002		  .MTVL2==:2  ;SP TO VOL2 AREA
     2177      000003		  .MTHD1==:3  ;SP TO HDR1 AREA
     2178      000004		  .MTHD2==:4  ;SP TO HDR2 AREA
     2179      000003		 .MTASI==:3   ;RETURN MT TO MTA ASSOCIATION
     2180      000001		  .MTPHU==:1  ;RETURN MTA UNIT NUMBER HERE
     2181    777777  777777	   .MTNUL==:-1 ;NO ASSIGNMENT CODE
     2182      000004		 .MTCVV==:4   ;CLEAR VV
     2183
     2184		       ;MUTIL JSYS FUNCTION CODES
     2185
     2186      000001		 .MUENB==:1   ;ENABLE PID FOR RECEIVING
     2187      000002		 .MUDIS==:2   ;DISABLE PID FROM RECEIVING
     2188      000003		 .MUGTI==:3   ;GET PID OF [SYSTEM]INFO
     2189      000004		 .MUCPI==:4   ;CREATE A PRIVATE INFO FOR A JOB
     2190      000005		 .MUDES==:5   ;DESTROY A PID
     2191      000006		 .MUCRE==:6   ;CREATE A PID
     2192      000007		 .MUSSQ==:7   ;SET SEND AND RECEIVE QUOTAS
     2193      000010		 .MUCHO==:10   ;CHANGE OWNER OF A PID
     2194      000011		 .MUFOJ==:11   ;FIND OWNER'S JOB NUMBER
     2195      000012		 .MUFJP==:12   ;FIND JOB'S PIDS
     2196      000013		 .MUFSQ==:13   ;FIND SEND AND RECEIVE QUOTAS
     2197      000015		 .MUFFP==:15   ;FIND FORK'S PIDS
     2198      000016		 .MUSPQ==:16   ;SET PID QUOTA
     2199      000017		 .MUFPQ==:17   ;FIND PID QUOTA
     2200      000020		 .MUQRY==:20   ;QUERY
     2201      000021		 .MUAPF==:21   ;ASSOCIATE A PID WITH A FORK

     2203      000023		 .MUDFI==:23   ;DEFINE PID OF [SYSTEM]INFO
     2204      000024		 .MUSSP==:24   ;SET SYSTEM PID TABLE
     2205      000025		 .MURSP==:25   ;READ SYSTEM PID TABLE
     2206      000026		 .MUMPS==:26   ;GET MAXIMUM PACKET SIZE
     2207      000027		 .MUSKP==:27   ;SET PID TO RECEIVE KILLED PID MESSAGE
     2208      000030		 .MURKP==:30   ;READ PID THAT RECEIVES KILLED PID MESSAGES
     2209      000031		 .MUSPS==:31   ;Get system maximum packet size
     2210
     2211
     2212		       ;SYSTEM PID TABLE INDEX VALUES
     2213
     2214      000000		 .SPIPC==:0   ;PID OF IPCC
     2215      000001		 .SPINF==:1   ;PID OF INFO
     2216      000002		 .SPQSR==:2   ;PID OF QUASAR
     2217      000003		 .SPMDA==:3   ;PID OF QSRMDA
     2218      000004		 .SPOPR==:4   ;PID OF OPERATOR JOB (ORION)
     2219      000005		 .SPNSR==:5   ;PID OF NETSER
     2220
     2221
     2222		       ;NODE
     2223
     2224      000000		 .NDSLN==:0   ;SET LOCAL NODE NAME
     2225      000001		 .NDGLN==:1   ;GET LOCAL NODE NAME
     2226      000000		    .NDNOD==:0	 ;POINTER TO NODE NAME
     2227      000002		 .NDSNM==:2   ;SET LOCAL NODE NUMBER
     2228      000003		 .NDGNM==:3   ;GET LOCAL NODE NUMBER
     2229      000004		 .NDSLP==:4   ;SET LOOPBACK ON PORT
     2230      000000		  .NDPRT==:0  ;PORT TO SET IN LOOPBACK
     2231      000005		 .NDCLP==:5   ;CLEAR LOOPBACK ON PORT
     2232      000006		 .NDFLP==:6   ;FIND LOOPBACK PORT
     2233    400000  000000	  ND%LPR==1B0  ;LOOPBACK RUNNING
     2234    200000  000000	  ND%LPA==1B1  ;LOOPBACK ASSIGNED TO PORT
     2235      000007		 .NDSNT==:7   ;SET NETWORK TOPOLOGY INFORMATION
     2236      000010		 .NDGNT==:10   ;GET NETWORK TOPOLOGY INFORMATION
     2237      000000		  .NDNND==:0  ;NUMBER OF NODE BLOCK POINTERS FOLLOWING
     2238      000001		  .NDCNT==:1  ;NUMBER OF WORDS IN A NODE BLOCK
     2239      000002		  .NDBK1==2  ;FIRST ADDRESS OF A NODE BLOCK
     2240
     2241			 ;NODE BLOCK DEFINITIONS
     2242      000000		  .NDNAM==:0  ;POINTER TO ASCIZ NODE NAME
     2243      000001		  .NDSTA==:1  ;NODE STATE
     2244      000000		   .NDSON==:0 ;ON
     2245      000001		   .NDSOF==:1 ;OFF
     2246      000002		  .NDNXT==:2  ;POINTER TO ASCIZ NEARER NEIGHBOR STRING
     2247      000003		  .NDNBS==:3  ;NODE BLOCK SIZE
     2248
     2249      000011		 .NDSIC==:11   ;SET TOPOLOGY CHANGE INTERRUPT CHANNEL
     2250      000000		  .NDCHN==:0  ;CHANNEL NUMBER
     2251      000012		 .NDCIC==:12   ;CLEAR NETWORK TOPOLOGY INTERRUPT
     2252      000013		 .NDGVR==:13   ;GET NSP VERSION INFORMATION
     2253      000000		  .NDNVR==:0  ;NUMBER OF VERSIONS RETURNED
     2254      000001		  .NDCVR==:1  ;POINTER TO COMMUNICATONS VERSION BLOCK
     2255      000002		  .NDRVR==:2  ;POINTER TO ROUTING VERSION BLOCK

     2257      000000		  .NDVER==:0  ;VERSION NUMBER
     2258      000001		  .NDECO==:1  ;ECO NUMBER
     2259      000002		  .NDCST==:2  ;CUSTOMER LEVEL
     2260      000014		 .NDGLI==:14   ;GET LINE INFORMATION
     2261      000000		  .NDNLN==:0  ;<# OF ENTRIES FOLLOWING,,# LINE RETURNED
     2262      000001		  .NDCNT==:1  ;NUMBER OF WORDS IN A LINE BLOCK
     2263
     2264			 ; LINE BLOCK DEFINITION
     2265      000000		  .NDLNM==:0  ;NSP PORT (LINE) NUMBER
     2266      000001		  .NDLST==:1  ;STATE OF LINE
     2267      000001		   .NDLON==:1 ;ON
     2268      000002		   .NDLOF==:2 ;OFF
     2269      000003		   .NDLCN==:3 ;CONTROLLER LOOPBACK
     2270      000004		   .NDLCB==:4 ;CABLE LOOPBACK
     2271      000002		  .NDLND==:2  ;BYTE POINTER NODE AT END OF LINE
     2272      000003		  .NDLSZ==:3  ;SIZE OF BLOCK
     2273      000015		 .NDVFY==:15   ;VERIFY NODE NAME
     2274      000001		  .NDFLG==:1  ;FLAGS RETURNED BY MONITOR
     2275    400000  000000	   ND%EXM==:1B0 ;NODE SPECFIED EXACTLY MATCHES A KNOWN NODE
     2276
     2277		       ;NOUT
     2278
     2279    400000  000000	 NO%MAG==:1B0	;OUTPUT MAGNITUDE
     2280    200000  000000	 NO%SGN==:1B1	;OUTPUT SIGN
     2281    100000  000000	 NO%LFL==:1B2	;LEADING FILLER
     2282    040000  000000	 NO%ZRO==:1B3	;FILL WITH ZERO'S
     2283    020000  000000	 NO%OOV==:1B4	;OUTPUT ON COLUMN OVERFLOW
     2284    010000  000000	 NO%AST==:1B5	;OUTPUT ASTERISKS ON OVERFLOW
     2285    000177  000000	 NO%COL==:177B17   ;NUMBER OF COLUMNS TO USE
     2286      777777		 NO%RDX==:777777   ;RADIX
     2287
     2288
     2289      000004		 OF%FDT==:1B33	 ;FORCE DATE UPDATE
     2290
     2291		       ;ODCNV -- SEE IDCNV FOR BITS
     2292
     2293
     2294		       ;ODTIM
     2295
     2296    400000  000000	 OT%NDA==:1B0	;DO NOT OUTPUT DATE
     2297    200000  000000	 OT%DAY==:1B1	;OUTPUT DAY OF WEEK
     2298    100000  000000	 OT%FDY==:1B2	;OUTPUT NUMERIC MONTH
     2299    040000  000000	 OT%NMN==:1B3	;OUTPUT NUMERIC MONTH
     2300    020000  000000	 OT%FMN==:1B4	;OUTPUT MONTH IN FULL
     2301    010000  000000	 OT%4YR==:1B5	;OUTPUT 4-DIGIT YEAR
     2302    004000  000000	 OT%DAM==:1B6	;OUTPUT DAY AFTER MONTH
     2303    002000  000000	 OT%SPA==:1B7	;OUTPUT SPACES IN DATE
     2304    001000  000000	 OT%SLA==:1B8	;OUTPUT SLASHES IN DATE
     2305    000400  000000	 OT%NTM==:1B9	;DO NOT OUTPUT TIME
     2306    000200  000000	 OT%NSC==:1B10	 ;DO NOT OUTPUT SECONDS
     2307    000100  000000	 OT%12H==:1B11	 ;OUTPUT 12-HOUR FORMAT
     2308    000040  000000	 OT%NCO==:1B12	 ;DO NOT OUTPUT COLON
     2309    000020  000000	 OT%TMZ==:1B13	 ;OUTPUT TIME ZONE

     2311
     2312
     2313		       ;ODTNC -- SEE IDCNV FOR BITS
     2314
     2315
     2316		       ;OPENF
     2317
     2318    770000  000000	 OF%BSZ==:77B5	 ;BYTE SIZE
     2319    007400  000000	 OF%MOD==:17B9	 ;MODE
     2320      400000		 OF%HER==:1B18	 ;HALT ON IO ERROR
     2321      200000		 OF%RD==:1B19	;READ
     2322      100000		 OF%WR==:1B20	;WRITE
     2323      040000		 OF%EX==:1B21	;EXECUTE (RESERVED FOR THE FUTURE)
     2324      020000		 OF%APP==:1B22	 ;APPEND
     2325      002000		 OF%THW==:1B25	 ;THAWED
     2326      001000		 OF%AWT==:1B26	 ;ALWAYS WAIT
     2327      000400		 OF%PDT==:1B27	 ;PRESERVE DATES
     2328      000200		 OF%NWT==:1B28	 ;NEVER WAIT
     2329      000100		 OF%RTD==:1B29	 ;RESTRICTED
     2330      000040		 OF%PLN==:1B30	 ;SET TO DISABLE LINE NUMBER CHECKING FOR
     2331			    ; NON-LINE NUMBER FILES
     2332      000020		 OF%DUD==:1B31	 ;DON'T UPDATE TO DISK BY DDMP
     2333      000010		 OF%OFL==:1B32	 ;ALLOW OPENING THE DEVICE EVEN IF OFFLINE
     2334      000004		 OF%FDT==:1B33	 ;FORCE DATE UPDATE
     2335      000002		 OF%RAR==:1B34	 ; Wait if file is off-line
     2336
     2337
     2338
     2339		       ;PMAP BIT DEFINITIONS
     2340
     2341    400000  000000	 PM%CNT==:1B0	;RH WORD CONTAINS A COUNT
     2342    200000  000000	 PM%MVP==:1B1	;MOVE PAGE INSTEAD OF INDIRECT POINTER
     2343			    ; (NOT IMPLEMENTED
     2344    100000  000000	 PM%RD==:1B2   ;READ
     2345    040000  000000	 PM%WT==:1B3   ;WRITE
     2346    040000  000000	 PM%WR==:1B3   ; (ANOTHER NAME FOR ABOVE)
     2347    020000  000000	 PM%EX==:1B4   ;EXECUTE (RESERVED FOR THE FUTURE)
     2348    160000  000000	 PM%RWX==:7B4	;CONVENIENT ABBREV FOR RD+WT+EX
     2349    010000  000000	 PM%PLD==:1B5	;PRELOAD PAGES BEING MAPPED
     2350    004000  000000	 PM%IND==:1B6	;USE INDIRECT PTRS (RESERVED FOR THE FUTURE)
     2351    001000  000000	 PM%TPU==:1B8	;TRAP TO USER
     2352			    ; (NOT IMPLEMENTED -- OBSOLETE)
     2353    000400  000000	 PM%CPY==:1B9	;COPY ON WRITE
     2354    000100  000000	 PM%ABT==:1B11	 ;ABORT UNMAP.
     2355      777777		 PM%RPT==:777777B35  ;REPEAT COUNT
     2356
     2357
     2358		       ;PMCTL - PHYSICAL MEMORY CONTROL
     2359
     2360      000000		 .MCRCE==:0   ;READ CACHE ENABLE
     2361      000001		 .MCSCE==:1   ;SET CACHE ENABLE
     2362      000000		  .MCCST==:0   ;ARGLIST OFFSET FOR CACHE STATE
     2363      000001		  MC%CEN==:1   ;CACHE ENABLED

     2365      000003		 .MCSPS==:3   ;SET PAGE STATUS
     2366      000000		  .MCPPN==:0   ;ARGLIST OFFSET FOR PHYSICAL PAGE NUMBER
     2367      000001		  .MCPST==:1   ;ARGLIST OFFSET FOR PAGE STATE
     2368      000000		  .MCPSA==:0   ;PAGE AVAILABLE
     2369      000001		  .MCPSS==:1   ;PAGE IN TRANSITION STATE
     2370      000002		  .MCPSO==:2   ;PAGE OFFLINE
     2371      000003		  .MCPSE==:3   ;PAGE OFFLINE DUE TO ERROR
     2372      000004		 .MCRME==:4   ;READ MEMORY ERROR INFORMATION
     2373      000001		  .PMMER==:1   ;MOS MEMORY ERROR
     2374      000000		  .PMMTP==:0   ;ENTRY HEADER AND TYPE
     2375      000001		  .PMMRG==:1   ;ERROR REGISTER
     2376      000002		  .PMMSY==:2   ;SYNDROME
     2377      000003		  .PMMBN==:3   ;BLOCK NUMBER
     2378      000004		  .PMMSB==:4   ;SPARE BIT NUMBER
     2379      000005		  .PMMEA==:5   ;ERROR ADDRESS
     2380      000006		  .PMMSN==:6   ;START OF SERIAL NUMBERS
     2381      000004		   .PMMNS==:4	;# OF SERIAL NUMBERS TO STORE
     2382
     2383
     2384		       ;PRARG - PROCESS ARGUMENTS
     2385
     2386		       ;FUNCTION CODE DEFINITIONS
     2387
     2388      000001		 .PRARD==:1   ;READ ARGUMENT BLOCK
     2389      000002		 .PRAST==:2   ;SET ARGUMENT BLOCK
     2390
     2391
     2392
     2393		       ;RCUSR AND RCDIR
     2394
     2395		       ; FLAGS SUPPLIED ON CALL
     2396
     2397    000010  000000	 RC%PAR==:1B14	 ;PARTIAL RECOGNITION IS ALLOWED
     2398    000004  000000	 RC%STP==:1B15	 ;STEP WILDCARD (RCDIR ONLY)
     2399    000002  000000	 RC%AWL==:1B16	 ;ALLOW WILDCARDS (RCDIR ONLY)
     2400    000001  000000	 RC%EMO==:1B17	 ;EXACT MATCH ONLY
     2401
     2402		       ; FLAGS RETURNED
     2403
     2404    400000  000000	 RC%DIR==1B0   ;FILES-ONLY DIRECTORY
     2405    200000  000000	 RC%ANA==1B1   ;ALPHANUMERIC ACCOUNTS ALLOWED
     2406    100000  000000	 RC%RLM==1B2   ;REPEAT LOGIN MESSAGE
     2407    040000  000000	 RC%NOM==:1B3	;NO MATCH FOUND
     2408    020000  000000	 RC%AMB==:1B4	;AMBIGUOUS
     2409    010000  000000	 RC%NMD==:1B5	;NO MORE DIRS - RETURNED IF STP IS REQUESTED
     2410    004000  000000	 RC%WLD==:1B6	;WILDCARD DIR WAS INPUT
     2411
     2412
     2413
     2414		       ;RCVOK
     2415
     2416      000000		 .RCFCJ==:0   ;FUNCTION CODE,, JOB NUMBER
     2417      000001		 .RCUNO==:1   ;USER NUMBER

     2419      000003		 .RCRQN==:3   ;REQUEST NUMBER
     2420      000004		 .RCNUA==:4   ;NUMBER OF USER ARGS
     2421      000005		 .RCARA==:5   ;POINTER TO USER ARGS
     2422      000006		 .RCCAP==:6   ;CURRENT CAPABILITIES
     2423      000007		 .RCTER==:7   ;TERMINAL NUMBER
     2424      000010		 .RCRJB==:10   ;REQUESTED JOB
     2425
     2426		       ;RDTTY AND TEXTI
     2427
     2428    400000  000000	 RD%BRK==:1B0	;BREAK ON REGULAR BREAK SET
     2429    200000  000000	 RD%TOP==:1B1	;BREAK ON TOPS10 BREAK SET
     2430    100000  000000	 RD%PUN==:1B2	;BREAK ON PUNCTUATION
     2431    040000  000000	 RD%BEL==:1B3	;BREAK ON END OF LINE
     2432    020000  000000	 RD%CRF==:1B4	;SUPPRESS CR (RETURNS LF ONLY)
     2433    010000  000000	 RD%RND==:1B5	;RETURN IF NOTHING TO DELETE
     2434    004000  000000	 RD%JFN==:1B6	;JFNS GIVEN FOR SOURCE
     2435    002000  000000	 RD%RIE==:1B7	;RETURN ON INPUT (BUFFER) EMPTY
     2436    001000  000000	 RD%BBG==:1B8	;BEGINNING OF (DEST) BUFFER GIVEN
     2437    000400  000000	 RD%BEG==:1B9	;RETURN IMMEDIATELY WHEN TYPIST EDITS TO .RDBKL
     2438    000200  000000	 RD%RAI==:1B10	 ;RAISE LOWERCASE INPUT
     2439    000100  000000	 RD%SUI==:1B11	 ;SUPPRESS U INDICATION
     2440    000040  000000	 RD%BTM==:1B12	 ;BREAK CHARACTER TERMINATED INPUT
     2441    000020  000000	 RD%BFE==:1B13	 ;RETURNED BECAUSE BUFFER EMPTY
     2442    000010  000000	 RD%BLR==:1B14	 ;BACKUP LIMIT REACHED
     2443
     2444		       ;TEXTI ARG BLOCK
     2445
     2446      000000		 .RDCWB==:0   ;COUNT OF WORDS IN BLOCK
     2447      000001		 .RDFLG==:1   ;FLAGS
     2448      000002		 .RDIOJ==:2   ;IO JFNS
     2449      000003		 .RDDBP==:3   ;DEST BYTE POINTER
     2450      000004		 .RDDBC==:4   ;DEST BYTE COUNT
     2451      000005		 .RDBFP==:5   ;TOP OF BUFFER POINTER
     2452      000006		 .RDRTY==:6   ;RETYPE (R) POINTER
     2453      000007		 .RDBRK==:7   ;BREAK SET MASK POINTER
     2454      000010		 .RDBKL==:10   ;BACKUP LIMIT POINTER
     2455
     2456
     2457
     2458		       ;RFSTS
     2459
     2460    400000  000000	 RF%LNG==:1B0	;LONG FORM OF RFSTS CALL, ARG BLOCK IN 2
     2461      777777		 RF%PRH==:777777B35  ;PROCESS HANDLE
     2462
     2463		       ;RFSTS ARG BLOCK
     2464
     2465      000000		 .RFCNT==:0   ;XWD COUNT OF WORDS RETURNED,
     2466			    ; MAXIMUM WORDS TO RETURN
     2467      000001		 .RFPSW==:1   ;PROCESS STATUS WORD
     2468      000002		 .RFPFL==:2   ;PROCESS' PC FLAGS
     2469      000003		 .RFPPC==:3   ;PROCESS' PC
     2470      000004		 .RFSFL==:4   ;STATUS FLAGS FOR PROCESS:
     2471    400000  000000	   RF%EXO==1B0	 ;PROCESS IS EXECUTE-ONLY

     2473		       ;PROCESS STATUS WORD
     2474
     2475    400000  000000	 RF%FRZ==:1B0	;PROCESS IS FROZEN
     2476    377777  000000	 RF%STS==:377777B17  ;PROCESS STATUS CODE
     2477      000000		    .RFRUN==:0	 ;RUNNABLE
     2478      000001		    .RFIO==:1	;DISMISSED FOR I/O
     2479      000002		    .RFHLT==:2	 ;HALTED
     2480      000003		    .RFFPT==:3	 ;FORCED PROCESS TERMINATION
     2481      000004		    .RFWAT==:4	 ;WAITING FOR INFERIOR PROCESS
     2482      000005		    .RFSLP==:5	 ;SLEEP
     2483      000006		    .RFTRP==:6	 ;JSYS TRAPPED
     2484      000007		    .RFABK==:7	 ;ADDRESS BREAK FREEZE
     2485      777777		 RF%SIC==:777777B35  ;SOFTWARE INTERRUPT CHANNNEL
     2486
     2487
     2488		       ;RFTAD/SFTAD
     2489
     2490      000000		 .RSWRT==:0   ;WRITE DATE WORD
     2491      000001		 .RSCRV==:1   ;CREATION DATE WORD
     2492      000002		 .RSREF==:2   ;REFERENCE DATE WORD
     2493      000003		 .RSCRE==:3   ;INTERNAL SYSTEM WRITE DATE WORD
     2494      000004		 .RSTDT==:4   ; Tape write date word
     2495      000005		 .RSNET==:5   ; Online expiration date/interval word
     2496      000006		 .RSFET==:6   ; Offline expiration date/interval word
     2497
     2498
     2499		       ;RMAP
     2500
     2501    100000  000000	 RM%RD==1B2   ;READ ACCESS ALLOWED
     2502    040000  000000	 RM%WR==:1B3   ;WRITE ACCESS ALLOWED
     2503    020000  000000	 RM%EX==:1B4   ;EXECUTE ACCESS ALLOWED
     2504    010000  000000	 RM%PEX==:1B5	;PAGE EXISTS
     2505    000400  000000	 RM%CPY==:1B9	;COPY ON WRITE
     2506
     2507
     2508		       ;RPACS/SPACS BIT DEFINITIONS
     2509
     2510    100000  000000	 PA%RD==:1B2   ;READ ACCESS ALLOWED
     2511    040000  000000	 PA%WT==:1B3   ;WRITE ACCESS ALLOWED
     2512    040000  000000	 PA%WR==:1B3   ; (ANOTHER NAME FOR ABOVE)
     2513    020000  000000	 PA%EX==:1B4   ;EXECUTE ACCESS ALLOWED
     2514			    ; (RESERVED FOR THE FUTURE)
     2515    010000  000000	 PA%PEX==:1B5	;PAGE EXISTS
     2516    004000  000000	 PA%IND==:1B6	;INDIRECT POINTER
     2517    001000  000000	 PA%TPU==:1B8	;TRAP TO USER
     2518			    ; (NOT IMPLEMENTED -- OBSOLETE)
     2519    000400  000000	 PA%CPY==:1B9	;COPY ON WRITE
     2520    000200  000000	 PA%PRV==:1B10	 ;PRIVATE
     2521      100000		 P1%RD==:1B20	;READ ACCESS ALLOWED IN 1ST POINTER
     2522      040000		 P1%WR==:1B21	;WRITE ACCESS ALLOWED IN 1ST POINTER
     2523      040000		 P1%WT==:1B21	; (ANOTHER NAME FOR ABOVE)
     2524      020000		 P1%EX==:1B22	;EXECUTE ACCESS ALLOWED IN 1ST POINTER
     2525			    ; (RESERVED FOR THE FUTURE)

     2527      000400		 P1%CPY==:1B27	 ;COPY-ON-WRITE IN 1ST POINTER
     2528
     2529
     2530
     2531		       ;RSCAN
     2532
     2533      000000		 .RSINI==:0   ;MAKE RESCAN BUFFER AVAILABLE FOR INPUT
     2534      000001		 .RSCNT==:1   ;COUNT CHARACTERS LEFT TO READ FROM RESCAN BUFFER
     2535
     2536
     2537		       ;RTIW
     2538
     2539    400000  000000	 RT%DIM==:1B0	;DEFERRED TERMINAL INTERRUPT MASK GIVEN
     2540      377777		 RT%PRH==:377777B35  ;PROCESS HANDLE
     2541
     2542
     2543		       ;SCTTY
     2544
     2545      000000		 .SCRET==:0   ;RETURN DESIGNATOR (CTTY) FOR FORK
     2546      000001		 .SCSET==:1   ;SET SCTTY FOR FORK
     2547      000002		 .SCRST==:2   ;CLEAR FORK CTTY (RESTORE JOB CTTY)
     2548
     2549		       ;SCVEC
     2550
     2551      000000		 .SVEAD==:0   ;ENTRY ADDRESS
     2552      000001		 .SVINE==:1   ;INITIAL ENTRY FOR SETUP
     2553      000002		 .SVGET==:2   ;ENTRY ADDRESS FOR GET SHARE FILE ROUTINE
     2554      000003		 .SV40==:3   ;ADDRESS TO GET LOCATION 40
     2555      000004		 .SVRPC==:4   ;ADDRESS TO GET RETURN PC
     2556      000005		 .SVMAK==:5   ;ENTRY FOR MAKE SHARE FILE ROUTINE
     2557      000006		 .SVCST==:6   ;2 WORD BLOCK FOR CONTROL-C/START PROCESSING
     2558
     2559
     2560		       ;SDVEC
     2561
     2562      000000		 .SDEAD==:0   ;ENTRY ADDRESS
     2563      000001		 .SDINE==:1   ;INITIAL ENTRY
     2564      000002		 .SDVER==:2   ;DMS VERSION
     2565      000003		 .SDDMS==:3   ;ADDRESS TO STORE DMS JSYS
     2566      000004		 .SDRPC==:4   ;ADDRESS TO STORE RETURN PC
     2567
     2568
     2569
     2570		       ;SETJB FUNCTION CODES
     2571
     2572      000000		 .SJDEN==:0   ;SET DEFAULT MAGTAPE DENSITY
     2573      000000		  .SJDDN==:0   ;SYSTEM DEFAULT DENSITY
     2574      000001		  .SJDN2==:1   ;200 BPI
     2575      000002		  .SJDN5==:2   ;556 BPI
     2576      000003		  .SJDN8==:3   ;800 BPI
     2577      000004		  .SJD16==:4   ;1600 BPI
     2578      000005		  .SJD62==:5   ;6250 BPI
     2579      000001		 .SJPAR==:1   ;SET DEFAULT MAGTAPE PARITY

     2581      000001		  .SJPRE==:1   ;EVEN PARITY
     2582      000002		 .SJDM==:2   ;SET DEFAULT MAGTAPE DATA MODE
     2583      000000		  .SJDDM==:0   ;SYSTEM DEFAULT DATA MODE
     2584      000001		  .SJDMC==:1   ;CORE DUMP MODE
     2585      000002		  .SJDM6==:2   ;SIX BIT BYTE MODE (FOR 7-TRACK DRIVES)
     2586      000003		  .SJDMA==:3   ;ANSI ASCII MODE (7 BITS IN 8 BIT BYTE)
     2587      000004		  .SJDM8==:4   ;INDUSTRY COMPATIBLE MODE
     2588      000005		  .SJDMH==:5   ;HI-DENSITY MODE (9 EIGHT BIT
     2589			    ; BYTES IN 2 WORDS)
     2590      000003		 .SJRS==:3   ;SET DEFAULT MAGTAPE RECORD SIZE
     2591      000004		 .SJDFS==:4   ;SET DEFERRED SPOOLING
     2592      000000		  .SJSPI==:0   ;IMMEDIATE MODE SPOOLING
     2593      000001		  .SJSPD==:1   ;DEFERRED MODE SPOOLING
     2594      000005		 .SJSRM==:5   ;SET JOB SESSION REMARK
     2595      000006		 .SJT20==:6   ;DECLARE WHETHER TOPS20 COMMAND LEVEL OR NOT
     2596      000007		 .SJDFR==:7   ; Set default job retrieval mode
     2597      000000		  .SJRFA==:0   ; OPENF should always fail
     2598      000001		  .SJRWA==:1   ; OPENF should always request  wait									     _
     2599      000010		 .SJBAT==:10   ;SET BATCH FLAGS AND STREAM
     2600			    ;SEE .JIBCH FOR FIELD DEFINITIONS
     2601      000011		 .SJLLO==:11   ;SET JOB LOCATION
     2602
     2603
     2604		       ;SFORK
     2605
     2606    400000  000000	 SF%CON==:1B0	;CONTINUE PROCESS, IGNORE PC IN AC2
     2607      777777		 SF%PRH==:777777B35  ;PROCESS HANDLE
     2608
     2609
     2610		       ;SFUST
     2611
     2612      000000		 .SFAUT==:0   ;SET AUTHOR STRING
     2613      000001		 .SFLWR==:1   ;SET LAST WRITER STRING
     2614
     2615
     2616
     2617		       ;SMON FUNCTION CODES AND BIT DEFINITIONS (SYSTEM FLAGS)
     2618
     2619      000000		 .SFFAC==:0   ;ALLOW FACT ENTRIES
     2620      000001		 .SFCDE==:1   ;CHECKDISK FOUND ERRORS
     2621      000002		 .SFCDR==:2   ;CHECKDISK RUNNING
     2622      000003		 .SFMST==:3   ;MANUAL START IN PROGRESS
     2623      000004		 .SFRMT==:4   ;REMOTE LOGINS ALLOWED
     2624      000005		 .SFPTY==:5   ;PTY LOGINS ALLOWED
     2625      000006		 .SFCTY==:6   ;CTY LOGIN ALLOWED
     2626      000007		 .SFOPR==:7   ;OPERATOR IN ATTENDANCE
     2627      000010		 .SFLCL==:10   ;LOCAL LOGINS ALLOWED
     2628      000011		 .SFBTE==:11   ;BIT TABLE ERRORS FOUND ON STARTUP
     2629      000012		 .SFCRD==:12   ;USER CAN CHANGE DIRECTORY CHARACTERISTICS
     2630      000013		 .SFNVT==:13	   ;TOPS20AN ;NVT LOGIN ALLOWED
     2631      000014		 .SFWCT==:14   ;WHEEL LOGIN ON CTY ALLOWED
     2632      000015		 .SFWLC==:15   ;WHEEL LOGIN ON LOCAL TERMINALS ALLOWED
     2633      000016		 .SFWRM==:16   ;WHEEL LOGIN ON REMOTE TERMINALS ALLOWED

     2635      000020		 .SFWNV==:20	   ;TOPS20AN ;WHEEL LOGIN ON NVT'S ALLOWED
     2636      000021		 .SFUSG==:21   ;USAGE FILE IN USE
     2637      000022		 .SFFLO==:22   ;FULL LATENCY OPTIMIZATION
     2638			    ;CAUTION: SETTING THIS REQUIRES THAT THE
     2639			    ;  SYSTEM BE AT REVISION LEVEL 10, AND
     2640			    ;  THAT RH20 BOARD M8555 BE AT REVISION LEVEL D.
     2641			    ;  OTHERWISE, THE FILE-SYSTEM MAY BE DAMAGED.
     2642
     2643      000023		 .SFMTA==:23   ;MAGTAPE ALLOCATION ENABLED
     2644		       ;BELOW ARE FUNCTION CODES THAT DO NOT MAP DIRECTLY INTO BITS
     2645
     2646
     2647      000044		 .SFNTN==:44	   ;TOPS20AN ;NETWORK ON/OFF CONTROL
     2648      000045		 .SFNDU==:45	   ;TOPS20AN ;NET DOWN/UP REQUEST
     2649      000046		 .SFNHI==:46	   ;TOPS20AN ;NET HOST TABLE INITIALIZE
     2650      000047		 .SFTMZ==:47   ;SET TIME ZONE THIS SYSTEM IS IN
     2651      000050		 .SFLHN==:50	   ;TOPS20AN ;SET LOCAL HOST NUMBER OF THIS NET SITE
     2652      000051		 .SFAVR==:51   ;ACCOUNT VALIDATION ON/OFF
     2653      000052		 .SFSTS==:52   ;ENABLE/DISABLE STATUS REPORTING
     2654      000053		 .SFSOK==:53   ;GETOK/GIVOK DEFAULT SETTING
     2655      000054		 .SFMCY==:54   ;SET MAX ORDINARY OFFLINE EXP PERIOD
     2656      000055		 .SFRDU==:55   ;READ DATE UPDATE FUNCTION
     2657      000056		 .SFACY==:56   ;SET MAX ARCHIVE EXP PERIOD
     2658      000057		 .SFRTW==:57   ;SET [NO] RETRIEVAL WAITS NON-0 = NO WAIT
     2659      000060		 .SFTDF==:60   ;TAPE MOUNT CONTROLS
     2660    400000  000000	   MT%UUT==1B0	 ;UNLOAD UNREADABLE TAPES
     2661      000061		 .SFWSP==:61   ;WORKING SET PRELOADING
     2662
     2663    400000  000000	 SF%FAC==:1B<.SFFAC  ;FACT ENTRIES ALLOWED
     2664    200000  000000	 SF%CDE==:1B<.SFCDE  ;CHECKDISK FOUND ERRORS
     2665    100000  000000	 SF%CDR==:1B<.SFCDR  ;CHECKDISK RUNNING
     2666    040000  000000	 SF%MST==:1B<.SFMST  ;MANUAL START IN PROGRESS
     2667    020000  000000	 SF%RMT==:1B<.SFRMT  ;REMOTE LOGINS ALLOWED
     2668    010000  000000	 SF%PTY==:1B<.SFPTY  ;PTY LOGINS ALLOWED
     2669    004000  000000	 SF%CTY==:1B<.SFCTY  ;CTY LOGIN ALLOWED
     2670    002000  000000	 SF%OPR==:1B<.SFOPR  ;OPERATOR IN ATTENDANCE
     2671    001000  000000	 SF%LCL==:1B<.SFLCL  ;LOCAL LOGINS ALLOWED
     2672    000400  000000	 SF%BTE==:1B<.SFBTE  ;BIT TABLE ERRORS FOUND ON STARTUP
     2673    000200  000000	 SF%CRD==:1B<.SFCRD  ;USER CAN CHANGE DIRECTORY CHARACTERISTICS
     2674    000100  000000	 SF%NVT==:1B<.SFNVT   ;TOPS20AN ;NVT LOGINS ALLOWED
     2675    000001  000000	 SF%USG==:1B<.SFUSG  ;USAGE FILE IN USE
     2676      400000		 SF%FLO==:1B<.SFFLO  ;FULL LATENCY OPTIMIZATION IN USE
     2677			    ;CAUTION: SETTING THIS REQUIRES THAT THE
     2678			    ;  SYSTEM BE AT REVISION LEVEL 10, AND
     2679			    ;  THAT RH20 BOARD M8555 BE AT REVISION LEVEL D.
     2680			    ;  OTHERWISE, THE FILE-SYSTEM MAY BE DAMAGED.
     2681      200000		 SF%MTA==:1B<.SFMTA  ;MAGTAPE ALLOCATION ENABLED
     2682
     2683
     2684    400000  000000	 SF%EOK==:1B0	;ENABLE ACCESS CHECKING
     2685    200000  000000	 SF%DOK==:1B1	;ALLOW ACCESS IF CHECKING DISABLED
     2686
     2687

     2689
     2690    400000  000000	 SI%TMG==:1B0	;TRUNCATE MESSAGE
     2691    200000  000000	 SI%EOM==:1B1	;END-OF-MESSAGE FOUND
     2692
     2693		       ;SKED JSYS
     2694
     2695      000000		  .SACNT==:0  ;ARGUMENT BLOCK OFFSET FOR COUNT
     2696
     2697			 ;FUNCTION CODES
     2698
     2699      000001		 .SKRBC==:1   ;READ BIAS CONTROL KNOB
     2700      000001		  .SAKNB==:1  ;OFFSET FOR KNOB VALUE
     2701      000002		 .SKSBC==:2   ;SET BIAS CONTROL KNOB
     2702      000003		 .SKRCS==:3   ;READ SHARE OF A CLASS
     2703      000001		  .SACLS==:1  ;CLASS
     2704      000002		  .SASHR==:2  ;SHARE
     2705      000003		  .SAUSE==:3  ;USE
     2706      000004		  .SA1ML==:4  ;1 MINUTE LOAD AVERAGE
     2707      000005		  .SA5ML==:5  ;5 MINUTE LOAD AVERAGE
     2708      000006		  .SA15L==:6  ;15 MINUTE LOAD
     2709      000004		 .SKSCS==:4   ;SET SHARE OF A CLASS
     2710      000005		 .SKICS==:5   ;START OR STOP CLASS SCHEDULING
     2711      000001		  .SACTL==:1  ;WORD FOR CONTROL BITS
     2712      000006		 .SKSCJ==:6   ;SET CLASS OF A JOB
     2713      000001		  .SAJOB==:1  ;JOB
     2714      000002		  .SAJCL==:2  ;CLASS OF JOB
     2715      000007		 .SKRJP==:7   ;READ CLASS PARAMETERS FOR A JOB
     2716      000003		  .SAJSH==:3  ;JOB'S SHARE ALLOTMENT
     2717      000004		  .SAJUS==:4  ;JOB'S CURRENT USE
     2718      000010		 .SKBCR==:10   ;READ CLASS SETTING FOR BATCH JOBS
     2719      000001		  .SABCL==:1  ;BATCH CLASS
     2720      000011		 .SKBCS==:11   ;SET CLASS FOR BATCH JOBS
     2721      000012		 .SKBBG==:12   ;RUN BATCH JOBS ON DREGS QUEUE
     2722      000001		  .SADRG==:1  ;WORD TO SPECIFY DREGS OR NOT
     2723      000013		 .SKDDC==:13   ;SET SYSTEM CLASS DEFAULT
     2724      000001		  .SADCL==:1  ;DEFAULT CLASS WORD
     2725      000014		 .SKRCV==:14   ;READ STATUS
     2726    400000  000000	  SK%ACT==:1B0	;CLASS BY ACCOUNTS
     2727    200000  000000	  SK%WDF==:1B1	;WITHHOLD WINDFALL
     2728    100000  000000	  SK%STP==:1B2	;CLASS SCHEDULER OFF
     2729    040000  000000	  SK%DRG==:1B3	;BATCH JOBS ARE BEING RUN ON DREGS QUEUE
     2730
     2731		       ;SNOOP JSYS DEFINITIONS
     2732
     2733		       ;SNOOP FUNCTION CODES
     2734
     2735      000000		 .SNPLC==:0   ;LOCK CODE INTO MONITOR VIRT MEMORY
     2736      000001		 .SNPLS==:1   ;LOCK DOWN THE SWAPPABLE MONITOR
     2737      000002		 .SNPDB==:2   ;DEFINE A BREAK POINT
     2738      000003		 .SNPIB==:3   ;INSERT THE BREAK POINTS
     2739      000004		 .SNPRB==:4   ;REMOVE THE BREAK POINTS
     2740      000005		 .SNPUL==:5   ;UNLOCK AND RELEASE ALL SNOOP RESOURCES
     2741      000006		 .SNPSY==:6   ;LOOK UP A MONITOR SYMBOL

     2743
     2744		       ;SOUTM JSYS DEFINITIONS
     2745
     2746    400000  000000	 SO%WMG==1B0   ;WRITE END-OF-MESSAGE
     2747
     2748		       ;SPOOL JSYS FUNCTION CODES
     2749
     2750      000000		 .SPLDI==:0   ;DEFINE AN INPUT SPOOLING DEVICE
     2751      000001		 .SPLSD==:1   ;SET DIRECTORY OF SPOOLED DEVICE
     2752      000002		 .SPLRD==:2   ;READ DIRECTORY OF SPOOLED DEVICE
     2753
     2754		       ;FLAGS IN SPOOL MESSAGE ON LOGOUT AND SPOOLED FILE CLOSE
     2755
     2756    400000  000000	 SP%BAT==:1B0	;JOB IS A BATCH JOB
     2757    200000  000000	 SP%DFS==:1B1	;SPOOLING IS DEFERRED
     2758    100000  000000	 SP%ELO==:1B2	;JOB EXECUTED LGOUT JSYS ITSELF
     2759    040000  000000	 SP%FLO==:1B3	;JOB FORCED TO LOG OUT BY TRAP IN TOP FK
     2760    020000  000000	 SP%OLO==:1B4	;OTHER JOB AIMED LGOUT AT THIS ONE
     2761
     2762		       ;SPOOL ARGUMENT BLOCK
     2763
     2764      000000		 .SPLDV==:0   ;DEVICE DESIGNATOR
     2765      000001		 .SPLNA==:1   ;NAME STRING
     2766      000001		 .SPLDR==:1   ;DIRECTORY NUMBER
     2767      000002		 .SPLGN==:2   ;GENERATION NUMBER
     2768
     2769
     2770		       ;SSAVE
     2771
     2772    777777  000000	 SS%NNP==777777B17  ;NEGATIVE NUMBER OF PAGES
     2773      400000		 SS%CPY==:1B18	 ;ALLOW COPY-ON-WRITE
     2774      200000		 SS%UCA==:1B19	 ;USE CURRENT ACCESS
     2775      100000		 SS%RD==:1B20	;ALLOW READ ACCESS
     2776      040000		 SS%WR==:1B21	;ALLOW WRITE ACCESS
     2777      020000		 SS%EXE==:1B22	 ;ALLOW EXECUTE ACCESS
     2778      000777		 SS%FPN==:777B35   ;FIRST PAGE NUMBER
     2779
     2780
     2781		       ;STCMP
     2782
     2783    400000  000000	 SC%LSS==:1B0	;T1 LESS THAN T2
     2784    200000  000000	 SC%SUB==:1B1	;T1 SUBSTRING OF T2
     2785    100000  000000	 SC%GTR==:1B2	;T1 GREATER THAN T2
     2786
     2787
     2788
     2789		       ;STDIR
     2790
     2791    400000  000000	 ST%DIR==:1B0	;FILES ONLY DIRECTORY
     2792    200000  000000	 ST%ANA==:1B1	;ALPHANUMERIC ACCOUNTS
     2793    100000  000000	 ST%RLM==:1B2	;REPEAT LOGIN MESSAGE
     2794
     2795

     2797
     2798    400000  000000	 ST%DIM==:1B0	;SET DEFERRED INTERRUPT MASK
     2799      777777		 ST%PRH==:777777B35  ;PROCESS HANDLE
     2800
     2801		       ;SWTRP DEFINITIONS
     2802
     2803      000000		 .SWART==:0   ;SET ARITHMETIC TRAP
     2804      000001		 .SWRAT==:1   ;READ ARITHMETIC TRAP
     2805      000002		 .SWLUT==:2   ;SET LUUO ADDRESS
     2806      000003		 .SWRLT==:3   ;READ LUUO ADDRESS
     2807      000000		  .ARPFL==:0  ;OFFSET IN TRAP BLOCK FOR PC FLAGS
     2808      000001		  .AROPC==:1  ;OFFSET FOR OLD PC VALUE
     2809      000002		  .AREFA==:2  ;OFFSET FOR E
     2810      000003		  .ARNPC==:3  ;OFFSET FOR NEW PC WORD
     2811
     2812		       ;TBLUK
     2813
     2814    400000  000000	 TL%NOM==:1B0	;NO MATCH
     2815    200000  000000	 TL%AMB==:1B1	;AMBIGUOUS
     2816    100000  000000	 TL%ABR==:1B2	;LEGAL ABBREVIATION
     2817    040000  000000	 TL%EXM==:1B3	;EXACT MATCH
     2818
     2819
     2820		       ;TFORK
     2821
     2822		       ;FUNCTION CODES IN LH AC1
     2823
     2824      000000		 .TFSET==:0   ;SET TRAPS AS SPEC'D BY BIT TABLE
     2825      000001		 .TFRAL==:1   ;REMOVE ALL TRAPS SET BY THIS FORK
     2826      000002		 .TFRTP==:2   ;REMOVE TRAPS SET BY THIS FORK
     2827      000003		 .TFSPS==:3   ;SET JSYS TRAP PSI CHAN IN LH(2)
     2828      000004		 .TFRPS==:4   ;READ JSYS TRAP PSI CHAN INTO LH(2)
     2829      000005		 .TFTST==:5   ;TEST IF SELF MONITORED
     2830      000006		 .TFRES==:6   ;REMOVE TRAPS FROM ALL INFERIORS, CLR PSI
     2831      000007		 .TFUUO==:7   ;SET UUO TRAPS FOR FORK
     2832      000010		 .TFSJU==:8   ;SET BOTH UUO AND JSYS TRAPS
     2833      000011		 .TFRUU==:9   ;REMOVE UUO TRAPS
     2834
     2835		       ;TIMER DEFINITIONS
     2836
     2837      000000		 .TIMRT==:0   ;SET TIME LIMIT
     2838      000001		 .TIMEL==:1   ;SET ELAPSED TIME CLOCK
     2839      000002		 .TIMDT==:2   ;SET DATE  TIME CLOCK							_
     2840      000003		 .TIMDD==:3   ;DELETE AN EXPLICT DATE  TIME CLOCK								      _
     2841      000004		 .TIMBF==:4   ;DELETE ALL ENTIRES BEFORE DT									  _
     2842      000005		 .TIMAL==:5   ;DELETE ALL (INCLUDES TIME LIMIT)
     2843
     2844
     2845
     2846		       ;TLINK
     2847
     2848    400000  000000	 TL%CRO==:1B0	;CLEAR REMOTE TO OBJECT LINK
     2849    200000  000000	 TL%COR==:1B1	;CLEAR OBJECT TO REMOTE LINK

     2851    040000  000000	 TL%ERO==:1B3	;ESTABLISH REMOTE TO OBJECT LINK
     2852    020000  000000	 TL%SAB==:1B4	;SET ACCEPT BIT FOR OBJECT
     2853    010000  000000	 TL%ABS==:1B5	;ACCEPT BIT STATE
     2854    004000  000000	 TL%STA==:1B6	;SET OR CLEAR ADVICE
     2855    002000  000000	 TL%AAD==1B7   ;ACCEPT ADVICE
     2856      777777		 TL%OBJ==:777777B35  ;OBJECT DESIGNATOR
     2857
     2858
     2859
     2860		       ;UFPGS
     2861
     2862    400000  000000	 UF%NOW==:1B0	;NO WAIT ON UPDATE
     2863
     2864		       ;UTEST FUNCTION CODES
     2865
     2866      000000		 .UTSET==:0   ;START TESTING
     2867      000001		 .UTCLR==:1   ;STOP TESTING AND RETURN RESULTS
     2868
     2869		       ;UTEST ARGUMENT BLOCK
     2870
     2871      000000		 .UTADR==:0   ;STARTING ADDRESS OF CODE
     2872      000001		 .UTLEN==:1   ;LENGTH OF CODE
     2873      000002		 .UTMAP==:2   ;START OF BIT MAP
     2874
     2875		       ;USAGE
     2876
     2877      000000		 .USENT==:0   ;WRITE ENTRY
     2878      000001		 .USCLS==:1   ;CLOSE OUT CURRENT FILE
     2879      000002		 .USCKP==:2   ;PERFORM CHECKPOINT
     2880      000003		 .USLGI==:3   ;LOGIN
     2881      000004		 .USLGO==:4   ;LOGOUT
     2882      000005		 .USSEN==:5   ;SESSION END
     2883      000006		 .USCKI==:6   ;SET CHECKPOINT INTERVAL
     2884      000007		 .USENA==:7   ;ENABLE ACCOUNT VALIDATION
     2885      000010		 .USCAS==:10   ;CHANGE ACCOUNTING SHIFT NOW
     2886      000011		 .USSAS==:11   ;SET AUTOMATIC ACCOUNTING SHIFT CHANGE TIMES
     2887      000012		 .USRAS==:12   ;READ AUTOMATIC ACCOUNTING SHIFT CHANGE TIMES
     2888			    ;TABLE ENTRY FORMAT FOR .USSAS/.USRAS:
     2889    774000  000000	  US%DOW==:177B6   ;DAY-OF-WEEK BITS
     2890      777777		  US%SSM==:777777  ;TIME IN SECONDS SINCE MIDNIGHT
     2891
     2892		       ;UTFRK
     2893
     2894    400000  000000	 UT%TRP==:1B0	;ITRAP (OR DO ERJMP/ERCAL) TRAPPED JSYS
     2895
     2896
     2897		       ;WILD FUNCTIONS
     2898
     2899      000000		 .WLSTR==:0   ;COMPARE TWO STRINGS
     2900      000001		 .WLJFN==:1   ;COMPARE TWO JFNS
     2901
     2902		       ;WILD FLAGS AND BITS
     2903

     2905    400000  000000	 WL%NOM==:1B0	;STRINGS DID NOT MATCH
     2906    200000  000000	 WL%ABR==:1B1	;NON-WILD STRING IS ABBREVIATION OF WILD STRING
     2907    200000  000000	 WL%DEV==:1B1	;DEVICE FIELD DID NOT MATCH
     2908    100000  000000	 WL%DIR==:1B2	;DIRECTORY FIELD DID NOT MATCH
     2909    040000  000000	 WL%NAM==:1B3	;NAME FIELD DID NOT MATCH
     2910    020000  000000	 WL%EXT==:1B4	;FILE TYPE DID NOT MATCH
     2911    010000  000000	 WL%GEN==:1B5	;GENERATION NUMBER DID NOT MATCH
     2912
     2913
     2914
     2915		       ;SCHEDULER CONTROL FLAGS (JSYS NOT YET DEFINED)
     2916
     2917      400000		 SK%CYT==:1B18	 ;CYCLE TIME
     2918      200000		 SK%IOC==:1B19	 ;IO QUANTUM CHARGE
     2919      140000		 SK%HTF==:3B21	 ;BALSET HOLD TIME
     2920      020000		 SK%HQR==:1B22	 ;HIGH QUEUE RESERVE
     2921      010000		 SK%LQR==:1B23	 ;LOW QUEUE RESERVE
     2922      004000		 SK%BQE==:1B24	 ;BALSET QUEUE ON ENTRY
     2923      002000		 SK%BQR==:1B25	 ;BALSET QUEUE ON REQUEUE
     2924      001000		 SK%RQ1==:1B26	 ;REQUEUE TO QUEUE 1
     2925      000400		 SK%TTP==:1B27	 ;TTY PREFERENCE
     2926      000200		 SK%WCF==:1B28	 ;WAIT CREDIT PROPORTIONAL TO LOAD AV
     2927
     2928		       ;***********************************************
     2929		       ;GENERAL FIELD AND VALUE DEFINITIONS
     2930		       ;USED BY MANY JSYSES
     2931		       ;***********************************************
     2932
     2933
     2934		       ;GENERAL FORK HANDLES
     2935
     2936      400000		 .FHSLF==:400000   ;SELF
     2937      777777		 .FHSUP==:<Z -1   ;SUPERIOR
     2938      777776		 .FHTOP==:<Z -2   ;TOP IN JOB
     2939      777775		 .FHSAI==:<Z -3   ;SELF AND INFERIORS
     2940      777774		 .FHINF==:<Z -4   ;INFERIORS
     2941      777773		 .FHJOB==:<Z -5   ;ALL IN JOB
     2942
     2943
     2944		       ;FIELDS OF JFN MODE WORD
     2945
     2946    400000  000000	 TT%OSP==:1B0	;OUTPUT SUPPRESS
     2947    200000  000000	 TT%MFF==:1B1	;MECHANICAL FORMFEED PRESENT
     2948    100000  000000	 TT%TAB==:1B2	;MECHANICAL TAB PRESENT
     2949    040000  000000	 TT%LCA==:1B3	;LOWER CASE CAPABILITIES PRESENT
     2950    037600  000000	 TT%LEN==:177B10   ;PAGE LENGTH
     2951    000177  000000	 TT%WID==:177B17   ;PAGE WIDTH
     2952      170000		 TT%WAK==:17B23   ;WAKEUP FIELD
     2953      400000		 TT%WK0==:1B18	 ;WAKEUP CLASS 0 (UNUSED)
     2954      200000		 TT%IGN==:1B19	 ;IGNORE TT%WAK ON SFMOD
     2955      100000		 TT%WKF==:1B20	 ;WAKEUP ON FORMATING CONTROL CHARS
     2956      040000		 TT%WKN==:1B21	 ;WAKEUP ON NON-FORMATTING CONTROLS
     2957      020000		 TT%WKP==:1B22	 ;WAKEUP ON PUNCTUATION

     2959      004000		 TT%ECO==:1B24	 ;ECHOS ON
     2960      002000		 TT%ECM==:1B25	 ;ECHO MODE
     2961      001000		 TT%ALK==:1B26	 ;ALLOW LINKS
     2962      000400		 TT%AAD==:1B27	 ;ALLOW ADVICE (NOT IMPLEMENTED)
     2963      000300		 TT%DAM==:3B29	 ;DATA MODE
     2964      000000		 .TTBIN==:0   ;BINARY
     2965      000001		 .TTASC==:1   ;ASCII
     2966      000002		 .TTATO==:2   ;ASCII AND TRANSLATE OUTPUT ONLY
     2967      000003		 .TTATE==:3   ;ASCII AND TRANSLATE ECHOS ONLY
     2968      000040		 TT%UOC==:1B30	 ;UPPER CASE OUTPUT CONTROL
     2969      000020		 TT%LIC==:1B31	 ;LOWER CASE INPUT CONTROL
     2970      000014		 TT%DUM==:3B33	 ;DUPLEX MODE
     2971      000000		 .TTFDX==:0   ;FULL DUPLEX
     2972      000001		 .TT0DX==:1   ;NOT USED, RESERVED
     2973      000002		 .TTHDX==:2   ;HALF DUPLEX (CHARACTER)
     2974      000003		 .TTLDX==:3   ;LINE HALF DUPLEX
     2975      000002		 TT%PGM==:1B34	 ;PAGE MODE
     2976      000001		 TT%CAR==:1B35	 ;CARRIER STATE
     2977
     2978
     2979
     2980		       ;DIRECTORY PROTECTION DEFINITIONS (3 6-BIT FIELDS: OWNER, GROUP, WORLD)
     2981
     2982      000040		 DP%RD==:40   ;READING DIRECTORY IS ALLOWED
     2983      000010		 DP%CN==:10   ;CONNECT TO DIR, OR CHANGE PROT/ACCOUNT
     2984      000004		 DP%CF==:4   ;CREATING FILES IN DIR IS ALLOWED
     2985
     2986		       ;FILE PROTECTION DEFINITIONS (3 6-BIT FIELDS: OWNER, GROUP, WORLD)
     2987
     2988      000002		 FP%DIR==:2   ;DIRECTORY LISTING
     2989      000004		 FP%APP==:4   ;APPEND
     2990      000010		 FP%EX==:10   ;EXECUTE
     2991      000020		 FP%WR==:20   ;WRITE
     2992      000040		 FP%RD==:40   ;READ
     2993
     2994
     2995		       ;INPUT AND OUTPUT IDENTIFIERS
     2996
     2997      000100		 .PRIIN==:100	;PRIMARY INPUT
     2998      000101		 .PRIOU==:101	;PRIMARY OUTPUT
     2999      377777		 .NULIO==:377777   ;NULL DESIGNATOR
     3000      777777		 .CTTRM==:777777   ;JOB'S CONTROLLING TERMINAL
     3001      600000		 .DVDES==:600000   ;UNIVERSAL DEVICE CODE
     3002      400000		 .TTDES==:400000   ;UNIVERSAL TERMINAL CODE
     3003
     3004
     3005		       ;MAGTAPE DEVICE STATUS BITS
     3006
     3007      400000		 MT%ILW==:1B18	 ;ILLEGAL WRITE
     3008      200000		 MT%DVE==:1B19	 ;DEVICE ERROR
     3009      100000		 MT%DAE==:1B20	 ;DATA ERROR
     3010      040000		 MT%SER==:1B21	 ;SUPPRESS ERROR RECOVERY PROCEDURES
     3011      020000		 MT%EOF==:1B22	 ;EOF (FILE MARK)

     3013      004000		 MT%BOT==:1B24	 ;BEGINNING OF TAPE
     3014      002000		 MT%EOT==:1B25	 ;END OF TAPE
     3015      001000		 MT%EVP==:1B26	 ;EVEN PARITY
     3016      000600		 MT%DEN==:3B28	 ;DENSITY (0 IS 'NORMAL')
     3017      000001		 .MTLOD==:1   ;LOW DENSITY (200 BPI)
     3018      000002		 .MTMED==:2   ;MEDIUM DENSITY (556 BPI)
     3019      000003		 .MTHID==:3   ;HIGH DENSITY (800 BPI)
     3020      000160		 MT%CCT==:7B31	 ;CHARACTER COUNTER
     3021
     3022
     3023		       ;DEVICE DATA MODES
     3024
     3025      000001		 .DMASC==:1   ;ASCII
     3026      000010		 .DMIMG==:10   ;IMAGE
     3027      000013		 .DMIMB==:13   ;IMAGE BINARY
     3028      000014		 .DMBIN==:14   ;BINARY
     3029
     3030
     3031
     3032		       ;DEFINED PSI CHANNELS
     3033
     3034		       RADIX 5+5
     3035
     3036      000006		 .ICAOV==:6   ;ARITHMETIC OVERFLOW
     3037      000007		 .ICFOV==:7   ;FLOATING OVERFLOW
     3038      000011		 .ICPOV==:9   ;PDL OVERFLOW
     3039      000012		 .ICEOF==:10   ;END OF FILE
     3040      000013		 .ICDAE==:11   ;DATA ERROR
     3041      000014		 .ICQTA==:12   ;QUOTA/DISK EXCEEDED
     3042      000016		 .ICTOD==:14   ;TIME OF DAY (NOT IMPLEMENTED)
     3043      000017		 .ICILI==:15   ;ILLEG INSTRUCTION
     3044      000020		 .ICIRD==:16   ;ILLEGAL READ
     3045      000021		 .ICIWR==:17   ;ILLEGAL WRITE
     3046      000022		 .ICIEX==:18   ;ILLEGAL EXECUTE (NOT IMPLEMENTED)
     3047      000023		 .ICIFT==:19   ;INFERIOR FORK TERMINATION
     3048      000024		 .ICMSE==:20   ;MACHINE SIZE EXCEEDED
     3049      000025		 .ICTRU==:21   ;TRAP TO USER (NOT IMPLEMENTED)
     3050      000026		 .ICNXP==:22   ;NONEXISTENT PAGE REFERENCED
     3051
     3052
     3053
     3054		       ;TERMINAL TYPE NUMBERS
     3055
     3056      000000		 .TT33==:0   ;MODEL 33
     3057      000001		 .TT35==:1   ;MODEL 35
     3058      000002		 .TT37==:2   ;MODEL 37
     3059      000003		 .TTEXE==:3   ;EXECUPORT
     3060      000010		 .TTDEF==:D8   ;DEFAULT
     3061      000011		 .TTIDL==:D9   ;IDEAL
     3062      000012		 .TTV05==:D10	;VT05
     3063      000013		 .TTV50==:D11	;VT50
     3064      000014		 .TTL30==:D12	;LA30
     3065      000015		 .TTG40==:D13	;GT40

     3067      000017		 .TTV52==:D15	;VT52
     3068      000020		 .TT100==:D16	;VT100
     3069      000021		 .TTL38==:D17	;LA38
     3070      000022		 .TT120==:D18	;LA120
     3071
     3072		       ;DEFINED TERMINAL CODES
     3073
     3074      000000		 .TICBK==:0   ;BREAK
     3075      000001		 .TICCA==:1   ;A
     3076      000002		 .TICCB==:2   ;B
     3077      000003		 .TICCC==:3   ;C
     3078      000004		 .TICCD==:4   ;D
     3079      000005		 .TICCE==:5   ;E
     3080      000006		 .TICCF==:6   ;F
     3081      000007		 .TICCG==:7   ;G
     3082      000010		 .TICCH==:8   ;H
     3083      000011		 .TICCI==:9   ;I
     3084      000012		 .TICCJ==:10   ;J
     3085      000013		 .TICCK==:11   ;K
     3086      000014		 .TICCL==:12   ;L
     3087      000015		 .TICCM==:13   ;M
     3088      000016		 .TICCN==:14   ;N
     3089      000017		 .TICCO==:15   ;O
     3090      000020		 .TICCP==:16   ;P
     3091      000021		 .TICCQ==:17   ;Q
     3092      000022		 .TICCR==:18   ;R
     3093      000023		 .TICCS==:19   ;S
     3094      000024		 .TICCT==:20   ;T
     3095      000025		 .TICCU==:21   ;U
     3096      000026		 .TICCV==:22   ;V
     3097      000027		 .TICCW==:23   ;W
     3098      000030		 .TICCX==:24   ;X
     3099      000031		 .TICCY==:25   ;Y
     3100      000032		 .TICCZ==:26   ;Z
     3101      000033		 .TICES==:27   ;ESC
     3102      000034		 .TICRB==:28   ;RUBOUT
     3103      000035		 .TICSP==:29   ;SPACE
     3104      000036		 .TICRF==:30   ;CARRIER OFF
     3105      000037		 .TICTI==:31   ;TYPEIN
     3106      000040		 .TICTO==:32   ;TYPEOUT
     3107
     3108
     3109
     3110		       RADIX 8
     3111
     3112		       ;CAPABILITIES
     3113
     3114    400000  000000	 SC%CTC==:1B0	;CONTROL-C
     3115    200000  000000	 SC%GTB==:1B1	;GETAB
     3116    100000  000000	 SC%MMN==:1B2	;MAP MONITOR
     3117    040000  000000	 SC%LOG==:1B3	;LOGGING FUNCTIONS
     3118    020000  000000	 SC%MPP==:1B4	;MAP PRIVILEGED PAGES
     3119    010000  000000	 SC%SDV==:1B5	;SPECIAL DEVICES

     3121
     3122    000400  000000	 SC%SUP==:1B9	;SUPERIOR ACCESS
     3123
     3124    000001  000000	 SC%FRZ==:1B17	 ;FREEZE ON TERMINATING CONDITIONS
     3125
     3126      400000		 SC%WHL==:1B18	 ;WHEEL
     3127      200000		 SC%OPR==:1B19	 ;OPERATOR
     3128      100000		 SC%CNF==:1B20	 ;CONFIDENTIAL INFORMATION ACCESS
     3129      040000		 SC%MNT==:1B21	 ;MAINTENANCE
     3130      020000		 SC%IPC==:1B22	 ;IPCF PRIVILEGES
     3131      010000		 SC%ENQ==:1B23	 ;ENQ/DEQ PRIVILEGES
     3132      004000		 SC%NWZ==:1B24	     ;TOPS20AN ;NET WIZARD PRIVILEGES (ASNSQ, ETC.)
     3133      002000		 SC%NAS==:1B25	     ;TOPS20AN ;NETWORK ABSOLUTE SOCKET PRIVILEGE
     3134
     3135
     3136		       ;OUTMODED NAMES FOR BITS IN DIRECTORY MODE WORD - USE CD%XXX
     3137		       ;EQUIVALENTS
     3138
     3139    400000  000000	 MD%FO==:CD%DIR   ;FILES ONLY DIRECTORY
     3140    200000  000000	 MD%SA==:CD%ANA   ;STRING ACCOUNT ALLOWED
     3141    100000  000000	 MD%RLM==:CD%RLM   ;REPEAT LOGIN MESSAGE
     3142
     3143
     3144
     3145		       ;FDB DEFINITIONS
     3146
     3147
     3148      000000		 .FBHDR==:0   ;HEADER WORD
     3149      000177		  FB%LEN==:177B35  ;LENGTH OF THIS FDB
     3150      000001		 .FBCTL==:1   ;FLAGS
     3151    400000  000000	  FB%TMP==:1B0	;FILE IS TEMPORARY
     3152    200000  000000	  FB%PRM==:1B1	;FILE IS PERMANENT
     3153    100000  000000	  FB%NEX==:1B2	;FILE DOES NOT HAVE AN EXTENSION YET
     3154    040000  000000	  FB%DEL==:1B3	;FILE IS DELETED
     3155    020000  000000	  FB%NXF==:1B4	;FILE IS NONEXISTENT
     3156    010000  000000	  FB%LNG==:1B5	;FILE IS A LONG FILE
     3157    004000  000000	  FB%SHT==:1B6	;FILE HAS COMPRESSED PAGE TABLE
     3158    002000  000000	  FB%DIR==:1B7	;FILE IS A DIRECTORY FILE
     3159    001000  000000	  FB%NOD==:1B8	;FILE IS NOT TO BE DUMPED BY BACKUP SYSTEM
     3160    000400  000000	  FB%BAT==:1B9	;FILE HAS AT LEAST ONE BAD PAGE IN IT
     3161    000200  000000	  FB%SDR==:1B10  ;THIS DIRECTORY HAS SUBDIRECTORIES
     3162    000100  000000	  FB%ARC==:1B11  ; File has archive status
     3163    000040  000000	  FB%INV==:1B12  ; File is invisible
     3164    000020  000000	  FB%OFF==:1B13  ; File is offline
     3165    000017  000000	  FB%FCF==:17B17  ;FILE CLASS FIELD
     3166      000000		    .FBNRM==:0	;NON-RMS
     3167      000001		    .FBRMS==:1	;RMS FILES
     3168      000002		 .FBEXL==:2   ;LINK TO FDB OF NEXT EXTENSION
     3169      000003		 .FBADR==:3   ;DISK ADDRESS OF INDEX BLOCK
     3170      000004		 .FBPRT==:4   ;PROTECTION OF THE FILE
     3171      000005		 .FBCRE==:5   ;TIME AND DATE OF LAST WRITE
     3172      000006		 .FBUSE==:6   ;LAST WRITER ,, AUTHOR (OBS)
     3173      000006		 .FBAUT==:6   ;POINTER TO AUTHOR STRING

     3175    777777  000000	  FB%GEN==:777777B17 ;GENERATION NUMBER
     3176      000007		 .FBDRN==:7   ;GENERATION ,, DIR #
     3177      777777		  FB%DRN==:777777  ;DIR NUMBER
     3178      000010		 .FBACT==:10   ;ACCOUNT
     3179      000011		 .FBBYV==:11   ;RETENTION+BYTE SIZE+MODE ,, # OF PAGES
     3180    770000  000000	  FB%RET==:77B5  ;RETENTION COUNT
     3181    007700  000000	   FB%BSZ==:77B11  ;BYTE SIZE
     3182    000017  000000	  FB%MOD==:17B17  ;LAST OPENF MODE
     3183      777777		  FB%PGC==:777777 ;PAGE COUNT
     3184      000012		 .FBSIZ==:12   ;EOF POINTER
     3185      000013		 .FBCRV==:13   ;TIME AND DATE OF CREATION OF FILE
     3186      000014		 .FBWRT==:14   ;TIME AND DATE OF LAST USER WRITE
     3187      000015		 .FBREF==:15   ;TIME AND DATE OF LAST NON-WRITE ACCESS
     3188      000016		 .FBCNT==:16   ;# OF WRITES ,, # OF REFERENCES
     3189      000017		 .FBBK0==:17   ;BACKUP WORDS (5)
     3190      000020		 .FBBK1==:20
     3191      000021		 .FBBK2==:21
     3192      000022		 .FBBBT==:22   ; Bits,,#pages in offline file
     3193    200000  000000	  AR%RAR==:1B1	; Request archive by user
     3194    100000  000000	  AR%RIV==:1B2	; Request invol migration by system
     3195    040000  000000	  AR%NDL==:1B3	; Do not delete contents of file when archived
     3196    020000  000000	  AR%NAR==:1B4	; Please don't migrate this file
     3197    010000  000000	  AR%EXM==:1B5	; File exempt from migration
     3198    004000  000000	  AR%1ST==:1B6	; 1st pass of archive/collection run complete
     3199    002000  000000	  AR%RFL==:1B7	; Retrieve failed
     3200    001000  000000	  AR%WRN==:1B8	; USER WARNED OF APPROACHING EXPIRATION
     3201    000007  000000	  AR%RSN==:7B17  ; Reason pushed offline
     3202      000001		    .AREXP==:1	; File expired
     3203      000002		    .ARARR==:2	; Archive was requested
     3204      000003		    .ARRIR==:3	; Migration was requested
     3205      777777		  AR%PSZ==:777777 ; RH is pg count when file went offline
     3206      000023		 .FBNET==:23   ; On-line expiration date/interval
     3207      000024		 .FBUSW==:24   ;USER SETTABLE WORD
     3208      000025		 .FBGNL==:25   ;LINK TO NEXT GENERATION FILE
     3209      000026		 .FBNAM==:26   ;POINTER TO NAME BLOCK
     3210      000027		 .FBEXT==:27   ;POINTER TO EXTENSION BLOCK
     3211      000030		 .FBLWR==:30   ;POINTER TO LAST WRITER STRING
     3212      000031		 .FBTDT==:31   ; Archive or collection date  time									    _
     3213      000032		 .FBFET==:32   ; Offline expiration date/interval
     3214      000033		 .FBTP1==:33   ; Tape ID for run 1 tape
     3215      000034		 .FBSS1==:34   ; Saveset #,,Tape file # for run 1 tape
     3216      000035		 .FBTP2==:35   ; Tape ID for run 2 tape
     3217      000036		 .FBSS2==:36   ; Saveset #,,Tape file # for run 2 tape
     3218
     3219      000030		 .FBLN0==:30   ;LENGTH OF VERSION 0 FDB
     3220      000037		 .FBLN1==:37   ;LENGTH OF VERSION 1 FDB
     3221      000037		 .FBLXT==:37   ; Minimum length for archive/virtual dsk sys
     3222      000037		 .FBLEN==:37   ;LENGTH OF THE FDB
     3223
     3224		       ;CARD READER DEFINITIONS
     3225
     3226      000134		 .CRILC==:""   ;ILLEGAL CHARACTER CODE
     3227

     3229		       ;USE THESE DEFINITIONS TO TEST FOR A NUMBER AS FOLLOWS:
     3230		       ; LOAD AC,NMFLG,LOC
     3231		       ; CAIE AC,NUMVAL
     3232
     3233    700000  000000	 NMFLG==:7B2
     3234      000005		 NUMVAL==:5
     3235
     3236
     3237		       ;MAGTAPE LABEL TYPES
     3238
     3239      000001		 .LTUNL==:1   ;UNLABELED
     3240      000002		 .LTANS==:2   ;ANSI STANDARD
     3241      000003		 .LTEBC==:3   ;EBCDIC
     3242      000004		 .LTT20==:4   ;TOPS-20
     3243      000004		 .LTMAX==:4   ;MAXIMUM LABEL TYPE
     3244
     3245		       ; MAGTAPE DRIVE TYPES
     3246
     3247      000001		 .TMDR9==:1   ;9-TRACK
     3248      000002		 .TMDR7==:2   ;7-TRACK
     3249      000002		 .TMDMX==:2   ;MAXIMUM DRIVE-TYPE VALUE
     3250
     3251
     3252
     3253		       ;DEFINITIONS FOR COMMUNICATIONS PROTOCOLS
     3254
     3255		       ;DEFINE THE SUPPORTED PROTOCOL TYPES
     3256
     3257      000000		 .VN20F==:0   ;RSX20F PROTOCOL
     3258      000001		 .VNMCB==:1   ;MCB DECNET PROTOCOL
     3259      000002		 .VNDDC==:2   ;DDCMP PROTOCOL
     3260      000003		 .VNMOP==:3   ;MOP (DDCMP MAINTENANCE) MODE
     3261      000004		 .VNCNL==:4   ;CONTROLLER LOOPBACK
     3262      000005		 .VNCBL==:5   ;CABLE LOOPBACK
     3263
     3264		       ;DEFINE BITS USED WHEN RELOADING AN -11
     3265
     3266    400000  000000	 RM%ROM==:1B0	;IF SET, ACTIVATE ROM
     3267
     3268		       ;***********************************************
     3269		       ;GENERAL FIELD AND VALUE DEFINITIONS
     3270		       ;USED BY TOPS20AN JSYS'S
     3271		       ;***********************************************
     3272
     3273		       ;STATES OF A CONNECTION IN ARPANET NCP
     3274		       ; RETURNED IN B0-B3 OF GDSTS ON A NET CONNECTION
     3275		       ; ALSO AVAILABLE IN A GETAB, BUT THAT'S NOT THE PREFERRED WAY
     3276		       ; TO READ THEM, IF YOU HAVE A JFN FOR THE CONNECTION.
     3277
     3278      000001		 .NSCZD==:01   ;CLOSED
     3279      000002		 .NSPND==:02   ;PENDING
     3280      000003		 .NSLSN==:03   ;LISTENING
     3281      000004		 .NSRCR==:04   ;REQUEST FOR CONNECTION RECEIVED

     3283      000006		 .NSRCS==:06   ;REQUEST FOR CONNECTION SENT
     3284      000007		 .NSOPN==:07   ;OPENED
     3285      000010		 .NSCSW==:10   ;CLOSE WAIT (NCP CLOSE)
     3286      000011		 .NSDTW==:11   ;FINAL DATA WAIT
     3287      000012		 .NSRF1==:12   ;RFNM WAIT SUB ONE (NORMAL NCP CLOSE)
     3288      000013		 .NSCZW==:13   ;CLOSE WAIT (PROGRAM CLOSE)
     3289      000014		 .NSRF2==:14   ;RFNM WAIT SUB TWO (UNEXPECTED NCP CLOSE)
     3290      000016		 .NSFRE==:16   ;FREE
     3291
     3292		       ;HOST STATUS BITS
     3293
     3294    400000  000000	 HS%UP==1B0   ;HOST IS UP
     3295    200000  000000	 HS%VAL==1B1   ;VALID STATUS
     3296    160000  000000	 HS%DAY==7B4   ;DAY WHEN UP IF DOWN
     3297    017400  000000	 HS%HR==37B9   ;HOUR
     3298    000360  000000	 HS%MIN==17B13	 ;5 MIN INTERVAL
     3299    000017  000000	 HS%RSN==17B17	 ;REASON
     3300      400000		 HS%SRV==1B18	;HOST IS SERVER
     3301      200000		 HS%USR==1B19	;HOST IS USER
     3302      100000		 HS%NCK==1B20	;HOST NAME STRING WAS NICKNAME
     3303      077000		 HS%STY==77B26	 ;SYSTEM TYPE MASK
     3304      000400		 HS%NEW==1B27	;HOST DOES NEW PROTOCOL
     3305      000200		 HS%NAM==1B28	;HOST HAS NAME
     3306
     3307      001000		 .HS10X==1B26	;TENEX
     3308      002000		 .HSITS==2B26	;ITS
     3309      003000		 .HSDEC==3B26	;TOPS-10
     3310      004000		 .HSTIP==4B26	;TIP
     3311      005000		 .HSMTP==5B26	;MTIP
     3312      006000		 .HSELF==6B26	;ELF
     3313      007000		 .HSANT==7B26	;ANTS
     3314      010000		 .HSMLT==10B26	 ;MULTICS
     3315      011000		 .HST20==11B26	 ;TOPS-20
     3316      012000		 .HSUNX==12B26	 ;UNIX
     3317
     3318		       ;ERROR CODE DEFINITIONS
     3319
     3320      600000		  .ERBAS==:600000  ;BASE VALUE FOR ALL ERROR CODES
     3321
     3322		       DEFINE .ERCOD <
     3323
     3324		       .ERR (10,LGINX1,<Invalid account identifier)
     3325		       .ERR (11,LGINX2,<Directory is "files-only" and cannot be logged in to)
     3326		       .ERR (12,LGINX3,<Internal format of directory is incorrect)
     3327		       .ERR (13,LGINX4,<Invalid password)
     3328		       .ERR (14,LGINX5,<Job is already logged in)
     3329		       .ERR (20,CRJBX1,<Invalid parameter or function bit combination)
     3330		       .ERR (21,CRJBX2,<Illegal for created job to enter MINI-EXEC)
     3331		       .ERR (22,CRJBX3,<Reserved)
     3332		       .ERR (23,CRJBX4,<Terminal is not available)
     3333		       .ERR (24,CRJBX5,<Unknown name for LOGIN)
     3334		       .ERR (25,CRJBX6,<Insufficient system resources)
     3335		       .ERR (26,CRJBX7,<Reserved)

     3337		       .ERR (36,LOUTX2,<Invalid job number)
     3338		       .ERR (45,CACTX1,<Invalid account identifier)
     3339		       .ERR (46,CACTX2,<Job is not logged in)
     3340		       .ERR (50,EFCTX1,<WHEEL or OPERATOR capability required)
     3341		       .ERR (51,EFCTX2,<Entry cannot be longer than 64 words)
     3342		       .ERR (52,EFCTX3,<Fatal error when accessing FACT file)
     3343		       .ERR (55,GJFX1,<Desired JFN invalid)
     3344		       .ERR (56,GJFX2,<Desired JFN not available)
     3345		       .ERR (57,GJFX3,<No JFN available)
     3346		       .ERR (60,GJFX4,<Invalid character in filename)
     3347		       .ERR (61,GJFX5,<Field cannot be longer than 39 characters)
     3348		       .ERR (62,GJFX6,<Device field not in a valid position)
     3349		       .ERR (63,GJFX7,<Directory field not in a valid position)
     3350		       .ERR (64,GJFX8,<Directory terminating delimiter is not preceded by a valid beginning delimi
     3351		       ter)
     3352		       .ERR (65,GJFX9,<More than one name field is not allowed)
     3353		       .ERR (66,GJFX10,<Generation number is not numeric)
     3354		       .ERR (67,GJFX11,<More than one generation number field is not allowed)
     3355		       .ERR (70,GJFX12,<More than one account field is not allowed)
     3356		       .ERR (71,GJFX13,<More than one protection field is not allowed)
     3357		       .ERR (72,GJFX14,<Invalid protection)
     3358		       .ERR (73,GJFX15,<Invalid confirmation character)
     3359		       .ERR (74,GJFX16,<No such device)
     3360		       .ERR (75,GJFX17,<No such directory name)
     3361		       .ERR (76,GJFX18,<No such filename)
     3362		       .ERR (77,GJFX19,<No such file type)
     3363		       .ERR (100,GJFX20,<No such generation number)
     3364		       .ERR (101,GJFX21,<File was expunged)
     3365		       .ERR (102,GJFX22,<Insufficient system resources (Job Storage Block full))
     3366		       .ERR (103,GJFX23,<Exceeded maximum number of files per directory)
     3367		       .ERR (104,GJFX24,<File not found)
     3368		       .ERR (107,GJFX27,<File already exists (new file required))
     3369		       .ERR (110,GJFX28,<Device is not on line)
     3370		       .ERR (111,GJFX29,<Device is not available to this job)
     3371		       .ERR (112,GJFX30,<Account is not numeric)
     3372		       .ERR (113,GJFX31,<Invalid wildcard designator)
     3373		       .ERR (114,GJFX32,<No files match this specification)
     3374		       .ERR (115,GJFX33,<Filename was not specified)
     3375		       .ERR (116,GJFX34,<Invalid character "?" in file specification)
     3376		       .ERR (117,GJFX35,<Directory access privileges required)
     3377		       .ERR (120,OPNX1,<File is already open)
     3378		       .ERR (121,OPNX2,<File does not exist)
     3379		       .ERR (122,OPNX3,<Read access required)
     3380		       .ERR (123,OPNX4,<Write access required)
     3381		       .ERR (124,OPNX5,<Execute access required)
     3382		       .ERR (125,OPNX6,<Append access required)
     3383		       .ERR (126,OPNX7,<Device already assigned to another job)
     3384		       .ERR (127,OPNX8,<Device is not on line)
     3385		       .ERR (130,OPNX9,<Invalid simultaneous access)
     3386		       .ERR (131,OPNX10,<Entire file structure full)
     3387		       .ERR (133,OPNX12,<List access required)
     3388		       .ERR (134,OPNX13,<Invalid access requested)
     3389		       .ERR (135,OPNX14,<Invalid mode requested)

     3391		       .ERR (137,OPNX16,<File has bad index block)
     3392		       .ERR (140,OPNX17,<No room in job for long file page table)
     3393		       .ERR (141,OPNX18,<Unit Record Devices are not available)
     3394		       .ERR (142,OPNX19,<IMP is not up) ;TOPS20AN
     3395		       .ERR (143,OPNX20,<Host is not up) ;TOPS20AN
     3396		       .ERR (144,OPNX21,<Connection refused) ;TOPS20AN
     3397		       .ERR (145,OPNX22,<Connection byte size does not match) ;TOPS20AN
     3398		       .ERR (150,DESX1,<Invalid source/destination designator)
     3399		       .ERR (151,DESX2,<Terminal is not available to this job)
     3400		       .ERR (152,DESX3,<JFN is not assigned)
     3401		       .ERR (153,DESX4,<Invalid use of terminal designator or string pointer)
     3402		       .ERR (154,DESX5,<File is not open)
     3403		       .ERR (155,DESX6,<Device is not a terminal)
     3404		       .ERR (156,DESX7,<JFN cannot refer to output wildcard designators)
     3405		       .ERR (157,DESX8,<File is not on disk)
     3406		       .ERR (160,CLSX1,<File is not open)
     3407		       .ERR (161,CLSX2,<File cannot be closed by this process)
     3408		       .ERR (165,RJFNX1,<File is not closed)
     3409		       .ERR (166,RJFNX2,<JFN is being used to accumulate filename)
     3410		       .ERR (167,RJFNX3,<JFN is not accessible by this process)
     3411		       .ERR (170,DELFX1,<Delete access required)
     3412		       .ERR (175,SFPTX1,<File is not open)
     3413		       .ERR (176,SFPTX2,<Illegal to reset pointer for this file)
     3414		       .ERR (177,SFPTX3,<Invalid byte number)
     3415		       .ERR (200,CNDIX1,<Invalid password)
     3416		       .ERR (202,CNDIX3,<Invalid directory number)
     3417		       .ERR (204,CNDIX5,<Job is not logged in)
     3418		       .ERR (210,SFBSX1,<Illegal to change byte size for this opening of file)
     3419		       .ERR (211,SFBSX2,<Invalid byte size)
     3420		       .ERR (215,IOX1,<File is not opened for reading)
     3421		       .ERR (216,IOX2,<File is not opened for writing)
     3422		       .ERR (217,IOX3,<File is not open for random access)
     3423		       .ERR (220,IOX4,<End of file reached)
     3424		       .ERR (221,IOX5,<Device or data error)
     3425		       .ERR (222,IOX6,<Illegal to write beyond absolute end of file)
     3426		       .ERR (240,PMAPX1,<Invalid access requested)
     3427		       .ERR (241,PMAPX2,<Invalid use of PMAP)
     3428		       .ERR (245,SPACX1,<Invalid access requested)
     3429		       .ERR (250,FRKHX1,<Invalid process handle)
     3430		       .ERR (251,FRKHX2,<Illegal to manipulate a superior process)
     3431		       .ERR (252,FRKHX3,<Invalid use of multiple process handle)
     3432		       .ERR (253,FRKHX4,<Process is running)
     3433		       .ERR (255,FRKHX6,<All relative process handles in use)
     3434		       .ERR (260,SPLFX1,<Process is not inferior or equal to self)
     3435		       .ERR (261,SPLFX2,<Process is not inferior to self)
     3436		       .ERR (262,SPLFX3,<New superior process is inferior to intended inferior)
     3437		       .ERR (267,GTABX1,<Invalid table number)
     3438		       .ERR (270,GTABX2,<Invalid table index)
     3439		       .ERR (271,GTABX3,<GETAB capability required)
     3440		       .ERR (273,RUNTX1,<Invalid process handle -3 or -4)
     3441		       .ERR (275,STADX1,<WHEEL or OPERATOR capability required)
     3442		       .ERR (276,STADX2,<Invalid date or time)
     3443		       .ERR (300,ASNDX1,<Device is not assignable)

     3445		       .ERR (302,ASNDX3,<No such device)
     3446		       .ERR (320,ATACX1,<Invalid job number)
     3447		       .ERR (321,ATACX2,<Job already attached)
     3448		       .ERR (322,ATACX3,<Incorrect user number)
     3449		       .ERR (323,ATACX4,<Invalid password)
     3450		       .ERR (324,ATACX5,<This job has no controlling terminal)
     3451		       .ERR (332,STDVX1,<No such device)
     3452		       .ERR (335,DEVX1,<Invalid device designator)
     3453		       .ERR (336,DEVX2,<Device already assigned to another job)
     3454		       .ERR (337,DEVX3,<Device is not on line)
     3455		       .ERR (345,MNTX1,<Internal format of directory is incorrect)
     3456		       .ERR (346,MNTX2,<Device is not on line)
     3457		       .ERR (347,MNTX3,<Device is not mountable)
     3458		       .ERR (350,TERMX1,<Invalid terminal code)
     3459		       .ERR (351,TLNKX1,<Illegal to set remote to object before object to remote)
     3460		       .ERR (352,ATIX1,<Invalid software interrupt channel number)
     3461		       .ERR (353,ATIX2,<Control-C capability required)
     3462		       .ERR (356,TLNKX2,<Link was not received within 15 seconds)
     3463		       .ERR (357,TLNKX3,<Links full)
     3464		       .ERR (360,TTYX1,<Device is not a terminal)
     3465		       .ERR (361,RSCNX1,<Overflowed rescan buffer, input string truncated)
     3466		       .ERR (362,RSCNX2,<Invalid function code)
     3467		       .ERR (363,CFRKX3,<Insufficient system resources)
     3468		       .ERR (365,KFRKX1,<Illegal to kill top level process)
     3469		       .ERR (366,KFRKX2,<Illegal to kill self)
     3470		       .ERR (367,RFRKX1,<Processes are not frozen)
     3471		       .ERR (370,HFRKX1,<Illegal to halt self with HFORK)
     3472		       .ERR (371,GFRKX1,<Invalid process handle)
     3473		       .ERR (373,GETX1,<Invalid save file format)
     3474		       .ERR (374,GETX2,<System Special Pages Table full)
     3475		       .ERR (375,TFRKX1,<Undefined function code)
     3476		       .ERR (376,TFRKX2,<Unassigned fork handle or not immediate inferior)
     3477		       .ERR (377,SFRVX1,<Invalid position in entry vector)
     3478		       .ERR (407,NOUTX1,<Radix is not in range 2 to 36 )
     3479		       .ERR (410,NOUTX2,<Column overflow)
     3480		       .ERR (411,TFRKX3,<Fork(s) not frozen)
     3481		       .ERR (414,IFIXX1,<Radix is not in range 2 to 10)
     3482		       .ERR (415,IFIXX2,<First nonspace character is not a digit)
     3483		       .ERR (416,IFIXX3,<Overflow (number is greater than 2**35 ))
     3484		       .ERR (424,GFDBX1,<Invalid displacement)
     3485		       .ERR (425,GFDBX2,<Invalid number of words)
     3486		       .ERR (426,GFDBX3,<List access required)
     3487		       .ERR (430,CFDBX1,<Invalid displacement)
     3488		       .ERR (431,CFDBX2,<Illegal to change specified bits)
     3489		       .ERR (432,CFDBX3,<Write or owner access required)
     3490		       .ERR (433,CFDBX4,<Invalid value for specified bits)
     3491		       .ERR (440,DUMPX1,<Command list error)
     3492		       .ERR (441,DUMPX2,<JFN is not open in dump mode)
     3493		       .ERR (442,DUMPX3,<Address error (too big or crosses end of memory))
     3494		       .ERR (443,DUMPX4,<Access error (cannot read or write data in memory))
     3495		       .ERR (450,RNAMX1,<Files are not on same device)
     3496		       .ERR (451,RNAMX2,<Destination file expunged)
     3497		       .ERR (452,RNAMX3,<Write or owner access to destination file required)

     3499		       .ERR (454,BKJFX1,<Illegal to back up terminal pointer twice)
     3500		       .ERR (460,TIMEX1,<Time cannot be greater than 24 hours)
     3501		       .ERR (461,ZONEX1,<Time zone out of range)
     3502		       .ERR (462,ODTNX1,<Time zone must be USA or Greenwich)
     3503		       .ERR (464,DILFX1,<Invalid date format)
     3504		       .ERR (465,TILFX1,<Invalid time format)
     3505		       .ERR (466,DATEX1,<Year out of range)
     3506		       .ERR (467,DATEX2,<Month is not less than 12)
     3507		       .ERR (470,DATEX3,<Day of month too large)
     3508		       .ERR (471,DATEX4,<Day of week is not less than 7)
     3509		       .ERR (472,DATEX5,<Date out of range)
     3510		       .ERR (473,DATEX6,<System date and time are not set)
     3511		       .ERR (516,SMONX1,<WHEEL or OPERATOR capability required)
     3512		       .ERR (530,SACTX1,<File is not on multiple-directory device)
     3513		       .ERR (531,SACTX2,<Insufficient system resources (Job Storage Block full))
     3514		       .ERR (532,SACTX3,<Directory requires numeric account)
     3515		       .ERR (533,SACTX4,<Write or owner access required)
     3516		       .ERR (540,GACTX1,<File is not on multiple-directory device)
     3517		       .ERR (541,GACTX2,<File expunged)
     3518		       .ERR (544,FFUFX1,<File is not open)
     3519		       .ERR (545,FFUFX2,<File is not on multiple-directory device)
     3520		       .ERR (546,FFUFX3,<No used page found)
     3521		       .ERR (555,DSMX1,<File(s) not closed)
     3522		       .ERR (560,RDDIX1,<Illegal to read directory for this device)
     3523		       .ERR (570,SIRX1,<Table address is not greater than 20)
     3524		       .ERR (600,SSAVX1,<Illegal to save files on this device)
     3525		       .ERR (601,SSAVX2,<Page count is not less than or equal to 1000)
     3526		       .ERR (610,SEVEX1,<Entry vector is not less than 1000)
     3527		       .ERR (614,WHELX1,<WHEEL or OPERATOR capability required)
     3528		       .ERR (615,CAPX1,<WHEEL or OPERATOR capability required)
     3529		       .ERR (617,PEEKX2,<Read access failure on monitor page)
     3530		       .ERR (620,CRDIX1,<WHEEL or OPERATOR capability required)
     3531		       .ERR (621,CRDIX2,<Illegal to change number of old directory)
     3532		       .ERR (622,CRDIX3,<Insufficient system resources (Job Storage Block full))
     3533		       .ERR (623,CRDIX4,<Superior directory full)
     3534		       .ERR (624,CRDIX5,<Directory name not given)
     3535		       .ERR (626,CRDIX7,<File(s) open in directory)
     3536		       .ERR (640,GTDIX1,<WHEEL or OPERATOR capability required)
     3537		       .ERR (641,GTDIX2,<Invalid directory number)
     3538		       .ERR (650,FLINX1,<First character is not blank or numeric)
     3539		       .ERR (651,FLINX2,<Number too small)
     3540		       .ERR (652,FLINX3,<Number too large)
     3541		       .ERR (653,FLINX4,<Invalid format)
     3542		       .ERR (660,FLOTX1,<Column overflow in field 1 or 2)
     3543		       .ERR (661,FLOTX2,<Column overflow in field 3)
     3544		       .ERR (662,FLOTX3,<Invalid format specified)
     3545		       .ERR (670,HPTX1,<Undefined clock number)
     3546		       .ERR (700,FDFRX1,<Not a multiple-directory device)
     3547		       .ERR (701,FDFRX2,<Invalid directory number)
     3548		       .ERR (704,GTHSX1,<Unknown host number) ;TOPS20AN
     3549		       .ERR (705,GTHSX2,<No number for that host name) ;TOPS20AN
     3550		       .ERR (707,GTHSX3,<No string for that Host number) ;TOPS20AN
     3551		       .ERR (710,ATNX1,<Invalid receive JFN) ;TOPS20AN

     3553		       .ERR (712,ATNX3,<Receive JFN not open) ;TOPS20AN
     3554		       .ERR (713,ATNX4,<Receive JFN is not a NET connection) ;TOPS20AN
     3555		       .ERR (714,ATNX5,<Receive JFN has been used) ;TOPS20AN
     3556		       .ERR (715,ATNX6,<Receive connection refused) ;TOPS20AN
     3557		       .ERR (716,ATNX7,<Invalid send JFN) ;TOPS20AN
     3558		       .ERR (717,ATNX8,<Send JFN not opened for write) ;TOPS20AN
     3559		       .ERR (720,ATNX9,<Send JFN not open) ;TOPS20AN
     3560		       .ERR (721,ATNX10,<Send JFN is not a NET connection) ;TOPS20AN
     3561		       .ERR (722,ATNX11,<Send JFN has been used) ;TOPS20AN
     3562		       .ERR (723,ATNX12,<Send connection refused) ;TOPS20AN
     3563		       .ERR (724,ATNX13,<Insufficient system resources (No NVT's)) ;TOPS20AN
     3564		       .ERR (727,CVHST1,<No string for that Host number) ;TOPS20AN
     3565		       .ERR (730,CVSKX1,<Invalid network JFN) ;TOPS20AN
     3566		       .ERR (731,CVSKX2,<Local socket invalid in this context) ;TOPS20AN
     3567		       .ERR (732,SNDIX1,<Invalid message size) ;TOPS20AN
     3568		       .ERR (733,SNDIX2,<Insufficient system resources (No buffers available)) ;TOPS20AN
     3569		       .ERR (734,SNDIX3,<Illegal to specify NCP links 0 - 72) ;TOPS20AN
     3570		       .ERR (735,SNDIX4,<Invalid header value for this queue) ;TOPS20AN
     3571		       .ERR (736,SNDIX5,<IMP down) ;TOPS20AN
     3572		       .ERR (737,NTWZX1,<NET WIZARD capability	required) ;TOPS20AN
     3573		       .ERR (740,ASNSX1,<Insufficient system resources (All special queues in use)) ;TOPS20AN
     3574		       .ERR (741,ASNSX2,<Link(s) assigned to another special queue) ;TOPS20AN
     3575		       .ERR (742,SQX1,<Special network queue handle out of range) ;TOPS20AN
     3576		       .ERR (743,SQX2,<Special network queue not assigned) ;TOPS20AN
     3577		       .ERR (746,GTNCX1,<Invalid network JFN) ;TOPS20AN
     3578		       .ERR (747,GTNCX2,<Invalid or inactive NVT) ;TOPS20AN
     3579		       .ERR (750,RNAMX5,<Destination file is not closed)
     3580		       .ERR (751,RNAMX6,<Destination file has bad page table)
     3581		       .ERR (752,RNAMX7,<Source file expunged)
     3582		       .ERR (753,RNAMX8,<Write or owner access to source file required)
     3583		       .ERR (754,RNAMX9,<Source file is nonexistent)
     3584		       .ERR (755,RNMX10,<Source file is not closed)
     3585		       .ERR (756,RNMX11,<Source file has bad page table)
     3586		       .ERR (757,RNMX12,<Illegal to rename to self)
     3587		       .ERR (760,GJFX36,<Internal format of directory is incorrect)
     3588		       .ERR (770,ILINS1,<Undefined operation code)
     3589		       .ERR (771,ILINS2,<Undefined JSYS)
     3590		       .ERR (772,ILINS3,<UUO simulation facility not available)
     3591		       .ERR (1000,CRLNX1,<Logical name is not defined)
     3592		       .ERR (1001,INLNX1,<Index is beyond end of logical name table)
     3593		       .ERR (1002,LNSTX1,<No such logical name)
     3594		       .ERR (1003,MLKBX1,<Lock facility already in use)
     3595		       .ERR (1004,MLKBX2,<Too many pages to be locked)
     3596		       .ERR (1005,MLKBX3,<Page is not available)
     3597		       .ERR (1006,MLKBX4,<Illegal to remove previous contents of user map)
     3598		       .ERR (1007,VBCX1,<Display data area not locked in core)
     3599		       .ERR (1010,RDTX1,<Invalid string pointer)
     3600		       .ERR (1011,GFKSX1,<Area too small to hold process structure)
     3601		       .ERR (1013,GTJIX1,<Invalid index)
     3602		       .ERR (1014,GTJIX2,<Invalid terminal line number)
     3603		       .ERR (1015,GTJIX3,<Invalid job number)
     3604		       .ERR (1016,IPCFX1,<Length of packet descriptor block cannot be less than 4)
     3605		       .ERR (1017,IPCFX2,<No message for this PID)

     3607		       .ERR (1021,IPCFX4,<Receiver's PID invalid)
     3608		       .ERR (1022,IPCFX5,<Receiver's PID disabled)
     3609		       .ERR (1023,IPCFX6,<Send quota exceeded)
     3610		       .ERR (1024,IPCFX7,<Receiver quota exceeded)
     3611		       .ERR (1025,IPCFX8,<IPCF free space exhausted)
     3612		       .ERR (1026,IPCFX9,<Sender's PID invalid)
     3613		       .ERR (1027,IPCF10,<WHEEL capability required)
     3614		       .ERR (1030,IPCF11,<WHEEL or IPCF capability required)
     3615		       .ERR (1031,IPCF12,<No free PID's available)
     3616		       .ERR (1032,IPCF13,<PID quota exceeded)
     3617		       .ERR (1033,IPCF14,<No PID's available to this job)
     3618		       .ERR (1034,IPCF15,<No PID's available to this process)
     3619		       .ERR (1035,IPCF16,<Receive and message data modes do not match)
     3620		       .ERR (1036,IPCF17,<Argument block too small)
     3621		       .ERR (1037,IPCF18,<Invalid MUTIL JSYS function)
     3622		       .ERR (1040,IPCF19,<No PID for [SYSTEM] INFO)
     3623		       .ERR (1041,IPCF20,<Invalid process handle)
     3624		       .ERR (1042,IPCF21,<Invalid job number)
     3625		       .ERR (1043,IPCF22,<Invalid software interrupt channel number)
     3626		       .ERR (1044,IPCF23,<[SYSTEM] INFO already exists)
     3627		       .ERR (1045,IPCF24,<Invalid message size)
     3628		       .ERR (1046,IPCF25,<PID does not belong to this job)
     3629		       .ERR (1047,IPCF26,<PID does not belong to this process)
     3630		       .ERR (1050,IPCF27,<PID is not defined)
     3631		       .ERR (1051,IPCF28,<PID not accessible by this process)
     3632		       .ERR (1052,IPCF29,<PID already being used by another process)
     3633		       .ERR (1053,IPCF30,<Job is not logged in)
     3634		       .ERR (1054,GNJFX1,<No more files in this specification)
     3635		       .ERR (1055,ENQX1,<Invalid function)
     3636		       .ERR (1056,ENQX2,<Level number too small)
     3637		       .ERR (1057,ENQX3,<Request and lock level numbers do not match)
     3638		       .ERR (1060,ENQX4,<Number of pool and lock resources do not match)
     3639		       .ERR (1061,ENQX5,<Lock already requested)
     3640		       .ERR (1062,ENQX6,<Requested locks are not all locked)
     3641		       .ERR (1063,ENQX7,<No ENQ on this lock)
     3642		       .ERR (1064,ENQX8,<Invalid access change requested)
     3643		       .ERR (1065,ENQX9,<Invalid number of blocks specified)
     3644		       .ERR (1066,ENQX10,<Invalid argument block length)
     3645		       .ERR (1067,ENQX11,<Invalid software interrupt channel number)
     3646		       .ERR (1070,ENQX12,<Invalid number of resources requested)
     3647		       .ERR (1071,ENQX13,<Indirect or indexed byte pointer not allowed)
     3648		       .ERR (1072,ENQX14,<Invalid byte size)
     3649		       .ERR (1073,ENQX15,<ENQ/DEQ capability required)
     3650		       .ERR (1074,ENQX16,<WHEEL or OPERATOR capability required)
     3651		       .ERR (1075,ENQX17,<Invalid JFN)
     3652		       .ERR (1076,ENQX18,<Quota exceeded)
     3653		       .ERR (1077,ENQX19,<String too long)
     3654		       .ERR (1100,ENQX20,<Locked JFN cannot be closed)
     3655		       .ERR (1101,ENQX21,<Job is not logged in)
     3656		       .ERR (1102,IPCF31,<Invalid page number)
     3657		       .ERR (1103,IPCF32,<Page is not private)
     3658		       .ERR (1104,PMAPX3,<Illegal to move shared page into file)
     3659		       .ERR (1105,PMAPX4,<Illegal to move file page into process)

     3661		       .ERR (1107,PMAPX6,<Disk quota exceeded)
     3662		       .ERR (1110,SNOPX1,<WHEEL or OPERATOR capability required)
     3663		       .ERR (1111,SNOPX2,<Invalid function)
     3664		       .ERR (1112,SNOPX3,<.SNPLC function must be first)
     3665		       .ERR (1113,SNOPX4,<Only one .SNPLC function allowed)
     3666		       .ERR (1114,SNOPX5,<Invalid page number)
     3667		       .ERR (1115,SNOPX6,<Invalid number of pages to lock)
     3668		       .ERR (1116,SNOPX7,<Illegal to define breakpoints after inserting them)
     3669		       .ERR (1117,SNOPX8,<Breakpoint is not set on instruction)
     3670		       .ERR (1120,SNOPX9,<No more breakpoints allowed)
     3671		       .ERR (1121,SNOP10,<Breakpoints already inserted)
     3672		       .ERR (1122,SNOP11,<Breakpoints not inserted)
     3673		       .ERR (1123,SNOP12,<Invalid format for program name symbol)
     3674		       .ERR (1124,SNOP13,<No such program name symbol)
     3675		       .ERR (1125,SNOP14,<No such symbol)
     3676		       .ERR (1126,SNOP15,<Not enough free pages for snooping)
     3677		       .ERR (1127,SNOP16,<Multiply defined symbol)
     3678		       .ERR (1130,IPCF33,<Invalid index into system PID table)
     3679		       .ERR (1131,SNOP17,<Breakpoint already defined)
     3680		       .ERR (1132,OPNX23,<Disk quota exceeded)
     3681		       .ERR (1133,GJFX37,<Input deleted)
     3682		       .ERR (1134,CRLNX2,<WHEEL or OPERATOR capability required)
     3683		       .ERR (1135,INLNX2,<Invalid function)
     3684		       .ERR (1136,LNSTX2,<Invalid function)
     3685		       .ERR (1137,ALCX1,<Invalid function)
     3686		       .ERR (1140,ALCX2,<WHEEL or OPERATOR capability required)
     3687		       .ERR (1141,ALCX3,<Device is not assignable)
     3688		       .ERR (1142,ALCX4,<Invalid job number)
     3689		       .ERR (1143,ALCX5,<Device already assigned to another job)
     3690		       .ERR (1144,SPLX1,<Invalid function)
     3691		       .ERR (1145,SPLX2,<Argument block too small)
     3692		       .ERR (1146,SPLX3,<Invalid device designator)
     3693		       .ERR (1147,SPLX4,<WHEEL or OPERATOR capability required)
     3694		       .ERR (1150,SPLX5,<Illegal to specify 0 as generation number for first file)
     3695		       .ERR (1151,CLSX3,<File still mapped)
     3696		       .ERR (1152,CRLNX3,<Invalid function)
     3697		       .ERR (1153,ALCX6,<Device assigned to user job, but will be given to allocator when released
     3698		       )
     3699		       .ERR (1154,CKAX1,<Argument block too small)
     3700		       .ERR (1155,CKAX2,<Invalid directory number)
     3701		       .ERR (1156,CKAX3,<Invalid access code)
     3702		       .ERR (1157,TIMX1,<Invalid function)
     3703		       .ERR (1160,TIMX2,<Invalid process handle)
     3704		       .ERR (1161,TIMX3,<Time limit already set)
     3705		       .ERR (1162,TIMX4,<Illegal to clear time limit)
     3706		       .ERR (1163,SNOP18,<Data page is not private or copy-on-write)
     3707		       .ERR (1164,GJFX38,<File not found because output-only device was specified)
     3708		       .ERR (1165,GJFX39,<Logical name loop detected)
     3709		       .ERR (1166,CRDIX8,<Invalid directory number)
     3710		       .ERR (1167,CRDIX9,<Internal format of directory is incorrect)
     3711		       .ERR (1170,CRDI10,<Maximum directory number exceeded;  index table needs expanding)
     3712		       .ERR (1171,DELDX1,<WHEEL or OPERATOR capability required)
     3713		       .ERR (1172,DELDX2,<Invalid directory number)

     3715		       .ERR (1174,DIAGX1,<Invalid function)
     3716		       .ERR (1175,DIAGX2,<Device is not assigned)
     3717		       .ERR (1176,DIAGX3,<Argument block too small)
     3718		       .ERR (1177,DIAGX4,<Invalid device type)
     3719		       .ERR (1200,DIAGX5,<WHEEL, OPERATOR, or MAINTENANCE capability required)
     3720		       .ERR (1201,DIAGX6,<Invalid channel command list)
     3721		       .ERR (1202,DIAGX7,<Illegal to do I/O across page boundary)
     3722		       .ERR (1203,DIAGX8,<No such device)
     3723		       .ERR (1204,DIAGX9,<Unit does not exist)
     3724		       .ERR (1205,DIAG10,<Subunit does not exist)
     3725		       .ERR (1206,SYEX1,<Unreasonable SYSERR block size)
     3726		       .ERR (1207,SYEX2,<No buffer space available for SYSERR)
     3727		       .ERR (1210,MTOX1,<Invalid function)
     3728		       .ERR (1211,IOX7,<Insufficient system resources (Job Storage Block full))
     3729		       .ERR (1212,IOX8,<Monitor internal error)
     3730		       .ERR (1213,MTOX5,<Invalid hardware data mode for magnetic tape)
     3731		       .ERR (1214,DUMPX5,<No-wait dump mode not supported for this device)
     3732		       .ERR (1215,DUMPX6,<Dump mode not supported for this device)
     3733		       .ERR (1216,IOX9,<Function legal for sequential write only)
     3734		       .ERR (1217,CLSX4,<Device still active)
     3735		       .ERR (1220,MTOX2,<Record size was not set before I/O was done)
     3736		       .ERR (1221,MTOX3,<Function not legal in dump mode)
     3737		       .ERR (1222,MTOX4,<Invalid record size)
     3738		       .ERR (1223,MTOX6,<Invalid magnetic tape density)
     3739		       .ERR (1224,OPNX25,<Device is write locked)
     3740		       .ERR (1225,GJFX40,<Undefined attribute in file specification)
     3741		       .ERR (1226,MTOX7,<WHEEL or OPERATOR capability required)
     3742		       .ERR (1227,LOUTX3,<WHEEL or OPERATOR capability required)
     3743		       .ERR (1230,LOUTX4,<LOG capability required)
     3744		       .ERR (1231,CAPX2,<WHEEL, OPERATOR, or MAINTENANCE capability required)
     3745		       .ERR (1232,SSAVX3,<Insufficient system resources (Job Storage Block full))
     3746		       .ERR (1233,SSAVX4,<Directory area of EXE file is more than one page)
     3747		       .ERR (1234,TDELX1,<Table is empty)
     3748		       .ERR (1235,TADDX1,<Table is full)
     3749		       .ERR (1236,TADDX2,<Entry is already in table)
     3750		       .ERR (1237,TLUKX1,<Internal format of table is incorrect)
     3751		       .ERR (1240,IOX10,<Record is longer than user requested)
     3752		       .ERR (1241,CNDIX2,<WHEEL or OPERATOR capability required)
     3753		       .ERR (1242,CNDIX4,<Invalid job number)
     3754		       .ERR (1243,CNDIX6,<Job is not logged in)
     3755		       .ERR (1244,SJBX1,<Invalid function)
     3756		       .ERR (1245,SJBX2,<Invalid magnetic tape density)
     3757		       .ERR (1246,SJBX3,<Invalid magnetic tape data mode)
     3758		       .ERR (1247,TMONX1,<Invalid TMON function)
     3759		       .ERR (1250,SMONX2,<Invalid SMON function)
     3760		       .ERR (1251,SJBX4,<Invalid job number)
     3761		       .ERR (1252,SJBX5,<Job is not logged in)
     3762		       .ERR (1253,SJBX6,<WHEEL or OPERATOR capability required)
     3763		       .ERR (1254,GTJIX4,<No such job)
     3764		       .ERR (1255,ILINS4,<UUO simulation is disabled)
     3765		       .ERR (1256,ILINS5,<RMS facility is not available)
     3766		       .ERR (1257,COMNX1,<Invalid COMND function code)
     3767		       .ERR (1260,COMNX2,<Field too long for internal buffer)

     3769		       .ERR (1262,COMNX4,<Invalid character in input)
     3770		       .ERR (1263,PRAX1,<Invalid PRARG function code)
     3771		       .ERR (1264,PRAX2,<No room in monitor data base for argument block)
     3772		       .ERR (1265,COMNX5,<Invalid string pointer argument)
     3773		       .ERR (1266,COMNX6,<Problem in indirect file)
     3774		       .ERR (1267,COMNX7,<Error in command)
     3775		       .ERR (1270,PRAX3,<PRARG argument block too large)
     3776		       .ERR (1271,CKAX4,<File is not on disk)
     3777		       .ERR (1272,GACCX1,<Invalid job number)
     3778		       .ERR (1273,GACCX2,<No such job)
     3779		       .ERR (1274,MTOX8,<Argument block too long)
     3780		       .ERR (1275,DBRKX1,<No interrupts in progress)
     3781		       .ERR (1276,SJPRX1,<Job is not logged in)
     3782		       .ERR (1277,GJFX41,<File name must not exceed 6 characters)
     3783		       .ERR (1300,GJFX42,<File type must not exceed 3 characters)
     3784		       .ERR (1301,GACCX3,<Confidential Information Access capability required)
     3785		       .ERR (1302,TIMEX2,<Downtime cannot be more than 7 days in the future)
     3786		       .ERR (1303,DELFX2,<File cannot be expunged because it is currently open)
     3787		       .ERR (1304,DELFX3,<System scratch area depleted; file not deleted)
     3788		       .ERR (1305,DELFX4,<Directory symbol table could not be rebuilt)
     3789		       .ERR (1306,DELFX5,<Directory symbol table needs rebuilding)
     3790		       .ERR (1307,DELFX6,<Internal format of directory is incorrect)
     3791		       .ERR (1310,DELFX7,<FDB formatted incorrectly; file not deleted)
     3792		       .ERR (1311,DELFX8,<FDB not found; file not deleted)
     3793		       .ERR (1312,FRKHX7,<Process page cannot exceed 777)
     3794		       .ERR (1313,DIRX1,<Invalid directory number)
     3795		       .ERR (1314,DIRX2,<Insufficient system resources)
     3796		       .ERR (1315,DIRX3,<Internal format of directory is incorrect)
     3797		       .ERR (1316,UFPGX1,<File is not open for write)
     3798		       .ERR (1317,LNGFX1,<Page table does not exist and file not open for write)
     3799		       .ERR (1320,IPCF34,<Cannot receive into an existing page)
     3800		       .ERR (1321,COMNX8,<Number base out of range 2-10)
     3801		       .ERR (1322,MTOX9,<Output still pending)
     3802		       .ERR (1323,MTOX10,<VFU or RAM file cannot be OPENed)
     3803		       .ERR (1324,MTOX11,<Data too large for buffers)
     3804		       .ERR (1325,MTOX12,<Input error or not all data read)
     3805		       .ERR (1326,MTOX13,<Argument block too small)
     3806		       .ERR (1327,MTOX14,<Invalid software interrupt channel number)
     3807		       .ERR (1330,SAVX1,<Illegal to save files on this device)
     3808		       .ERR (1331,MTOX15,<Device does not have Direct Access (programmable) VFU)
     3809		       .ERR (1332,MTOX16,<VFU or Translation Ram file must be on disk)
     3810		       .ERR (1333,LPINX1,<Invalid unit number)
     3811		       .ERR (1334,LPINX2,<WHEEL or OPERATOR capability required)
     3812		       .ERR (1335,LPINX3,<Illegal to load RAM or VFU while device is OPEN)
     3813		       .ERR (1336,MTOX17,<Device is not on line)
     3814		       .ERR (1337,LGINX6,<No more job slots available for logging-in)
     3815		       .ERR (1340,DESX9,<Invalid operation for this device)
     3816		       .ERR (1341,ACESX1,<Argument block too small)
     3817		       .ERR (1342,ACESX2,<Insufficient system resources)
     3818		       .ERR (1343,DSKOX1,<Channel number too large)
     3819		       .ERR (1344,DSKOX2,<Unit number too large)
     3820		       .ERR (1345,MSTRX1,<Invalid function)
     3821		       .ERR (1346,MSTRX2,<WHEEL or OPERATOR capability required)

     3823		       .ERR (1350,MSTRX4,<Insufficient system resources)
     3824		       .ERR (1351,MSTRX5,<Drive is not on-line)
     3825		       .ERR (1352,MSTRX6,<Home blocks are bad)
     3826		       .ERR (1353,MSTRX7,<Invalid structure name)
     3827		       .ERR (1354,MSTRX8,<Could not get OFN for ROOT-DIRECTORY)
     3828		       .ERR (1355,MSTRX9,<Could not MAP ROOT-DIRECTORY)
     3829		       .ERR (1356,MSTX10,<ROOT-DIRECTORY bad)
     3830		       .ERR (1357,MSTX11,<Could not initialize Index Table)
     3831		       .ERR (1360,MSTX12,<Could not OPEN Bit Table File)
     3832		       .ERR (1361,MSTX13,<Backup copy of ROOT-DIRECTORY is bad)
     3833		       .ERR (1362,MSTX14,<Invalid channel number)
     3834		       .ERR (1363,MSTX15,<Invalid unit number)
     3835		       .ERR (1364,MSTX16,<Invalid controller number)
     3836		       .ERR (1365,DSKX01,<Invalid structure number)
     3837		       .ERR (1366,DSKX02,<Bit table is being initialized)
     3838		       .ERR (1367,DSKX03,<Bit table has not been initialized)
     3839		       .ERR (1370,DSKX04,<Bit table being initialized by another job)
     3840		       .ERR (1371,GFUSX1,<Invalid function)
     3841		       .ERR (1372,GFUSX2,<Insufficient system resources)
     3842		       .ERR (1373,SFUSX1,<Invalid function)
     3843		       .ERR (1374,SFUSX2,<Insufficient system resources)
     3844		       .ERR (1375,SFUSX3,<No such user name)
     3845		       .ERR (1376,RCDIX1,<Insufficient system resources)
     3846		       .ERR (1377,RCDIX2,<Invalid directory specification)
     3847		       .ERR (1400,RCDIX3,<Invalid structure name)
     3848		       .ERR (1401,RCDIX4,<Monitor internal error)
     3849		       .ERR (1402,RCUSX1,<Insufficient system resources)
     3850		       .ERR (1403,TDELX2,<Invalid table entry location)
     3851		       .ERR (1404,TIMX5,<Invalid software interrupt channel number)
     3852		       .ERR (1405,LSTRX1,<Process has not encountered any errors)
     3853		       .ERR (1406,SWJFX1,<Illegal to swap same JFN)
     3854		       .ERR (1407,MTOX18,<Invalid software interrupt channel number)
     3855		       .ERR (1410,OPNX26,<Illegal to open a string pointer)
     3856		       .ERR (1411,DELFX9,<File is not a directory file)
     3857		       .ERR (1412,CRDIX6,<Directory file is mapped)
     3858		       .ERR (1413,COMNX9,<End of input file reached)
     3859		       .ERR (1414,STYPX1,<Invalid terminal type)
     3860		       .ERR (1415,PMAPX7,<Illegal to map file on dismounted structure)
     3861		       .ERR (1416,DSKOX3,<Invalid structure number)
     3862		       .ERR (1417,DESX10,<Structure is dismounted)
     3863		       .ERR (1420,DSKOX4,<Invalid address type specified)
     3864		       .ERR (1421,MSTX17,<All units in a structure must be of the same type)
     3865		       .ERR (1422,MSTX18,<No more units in system)
     3866		       .ERR (1423,MSTX19,<Unit is already part of a mounted structure)
     3867		       .ERR (1424,MSTX20,<Data error reading HOME blocks)
     3868		       .ERR (1425,MSTX21,<Structure is not mounted)
     3869		       .ERR (1426,MSTX22,<Illegal to change specified bits)
     3870		       .ERR (1427,CRDI11,<Invalid terminating bracket on directory)
     3871		       .ERR (1430,MSTX23,<Could not write HOME blocks)
     3872		       .ERR (1431,ACESX3,<Password is required)
     3873		       .ERR (1432,ACESX4,<Function not allowed for another job)
     3874		       .ERR (1433,ACESX5,<No function specified for ACCES)
     3875		       .ERR (1434,STRX05,<No such user name)

     3877		       .ERR (1436,STRX01,<Structure is not mounted)
     3878		       .ERR (1437,STRX02,<Insufficient system resources)
     3879		       .ERR (1440,IOX11,<Quota exceeded or disk full)
     3880		       .ERR (1441,IOX12,<Insufficient system resources (Swapping space full))
     3881		       .ERR (1442,STRX03,<No such directory name)
     3882		       .ERR (1443,STRX04,<Ambiguous directory specification)
     3883		       .ERR (1444,PPNX1,<Invalid PPN)
     3884		       .ERR (1445,PPNX2,<Structure is not mounted)
     3885		       .ERR (1446,PPNX3,<Insufficient system resources)
     3886		       .ERR (1447,PPNX4,<Invalid directory number)
     3887		       .ERR (1450,SPLX6,<No directory to write spooled files into)
     3888		       .ERR (1451,CRDI12,<Structure is not mounted)
     3889		       .ERR (1452,GFUSX3,<File expunged)
     3890		       .ERR (1453,GFUSX4,<Internal format of directory is incorrect)
     3891		       .ERR (1454,RNMX13,<Insufficient system resources)
     3892		       .ERR (1455,SJBX8,<Illegal to perform this function)
     3893		       .ERR (1456,DECRSV,<DEC reserved bits not zero)
     3894		       .ERR (1457,FFFFX1,<No free pages in file)
     3895		       .ERR (1460,WILDX1,<Second JFN cannot be wild)
     3896
     3897		       ; ERROR CODES 1461-1534 ARE AVAILABLE******
     3898
     3899		       .ERR (1535,TIMX6,<Time has already passed)
     3900		       .ERR (1536,TIMX7,<No space available for a clock)
     3901		       .ERR (1537,TIMX8,<User clock allocation exceeded)
     3902		       .ERR (1540,TIMX9,<No such clock entry found)
     3903		       .ERR (1541,TIMX10,<No system date and time)
     3904
     3905		       .ERR (1550,SCTX1,<Invalid function code)
     3906		       .ERR (1551,SCTX2,<Terminal already in use as controlling terminal)
     3907		       .ERR (1552,SCTX3,<Illegal to redefine the job's controlling terminal)
     3908		       .ERR (1553,SCTX4,<SC%SCT capability required)
     3909
     3910		       ; Error codes 1554-1677 are available ******
     3911
     3912		       .ERR (1700,SFUSX4,<File expunged)
     3913		       .ERR (1701,SFUSX5,<Write or owner access required)
     3914		       .ERR (1702,SFUSX6,<No such user name)
     3915		       .ERR (1703,GETX3,<Illegal to overlay existing pages)
     3916		       .ERR (1704,FILX01,<File is not open)
     3917		       .ERR (1705,ARGX01,<Invalid password)
     3918		       .ERR (1706,CAPX3,<WHEEL capability required)
     3919		       .ERR (1707,CAPX4,<WHEEL or IPCF capability required)
     3920		       .ERR (1711,CAPX6,<ENQ/DEQ capability required)
     3921		       .ERR (1712,CAPX7,<Confidential Information Access Capability required)
     3922		       .ERR (1713,ARGX02,<Invalid function)
     3923		       .ERR (1714,ARGX03,<Illegal to change specified bits)
     3924		       .ERR (1715,ARGX04,<Argument block too small)
     3925		       .ERR (1716,ARGX05,<Argument block too long)
     3926		       .ERR (1717,ARGX06,<Invalid page number)
     3927		       .ERR (1720,ARGX07,<Invalid job number)
     3928		       .ERR (1721,ARGX08,<No such job)
     3929		       .ERR (1722,ARGX09,<Invalid byte size)

     3931		       .ERR (1724,ARGX11,<Invalid directory number)
     3932		       .ERR (1725,ARGX12,<Invalid process handle)
     3933		       .ERR (1726,ARGX13,<Invalid software interrupt channel number)
     3934		       .ERR (1727,MONX01,<Insufficient system resources)
     3935		       .ERR (1730,MONX02,<Insufficient system resources (JSB full))
     3936		       .ERR (1731,MONX03,<Monitor internal error)
     3937		       .ERR (1732,MONX04,<Insufficient system resources (Swapping space full))
     3938		       .ERR (1733,ARGX14,<Invalid account identifier)
     3939		       .ERR (1734,ARGX15,<Job is not logged in)
     3940		       .ERR (1735,FILX02,<Write or owner access required)
     3941		       .ERR (1736,FILX03,<List access required)
     3942		       .ERR (1737,DEVX4,<Device is not assignable)
     3943		       .ERR (1740,FILX04,<File is not on multiple-directory device)
     3944		       .ERR (1741,ARGX16,<Password is required)
     3945		       .ERR (1742,ARGX17,<Invalid argument block length)
     3946		       .ERR (1743,ARGX18,<Invalid structure name)
     3947		       .ERR (1744,DEVX5,<No such device)
     3948		       .ERR (1745,DIRX4,<Invalid directory specification)
     3949		       .ERR (1746,FILX05,<File expunged)
     3950		       .ERR (1747,STRX06,<No such user number)
     3951		       .ERR (1750,MSTX24,<Illegal to dismount the Public Structure)
     3952		       .ERR (1751,MSTX25,<Invalid number of swapping pages)
     3953		       .ERR (1752,MSTX26,<Invalid number of Front-End-Filesystem pages)
     3954		       .ERR (1753,LOUTX5,<Illegal to log out job 0)
     3955		       .ERR (1754,GJFX43,<More than one ;T specification is not allowed)
     3956		       .ERR (1755,MTOX19,<Invalid terminal page width)
     3957		       .ERR (1756,MTOX20,<Invalid terminal page length)
     3958		       .ERR (1757,MSTX27,<Specified unit is not a disk)
     3959		       .ERR (1760,MSTX28,<Could not initialize bit table for structure)
     3960		       .ERR (1761,MSTX29,<Could not reconstruct ROOT-DIRECTORY)
     3961		       .ERR (1763,DSKX05,<Disk assignments and deassignments are currently prohibited)
     3962		       .ERR (1764,DSKX06,<Invalid disk address)
     3963		       .ERR (1765,DSKX07,<Address cannot be deassigned because it is not assigned)
     3964		       .ERR (1766,DSKX08,<Address cannot be assigned because it is already assigned)
     3965		       .ERR (1767,COMX10,<Invalid default string)
     3966		       .ERR (1770,MSTX30,<Incorrect Bit Table counts on structure)
     3967		       .ERR (1771,LOCKX1,<Illegal to lock other than a private page)
     3968		       .ERR (1772,LOCKX2,<Requested page unavailable)
     3969		       .ERR (1773,LOCKX3,<Attempt to lock too much memory)
     3970		       .ERR (1774,ILLX01,<Illegal memory read)
     3971		       .ERR (1775,ILLX02,<Illegal memory write)
     3972		       .ERR (1776,ILLX03,<Memory data parity error )
     3973		       .ERR (1777,ILLX04,<Reference to non-existent page)
     3974		       .ERR (2000,MSTX31,<Structure already mounted)
     3975		       .ERR (2001,MSTX32,<Structure was not mounted)
     3976		       .ERR (2002,MSTX33,<Structure is unavailable for mounting)
     3977		       .ERR (2003,STDIX1,<The STDIR JSYS has been replaced by RCDIR and RCUSR)
     3978		       .ERR (2004,CNDIX7,<The CNDIR JSYS has been replaced by ACCES)
     3979		       .ERR (2005,PMCLX1,<Illegal page state or state transition)
     3980		       .ERR (2006,PMCLX2,<Requested physical page is unavailable)
     3981		       .ERR (2007,PMCLX3,<Requested physical page contains errors)
     3982		       .ERR (2010,DLFX10,<Cannot delete directory; file still mapped)
     3983		       .ERR (2011,DLFX11,<Cannot delete directory file in this manner)

     3985		       .ERR (2013,UTSTX1,<Invalid function code)
     3986		       .ERR (2014,UTSTX2,<Area of code too large to test)
     3987		       .ERR (2015,UTSTX3,<UTEST facility in use by another process)
     3988		       .ERR (2016,BOTX01,<Invalid DTE-20 number)
     3989		       .ERR (2017,BOTX02,<Invalid byte size)
     3990		       .ERR (2020,DCNX1,<Invalid network file name)
     3991		       .ERR (2021,DCNX5,<No more logical links available)
     3992		       .ERR (2022,DCNX3,<Invalid object)
     3993		       .ERR (2023,DCNX4,<Invalid task name)
     3994		       .ERR (2024,DCNX9,<Object is already defined)
     3995		       .ERR (2025,DCNX8,<Invalid network operation)
     3996		       .ERR (2026,DCNX11,<Link aborted)
     3997		       .ERR (2027,DCNX12,<String exceeds 16 bytes)
     3998		       .ERR (2030,TTYX01,<Line is not active)
     3999		       .ERR (2031,BOTX03,<Invalid protocol version number)
     4000		       .ERR (2032,MONX05,<Insufficient system resources (no resident free space))
     4001		       .ERR (2033,ARGX19,<Invalid unit number)
     4002		       .ERR (2034,IOX69,<General temporary TAPE error code)
     4003		       .ERR (2035,COMX11,<Invalid CMRTY pointer)
     4004		       .ERR (2036,COMX12,<Invalid CMBFP pointer)
     4005		       .ERR (2037,COMX13,<Invalid CMPTR pointer)
     4006		       .ERR (2040,COMX14,<Invalid CMABP pointer)
     4007		       .ERR (2041,COMX15,<Invalid default string pointer)
     4008		       .ERR (2042,COMX16,<Invalid help message pointer)
     4009		       .ERR (2043,COMX17,<Invalid byte pointer in function block)
     4010		       .ERR (2044,NPXAMB,<Ambiguous)
     4011		       .ERR (2045,NPXNSW,<Not a switch - does not begin with slash)
     4012		       .ERR (2046,NPXNOM,<Does not match switch or keyword)
     4013		       .ERR (2047,NPXNUL,<Null switch or keyword given)
     4014		       .ERR (2050,NPXINW,<Invalid guide word)
     4015		       .ERR (2051,NPXNC,<Not confirmed)
     4016		       .ERR (2052,NPXICN,<Invalid character in number)
     4017		       .ERR (2053,NPXIDT,<Invalid device terminator)
     4018		       .ERR (2054,NPXNQS,<Not a quoted string - does not begin with double quote)
     4019		       .ERR (2055,NPXNMT,<Does not match token)
     4020		       .ERR (2056,NPXNMD,<Does not match directory or user name)
     4021		       .ERR (2057,NPXCMA,<Comma not given)
     4022		       .ERR (2060,GJFX45,<Illegal to request multiple specifications for the same attribute)
     4023		       .ERR (2061,GJFX46,<Attribute value is required)
     4024		       .ERR (2062,GJFX47,<Attribute does not take a value)
     4025		       .ERR (2063,MSTX34,<Unit is write-locked)
     4026		       .ERR (2064,GJFX48,<GTJFN input buffer is empty)
     4027		       .ERR (2065,GJFX49,<Invalid attribute for this device)
     4028		       .ERR (2077,SJBX7,<Remark exceeds 39 characters)
     4029		       .ERR (2100,DELF10,<Directory still contains subdirectory)
     4030		       .ERR (2101,CRDI13,<Request exceeds superior directory working quota)
     4031		       .ERR (2102,CRDI14,<Request exceeds superior directory permanent quota)
     4032		       .ERR (2103,CRDI15,<Request exceeds superior directory subdirectory quota)
     4033		       .ERR (2104,CRDI16,<Invalid user group)
     4034		       .ERR (2105,ENACX1,<Account validation data base file not completely closed)
     4035		       .ERR (2106,ENACX2,<Cannot get a JFN for <SYSTEMACCOUNTS-TABLE.BIN)
     4036		       .ERR (2107,ENACX3,<Account validation data base file too long)
     4037		       .ERR (2110,ENACX4,<Cannot get an OFN for <SYSTEMACCOUNTS-TABLE.BIN)

     4039		       .ERR (2112,VACCX1,<Account string exceeds 39 characters)
     4040		       .ERR (2113,USGX01,<Invalid USAGE entry type code)
     4041		       .ERR (2114,BOTX04,<Byte count is not positive)
     4042		       .ERR (2115,NODX01,<Node name exceeds 6 characters)
     4043		       .ERR (2116,USGX02,<Item not found in argument list)
     4044		       .ERR (2117,CRDI17,<Illegal to create non-files-only subdirectory under files-only directory
     4045		       )
     4046		       .ERR (2120,ENQX23,<Mismatched mask block lengths)
     4047		       .ERR (2121,ENQX22,<Invalid mask block length)
     4048		       .ERR (2122,DCNX2,<Interrupt message must be read first)
     4049		       .ERR (2123,ABRKX1,<Address break not available on this system)
     4050		       .ERR (2124,USGX03,<Default item not allowed)
     4051		       .ERR (2125,IPCF35,<Invalid IPCF quota)
     4052		       .ERR (2126,VACCX2,<Account has expired)
     4053		       .ERR (2127,CRDI18,<Illegal to delete logged-in directory)
     4054		       .ERR (2130,CRDI19,<Illegal to delete connected directory)
     4055		       .ERR (2132,BOTX05,<Protocol initialization failed)
     4056		       .ERR (2133,CRDI20,<WHEEL, OPERATOR, or requested capability required)
     4057		       .ERR (2134,COMX18,<Invalid character in node name)
     4058		       .ERR (2135,COMX19,<Too many characters in node name)
     4059		       .ERR (2136,CRDI21,<Working space insufficient for current allocation)
     4060		       .ERR (2137,ACESX7,<Directory is "files-only" and cannot be accessed)
     4061		       .ERR (2140,CRDI22,<Subdirectory quota insufficient for existing subdirectories)
     4062		       .ERR (2141,CRDI23,<Superior directory does not exist)
     4063		       .ERR (2142,STRX07,<Invalid user number)
     4064		       .ERR (2143,STRX08,<Invalid user name)
     4065		       .ERR (2144,CRDI24,<Invalid subdirectory quota)
     4066		       .ERR (2146,ATSX01,<Invalid mode)
     4067		       .ERR (2147,ATSX02,<Illegal to declare mode twice)
     4068		       .ERR (2150,ATSX03,<Illegal to declare mode after acquiring terminal)
     4069		       .ERR (2151,ATSX04,<Invalid event code)
     4070		       .ERR (2152,ATSX05,<Invalid function code for channel assignment)
     4071		       .ERR (2153,ATSX06,<JFN is not an ATS JFN)
     4072		       .ERR (2154,ATSX07,<Table length too small)
     4073		       .ERR (2155,ATSX08,<Table lengths must be the same)
     4074		       .ERR (2156,ATSX09,<Table length too large)
     4075		       .ERR (2157,ATSX10,<Maximum applications terminals for system already assigned)
     4076		       .ERR (2160,ATSX11,<Byte count is too large)
     4077		       .ERR (2161,ATSX12,<Terminal not assigned to this JFN)
     4078		       .ERR (2162,ATSX13,<Terminal is XOFF'd)
     4079		       .err (2163,ATSX14,<Terminal has been released)
     4080		       .ERR (2164,ATSX15,<Terminal identifier is not assigned)
     4081		       .ERR (2165,PMCLX4,<No more error information)
     4082		       .ERR (2166,ATSX16,<Invalid Host Terminal Number)
     4083		       .ERR (2167,ATSX17,<Output failed -- monitor internal error)
     4084		       .ERR (2170,FRKHX8,<Illegal to manipulate an execute-only process)
     4085		       .ERR (2171,ARGX20,<Invalid arithmetic trap argument)
     4086		       .ERR (2172,ARGX21,<Invalid LUUO trap argument)
     4087		       .ERR (2173,ARGX22,<Invalid flags)
     4088		       .ERR (2174,ATSX18,<ATS input message too long for internal buffers)
     4089		       .ERR (2175,ATSX19,<Monitor internal error - ATS input message truncated)
     4090		       .ERR (2176,ATSX20,<Illegal to close JFN with terminal assigned)
     4091		       .ERR (2177,ARGX23,<Invalid section number)

     4093		       .ERR (2201,MSTX35,<Too many units in structure)
     4094		       .ERR (2202,DCNX13,<Node not accessible)
     4095		       .ERR (2203,DCNX14,<Previous interrupt message outstanding)
     4096		       .ERR (2204,DCNX15,<No interrupt message available)
     4097		       .ERR (2205,GJFX50,<Invalid argrument for attribute)
     4098		       .ERR (2206,KDPX01,<KMC11 not running)
     4099		       .ERR (2207,NODX02,<Line not turned off)
     4100		       .ERR (2210,NODX03,<Another line already looped)
     4101		       .ERR (2211,GJFX51,<Byte count too small)
     4102		       .ERR (2212,COMX20,<Invalid node name)
     4103		       .ERR (2213,ATSX21,<Maximum applications terminals for job already assigned)
     4104		       .ERR (2214,ATSX22,<Failed to acquire applications terminal)
     4105		       .ERR (2215,ATSX23,<Invalid device name)
     4106		       .ERR (2216,ATSX24,<Invalid server name)
     4107		       .ERR (2217,ATSX25,<Terminal is already released)
     4108		       .ERR (2220,GOKER1,<Illegal function)
     4109		       .ERR (2221,GOKER2,<Request denied by Access Control Facility)
     4110		       .ERR (2222,STRX09,<Prior structure mount required)
     4111		       .ERR (2223,MSTX36,<Illegal while JFNs assigned)
     4112		       .ERR (2224,MSTX37,<Illegal while accessing or connected to structure)
     4113		       .ERR (2225,MSTX40,<Invalid PSI channel number given)
     4114		       .ERR (2226,ATSX26,<Invalid host name)
     4115		       .ERR (2227,IOX13,<Invalid segment type)
     4116		       .ERR (2230,IOX14,<Invalid segment size)
     4117		       .ERR (2231,IOX15,<Illegal tape format for dump mode)
     4118		       .ERR (2232,IOX16,<Density specified does not match tape density)
     4119		       .ERR (2233,IOX17,<Invalid tape label)
     4120		       .ERR (2234,IOX20,<Illegal tape record size)
     4121		       .ERR (2235,IOX21,<Tape HDR1 missing)
     4122		       .ERR (2236,IOX22,<Invalid tape HDR1 sequence number)
     4123		       .ERR (2237,IOX23,<Tape label read error)
     4124		       .ERR (2240,IOX24,<Tape HDR1 missing)
     4125		       .ERR (2241,IOX25,<Invalid tape format)
     4126		       .ERR (2242,SWJFX2,<Illegal to swap ATS JFN)
     4127		       .ERR (2243,IOX26,<Tape write date has not expired)
     4128		       .ERR (2244,IOX27,<Tape is domestic and HDR2 is missing)
     4129		       .ERR (2245,IOX30,<Tape has invalid access character)
     4130		       .ERR (2246,ARGX25,<Invalid class)
     4131		       .ERR (2247,SKDX1,<Cannot change class)
     4132		       .ERR (2250,MREQX1,<Request canceled by user)
     4133		       .ERR (2251,MREQX2,<Labeled tapes not permitted on 7-track drives)
     4134		       .ERR (2252,MREQX3,<Unknown density specified)
     4135		       .ERR (2253,MREQX4,<Unknown drive type specified)
     4136		       .ERR (2254,MREQX5,<Unknown label type specified)
     4137		       .ERR (2255,MREQX6,<Set name illegal or not specified)
     4138		       .ERR (2256,MREQX7,<Illegal starting-volume specification)
     4139		       .ERR (2257,MREQX8,<Attempt to switch to volume outside set)
     4140		       .ERR (2260,MREQX9,<Illegal volume identifier specified)
     4141		       .ERR (2261,MREQ10,<Density mismatch between request and volume)
     4142		       .ERR (2262,MREQ11,<Drive type mismatch between request and volume)
     4143		       .ERR (2263,MREQ12,<Label type mismatch between request and volume)
     4144		       .ERR (2264,MREQ13,<Structural error in mount message)
     4145		       .ERR (2265,MREQ14,<Setname mismatch between request and volume)

     4147		       .ERR (2267,MREQ16,<Volume identifiers not supplied by operator)
     4148		       .ERR (2270,MREQ17,<Volume-identifier list missing)
     4149		       .ERR (2271,MREQ18,<End of volume-identifier list reached while reading)
     4150		       .ERR (2272,MREQ19,<Requested tape drive type not available to system)
     4151		       .ERR (2273,MREQ20,<Structural error in mount entry)
     4152		       .ERR (2274,MREQ21,<Mount requested for unknown device type)
     4153		       .ERR (2275,DEVX6,<Job has open JFN on device)
     4154		       .ERR (2276,ATSX27,<Terminal is not open)
     4155		       .ERR (2277,ATSX28,<Unknown error received)
     4156		       .ERR (2300,ATSX29,<Receive error threshold exceeded)
     4157		       .ERR (2301,ATSX30,<Reply threshold exceeded)
     4158		       .ERR (2302,ATSX31,<NAK threshold exceeded)
     4159		       .ERR (2303,ATSX32,<Terminal protocol error)
     4160		       .ERR (2304,ATSX33,<Intervention required at terminal)
     4161		       .ERR (2305,ATSX34,<Powerfail)
     4162		       .ERR (2306,ATSX35,<Data pipe was disconnected)
     4163		       .ERR (2307,ATSX36,<Dialup terminal was attached)
     4164		       .ERR (2310,DATEX7,<Julian day is out of range)
     4165		       .ERR (2311,MREQ22,<Structure name not specified)
     4166		       .ERR (2312,ARCFX2,<File already has archive status)
     4167		       .ERR (2313,ARCFX3,<Cannot perform ARCF functions on non-multiple directory devices)
     4168		       .ERR (2314,ARCFX4,<File is not on-line)
     4169		       .ERR (2315,ARCFX5,<Files not on the same device or structure)
     4170		       .ERR (2316,ARCFX6,<File does not have archive status)
     4171		       .ERR (2317,ARCFX7,<Invalid parameter)
     4172		       .ERR (2320,ARCFX8,<Archive not complete)
     4173		       .ERR (2321,ARCFX9,<File not off-line)
     4174		       .ERR (2322,ARCX10,<Archive prohibited)
     4175		       .ERR (2323,ARCX11,<Archive requested, modification prohibited)
     4176		       .ERR (2324,ARCX12,<Archive requested, delete prohibited)
     4177		       .ERR (2325,ARCX13,<Archive system request not completed)
     4178		       .ERR (2326,OPNX30,<File has archive status, modification is prohibited)
     4179		       .ERR (2327,OPNX31,<File is off-line)
     4180		       .ERR (2330,DELX11,<File has archive status, delete is not permitted)
     4181		       .ERR (2331,DELX12,<File has no pointer to offline storage)
     4182		       .ERR (2332,ARCX14,<File restore failed)
     4183		       .ERR (2333,ARCX15,<Migration prohibited)
     4184		       .ERR (2334,ARCX16,<Cannot exempt offline file)
     4185		       .ERR (2335,ARCX17,<FDB incorrect format for ARCF JSYS)
     4186		       .ERR (2336,ARCX18,<Retrieval request cannot be fulfilled for waiting process)
     4187		       .ERR (2337,ARCX19,<Migration already pending)
     4188		       .ERR (2340,ARGX26,<File is offline)
     4189		       .ERR (2341,ARGX27,<Offline expiration time cannot exceed system maximum)
     4190		       .ERR (2342,DIRX5,<Directory too large)
     4191		       .ERR (2343,IOX31,<Invalid record descriptor in labeled tape)
     4192		       .ERR (2344,MREQ23,<Dismount refused by operator)
     4193		       .ERR (2345,MREQ24,<Illegal to dismount connected structure)
     4194		       .ERR (2346,MREQ25,<Structure not found)
     4195		       .ERR (2347,LTLBLX,<Too many user labels)
     4196		       .ERR (2350,LTLBX1,<Undefined record format on non-TOPS20 tape)
     4197		       .ERR (2351,MREQ26,<Tape mounting function disabled by installation)
     4198		       .ERR (2352,METRX1,<METER not supported on this processor)
     4199		       .ERR (2353,NSPX00,<Connection not accepted)

     4201		       .ERR (2355,NSPX02,<Destination node does not exist)
     4202		       .ERR (2356,NSPX03,<Node shutting down)
     4203		       .ERR (2357,NSPX04,<Destination process does not exist)
     4204		       .ERR (2360,NSPX05,<Invalid process name)
     4205		       .ERR (2361,NSPX06,<Destination process queue overflow)
     4206		       .ERR (2362,NSPX07,<Unspecified error)
     4207		       .ERR (2363,NSPX08,<Connection aborted by third party)
     4208		       .ERR (2364,NSPX09,<Link aborted by process)
     4209		       .ERR (2365,NSPX10,<NSP Failure - Flow control violation)
     4210		       .ERR (2366,NSPX11,<Too many connections to node)
     4211		       .ERR (2367,NSPX12,<Too many connections to destination process)
     4212		       .ERR (2370,NSPX13,<Access denied due to unacceptable user name or password)
     4213		       .ERR (2371,NSPX14,<NSP failure - invalid SERVICES field)
     4214		       .ERR (2372,NSPX15,<Invalid account)
     4215		       .ERR (2373,NSPX16,<NSP failure - invalid SEGSIZ field)
     4216		       .ERR (2374,NSPX17,<Process aborted, timed out, or cancelled request)
     4217		       .ERR (2375,NSPX18,<No path to destination node)
     4218		       .ERR (2376,NSPX19,<NSP failure - flow control failure)
     4219		       .ERR (2377,NSPX20,<NSP failure - invalid DSTADDR)
     4220		       .ERR (2400,NSPX21,<Disconnect confirmation)
     4221		       .ERR (2401,NSPX22,<NSP failure - image data field too long)
     4222		       .ERR (2402,MREQ27,<Structure is set IGNORED)
     4223		       .ERR (2403,MREQ28,<Cannot overwrite volume - first file is not expired)
     4224		       .ERR (2404,MREQ29,<Cannot overwrite volume - write access required)
     4225		       .ERR (2405,MREQ30,<Tape label format error)
     4226		       .ERR (2406,DIAG11,<Unit already online)
     4227		       .ERR (2407,DIAG12,<Unit not online)
     4228		       .ERR (2410,DESX11,<Invalid operation for this label type)
     4229		       .ERR (2411,NSPX23,<Invalid NSP reason code)
     4230		       .ERR (2412,ARGX28,<not available on this system)
     4231		       .ERR (2413,NPX2CL,<Two colons required on node name)
     4232		       .ERR (2414,ARGX29,<Invalid class share)
     4233		       .ERR (2415,ARGX30,<Invalid KNOB value)
     4234		       .ERR (2416,ARGX31,<Class Scheduler already enabled)
     4235		       .ERR (2417,DEVX7,<Null device name given)
     4236		       .ERR (2420,GJFX52,<End of tape encountered while searching for file)
     4237		       .ERR (2420,GOKER3,<Access control job already running)
     4238			    ;END OF .ERCOD DEFINITION
     4239
     4240
     4241		       ;DEFINE THE ERROR CODE VALUES
     4242
     4243		       DEFINE .ERR (N,E,S) <
     4244			 E=:.ERBAS+N
     4245			 IFG <N-.ERMAX,.ERMAX==:N
     4246
     4247      000000		  .ERMAX==:0
     4248
     4249		       .ERCOD
     4250
     4251
     4252
     4253		       ;THIS SECTION CONSISTS OF SPECIAL CODE TO WRITE THE ERRMES.BIN FILE

     4255		       ; DEFINED TO BE NON-ZERO.
     4256
     4257		       IFNDEF .ERBLD,<.ERBLD==0
     4258
     4259		       IFN .ERBLD,<
     4260
     4261		       .ERGO: MOVSI 1,(GJ%FOU!GJ%SHT) ;GET A JFN ON ERROR FILE
     4262			 HRROI 2,[ASCIZ/ERRMES.BIN/]
     4263			 GTJFN
     4264			  JRST .ERER
     4265			 MOVE 2,[440000,,OF%WR]
     4266			 OPENF	 ;OPEN THE FILE FOR WRITE
     4267			  JRST .ERER
     4268			 MOVNI 3,.ERSTE-.ERTAB ;GET LENGTH OF FILE
     4269			 MOVE 2,[POINT 36,.ERTAB]
     4270			 SOUT	;OUTPUT THE ERROR FILE DATA
     4271			 CLOSF	 ;CLOSE THE FILE
     4272			  JRST .ERER
     4273			 HALTF	 ;DONE
     4274
     4275		       .ERER: MOVEI 1,101  ;TYPE OUT ERROR CODE
     4276			 HRLOI 2,400000
     4277			 SETZ 3,
     4278			 ERSTR
     4279			  JFCL
     4280			  JFCL
     4281			 HALTF
     4282
     4283		       LIT
     4284
     4285		       DEFINE .ERR (N,E,S) <
     4286			 .ERQQ==<.-.ERTAB*5
     4287			 .ERQQ2==N37777					  _
     4288			 .ERRM1 .ERQQ2,N,.ERQQ
     4289			 ASCII s'@
     4290
     4291
     4292		       DEFINE .ERRM1 (NN,N,.ERQQ)<
     4293			  IF1,<IFDEF EZ'NN,<
     4294			 PRINTX ERROR N=NN HAS ALREADY BEEN USED
     4295
     4296			  EZ'NN==1
     4297			  RELOC .ERTAB+NN
     4298			 .ERQQ
     4299			  RELOC
     4300
     4301
     4302		       .ERTAB: .ERMAX	;FIRST WORD OF TABLE IS THE LENGTH
     4303			    ; OF THE TABLE FOR ERSTR TO USE AS
     4304			    ; A BOUNDS CHECK.
     4305			 BLOCK .ERMAX  ;LEAVE ROOM FOR POINTERS
     4306
     4307		       .ERST: .ERCOD   ;BUILD STRINGS AND .ERTAB

     4309
     4310			 END .ERGO
     4311
     4312			    ;END OF IFN .ERBLD CONDITIONAL
     4313
     4314		       PURGE .ERR,REL
     4315
     4316		       END




	1		       ;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
	2		       ;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
	3		       ;
	4		       ;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
	5
	6		       ;VERSION 1
	7
	8		       IFNDEF REL,<REL==0  ;UNIVERSAL UNLESS OTHERWISE DECLARED
	9			  IFE REL,<
       11
       12			  IFN REL,<
       13			 TITLE MACREL  SUPPORT CODE FOR MACSYM
       14			 SEARCH MONSYM
       15			 SALL
       16			 IFNDEF .PSECT,<
       17			 .DIRECT .XTABM
       18
       19
       20		       ;THE STANDARD VERSION WORD CONSTRUCTION
       21		       ; VERS - PROGRAM VERSION NUMBER
       22		       ; VUPDAT - PROGRAM UPDATE NUMBER (1=A, 2=B ...)
       23		       ; VEDIT - PROGRAM EDIT NUMBER
       24		       ; VCUST - CUSTOMER EDIT CODE (0=DEC DEVELOPMENT, 1=DEC SWS, 2-7 CUST)
       25
       26		       DEFINE PGVER. (VERS,VUPDAT,VEDIT,VCUST)<
       27			 ..PGV0==.  ;;SAVE CURRECT LOCATION AND MODE
       28			 .JBVER=:137  ;;WHERE TO PUT VERSION
       29			 LOC .JBVER  ;;PUT VERSION IN STANDARD PLACE
       30			 BYTE (3)VCUST(9)VERS(6)VUPDAT(18)VEDIT
       31			 .ORG ..PGV0  ;;RESTORE LOCATION AND MODE
       32
       33
       34		       ;MASKS FOR THE ABOVE
       35
       36    700000  000000	 VI%WHO==:7B2	;Customer edit code
       37    077700  000000	 VI%MAJ==:777B11   ;Major version number
       38    000077  000000	 VI%MIN==:77B17   ;Minor version/update
       39      777777		 VI%EDN==:777777B35  ;Edit number
       40		       ;ADDED VI%XXX
       41			 SUBTTL MISC CONSTANTS

       43		       ;MISC CONSTANTS
       44
       45    377777  777777	 .INFIN==:377777,,777777  ;PLUS INFINITY
       46    400000  000000	 .MINFI==:1B0	;MINUS INFINITY
       47    777777  000000	 .LHALF==:777777B17  ;LEFT HALF
       48      777777		 .RHALF==:777777   ;RIGHT HALF
       49    777777  777777	 .FWORD==:-1   ;FULL WORD
       50
       51			 SUBTTL SYMBOLS FOR THE CONTROL CHARACTERS
       52
       53      000000		 .CHNUL==:000	;NULL
       54      000001		 .CHCNA==:001
       55      000002		 .CHCNB==:002
       56      000003		 .CHCNC==:003
       57      000004		 .CHCND==:004
       58      000005		 .CHCNE==:005
       59      000006		 .CHCNF==:006
       60      000007		 .CHBEL==:007	;BELL
       61      000010		 .CHBSP==:010	;BACKSPACE
       62      000011		 .CHTAB==:011	;TAB
       63      000012		 .CHLFD==:012	;LINE-FEED
       64      000013		 .CHVTB==:013	;VERTICAL TAB
       65      000014		 .CHFFD==:014	;FORM FEED
       66      000015		 .CHCRT==:015	;CARRIAGE RETURN
       67      000016		 .CHCNN==:016
       68      000017		 .CHCNO==:017
       69      000020		 .CHCNP==:020
       70      000021		 .CHCNQ==:021
       71      000022		 .CHCNR==:022
       72      000023		 .CHCNS==:023
       73      000024		 .CHCNT==:024
       74      000025		 .CHCNU==:025
       75      000026		 .CHCNV==:026
       76      000027		 .CHCNW==:027
       77      000030		 .CHCNX==:030
       78      000031		 .CHCNY==:031
       79      000032		 .CHCNZ==:032
       80      000033		 .CHESC==:033	;ESCAPE
       81      000034		 .CHCBS==:034	;CONTROL BACK SLASH
       82      000035		 .CHCRB==:035	;CONTROL RIGHT BRACKET
       83      000036		 .CHCCF==:036	;CONTROL CIRCONFLEX
       84      000037		 .CHCUN==:037	;CONTROL UNDERLINE
       85
       86      000175		 .CHALT==:175	;OLD ALTMODE
       87      000176		 .CHAL2==:176	;ALTERNATE OLD ALTMODE
       88      000177		 .CHDEL==:177	;DELETE
       89
       90			 SUBTTL HARDWARE BITS OF INTEREST TO USERS
       91
       92		       ;PC FLAGS
       93
       94    400000  000000	 PC%OVF==:1B0	;OVERFLOW
       95    200000  000000	 PC%CY0==:1B1	;CARRY 0

       97    040000  000000	 PC%FOV==:1B3	;FLOATING OVERFLOW
       98    020000  000000	 PC%BIS==:1B4	;BYTE INCREMENT SUPPRESSION
       99    010000  000000	 PC%USR==:1B5	;USER MODE
      100    004000  000000	 PC%UIO==:1B6	;USER IOT MODE
      101    002000  000000	 PC%LIP==:1B7	;LAST INSTRUCTION PUBLIC
      102    001000  000000	 PC%AFI==:1B8	;ADDRESS FAILURE INHIBIT
      103    000600  000000	 PC%ATN==:3B10	 ;APR TRAP NUMBER
      104    000100  000000	 PC%FUF==:1B11	 ;FLOATING UNDERFLOW
      105    000040  000000	 PC%NDV==:1B12	 ;NO DIVIDE
      106
      107			 SUBTTL MACROS FOR FIELD MASKS
      108
      109		       ;STANDARD MACROS
      110
      111		       ;MACROS TO HANDLE FIELD MASKS
      112
      113		       ;COMPUTE LENGTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES
      114		       ;REMEMBER THAT L DOES 'JFFO', I.E. HAS VALUE OF FIRST ONE BIT IN WORD
      115
      116		       ;COMPUTE WIDTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES
      117
      118		       DEFINE WID(MASK)<<L<-<<MASK<LMASK-1
      119
      120		       ;COMPUTE POSITION OF MASK, I.E. BIT POSITION OF RIGHTMOST ONE IN MASK
      121
      122		       DEFINE POS(MASK)<<L<<MASK-<MASK							_
      123
      124		       ;CONSTRUCT BYTE POINTER TO MASK
      125
      126		       DEFINE POINTR(LOC,MASK)<<POINT WID(MASK),LOC,POS(MASK)
      127
      128		       ;PUT RIGHT-JUSTIFIED VALUE INTO FIELD SPECIFIED BY MASK
      129
      130		       DEFINE FLD(VAL,MSK)<<<<VALBPOS(MSK)MSK								  _
      131
      132		       ;MAKE VALUE BE RIGHT JUSTIFIED IN WORD.
      133
      134		       DEFINE .RTJST(VAL,MSK)<<<<VALMSKBD70-POS(MSK)							    _
      135
      136		       ;CONSTRUCT MASK FROM BIT AA TO BIT BB. I.E. MASKB 0,8 = 777B8
      137
      138		       DEFINE MASKB(AA,BB)<<1B<<AA-1-1BBB
      139
      140		       ;MODULE - GIVES REMAINDER OF DEND DIVIDED BY DSOR
      141
      142		       DEFINE MOD.(DEND,DSOR)<<<DEND-<DEND/DSOR*DSOR
      143
      144			 SUBTTL MOVX
      145
      146		       ;MOVX - LOAD AC WITH CONSTANT
      147
      148		       DEFINE MOVX (AC,MSK)<
      149			  ..MX1==MSK   ;;EVAL EXPRESSION IF ANY

      151			  .IFN ..MX1,ABSOLUTE,<
      152			 MOVE AC,[MSK]
      153			  .IF ..MX1,ABSOLUTE,<
      154			 ..MX2==0  ;;FLAG SAYS HAVEN'T DONE IT YET
      155			 IFE <..MX1B53,
      156			   ..MX2==1
      157			   MOVEI AC,..MX1 ;;LH 0, DO AS RH
      158			 IFE ..MX2,<  ;;IF HAVEN'T DONE IT YET,
      159			 IFE <..MX1B17,
      160			   ..MX2==1
      161			   MOVSI AC,(..MX1) ;;RH 0, DO AS LH
      162			 IFE ..MX2,<  ;;IF HAVEN'T DONE IT YET,
      163			 IFE <<..MX1B53-O777777,
      164			   ..MX2==1
      165			   HRROI AC,<..MX1 ;;LH -1
      166			 IFE ..MX2,<  ;;IF HAVEN'T DONE IT YET,
      167			 IFE <<..MX1B17-O777777B17,
      168			   ..MX2==1
      169			   HRLOI AC,(..MX1-O777777) ;;RH -1
      170			 IFE ..MX2,<  ;;IF STILL HAVEN'T DONE IT,
      171			   MOVE AC,[..MX1] ;;GIVE UP AND USE LITERAL
      172
      173
      174		       IFNDEF .PSECT,<
      175			 ..MX2==0  ;;FLAG SAYS HAVEN'T DONE IT YET
      176			 IFE <..MX1B53,
      177			   ..MX2==1
      178			   MOVEI AC,..MX1 ;;LH 0, DO AS RH
      179			 IFE ..MX2,<  ;;IF HAVEN'T DONE IT YET,
      180			 IFE <..MX1B17,
      181			   ..MX2==1
      182			   MOVSI AC,(..MX1) ;;RH 0, DO AS LH
      183			 IFE ..MX2,<  ;;IF HAVEN'T DONE IT YET,
      184			 IFE <<..MX1B53-O777777,
      185			   ..MX2==1
      186			   HRROI AC,<..MX1 ;;LH -1
      187			 IFE ..MX2,<  ;;IF HAVEN'T DONE IT YET,
      188			 IFE <<..MX1B17-O777777B17,
      189			   ..MX2==1
      190			   HRLOI AC,(..MX1-O777777) ;;RH -1
      191			 IFE ..MX2,<  ;;IF STILL HAVEN'T DONE IT,
      192			   MOVE AC,[..MX1] ;;GIVE UP AND USE LITERAL
      193
      194			 PURGE ..MX1,..MX2
      195		       ;VARIENT MNEMONICS FOR TX DEFINITIONS
      196
      197		       DEFINE IORX (AC,MSK)<
      198			 TXO AC,<MSK
      199
      200		       DEFINE ANDX (AC,MSK)<
      201			 TXZ AC,<-<MSK
      202
      203		       DEFINE XORX (AC,MSK)<

      205
      206			 SUBTTL TX -- TEST MASK
      207
      208		       ;CREATE THE TX MACRO DEFINITIONS
      209
      210		       ;THIS DOUBLE IRP CAUSES ALL COMBINATIONS OF MODIFICATION AND TESTING
      211		       ;TO BE DEFINED
      212
      213		       DEFINE ..DOTX (M,T)<
      214			 IRP M,<
      215			 IRP T,<
      216			   DEFINE TX'M'T (AC,MSK)<
      217			  ..TX(M'T,AC,<MSK)
      218
      219			 ..DOTX (<N,O,Z,C,,E,N,A) ;DO ALL DEFINITIONS
      220			 PURGE ..DOTX
      221
      222		       ;..TX
      223		       ;ALL TX MACROS JUST CALL ..TX WHICH DOES ALL THE WORK
      224
      225		       DEFINE ..TX(MT,AC,MSK)<
      226			  ..TX1==MSK   ;;EVAL EXPRESSION IF ANY
      227		       IFDEF .PSECT,<
      228			  .IFN ..TX1,ABSOLUTE,<
      229			 TD'MT AC,[MSK]
      230			  .IF ..TX1,ABSOLUTE,<	;;MASK MUST BE TESTABLE
      231			 ..TX2==0  ;;FLAG SAYS HAVEN'T DONE IT YET
      232			 IFE <..TX1O777777B17,					   _
      233			   ..TX2==1  ;;LH 0, DO AS RH
      234			   TR'MT AC,..TX1
      235			 IFE ..TX2,<  ;;IF HAVEN'T DONE IT YET,
      236			 IFE <..TX1O777777,					   _
      237			   ..TX2==1  ;;RH 0, DO AS LH
      238			   TL'MT AC,(..TX1)
      239			 IFE ..TX2,<  ;;IF HAVEN'T DONE IT YET,
      240			   IFE <<..TX1B53-O777777, ;;IF LH ALL ONES,
      241			     ..TX3 (MT,AC) ;;TRY Z,O,C SPECIAL CASES
      242			 IFE ..TX2,<  ;;IF STILL HAVEN'T DONE IT,
      243			   TD'MT AC,[..TX1] ;;MUST GIVE UP AND USE LITERAL
      244			 PURGE ..TX1,..TX2
      245		       IFNDEF .PSECT,<
      246			 ..TX2==0  ;;FLAG SAYS HAVEN'T DONE IT YET
      247			 IFE <..TX1O777777B17,					   _
      248			   ..TX2==1  ;;LH 0, DO AS RH
      249			   TR'MT AC,..TX1
      250			 IFE ..TX2,<  ;;IF HAVEN'T DONE IT YET,
      251			 IFE <..TX1O777777,					   _
      252			   ..TX2==1  ;;RH 0, DO AS LH
      253			   TL'MT AC,(..TX1)
      254			 IFE ..TX2,<  ;;IF HAVEN'T DONE IT YET,
      255			   IFE <<..TX1B53-O777777, ;;IF LH ALL ONES,
      256			     ..TX3 (MT,AC) ;;TRY Z,O,C SPECIAL CASES
      257			 IFE ..TX2,<  ;;IF STILL HAVEN'T DONE IT,

      259			 PURGE ..TX1,..TX2
      260		       ;SPECIAL CASE FOR LH ALL ONES
      261
      262		       DEFINE ..TX3 (MT,AC)<
      263			 IFIDN <MTZ,  ;;IF ZEROING WANTED
      264			   ..TX2==1
      265			   ANDI AC,-..TX1 ;;CAN DO IT WITH ANDI
      266			 IFIDN <MTO,  ;;IF SET TO ONES WANTED
      267			   ..TX2==1
      268			   ORCMI AC,-..TX1 ;;CAN DO IT WITH IORCM
      269			 IFIDN <MTC,  ;;IF COMPLEMENT WANTED
      270			   ..TX2==1
      271			   EQVI AC,-..TX1 ;;CAN DO IT WITH EQV
      272
      273			 SUBTTL JX -- JUMP ON MASK
      274
      275		       ;JXE -- JUMP IF MASKED BITS ARE EQUAL TO 0
      276		       ;JXN -- JUMP IF MASKED BITS ARE NOT EQUAL TO 0
      277		       ;JXO -- JUMP IF MASKED BITS ARE ALL ONES
      278		       ;JXF -- JUMP IF MASKED BITS ARE NOT ALL ONES (FALSE)
      279
      280		       DEFINE JXE (AC,MSK,BA)<
      281			 ..JX1==MSK  ;;EVAL EXPRESSION IF ANY
      282		       IFDEF .PSECT,<
      283			 .IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
      284			  ..JX1==0
      285			 .IF ..JX1,ABSOLUTE,<
      286			 .IF0 <<..JX1-1B0, ;;IF MASK IS JUST B0,
      287			  JUMPGE AC,BA,
      288			 .IF0 <<..JX1+1, ;;IF MASK IF FULL WORD,
      289			   JUMPE AC,BA, ;;USE GIVEN CONDITION
      290			  TXNN (AC,..JX1)
      291			  JRST BA
      292			 PURGE ..JX1
      293		       IFNDEF .PSECT,<
      294			 .IF0 <<..JX1-1B0, ;;IF MASK IS JUST B0,
      295			  JUMPGE AC,BA,
      296			 .IF0 <<..JX1+1, ;;IF MASK IF FULL WORD,
      297			   JUMPE AC,BA, ;;USE GIVEN CONDITION
      298			  TXNN (AC,..JX1)
      299			  JRST BA
      300			 PURGE ..JX1
      301
      302		       DEFINE JXN (AC,MSK,BA)<
      303			 ..JX1==MSK  ;;EVAL EXPRESSION IF ANY
      304		       IFDEF .PSECT,<
      305			 .IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
      306			  ..JX1==0
      307			 .IF ..JX1,ABSOLUTE,<
      308			 .IF0 <<..JX1-1B0, ;;IF MASK IS JUST B0,
      309			  JUMPL AC,BA,
      310			 .IF0 <<..JX1+1, ;;IF MASK IF FULL WORD,
      311			   JUMPN AC,BA, ;;USE GIVEN CONDITION

      313			  JRST BA
      314			 PURGE ..JX1
      315		       IFNDEF .PSECT,<
      316			 .IF0 <<..JX1-1B0, ;;IF MASK IS JUST B0,
      317			  JUMPL AC,BA,
      318			 .IF0 <<..JX1+1, ;;IF MASK IF FULL WORD,
      319			   JUMPN AC,BA, ;;USE GIVEN CONDITION
      320			  TXNE (AC,..JX1)
      321			  JRST BA
      322			 PURGE ..JX1
      323
      324		       DEFINE JXO (AC,MSK,BA)<
      325			 ..JX1==MSK  ;;EVAL EXPRESSION
      326		       IFDEF .PSECT,<
      327			 .IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
      328			  ..JX1==0
      329			 .IF ..JX1,ABSOLUTE,<
      330			 .IF0 <<..JX1-1B0,
      331			  JUMPL AC,BA,
      332			 ..ONEB (..BT,MSK) ;;TEST MASK FOR ONLY ONE BIT ON
      333			 .IF0 ..BT,<
      334			   SETCM .SAC,AC  ;;GENERAL CASE, GET COMPLEMENTS OF BITS
      335			   JXE (.SAC,..JX1,BA), ;;JUMP IF BITS WERE ORIGINALLY ONES
      336			     TXNE AC,..JX1 ;;TEST AND JUMP
      337			     JRST BA
      338			 PURGE ..JX1
      339		       IFNDEF .PSECT,<
      340			 .IF0 <<..JX1-1B0,
      341			  JUMPL AC,BA,
      342			 ..ONEB (..BT,MSK) ;;TEST MASK FOR ONLY ONE BIT ON
      343			 .IF0 ..BT,<
      344			   SETCM .SAC,AC  ;;GENERAL CASE, GET COMPLEMENTS OF BITS
      345			   JXE (.SAC,..JX1,BA), ;;JUMP IF BITS WERE ORIGINALLY ONES
      346			     TXNE AC,..JX1 ;;TEST AND JUMP
      347			     JRST BA
      348			 PURGE ..JX1
      349
      350		       DEFINE JXF (AC,MSK,BA)<
      351			 ..JX1==MSK  ;;EVAL EXPRESSION
      352		       IFDEF .PSECT,<
      353			 .IFN ..JX1,ABSOLUTE,<PRINTX MSK NOT ABSOLUTE
      354			  ..JX1==0
      355			 .IF ..JX1,ABSOLUTE,<
      356			 .IF0 <<..JX1-1B0,
      357			  JUMPGE AC,BA,
      358			 ..ONEB (..BT,MSK) ;;TEST MASK FOR ONLY ONE BIT ON
      359			 .IF0 ..BT,<
      360			   SETCM .SAC,AC  ;;GENERAL CASE, GET COMPLEMENT OF BITS
      361			   JXN (.SAC,..JX1,BA), ;;JUMP IF SOME ZEROS ORIGINALLY
      362			     TXNN AC,..JX1 ;;TEST AND JUMP
      363			     JRST BA
      364			 PURGE ..JX1
      365		       IFNDEF .PSECT,<

      367			  JUMPGE AC,BA,
      368			 ..ONEB (..BT,MSK) ;;TEST MASK FOR ONLY ONE BIT ON
      369			 .IF0 ..BT,<
      370			   SETCM .SAC,AC  ;;GENERAL CASE, GET COMPLEMENT OF BITS
      371			   JXN (.SAC,..JX1,BA), ;;JUMP IF SOME ZEROS ORIGINALLY
      372			     TXNN AC,..JX1 ;;TEST AND JUMP
      373			     JRST BA
      374			 PURGE ..JX1
      375
      376			 SUBTTL SUBFUNCTION MACROS
      377
      378		       ;.IF0 CONDITION, ACTION IF CONDITION 0, ACTION OTHERWISE
      379
      380		       DEFINE .IF0 (COND,THEN,ELSE)<
      381			 ..IFT==COND  ;;GET LOCAL VALUE FOR CONDITION
      382			 IFE ..IFT,<
      383			 THEN
      384			 ..IFT==0  ;;RESTORE IN CASE CHANGED BY NESTED .IF0
      385			 IFN ..IFT,<
      386			 ELSE
      387
      388		       ;CASE (NUMBER,<FIRST,SECOND,...,NTH)
      389
      390		       DEFINE .CASE (NUM,LIST)<
      391			 ..CSN==NUM
      392			 ..CSC==0
      393			 IRP LIST,<
      394			 IFE ..CSN-..CSC,<
      395			   STOPI
      396			   ..CAS1 (LIST)
      397			 ..CSC==..CSC+1
      398
      399		       DEFINE ..CAS1 (LIST)<
      400			 LIST
      401
      402		       ;TEST FOR FULL WORD, RH, LH, OR ARBITRARY BYTE
      403
      404		       DEFINE ..TSIZ (SYM,MSK)<
      405			 SYM==3   ;;ASSUME BYTE UNLESS...
      406			 IFE <MSK+1,SYM=0 ;;FULL WORD IF MASK IS -1
      407			 IFE <MSK-O777777,SYM==1 ;;RH IF MASK IS 777777
      408			 IFE <MSK-O777777B17,SYM==2 ;;LH IF MAST IS 777777,,0
      409
      410		       ;TEST FOR LOC BEING AN AC -- SET SYM TO 1 IF AC, 0 IF NOT AC
      411
      412		       DEFINE ..TSAC (SYM,LOC)<
      413			 IFNDEF .PSECT,<
      414			 SYM==0   ;;ASSUME NOT AC UNLESS...
      415			 ..TSA1==<Z LOC  ;;LOOK AT LOC
      416			   IFE ..TSA1O777777777760,<SYM==1 ;;AC IF VALUE IS 0-17					     _
      417
      418			 IFDEF .PSECT,<
      419			 SYM==0   ;;ASSUME NOT AC UNLESS...

      421			 .IF ..TSA1,ABSOLUTE,< ;;SEE IF WE CAN TEST VALUE
      422			   IFE ..TSA1O777777777760,<SYM==1 ;;AC IF VALUE IS 0-17					     _
      423			 PURGE ..TSA1
      424
      425		       ;FUNCTION TO TEST FOR MASK CONTAINING EXACTLY ONE BIT. RETURNS
      426		       ;1 IFF LEFTMOST BIT AND RIGHTMOST BIT ARE SAME
      427
      428		       DEFINE ..ONEB (SYM,MSK)<
      429			 SYM==<<<-<MSKMSK1B<L<MSK					      _  _
      430
      431		       ;DEFAULT SCRACH AC
      432
      433      000016		 .SAC=16
      434
      435			 SUBTTL DEFSTR -- DEFINE DATA STRUCTURE
      436
      437		       ;DEFINE DATA STRUCTURE
      438		       ; NAM - NAME OF STRUCTURE AS USED IN CODE
      439		       ; LOCN - ADDRESS OF DATA
      440		       ; POS - POSITION OF DATA WITHIN WORD (RIGHTMOST BIT NUMBER)
      441		       ; SIZ - SIZE OF DATA (IN BITS) WITHIN WORD
      442
      443		       DEFINE DEFSTR (NAM,LOCN,POS,SIZ)<
      444			 NAM==<-1B<POS+1BPOS-SIZ ;;ASSIGN SYMBOL TO HOLD MASK
      445			 IF1,<IFDEF %'NAM,<PRINTX ?NAM ALREADY DEFINED
      446			 DEFINE %'NAM (OP,AC,Y,MSK)<
      447			 OP (<AC,LOCN''Y,MSK) ;;DEFINE MACRO TO HOLD LOCATION
      448
      449		       ;ALTERNATE FORM OF DEFSTR -- TAKES MASK INSTEAD OF POS,SIZ
      450
      451		       DEFINE MSKSTR (NAM,LOCN,MASK)<
      452			 NAM==MASK  ;;ASSIGN SYMBOL TO HOLD MASK
      453			 IF1,<IFDEF %'NAM,<PRINTX ?NAM ALREADY DEFINED
      454			 DEFINE %'NAM (OP,AC,Y,MSK)<
      455			 OP (<AC,LOCN''Y,MSK) ;;DEFINE MACRO TO HOLD LOCATION
      456
      457		       ;..STR0 - PROCESS INSTANCE OF STRUCTURE USAGE, SINGLE STRUCTURE CASE.
      458
      459		       DEFINE ..STR0 (OP,AC,STR,Y)<
      460			 IFNDEF STR,<PRINTX STR IS NOT DEFINED
      461			   OP (<AC,Y,.FWORD) ;;RESERVE A WORD, ASSUME WORD MASK
      462			 IFDEF STR,<
      463			 IFNDEF %'STR,<
      464			   OP (<AC,Y,STR) ;;ASSUME NO OTHER LOCN
      465			 IFDEF %'STR,<
      466			   %'STR (OP,<AC,Y,STR) ;;DO IT
      467		       ;..STR1, ..STR2, ..STR3, AND ..STR4 ARE INTERNAL MACROS FOR PROCESSING
      468		       ;INSTANCES OF STRUCTURE USAGE.
      469
      470		       DEFINE ..STR1 (OP,AC,STR,Y,CLL)<
      471			 ..NS==0   ;;INIT COUNT OF STR'S
      472			 IRP STR,<..NS=..NS+1 ;;COUNT STR'S
      473			 IFE ..NS,<PRINTX ?EMPTY STRUCTURE LIST, OP

      475			   ..STR0 (OP,<AC,STR,Y)
      476			 IFG ..NS-1,<  ;;MORE THAN ONE, DO GENERAL CASE
      477			 ..ICNS   ;;INIT REMOTE MACRO
      478			 ..CNS (<CLL (OP,<AC,,) ;;CONS ON CALL AND FIRST ARGS
      479			 IRP STR,<  ;;DO ALL NAMES IN LIST
      480			   IFNDEF STR,<PRINTX STR NOT DEFINED
      481			   IFDEF STR,<
      482			   IFNDEF %'STR,<
      483			   ..CNS (<,STR,Y) ;;ASSUME NO OTHER LOCN
      484			   IFDEF %'STR,<
      485			   %'STR (..STR2,,Y,STR) ;;STR MACRO WILL GIVE LOCN TO ..STR2
      486			   ..CNS (<))  ;;CLOSE ARG LIST
      487			   ..GCNS  ;;DO THIS AND PREVIOUS NAME
      488			   ..ICNS  ;;REINIT CONS
      489			   ..CNS (<CLL (OP,<AC) ;;PUT ON FIRST ARGS
      490			   IFNDEF %'STR,<
      491			   ..CNS (<,STR,Y) ;;ASSUME NO OTHER LOCN
      492			   IFDEF %'STR,<
      493			   %'STR (..STR2,,Y,STR) ;;PUT ON THIS ARG, END IRP
      494			 ..CNS (<,,))  ;;CLOSE ARG LIST
      495			 ..GCNS  ;;DO LAST CALL
      496
      497		       ;..STR2 -- CALLED BY ABOVE TO APPEND STRUCTURE NAME AND LOC TO ARG LIST
      498
      499		       DEFINE ..STR2 (AA,LOC,STR)<
      500			 ..CNS (<,STR,LOC) ;;CONS ON NEXT ARG PAIR
      501
      502		       ;..STR3 -- CHECK FOR ALL STRUCTURES IN SAME REGISTER
      503
      504		       DEFINE ..STR3 (OP,AC,S1,L1,S2,L2)<
      505			 IFDIF <L1L2,
      506			   IFNB <L1,
      507			     OP (<AC,L1,..MSK) ;;DO ACCUMULATED STUFF
      508			     IFNB <L2,PRINTX S1 AND S2 ARE IN DIFFERENT WORDS
      509			   ..MSK==0  ;;INIT MASK
      510			 IFNB <L2,
      511			   ..MSK=..MSK!<S2
      512
      513		       ;..STR4 -- COMPARE SUCCESSIVE ITEMS, DO SEPARATE OPERATION IF
      514		       ;DIFFERENT WORDS ENCOUNTERED
      515
      516		       DEFINE ..STR4 (OP,AC,S1,L1,S2,L2)<
      517			 IFDIF <L1L2, ;;IF THIS DIFFERENT FROM PREVIOUS
      518			   IFNB <L1,
      519			     OP (<AC,L1,..MSK) ;;DO PREVIOUS
      520			   ..MSK==0  ;;REINIT MASK
      521			 IFNB <L2,
      522			   ..MSK=..MSK!<S2 ;;ACCUMULATE MASK
      523
      524		       ;..STR5 - SAME AS ..STR4 EXCEPT GIVES EXTRA ARG IF MORE STUFF TO
      525		       ;FOLLOW.
      526
      527		       DEFINE ..STR5 (OP,AC,S1,L1,S2,L2)<

      529			   IFNB <L1,
      530			     IFNB <L2,	;;IF MORE TO COME,
      531			  OP'1 (AC,L1,..MSK) ;;DO VERSION 1
      532			     IFB <L2,  ;;IF NO MORE,
      533			  OP'2 (AC,L1,..MSK) ;;DO VERSION 2
      534			   ..MSK==0  ;;REINIT MASK
      535			 IFNB <L2,
      536			   ..MSK=..MSK!<S2 ;;ACCUMULATE MASK
      537
      538		       ;'REMOTE' MACROS USED TO BUILD UP ARG LIST
      539
      540		       ;INITIALIZE CONS -- DEFINES CONS
      541
      542		       DEFINE ..ICNS <
      543			  DEFINE ..CNS (ARG)<
      544			 ..CNS2 <ARG,
      545
      546			  DEFINE ..CNS2 (NEW,OLD)<
      547			 DEFINE ..CNS (ARG)<
      548			   ..CNS2 <ARG,OLD'NEW
      549
      550
      551		       ;GET CONS -- EXECUTE STRING ACCUMULATED
      552
      553		       DEFINE ..GCNS <
      554			  DEFINE ..CNS2 (NEW,OLD)<
      555			   OLD	 ;;MAKE ..CNS2 DO THE STUFF
      556			 ..CNS ()  ;;GET ..CNS2 CALLED WITH THE STUFF
      557
      558		       ;SPECIFIC CASES
      559
      560		       ;LOAD, STORE
      561		       ; AC - AC OPERAND
      562		       ; STR - STRUCTURE NAME
      563		       ; Y - (OPTIONAL) ADDITIONAL SPECIFICATION OF DATA LOCATION
      564
      565		       DEFINE LOAD (AC,STR,Y)<
      566			 ..STR0 (..LDB,AC,STR,Y)
      567
      568			  DEFINE ..LDB (AC,LOC,MSK)<
      569			 ..TSIZ (..PST,MSK)
      570			 .CASE ..PST,<<
      571			  MOVE AC,LOC,
      572			  HRRZ AC,LOC,
      573			  HLRZ AC,LOC,
      574			  LDB AC,[POINTR (LOC,MSK)]
      575
      576		       DEFINE STOR (AC,STR,Y)<
      577			 ..STR0 (..DPB,AC,STR,Y)
      578
      579			  DEFINE ..DPB (AC,LOC,MSK)<
      580			 ..TSIZ (..PST,MSK)
      581			 .CASE ..PST,<<

      583			  HRRM AC,LOC,
      584			  HRLM AC,LOC,
      585			  DPB AC,[POINTR (LOC,MSK)]
      586
      587		       ;SET TO ZERO
      588
      589		       DEFINE SETZRO (STR,Y)<
      590			 ..STR1 (..TQZ,,<STR,Y,..STR4)
      591
      592			  DEFINE ..TQZ (AC,LOC,MSK)<
      593			 ..TSIZ (..PST,MSK) ;;SET ..PST TO CASE NUMBER
      594			 .CASE ..PST,<<
      595			  SETZM LOC, ;;FULL WORD
      596			  HLLZS LOC, ;;RH
      597			  HRRZS LOC, ;;LH
      598			   ..TSAC (..ACT,LOC) ;;SEE IF LOC IS AC
      599			   .IF0 ..ACT,<
      600			  MOVX .SAC,MSK ;;NOT AC
      601			  ANDCAM .SAC,LOC,
      602			  ..TX (Z,LOC,MSK)
      603
      604		       ;SET TO ONE
      605
      606		       DEFINE SETONE (STR,Y)<
      607			 ..STR1 (..TQO,,<STR,Y,..STR4)
      608
      609			  DEFINE ..TQO (AC,LOC,MSK)<
      610			 ..TSIZ (..PST,MSK)
      611			 .CASE ..PST,<<
      612			  SETOM LOC,
      613			  HLLOS LOC,
      614			  HRROS LOC,
      615			   ..TSAC (..ACT,LOC)
      616			   .IF0 ..ACT,<
      617			  MOVX .SAC,MSK
      618			  IORM .SAC,LOC,
      619			  ..TX (O,LOC,MSK)
      620
      621		       ;SET TO COMPLEMENT
      622
      623		       DEFINE SETCMP (STR,Y)<
      624			 ..STR1 (..TQC,,<STR,Y,..STR4)
      625
      626			  DEFINE ..TQC (AC,LOC,MSK)<
      627			 ..TSIZ (..PST,MSK)
      628			 .IF0 ..PST,<  ;;IF FULL WORD,
      629			  SETCMM LOC, ;;CAN USE SETCMM
      630			   ..TSAC (..ACT,LOC) ;;OTHERWISE, CHECK FOR AC
      631			   .IF0 ..ACT,<
      632			  MOVX .SAC,MSK
      633			  XORM .SAC,LOC,
      634			  ..TX(C,LOC,MSK)
      635

      637
      638		       DEFINE INCR (STR,Y)<
      639			 ..STR0 (.INCR0,,<STR,Y)
      640
      641			  DEFINE .INCR0 (AC,LOC,MSK)<
      642			 ..PST==MSK<-MSK ;;GET LOWEST BIT					   _
      643			 .IF0 ..PST-1,<
      644			  AOS LOC, ;;BIT 35, CAN USE AOS
      645			  MOVX .SAC,..PST ;;LOAD A ONE IN THE APPROPRIATE POSITION
      646			  ADDM .SAC,LOC
      647
      648		       DEFINE DECR (STR,Y)<
      649			 ..STR0 (.DECR0,,<STR,Y)
      650
      651			  DEFINE .DECR0 (AC,LOC,MSK)<
      652			 ..PST==MSK<-MSK					   _
      653			 .IF0 ..PST-1,<
      654			  SOS LOC, ;;BIT 35, CAN USE SOS
      655			  MOVX .SAC,-..PST ;;LOAD -1 IN APPROPRIATE POSITION
      656			  ADDM .SAC,LOC
      657
      658		       ;GENERAL DEFAULT, TAKES OPCODE
      659
      660		       DEFINE OPSTR (OP,STR,Y)<
      661			 ..STR0 (.OPST1,<OP,STR,Y)
      662
      663			  DEFINE .OPST1 (OP,LOC,MSK)<
      664			 ..TSIZ (..PST,MSK)
      665			 .IF0 ..PST,<
      666			  OP LOC, ;;FULL WORD, USE GIVEN OP DIRECTLY
      667			  ..LDB .SAC,LOC,MSK ;;OTHERWISE, GET SPECIFIED BYTE
      668			  OP .SAC
      669
      670		       DEFINE OPSTRM (OP,STR,Y)<
      671			 ..STR0 (.OPST2,<OP,STR,Y)
      672
      673			  DEFINE .OPST2 (OP,LOC,MSK)<
      674			 ..TSIZ (..PST,MSK)
      675			 .IF0 ..PST,<
      676			  OP LOC, ;;FULL WORD, USE OP DIRECTLY
      677			  ..LDB .SAC,LOC,MSK
      678			  OP .SAC
      679			  ..DPB .SAC,LOC,MSK
      680
      681		       ;JUMP IF ALL FIELDS ARE 0 (ONE REGISTER AT MOST)
      682
      683		       DEFINE JE (STR,Y,BA)<
      684			 ..STR1 (..JE,<BA,STR,Y,..STR3)
      685
      686			  DEFINE ..JE (BA,LOC,MSK)<
      687			 ..TSAC (..ACT,LOC) ;;SEE IF AC
      688			 .IF0 ..ACT,<
      689			   ..TSIZ (..PST,MSK) ;;SEE WHICH CASE

      691			  SKIPN LOC ;;FULL WORD, TEST IN MEMORY
      692			  JRST BA,
      693			  HRRZ .SAC,LOC ;;RIGHT HALF, GET IT
      694			  JUMPE .SAC,BA,
      695			  HLRZ .SAC,LOC ;;LEFT HALF, GET IT
      696			  JUMPE .SAC,BA,
      697			  MOVE .SAC,LOC ;;NOTA, GET WORD
      698			  JXE (.SAC,MSK,<BA),
      699			   JXE (LOC,MSK,<BA)
      700
      701		       ;JUMP IF NOT ALL FIELDS ARE 0 (ONE REGISTER AT MOST)
      702
      703		       DEFINE JN (STR,Y,BA)<
      704			 ..STR1 (..JN,<BA,STR,Y,..STR3)
      705
      706			  DEFINE ..JN (BA,LOC,MSK)<
      707			 ..TSAC (..ACT,LOC) ;;SEE IF AC
      708			 .IF0 ..ACT,<
      709			   ..TSIZ (..PST,MSK)
      710			   .CASE ..PST,<<
      711			  SKIPE LOC ;;FULL WORD, TEST IN MEMORY
      712			  JRST BA,
      713			  HRRZ .SAC,LOC ;;RIGHT HALF, GET IT
      714			  JUMPN .SAC,BA,
      715			  HLRZ .SAC,LOC ;;LEFT HALF, GET IT
      716			  JUMPN .SAC,BA,
      717			  MOVE .SAC,LOC ;;NOTA, GET WORD
      718			  JXN (.SAC,MSK,<BA),
      719			   JXN (LOC,MSK,<BA)
      720
      721		       ;JOR - JUMP ON 'OR' OF ALL FIELDS
      722
      723		       DEFINE JOR (STR,Y,BA)<
      724			 ..STR1 (..JN,<BA,STR,Y,..STR4)
      725
      726		       ;JNAND - JUMP ON NOT 'AND' OF ALL FIELDS
      727
      728		       DEFINE JNAND (STR,Y,BA)<
      729			 ..STR1 (..JNA3,<BA,STR,Y,..STR4)
      730
      731			  DEFINE ..JNA3 (BA,LOC,MSK)<
      732			 ..TSAC (..ACT,LOC)
      733			 .IF0 ..ACT,<
      734			   SETCM .SAC,LOC ;;NOT AC, GET COMPLEMENT OF WORD
      735			   JXN (.SAC,MSK,<BA), ;;JUMP IF ANY BITS ORIGINALLY OFF
      736			   JXF (LOC,MSK,<BA) ;;DO AC CASE
      737
      738		       ;JAND - JUMP ON 'AND' OF ALL FIELDS
      739
      740		       DEFINE JAND (STR,Y,BA,%TG)<
      741			 ..STR1 (..JAN,<%TG,<BA,STR,Y,..STR5)
      742		       %TG:
      743

      745			 ..JNA3 (BA1,LOC,MSK) ;;DO JUMP NAND TO LOCAL TAG
      746
      747			  DEFINE ..JAN2 (BA1,BA2,LOC,MSK)<
      748			 ..TSAC (..ACT,LOC)
      749			 .IF0 ..ACT,<
      750			   SETCM .SAC,LOC ;;NOT AC, GET COMPLEMENT OF WORD
      751			   JXE (.SAC,MSK,<BA2), ;;JUMP IF ALL BITS ORIGINALLY ONES
      752			   JXO (LOC,MSK,<BA2) ;;DO AC CASE
      753
      754		       ;JNOR - JUMP ON NOT 'OR' OF ALL FIELDS
      755
      756		       DEFINE JNOR (STR,Y,BA,%TG)<
      757			 ..STR1 (..JNO,<%TG,<BA,STR,Y,..STR5)
      758		       %TG:
      759
      760			  DEFINE ..JNO1 (BA1,BA2,LOC,MSK)<
      761			 ..JN (BA1,LOC,MSK) ;;DO JUMP OR TO LOCAL TAG
      762
      763			  DEFINE ..JNO2 (BA1,BA2,LOC,MSK)<
      764			 ..JE (<BA2,LOC,MSK) ;;DO JUMP NOR TO GIVEN TAG
      765
      766		       ;TEST AND MODIFY GROUP USING DEFINED STRUCTURES.  TEST-ONLY AND
      767		       ;MODIFY-ONLY PROVIDED FOR COMPLETENESS.
      768
      769		       DEFINE ..DOTY (M,T)<  ;;MACRO TO DEFINE ALL CASES
      770			 IRP M,<
      771			 IRP T,<
      772			   DEFINE TQ'M'T (STR,Y)<
      773			     ..STR1 (..TY,M'T,<STR,Y,..STR3)
      774
      775			 ..DOTY (<N,O,Z,C,,E,N,A) ;DO 16 DEFINES
      776			 PURGE ..DOTY
      777
      778		       ;ALL TY MACROS CALL ..TY AFTER INITIAL STRUCTURE PROCESSING
      779
      780		       DEFINE ..TY (MT,LOC,MSK)<
      781			 ..TSAC (..ACT,LOC) ;;SEE IF LOC IS AC
      782			 .IF0 ..ACT,<
      783			  PRINTX ?TQ'MT - LOC NOT IN AC,
      784			  TX'MT LOC,MSK
      785
      786			 SUBTTL CALL, RET, JSERR
      787
      788			  IFE REL,<
      789			 EXTERN JSERR0,JSHLT0,R,RSKP
      790
      791		       ;CALL AND RETURN
      792
      793      000001		 .AC1==1    ;ACS FOR JSYS ARGS
      794      000002		 .AC2==2
      795      000003		 .AC3==3
      796      000016		 .A16==16   ;TEMP FOR STKVAR AND TRVAR
      797      000017		 P=17	 ;STACK POINTER

      799    260740  000000	 OPDEF CALL [PUSHJ P,0]
      800    263740  000000	 OPDEF RET [POPJ P,0]
      801
      802		       ;ABBREVIATION FOR  CALL, RET, RETSKP
      803
      804    254000  000000	 OPDEF CALLRET [JRST]
      805		       .NODDT CALLRET
      806
      807		       DEFINE RETSKP <
      808			 JRST RSKP
      809
      810		       ;MACRO TO PRINT MESSAGE ON TERMINAL
      811
      812		       DEFINE TMSG ($MSG)<
      813			 HRROI .AC1,[ASCIZ $MSG]
      814			 PSOUT
      815
      816		       ;MACRO TO OUTPUT MESSAGE TO FILE
      817		       ; ASSUMES JFN ALREADY IN .AC1
      818
      819		       DEFINE FMSG ($MSG)<
      820			 HRROI .AC2,[ASCIZ $MSG]
      821			 MOVEI .AC3,0
      822			 SOUT
      823
      824		       ;MACRO TO PRINT MESSAGE FOR LAST ERROR, RETURNS +1
      825
      826		       DEFINE PERSTR ($MSG)<
      827			  IFNB <$MSG,
      828			 TMSG <$MSG
      829			 CALL JSMSG0
      830
      831		       ;MACRO TO PRINT JSYS ERROR MESSAGE, RETURNS +1 ALWAYS
      832
      833		       DEFINE JSERR<
      834			 CALL JSERR0
      835
      836		       ;MACRO FOR FATAL JSYS ERROR, PRINTS MSG THEN HALTS
      837
      838		       DEFINE JSHLT<
      839			 CALL JSHLT0
      840
      841		       ;PRINT ERROR MESSAGE IF JSYS FAILS
      842
      843		       DEFINE ERMSG(TEXT),<
      844			 ERJMP [TMSG <? TEXT
      845			   JSHLT]
      846
      847
      848		       ;MAKE SYMBOLS EXTERN IF NOT ALREADY DEFINED
      849
      850		       DEFINE EXT (SYM)<
      851			  IF2,<

      853			 IFNDEF SYM,<EXTERN SYM
      854			 SUPPRE SYM
      855
      856		       ;MACRO TO ADD BREAK CHARACTER TO FOUR WORD BREAK MASK (W0., W1., W2., W3.)
      857
      858		       DEFINE BRKCH. (%%V,V2)
      859		       < BRK1 (%%V,V2,0)
      860
      861
      862		       ;MACRO TO REMOVE CHARACTER
      863
      864		       DEFINE UNBRK. (%%V,V2)
      865		       < BRK1 (%%V,V2,1)
      866
      867
      868		       DEFINE BRK1 (%%V,V2,FLAVOR)
      869		       < V22==%%V
      870			 V1==%%V
      871			 IFNB <V2,V22==V2
      872		       REPEAT V22-<%%V+1, ;;BRACKETS AROUND %%V IN CASE ITS AN EXPRESSION
      873			 %%W==V1/D32 ;;DECIDE WHICH WORD CHARACTER GOES IN
      874			 %%X==V1-%%W*D32 ;;CALCULATE BIT POSITION WITHIN WORD
      875			 IFE FLAVOR,BRKC1 "<%%W+"0" ;;MODIFY CORRECT MASK WORD
      876			 IFN FLAVOR,BRKC2 "<%%W+"0"
      877			 V1==V1+1
      878
      879
      880
      881		       DEFINE BRKC1 (ARG1)
      882		       < W'ARG1'.==W'ARG1'.!<1B<%%X
      883
      884
      885		       DEFINE BRKC2 (ARG1)
      886		       < W'ARG1'.==W'ARG1'.<-1-1B<%%X						   _
      887
      888
      889		       ;MACRO TO INITIALIZE 4-WORD 12-BIT CHARACTER BREAK MASK
      890
      891		       DEFINE BRINI.(A0<0,A10,A20,A30)
      892		       <
      893		       W0.==A0
      894		       W1.==A1	  ;INITIALIZE BREAK MASK
      895		       W2.==A2
      896		       W3.==A3
      897
      898
      899		       ;MACRO TO DEFINE A BREAK SET
      900
      901		       DEFINE BRMSK. (INI0,INI1,INI2,INI3,ALLOW,DISALW)
      902		       < BRINI. INI0,INI1,INI2,INI3 ;;SET UP INITIAL MASK
      903			 IRPC ALLOW,< UNBRK. "ALLOW" ;;DON'T BREAK ON CHARS TO BE ALLOWED IN FIELD
      904			 IRPC DISALW,< BRKCH. "DISALW" ;;BREAK ON CHARACTERS NOT ALLOWED
      905			 EXP W0.,W1.,W2.,W3.  ;;STORE RESULTANT MASK IN MEMORY

      907
      908		       ;COMND - MACRO FOR BUILDING FUNCTION DESCRIPTOR BLOCK
      909		       ;THIS IS THE OLD ONE, BEFORE .CMBRK EXISTED.  USE FLDBK. FOR SPECIFYING
      910		       ;BREAK SETS
      911
      912		       DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST)<
      913			 ..XX==<FLD(TYP,CM%FNC)+FLGS+Z LST
      914			  IFNB <HLPM,..XX=CM%HPP!..XX
      915			  IFNB <DEFM,..XX=CM%DPP!..XX
      916			 ..XX
      917			  IFNB <DATA,DATA
      918			  IFB <DATA,0
      919			  IFNB <HLPM,POINT 7,[ASCIZ hLPM]
      920			  IFB <HLPM,IFNB <DEFM,0
      921			  IFNB <DEFM,POINT 7,[ASCIZ dEFM]
      922
      923		       ;COMND - MACRO FOR BUILDING FUNCTION DESCRIPTOR BLOCK
      924
      925		       DEFINE FLDBK. (TYP,FLGS,DATA,HLPM,DEFM,BRKADR,LST)<
      926			 ..XX==<FLD(TYP,CM%FNC)+FLGS+Z LST
      927			  IFNB <HLPM,..XX=CM%HPP!..XX
      928			  IFNB <DEFM,..XX=CM%DPP!..XX
      929			  IFNB <BRKADR,..XX=CM%BRK!..XX
      930			 ..XX
      931			  IFNB <DATA,DATA
      932			  IFB <DATA,0
      933			  IFNB <HLPM,POINT 7,[ASCIZ hLPM]
      934			  IFB <HLPM,IFNB <DEFM'BRKADR,0
      935			  IFB <DEFM,IFNB <BRKADR,0
      936			  IFNB <DEFM,POINT 7,[ASCIZ dEFM]
      937			  IFNB <BRKADR,BRKADR
      938
      939
      940		       ;USEFUL EXTENDED ADDRESSING DEFINITIONS
      941
      942    415000  000000	 OPDEF XMOVEI [SETMI]  ;EXTENDED MOVE IMMEDIATE
      943    501000  000000	 OPDEF XHLLI [HLLI]  ;NOT YET IN MACRO
      944
      945		       DEFINE XBLT. (A)<
      946			 EXTEND A,[XBLT]
      947
      948			 SUBTTL SUPPORT CODE FOR JSERR
      949
      950			  IFN REL,<
      951
      952		       A=1
      953		       B=2
      954		       C=3
      955		       D=4
      956
      957		       ;JSYS ERROR HANDLER
      958		       ; CALL JSERR0
      959		       ; RETURNS +1: ALWAYS, CAN BE USED IN +1 RETURN OF JSYS'S

      961		       JSERR0::MOVEI A,.PRIIN
      962			 CFIBF	 ;CLEAR TYPAHEAD
      963			 MOVEI A,.PRIOU
      964			 DOBE	;WAIT FOR PREVIOUS OUTPUT TO FINISH
      965			 TMSG <
      966		       ? JSYS ERROR:
      967		       JSMSG0::MOVEI A,.PRIOU
      968			 HRLOI B,.FHSLF  ;SAY  THIS FORK ,, LAST ERROR
      969			 SETZ C,
      970			 ERSTR
      971			  JFCL
      972			  JFCL
      973			 TMSG <
      974
      975			 RET
      976
      977		       ;FATAL JSYS ERROR - PRINT MESSAGE AND HALT
      978		       ; CALL JSHLT0
      979		       ; RETURNS: NEVER
      980
      981		       JSHLT0::CALL JSERR0  ;PRINT THE MSG
      982		       JSHLT1: HALTF
      983			 TMSG <PROGRAM CANNOT CONTINUE
      984
      985			 JRST JSHLT1  ;HALT AGAIN IF CONTINUED
      986			      ;END OF IFN REL,
      987
      988			 SUBTTL STKVAR - STACK VARIABLE FACILITY
      989
      990		       ;MACRO FOR ALLOCATING VARIABLES ON THE STACK. ITS ARGUMENT IS
      991		       ;A LIST OF ITEMS.  EACH ITEM MAY BE:
      992		       ; 1. A SINGLE VARIABLE WHICH WILL BE ALLOCATED ONE WORD
      993		       ; 2. A VARIABLE AND SIZE PARAMETER WRITTEN AS <VAR,SIZ.	THE
      994		       ; VARIABLE WILL BE ALLOCATED THE SPECIFIED NUMBER OF WORDS.
      995		       ;RETURN FROM A SUBROUTINE USING THIS FACILITY MUST BE VIA
      996		       ;RET OR RETSKP.	A DUMMY RETURN WHICH FIXES UP THE STACK IS PUT ON
      997		       ;THE STACK AT THE POINT THE STKVAR IS ENCOUNTERED.
      998		       ;WITHIN THE RANGE OF A STKVAR, PUSH/POP CANNOT BE USED AS THEY WILL
      999		       ;CAUSE THE VARIABLES (WHICH ARE DEFINED AS RELATIVE STACK LOCATIONS)
     1000		       ;TO REFERENCE THE WRONG PLACE.
     1001		       ;TYPICAL USE:   STKVAR <AA,BB,<QQ,5,ZZ
     1002
     1003			  IFE REL,<
     1004			 EXTERN .STKST,.ST
     1005
     1006		       DEFINE STKVAR (ARGS)<
     1007			 ..STKR==10  ;;REMEMBER RADIX
     1008			 RADIX 8
     1009			 ..STKN==0
     1010			 IRP ARGS,<
     1011			   .STKV1 (ARGS)
     1012			 JSP .A16,.STKST
     1013			  ..STKN,,..STKN

     1015			 PURGE ..STKN,..STKR,..STKQ
     1016
     1017
     1018		       ;INTERMEDIATE MACRO TO PEAL OFF ANGLEBRACKETS IF ANY
     1019
     1020		       DEFINE .STKV1 (ARG)<
     1021			 .STKV2 (ARG)
     1022
     1023		       ;INTERMEDIATE MACRO TO CALCULATE OFFSET AND COUNT VARIABLES
     1024
     1025		       DEFINE .STKV2 (VAR,SIZ)<
     1026			 IFB <SIZ,..STKN==..STKN+1
     1027			 IFNB <SIZ,..STKN==..STKN+SIZ
     1028			 ..STKQ==..STKN+1
     1029			 .STKV3 (VAR,..STKQ)
     1030
     1031		       ;INNERMOST MACRO TO DEFINE VARIABLE
     1032
     1033		       DEFINE .STKV3 (VAR,LOC)<
     1034			  IFDEF VAR,<.IF VAR,SYMBOL,<PRINTX STKVAR VAR ALREADY DEFINED
     1035			 DEFINE VAR<-O'LOC(P)
     1036			 $'VAR==<Z VAR	;SYMBOL FOR DDT
     1037
     1038			  IFN REL,<
     1039
     1040		       ;COMMON ENTRY AND EXIT ROUTINE FOR STACK VARIABLE
     1041
     1042			 ENTRY .STKST
     1043
     1044		       .STKST::ADD P,0(.A16)  ;BUMP STACK FOR VARIABLES USED
     1045			 JUMPGE P,STKSOV  ;TEST FOR STACK OVERFLOW
     1046		       STKSE1: PUSH P,0(.A16)  ;SAVE BLOCK SIZE FOR RETURN
     1047			 PUSHJ P,1(.A16)  ;CONTINUE ROUTINE, EXIT TO .+1
     1048		       .STKRT::JRST STKRT0  ;NON-SKIP RETURN COMES HERE
     1049			 POP P,.A16  ;SKIP RETURN COMES HERE-RECOVER COUNT
     1050			 SUB P,.A16  ;ADJUST STACK TO REMOVE BLOCK
     1051			 AOS 0(P)  ;NOW DO SKIP RETURN
     1052			 RET
     1053
     1054		       STKRT0: POP P,.A16  ;RECOVER COUNT
     1055			 SUB P,.A16  ;ADJUST STACK TO REMOVE BLOCK
     1056			 RET   ;DO NON-SKIP RETURN
     1057
     1058		       STKSOV: SUB P,0(.A16)  ;STACK OVERFLOW- UNDO ADD
     1059			 HLL .A16,0(.A16) ;SETUP TO DO MULTIPLE PUSH, GET COUNT
     1060		       STKSO1: PUSH P,[0]  ;DO ONE PUSH AT A TIME, GET REGULAR
     1061			 SUB .A16,[1,,0]  ; ACTION ON OVERFLOW
     1062			 TLNE .A16,777777 ;COUNT DOWN TO 0?
     1063			 JRST STKSO1  ;NO, KEEP PUSHING
     1064			 JRST STKSE1
     1065			      ;END OF IFN REL,
     1066
     1067			 SUBTTL TRVAR - TRANSIENT VARIABLE FACILITY

     1069		       ;TRANSIENT (STACK) VARIABLE FACILITY - EQUIVALENT TO STKVAR
     1070		       ;EXCEPT ALLOWS VARIABLES TO BE USED WITHIN LOWER LEVEL ROUTINES
     1071		       ;AND AFTER OTHER THINGS HAVE BEEN PUSHED ON STACK.
     1072		       ;N.B. USES .FP AS FRAME POINTER - MUST NOT BE CHANGED WHILE
     1073		       ;VARIABLES IN USE.
     1074
     1075      000015		 .FP==15    ;DEFAULT FRAME POINTER
     1076
     1077			  IFE REL,<
     1078			 EXTERN .TRSET,.TRRET,.ASSET,.ASRET
     1079
     1080		       DEFINE TRVAR (VARS)<
     1081			 ..TRR==10  ;;REMEMBER CURRENT RADIX
     1082			 RADIX 8
     1083			 ..NV==1   ;;INIT COUNT OF STACK WORDS
     1084			 IRP VARS,<
     1085			   .TRV1 (VARS)  ;;PROCESS LIST
     1086			 JSP .A16,.TRSET  ;;ALLOCATE STACK SPACE, SETUP .FP
     1087			  ..NV-1,,..NV-1
     1088			 RADIX ..TRR  ;;RESTORE RADIX
     1089			 PURGE ..TRR,..NV ;;CLEAN UP
     1090
     1091		       DEFINE .TRV1 (VAR)<
     1092			 .TRV2 (VAR)  ;;PEEL OFF ANGLEBRACKETS IF ANY
     1093
     1094		       DEFINE .TRV2 (NAM,SIZ)<
     1095			 .TRV3 (NAM,..NV) ;;DEFINE VARIABLE
     1096			 IFB <SIZ,..NV=..NV+1
     1097			 IFNB <SIZ,..NV=..NV+SIZ
     1098
     1099		       DEFINE .TRV3 (NAM,LOC)<
     1100			  IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX TRVAR NAM ALREADY DEFINED
     1101			 DEFINE NAM<O'LOC(.FP)
     1102			 $'NAM==<Z NAM	;;SYMBOL FOR DDT
     1103
     1104		       ;AC SUBROUTINE - ENTRY FOR SUBROUTINE CALLED WITH 1-4 ARGS IN ACS T1-T4.
     1105		       ;USES .FP AS FRAME PTR LIKE TRVAR
     1106
     1107		       DEFINE ASUBR (ARGS)<
     1108			 ..TRR==10  ;;SAVE RADIX
     1109			 RADIX 8
     1110			 ..NV==1   ;;INIT ARG COUNT
     1111			 IRP ARGS,<
     1112			   .TRV1 (ARGS)  ;;DEFINE ARG SYMBOL
     1113			 IFG ..NV-5,<PRINTX ?TOO MANY ARGUMENTS: ARGS
     1114			 JSP .A16,.ASSET  ;;SETUP STACK
     1115			 RADIX ..TRR  ;;RESTORE RADIX
     1116			 PURGE ..TRR,..NV
     1117
     1118			  IFN REL,<
     1119		       ;SUPPORT ROUTINE FOR TRVAR
     1120
     1121		       .TRSET::PUSH P,.FP  ;PRESERVE OLD .FP

     1123			 ADD P,0(.A16)	;ALLOCATE SPACE
     1124			 JUMPGE P,TRSOV
     1125		       TRSET1: PUSHJ P,1(.A16)	;CONTINUE ROUTINE, EXIT VIA .+1
     1126		       .TRRET::JRST [ MOVEM .FP,P ;CLEAR STACK
     1127			  POP P,.FP ;RESTORE OLD .FP
     1128			  POPJ P,]
     1129			 MOVEM .FP,P  ;HERE IF SKIP RETURN
     1130			 POP P,.FP
     1131			 AOS 0(P)  ;PASS SKIP RETURN
     1132			 POPJ P,
     1133
     1134		       TRSOV: SUB P,0(.A16)  ;STACK OVERFLOW - UNDO ADD
     1135			 HLL .A16,0(.A16) ;GET COUNT
     1136		       TRSOV1: PUSH P,[0]  ;DO ONE PUSH AT A TIME, GET REGULAR
     1137			 SUB .A16,[1,,0]  ; ACTION ON OVERFLOW
     1138			 TLNE .A16,777777 ;COUNT TO 0?
     1139			 JRST TRSOV1  ;NO, KEEP PUSHING
     1140			 JRST TRSET1  ;CONTINUE SETUP
     1141
     1142		       ;SUPPORT ROUTINE FOR ASUBR
     1143
     1144		       .ASSET::PUSH P,.FP  ;SAVE .FP
     1145			 MOVE .FP,P  ;SETUP FRAME POINTER
     1146			 ADD P,[4,,4]  ;ADJUST STACK
     1147			 JUMPGE P,[SUB P,[4,,4] ;PROBABLE OVERFLOW
     1148			  PUSH P,A ;DO WITH PUSH, GET INTERRUPT...
     1149			  PUSH P,B
     1150			  PUSH P,C
     1151			  PUSH P,D
     1152			  JRST ASSET1]
     1153			 DMOVEM A,1(.FP) ;SAVE ARGS
     1154			 DMOVEM C,3(.FP)
     1155		       ASSET1: PUSHJ P,0(.A16)	;CONTINUE ROUTINE
     1156		       .ASRET:: JRST [ MOVEM .FP,P ;NO-SKIP RETURN, CLEAR STACK
     1157			  POP P,.FP
     1158			  POPJ P,]
     1159			 MOVEM .FP,P  ;SKIP RETURN, CLEAR STZCK
     1160			 POP P,.FP
     1161			 AOS 0(P)
     1162			 POPJ P,
     1163			      ;END OF IFN REL,
     1164
     1165		       ;AC VARIABLE FACILITY
     1166
     1167			  IFE REL,<
     1168			 EXTERN .SAV1,.SAV2,.SAV3,.SAV4,.SAV8
     1169
     1170      000005		 .FPAC==5   ;FIRST PRESERVED AC
     1171      000010		 .NPAC==10   ;NUMBER OF PRESERVED ACS
     1172
     1173		       DEFINE ACVAR (LIST)<
     1174			 ..NAC==0  ;;INIT NUMBER OF ACS USED
     1175			 IRP LIST,<

     1177			 .ACV3 (..NAC)	;;SAVE ACS USED
     1178
     1179		       DEFINE .ACV1 (ITEM)<
     1180			 .ACV2 (ITEM)  ;;PEEL OFF ANGLEBRACKETS IF ANY
     1181
     1182		       DEFINE .ACV2 (NAM,SIZ)<
     1183			 NAM=.FPAC+..NAC  ;;DEFINE VARIABLE
     1184			 IFB <SIZ,..NAC=..NAC+1
     1185			 IFNB <SIZ,..NAC=..NAC+SIZ
     1186
     1187		       DEFINE .ACV3 (N)<
     1188			 IFG N-.NPAC,<PRINTX ?TOO MANY ACS USED
     1189			 IFLE N-4,<
     1190			   JSP .A16,.SAV'N ;;SAVE ACTUAL NUMBER USED
     1191			 IFG N-4,<
     1192			   JSP .A16,.SAV8 ;;SAVE ALL
     1193
     1194			  IFN REL,<
     1195		       ;SUPPORT ROUTINES FOR AC VARIABLE FACILITY
     1196
     1197		       .SAV1:: PUSH P,.FPAC
     1198			 PUSHJ P,0(.A16)  ;CONTINUE PROGRAM
     1199			  SKIPA
     1200			 AOS -1(P)
     1201			 POP P,.FPAC
     1202			 POPJ P,
     1203
     1204		       .SAV2:: PUSH P,.FPAC
     1205			 PUSH P,.FPAC+1
     1206			 PUSHJ P,0(.A16)
     1207			  SKIPA
     1208			 AOS -2(P)
     1209			 POP P,.FPAC+1
     1210			 POP P,.FPAC
     1211			 POPJ P,
     1212
     1213		       .SAV3::
     1214		       .SAV4:: PUSH P,.FPAC
     1215			 PUSH P,.FPAC+1
     1216			 PUSH P,.FPAC+2
     1217			 PUSH P,.FPAC+3
     1218			 PUSHJ P,0(.A16)
     1219			  SKIPA
     1220			 AOS -4(P)
     1221			 POP P,.FPAC+3
     1222			 POP P,.FPAC+2
     1223			 POP P,.FPAC+1
     1224			 POP P,.FPAC
     1225			 POPJ P,
     1226
     1227		       .SAV8:: ADD P,[10,,10]
     1228			 JUMPGE P,[HALT .]
     1229			 DMOVEM .FPAC,-7(P)

     1231			 DMOVEM .FPAC+4,-3(P)
     1232			 DMOVEM .FPAC+6,-1(P)
     1233			 PUSHJ P,0(.A16)
     1234			  SKIPA
     1235			 AOS -10(P)
     1236			 DMOVE .FPAC+6,-1(P)
     1237			 DMOVE .FPAC+4,-3(P)
     1238			 DMOVE .FPAC+2,-5(P)
     1239			 DMOVE .FPAC,-7(P)
     1240			 SUB P,[10,,10]
     1241			 POPJ P,
     1242
     1243
     1244		       ;AC SAVE FACILITY - COMPILES OPEN PUSH'S
     1245		       ; SAVEAC <LIST-OF-ACS
     1246		       ;DUMMY ROUTINE PUT ON STACK TO CAUSE AUTOMATIC RESTORE. SUPPORTS
     1247		       ; +1 OR +2 RETURNS.
     1248
     1249		       DEFINE SAVEAC (ACS)<
     1250			 .NAC==0
     1251			 IRP ACS,<
     1252			   PUSH P,ACS  ;;SAVE AN AC
     1253			   .NAC=.NAC+1	;;COUNT THEM
     1254			 .N1==.NAC
     1255			 SETMI .A16,[CAIA ;;STACK DUMMY RETURN
     1256			  AOS -.N1(P) ;;HANDLE SKIP RETURN
     1257			   IRP ACS,<
     1258			  .N1=.N1-1
     1259			  MOVE ACS,-.N1(P)  ;;RESTORE AN AC
     1260			  SUB P,[.NAC,,.NAC]  ;;CLEAR STACK
     1261			  POPJ P,] ;;FINAL RETURN
     1262			 PUSH P,.A16
     1263
     1264			  IFN REL,<
     1265		       ;STANDARD RETURNS
     1266
     1267		       RSKP:: AOS 0(P)
     1268		       R:: RET
     1269			      ;END OF IFN REL,
     1270
     1271  000000'		  LIT	 ;MAKE SURE LITERALS COME BEFORE END MARK
     1272			  IFN REL,<
     1273		       .RLEND==:.-1   ;MARK END OF CODE IN MACREL
     1274
     1275			 IF2,<PURGE REL  ;FLUSH REL FROM UNIV FILE
     1276			 END




	1		       ;<4.UTILITIESACTSYM.MAC.9,  6-Apr-79 09:44:47, Edit by KONEN
	2
	3			 UNIVERSAL ACTSYM - SYMBOL FILE FOR ACCOUNTING
	4			 SUBTTL B.A. HUIZENGA/BAH/TAH - 6-JUN-77
	5
	6
	7		       ;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
	8		       ;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
	9		       ;
       10		       ;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
       11
       12
       13
       14		       ;PARAMETERS FOR USAGE ITEM DESCRIPTORS
       15
       16		       ;FIELDS IN DATA ITEM DESCRIPTOR
       17
       18    770000  000000	 US%FLG==:77B5	 ;FLAGS
       19    400000  000000	     US%IMM==:1B0  ; 1 - IMMEDIATE DATA ITEM
       20			    ; 0 - ADDRESS OF DATA ITEM
       21    007700  000000	 US%TYP==:77B11   ;TYPE CODE
       22      000000		     .USASC==:0   ;ASCII
       23      000001		     .USSIX==:1   ;SIXBIT
       24      000002		     .USOCT==:2   ;OCTAL
       25      000003		     .USDEC==:3   ;DECIMAL
       26      000004		     .USDAT==:4   ;DATE-TIME
       27      000005		     .USTAB==:5   ;TABLE (SPECIAL FORM)
       28      000006		     .USVER==:6   ;VERSION NUMBER
       29      000007		     .USSPC==:7   ;SPACE FILL
       30
       31    000077  700000	 US%LEN==:777B20   ;LENGTH
       32      077777		 US%COD==:77777B35  ;ITEM CODE
       33
       34		       ;RECORD TYPE CODES
       35
       36			 RADIX 10  ;**** NOTE RADIX 10 ****
       37
       38      000001		 .UTRST==:1   ;SYSTEM RESTART ENTRY
       39      000002		 .UTSEN==:2   ;SESSION ENTRY
       40      000003		 .UTCKP==:3   ;CHECKPOINT ENTRY (SYSTEM RESTART)

       42      000005		 .UTTAD==:5   ;DATE-TIME CHANGE
       43      000006		 .UTBAT==:6   ;BATCH PROCESSOR
       44      000007		 .UTINP==:7   ;INPUT SPOOLER ENTRY
       45      000010		 .UTOUT==:8   ;OUTPUT SPOOLER ENTRY
       46      000011		 .UTFLU==:9   ;FILE USAGE DIRECTORY ENTRY
       47      000012		 .UTDSU==:10   ;DISK SPINDLE USAGE ENTRY
       48      000013		 .UTMNT==:11   ;STRUCTURE MOUNT ENTRY
       49      000014		 .UTMMT==:12   ;TAPE MOUNT ENTRY
       50      000015		 .UTDMT==:13   ;DECtape MOUNT ENTRY
       51      000016		 .UTFCM==:14   ;FILE COMMAND ENTRY
       52      000017		 .UTRET==:15   ; File retrieved
       53      000020		 .UTARC==:16   ; File archived
       54      000021		 .UTMIG==:17   ; File migrated
       55      000022		 .UTCOL==:18   ; File collected
       56
       57      011610		 .UTUSR==:5000	 ;USER-DEFINED ENTRY TYPES ARE 5000-9999
       58
       59			 RADIX 8   ;**** END OF RADIX 10 ****
       60
       61		       COMMENT				       _
       62
       63			 The format of the data to be passed to the accounting system
       64		       will consist of a list of items describing the entries in a single
       65		       record.
       66
       67		       The record descriptor list will have a header containing the record
       68		       type code and the record version information.
       69
       70		       Format of a record descriptor:
       71
       72			 !=======================================================!
       73			 !  DEC ver.   !  CUST ver.  !	      Entry Type	 !
       74			 !-------------------------------------------------------!
       75			 ! Flags  !  Type  !   Length	 !	 Item Code	 !
       76			 !-------------------------------------------------------!
       77			 !	     Data or Address (-1 for default)		 !
       78			 !-------------------------------------------------------!
       79						    .
       80						    .
       81						    .
       82			 !-------------------------------------------------------!
       83			 !		   0 (Marks end of list)		 !
       84			 !=======================================================!
       85
       86
       87			 The generation of these tables will be controlled by the
       88		       UITEM. macro. All known data items will have a name generated by
       89		       the use of this macro. If any application dependent items are needed
       90		       the UITEM. macro may be used to generate the new item. The USENT.
       91		       macro may be used to generate the first word of the entry descriptor
       92		       table.
       93
       94		       All USAGE entry headers and the system-defined USAGE entry types use the

       96
       97		       Installation-defined USAGE entries (with entry types above .UTUSR - 5000 to
       98		       9999) use the arbitrary data items (USUAS., USUSX., USUDC., USUOC., USUVR.,
       99		       USUDT., and USUSP.) in the order in which they are to be written into the
      100		       USAGE entry record.  Each arbitrary data record must be preceded by a
      101		       USUAR. item.
      102
      103		       Example of installation-defined USAGE entry:
      104
      105		       ;The following code writes a USAGE entry for a fictitious "file access count"
      106		       ; in a user program.  This program must be running as an enabled OPERATOR or
      107		       ; WHEEL.
      108
      109		       ;Here to write USAGE entry for file access count
      110
      111			 MOVEI T1,.USENT  ;USAGE function to write entry
      112			 MOVEI T2,FILRDB  ;Address of Record Descriptor Block
      113			 USAGE	 ;Write the entry
      114			  ERJMP USGERR	;Failed to write entry-- do something else
      115			 JRST USGOK  ;Entry written-- go on
      116
      117		       ;Record descriptor block for file access count accounting
      118
      119		       FILRDB:
      120			 USENT. (.UTUSR+12,1,1) ;Entry type 5012= file access count.
      121			 USPVR. (<BYTE(3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT,US%IMM) ;Version
      122			    ;  of this program (for header record).
      123
      124			 USUAR.   ;Start of first arbitrary record.
      125			 USUAS. ([ASCII this appears in every entry],,27) ;Text.
      126			 USUSP. (,,5)  ;Space fill, 5 characters.
      127			 USUDC. (FILCNT,,6) ;Count of file accesses, 000000-999999.
      128
      129			 USUAR.   ;Start of second arbitrary record.
      130			 USUSX. (<SIXBIT fILE: ,US%IMM,6) ;SIXBIT text for filename.
      131			 USUAS. (FILNAM,,200) ;File name, 200 characters.
      132
      133			 EXP 0	 ;End of entry.
      134
      135		       ;Storage
      136
      137		       FILCNT: BLOCK 1	 ;File access count
      138		       FILNAM: BLOCK D<200/5  ;File name text
      139
      140			 ;;; End of comment			       _
      141
      142			 SUBTTL UITEM. / USENT. / USAGE. DEFINITIONS
      143
      144			 SALL
      145
      146		       DEFINE UITEM. (NAME,TYPE,LEN) <
      147			   DEFINE US'NAME'. (DATA<-1,IMMED0,ULENLEN) <
      148			 USAGE. (.US'NAME,ULEN,TYPE,IMMED,<DATA)

      150
      151
      152		       DEFINE USENT. (ETYPE,DVER,CVER) <
      153			 BYTE (9) D<DVER,DCVER (18) D<ETYPE
      154
      155
      156		       DEFINE USAGE. (CODE,LENGTH,TYPE,FLAGS,DATUM) <
      157			 FLAGS+<TYPEB11+D<LENGTHB20+CODE
      158			   IFB	<DATUM,-1
      159			   IFNB <DATUM,DATUM
      160
      161
      162		       DEFINE USDSK. (TABLE) <
      163			 USAGE. (.USDST,0,.USTAB,US%IMM,<TABLE)
      164
      165			 SUBTTL USAGE. ITEM-CODE DEFINITIONS
      166
      167		       DEFINE USLIST <
      168
      169		       DEFUS (JNO,0,.USDEC,4)  ;JOB NUMBER
      170		       DEFUS (TAD,1,.USDAT,14)	;CURRENT DATE/TIME
      171		       DEFUS (TRM,2,.USASC,1)  ;TERMINAL DESIGNATOR
      172		       DEFUS (LNO,3,.USOCT,4)  ;LINE NUMBER
      173		       DEFUS (PNM,4,.USSIX,6)  ;PROGRAM NAME (CALLER)
      174		       DEFUS (PVR,5,.USVER,15)	;PROGRAM VERSION
      175		       DEFUS (AMV,6,.USVER,15)	;ACCOUNTING MODULE VERSION
      176		       DEFUS (NOD,7,.USSIX,6)  ;CALLER'S LOCATION
      177		       DEFUS (PPN,10,.USOCT,12) ;PROJECT / PROGRAMMER NUMBER (TOPS10 ONLY)
      178		       DEFUS (NM1,11,.USASC,12) ;NAME OF USER (TOPS10)
      179		       DEFUS (SNM,12,.USASC,39) ;SYSTEM NAME
      180		       DEFUS (MVR,13,.USVER,15) ;MONITOR VERSION NUMBER
      181		       DEFUS (MBD,14,.USDAT,14) ;MONITOR BUILD DATE
      182		       DEFUS (MUP,15,.USDEC,18) ;MONITOR UPTIME (IN SECONDS)
      183		       DEFUS (ACT,16,.USASC,39) ;ACCOUNT STRING
      184		       DEFUS (LCK,17,.USDAT,14) ;TIME OF LAST CHECKPOINT
      185		       DEFUS (RTM,20,.USDEC,9)	;RUNTIME IN MS
      186		       DEFUS (CTI,21,.USDEC,11) ;CORE-TIME INTEGRAL (TOPS10 ONLY)
      187		       DEFUS (SST,22,.USDAT,14) ;SESSION START TIME
      188		       DEFUS (JTY,23,.USDEC,1)	;JOB TYPE (BATCH / TIMESHARING)
      189		       DEFUS (BJN,24,.USSIX,6)	;BATCH JOB NAME
      190		       DEFUS (BSN,25,.USDEC,6)	;BATCH SEQUENCE NUMBER
      191		       DEFUS (COM,26,.USASC,39) ;USER COMMENT
      192		       DEFUS (DKR,27,.USDEC,8)	;DISK READS
      193		       DEFUS (DKW,30,.USDEC,8)	;DISK WRITES
      194		       DEFUS (VTI,31,.USDEC,11) ;VIRTUAL CORE-TIME INTEGRAL
      195		       DEFUS (EBX,32,.USDEC,9)	;EBOX MEGACOUNTS (CYCLES * 106)
      196		       DEFUS (MBX,33,.USDEC,9)	;MBOX MEGACOUNTS (CYCLES * 106)
      197		       DEFUS (MCL,34,.USDEC,6)	;MONITOR CALLS
      198		       DEFUS (MCM,35,.USDEC,6)	;MONITOR COMMANDS
      199		       DEFUS (SCL,36,.USDEC,3)	;SCHEDULING CLASS
      200		       DEFUS (TYI,37,.USDEC,6)	;TTY INPUT CHARACTERS
      201		       DEFUS (TYO,40,.USDEC,6)	;TTY OUTPUT CHARACTERS
      202		       DEFUS (TYW,41,.USDEC,6)	;TTY WAKEUPS

      204		       DEFUS (CP0,43,.USDEC,4)	;SERIAL NUMBER OF CPU0
      205		       DEFUS (CP1,44,.USDEC,4)	;SERIAL NUMBER OF CPU1
      206		       DEFUS (CP2,45,.USDEC,4)	;SERIAL NUMBER OF CPU2
      207		       DEFUS (CP3,46,.USDEC,4)	;SERIAL NUMBER OF CPU3
      208		       DEFUS (CP4,47,.USDEC,4)	;SERIAL NUMBER OF CPU4
      209		       DEFUS (CP5,50,.USDEC,4)	;SERIAL NUMBER OF CPU5
      210		       DEFUS (RQQ,51,.USDEC,11) ;RUN QUEUE QUOTIENT (TOPS10 ONLY)
      211		       DEFUS (NM2,52,.USASC,39) ;NAME OF USER (TOPS20)
      212		       DEFUS (CCT,53,.USDEC,7)	;CONSOLE CONNECT TIME (SECONDS)
      213		       DEFUS (DTL,54,.USDAT,14) ;DATE/TIME BEFORE CHANGE (STAD)
      214
      215		       ;DISK UTILIZATION RECORD ENTRIES
      216
      217		       DEFUS (NRF,55,.USDEC,3)	;NUMBER OF RECORDS FOLLOWING
      218		       DEFUS (TAL,56,.USDEC,10) ;TOTAL ALLOCATED STORAGE
      219		       DEFUS (TUS,57,.USDEC,10) ;TOTAL STORAGE USED
      220		       DEFUS (TNF,60,.USDEC,5)	;TOTAL NUMBER OF FILES
      221		       DEFUS (STR,61,.USASC,6)	;STRUCTURE NAME
      222		       DEFUS (STP,62,.USDEC,1)	;STRUCTURE TYPE CODE
      223		       DEFUS (KTP,63,.USDEC,3)	;CONTROLLER TYPE
      224		       DEFUS (DTP,64,.USDEC,3)	;DEVICE TYPE
      225		       DEFUS (LIQ,65,.USDEC,6)	;LOGGED IN QUOTA
      226		       DEFUS (LOQ,66,.USDEC,6)	;LOGGED OUT QUOTA
      227		       DEFUS (LLI,67,.USDAT,14) ;LAST LOGGED IN DATE/TIME
      228		       DEFUS (LAT,70,.USDAT,14) ;LAST DISK ACCOUNTING DATE/TIME
      229		       DEFUS (EXP,71,.USASC,1)	;EXPIRED DIRECTORY (Y/N)
      230		       DEFUS (DIR,72,.USASC,39) ;DIRECTORY NAME
      231		       DEFUS (ALC,73,.USDEC,10) ;ALLOCATED STORAGE
      232		       DEFUS (USG,74,.USDEC,10) ;STORAGE USED
      233		       DEFUS (FIL,75,.USDEC,5)	;NUMBER OF FILES
      234		       DEFUS (FON,76,.USASC,1)	;FILES ONLY INDICATOR (Y/N)
      235
      236		       ;SPOOLER INFORMATION RECORD ENTRIES
      237
      238		       DEFUS (SRT,77,.USDEC,9)	;SPOOLER RUNTIME
      239		       DEFUS (SCI,100,.USDEC,11) ;CORE-TIME INTEGRAL
      240		       DEFUS (SDR,101,.USDEC,8) ;SPOOLER DISK READS
      241		       DEFUS (SDW,102,.USDEC,8) ;SPOOLER DISK WRITES
      242		       DEFUS (JNM,103,.USSIX,6) ;JOB NAME
      243		       DEFUS (QNM,104,.USSIX,3) ;QUEUE NAME
      244		       DEFUS (SDV,105,.USSIX,6) ;PROCESSING DEVICE
      245		       DEFUS (SSN,106,.USDEC,6) ;SEQUENCE NUMBER
      246		       DEFUS (SUN,107,.USDEC,6) ;SPOOLER UNITS PROCESSED
      247		       DEFUS (CRT,110,.USDAT,14) ;CREATION DATE/TIME OF REQUEST
      248		       DEFUS (DSP,111,.USSIX,6) ;DISPOSITION
      249		       DEFUS (TXT,112,.USASC,39) ;OPR OR SYSTEM TEXT
      250		       DEFUS (PRI,113,.USDEC,2) ;PRIORITY
      251		       DEFUS (SNF,114,.USDEC,5) ;NUMBER OF FILES PROCESSED
      252		       DEFUS (SCD,115,.USDAT,14) ;SCHEDULED DATE/TIME
      253		       DEFUS (FRM,116,.USSIX,6) ;FORMS TYPE
      254
      255		       ;DATE/TIME CHANGE RECORD ENTIRES
      256

      258		       DEFUS (OFS,120,.USDEC,7) ;OFFSET IN SECONDS
      259		       DEFUS (ODT,121,.USDAT,14) ;OLD DATE/TIME
      260
      261		       ;ARBITRARY RECORD ITEM TYPES
      262
      263		       DEFUS (UAR,122,.USSPC,0) ;USER-DEFINED ARBITRARY RECORD DELIMITER
      264		       DEFUS (UAS,123,.USASC,0) ;USER-DEFINED ASCII STRING
      265		       DEFUS (USX,124,.USSIX,0) ;USER-DEFINED SIXBIT STRING
      266		       DEFUS (UOC,125,.USOCT,0) ;USER-DEFINED OCTAL NUMBER
      267		       DEFUS (UDC,126,.USDEC,0) ;USER-DEFINED DECIMAL NUMBER
      268		       DEFUS (UDT,127,.USDAT,14) ;USER-DEFINED DATE AND TIME
      269		       DEFUS (UVR,130,.USVER,15) ;USER-DEFINED VERSION (STANDARD FORMAT)
      270		       DEFUS (USP,131,.USSPC,0) ;USER-DEFINED SPACE FILL
      271
      272		       ;STRUCTURE MOUNT RECORD ENTRIES
      273
      274		       DEFUS (SSI,132,.USSIX,6) ;SIXBIT STRUCTURE ID
      275		       DEFUS (TNP,133,.USDEC,2) ;TOTAL NUMBER OF PACKS
      276		       DEFUS (SRV,134,.USDAT,14) ;SERVICED DATE/TIME OF REQUEST
      277		       DEFUS (MCT,135,.USDEC,3) ;MOUNT COUNT BEFORE MOUNT
      278		       DEFUS (DCT,136,.USDEC,3) ;MOUNT COUNT AFTER DISMOUNT
      279		       DEFUS (ATP,137,.USDEC,1) ;ACCESS TYPE
      280
      281		       ;TAPE MOUNT RECORD ENTRIES
      282
      283		       DEFUS (VID,140,.USSIX,6) ;MAGTAPE VOLUME LABEL IN VOL1 LABEL
      284		       DEFUS (VSN,141,.USSIX,6) ;VISUAL SERIAL NUMBER
      285		       DEFUS (MRF,142,.USDEC,10) ;THOUSANDS OF FRAMES READ
      286		       DEFUS (MWF,143,.USDEC,10) ;THOUSANDS OF FRAMES WRITTEN
      287		       DEFUS (MLT,144,.USDEC,10) ;LABEL TYPE
      288		       DEFUS (MLS,145,.USDEC,10) ;VOLUME LABEL STATE
      289		       DEFUS (MRD,146,.USDEC,10) ;NUMBER OF PHYSICAL RECORDS READ
      290		       DEFUS (MWR,147,.USDEC,10) ;NUMBER OF PHYSICAL RECORDS WRITTEN
      291		       DEFUS (FSI,150,.USSIX,6) ;FILE SET IDENTIFIER
      292		       DEFUS (SRE,151,.USDEC,10) ;NUMBER OF SOFT READ ERRORS
      293		       DEFUS (SWE,152,.USDEC,10) ;NUMBER OF SOFT WRITE ERRORS
      294		       DEFUS (HRE,153,.USDEC,10) ;NUMBER OF HARD READ ERRORS
      295		       DEFUS (HWE,154,.USDEC,10) ;NUMBER OF HARD WRITE ERRORS
      296
      297		       ; Retrieve/archive/migration/collection entries
      298
      299		       DEFUS (TP1,155,.USSIX,6) ; Tape ID 1
      300		       DEFUS (TS1,156,.USDEC,4) ; Tape saveset #
      301		       DEFUS (TF1,157,.USDEC,6) ; Tape file #
      302		       DEFUS (TP2,160,.USSIX,6) ; Tape 2 ID
      303		       DEFUS (TS2,161,.USDEC,4) ; Tape saveset #
      304		       DEFUS (TF2,162,.USDEC,6) ; Tape file #
      305		       DEFUS (RSN,163,.USOCT,1) ; Reason offline code
      306
      307		       DEFUS (EUT,164,.USDEC,7) ; ELAPSED USE TIME (STRUCTURE AND TAPE)
      308		       ;;; END OF USLIST
      309
      310		       ;MACRO TO DEFINE ALL USAGE. ITEM CODES

      312		       DEFINE DEFUS (NAM,VAL,TYP,LEN) <
      313			   IF1,<IFDEF .US'NAM,<
      314			 PRINTX .US'NAM ALREADY DEFINED
      315
      316			 .US'NAM==:VAL
      317			 UITEM. (NAM,TYP,LEN)
      318
      319
      320		       ;EXPAND ALL DEFINITIONS
      321
      322		       USLIST
      323
      324		       ;SPECIAL ITEM TYPE CODE DEFINITIONS
      325
      326      007776		 .USDSX==:7776	;STRUCTURE/DIRECTORY INFO WORD (SPECIAL)
      327      007777		 .USDST==:7777	;DISK STATISTICS TABLE POINTER
      328
      329
      330
      331			 END

  Finding, 3-111		     (Cont.)
1'st used file page,		     Returning disk, 3-134
  Finding, 3-112		   An IPCF message,
				     Retrieving, 3-173
				     sending, 3-175
				   Analysis,
AC'S,				     System performance, 3-330
  setting, 3-305		   ARCF JSYS, 3-8
ACCES JSYS, 3-1 		   Archive/virtual disk system,
Access, 			       2-70
  Directory, 2-8, 3-1		   ARPANET, 3-269, 3-330
  File, 2-7			   ARPANET host,
  page, 3-286			     Flushing an, 3-112
Access control, 2-58		   Arpanet host information,
Access-control, 3-120		     Returning, 3-136
Access-control program, 	   ARPANET queue,
    3-131, 3-329		     Assigning, 3-12
Accessibility,			   ASND JSYS, 3-11
  setting page, 3-339		   ASNSQ JSYS, 3-12
Account,			   Assigning a device, 3-11
  Changing, 3-27		   Assigning ARPANET queue,
  Returning file's, 3-115	       3-12
  Returning job's, 3-114	   Assigning devices, 3-273
Accounting,			   Assigning disk addresses,
  system, 3-375 		       3-89
Accounting functions, 2-1	   Assigning terminal
Accounts,			       interrupt, 3-14
  verifying, 3-381		   Association,
Acquiring physical memory,	     physical/logical
    3-253			       tape-drive, 3-198
Activation,			   ATI JSYS, 3-14
  Interrupt channel, 3-6	   ATNVT JSYS, 3-15
ADBRK JSYS, 3-3 		   ATTACH JSYS, 3-12
Adding a table entry, 3-357	   Attaching a job, 3-12
Address breaks, 3-3		   Author,
Addresses,			     Returning file, 3-130
  Assigning disk, 3-89		     setting file, 3-313
  setting interrupt table,
    3-319
AIC JSYS, 3-6
ALLOC JSYS, 3-7
Allocation,
  Device, 3-7


			       Index-1


				INDEX


				   CFBIF JSYS, 3-28
Backing up pointer, 3-17	   CFBOF JSYS, 3-28
BIN JSYS, 3-16			   CFORK JSYS, 3-29
BKJFN JSYS, 3-17		   Changing account, 3-27
Block-mode input, 3-317 	   Channel,
Block-mode output, 3-337	     Reserving a, 3-81
Block,				     Software interrupt, 2-51
  File descriptor, 2-9		   Channel activation,
  Job storage, 3-290		     Interrupt, 3-6
  Returning file descriptor,	   Channels,
    3-135			     Deactivating interrupt,
Blocking,			       3-86
  elapsed time process, 	     Panic, 2-53
    3-367			   Characteristics,
BLPT:, 2-30			     Returning device, 3-96
BOOT JSYS, 3-17 		   CHFDB JSYS, 3-30
BOUT JSYS, 3-26 		   CHKAC JSYS, 3-34
Breaks, 			   CIS JSYS, 3-35
  Address, 3-3			   Clearing file input buffer,
Buffer, 			       3-28
  Clearing file input, 3-28	   Clearing file output buffer,
  Clearing file output, 	       3-28
    3-28			   Clearing software interrupt
  Rescan, 3-290 		       system, 3-35
  testing file input, 3-314	   Clock,
  testing file output,		     Returning high-precision,
    3-334, 3-335		       3-159
Byte input, 3-16, 3-251 	   CLOSF JSYS, 3-35
Byte input,			   Closing a file, 3-35
  random, 3-283 		   Closing process files, 3-36
Byte output, 3-26, 3-252	   CLZFF JSYS, 3-36
Byte pointer, 1-5		   Codes,
Byte size,			     Deassigning terminal,
  resetting file, 3-306 	       3-92
				   Command parsing, 3-37
				   COMND JSYS, 3-37
				   Comparing strings, 3-346
CACCT JSYS, 3-27		   Comparison,
Capabilities, 2-57		     wild string, 3-383
  Enabling, 3-109		   Compatibility package,
  Process, 2-56 		       3-299
CCOC words, 3-276, 3-307	   Compatibility package entry
CDP:, 2-30			       vector, 3-298
CDR:, 2-29










			       Index-2


				INDEX


Connection,			   Deassigning terminal codes,
  Creating NVT, 3-15		       3-92
Control,			   DEBRK JSYS, 3-73
  Access, 2-58			   DELDF JSYS, 3-73
  scheduler, 3-322		   Deleting a table entry,
Control word,			       3-357
  scheduler priority, 3-322	   Deleting files, 3-75, 3-76
Controlling terminal,		   DELF JSYS, 3-75
  Redefining, 3-296		   DELNF JSYS, 3-76
Converting host number, 	   DEQ JSYS, 3-77
    3-72			   Descriptor block,
Converting internal		     File, 2-9
    date/time, 3-243		     Returning file, 3-135
Converting socket number,	   Designator,
    3-73			     Device, 1-4
Converting to internal		     File, 1-4
    date/time, 3-160		     Primary input, 3-271
CRDIR JSYS, 3-59		     Primary output, 3-271
Creating a logical name,	     Source/destination, 1-3
    3-71			     Special, 1-5
Creating a new job, 3-65	   Detaching a job, 3-92
Creating an inferior		   Device,
    process, 3-29		     Assigning a, 3-11
Creating NVT connection,	     Manipulating a spooled,
    3-15			       3-342
CRJOB JSYS, 3-65		   Device allocation, 3-7
CRLNM JSYS, 3-71		   Device characteristics,
CVHST JSYS, 3-72		     Returning, 3-96
CVSKT JSYS, 3-73		   Device designator, 1-4
				   Device functions,
				     MT, 3-228
				   Device mode,
Data modes,			     setting, 3-351
  Software, 2-47		   Device name string,
Date,				     translating, 3-347
  setting system, 3-346 	   Device status,
Date and time,			     Returning, 3-116
  file, 3-282			   Device string,
  offline expiration, 3-282	     Translating, 3-79
  online expiration, 3-282	   Device-control functions,
  setting file, 3-311		       3-199
Date/time,			   Devices, 2-27
  Converting internal,		     Assigning, 3-273
    3-243			     Releasing, 3-273
  Converting to internal,	   DEVST JSYS, 3-79
    3-160			   DFIN JSYS, 3-80
  Inputting, 3-161, 3-163	   DFOUT JSYS, 3-80
  Outputting, 3-244, 3-246	   DIAG JSYS, 3-81
Date/time format, 2-69		   DIBE JSYS, 3-86
Date/time standard, 1-6 	   DIC JSYS, 3-86
Deactivating interrupt		   DIR JSYS, 3-87
    channels, 3-86		   Directory access, 2-8, 3-1


			       Index-3


				INDEX


Directory information,		   ENQC JSYS, 3-104
  Returning, 3-134		   Entering MDDT, 3-171
Directory name string,		   Entries,
  translating, 3-352		     Making FACT file, 3-97
Directory number,		   Entry,
  Translating, 3-88		     adding a table, 3-357
DIRST JSYS, 3-88		     deleting a table, 3-357
Disabling interrupt system,	   Entry vector, 2-65, 3-305
    3-87			   Entry vector,
Disk addresses, 		     compatibility package,
  Assigning, 3-89		       3-298
Disk allocation,		     Returning PA1050, 3-115
  Returning, 3-134		     Returning process, 3-127
Disk system,			     Returning RMS, 3-117
  Archive/virtual, 2-70 	     RMS, 3-300
Disk usage,			   EPCAP JSYS, 3-109
  Returning, 3-116		   Error,
Dismissing a process, 3-86,	     Returning most recent,
    3-88, 3-89			       3-125
Dismissing interrupt, 3-73	   Error condition, 3-301
DISMS JSYS, 3-88		   Error file,
DOBE JSYS, 3-89 		     system, 3-356
Double-precision input, 	   Error strings,
    3-80			     Outputting, 3-110
Double-precision output,	     Translating, 3-109
    3-80			   ERSTR JSYS, 3-109
DSKAS JSYS, 3-89		   ESOUT JSYS, 3-110
DSKOP JSYS, 3-90		   Execution,
DTACH JSYS, 3-92		     resuming process, 3-380
DTI JSYS, 3-92			   Expiration date and time,
Dump input, 3-93		     offline, 3-282
Dump output, 3-94		     online, 3-282
DUMPI JSYS, 3-93		   Expunging files, 3-73
DUMPO JSYS, 3-94
DVCHR JSYS, 3-96
 
				   FACT file entries,
				     Making, 3-97
EBOX/MBOX meter values, 	   FDB, 2-9
  Returning, 3-172		   FFFFP JSYS, 3-111
EFACT JSYS, 3-97		   FFORK JSYS, 3-111
EIR JSYS, 3-98			   FFUFP JSYS, 3-112
Elapsed system restart time,	   File,
  returning, 3-368		     Closing a, 3-35
Elapsed time process		     Getting a save, 3-118
    blocking, 3-367		     Opening a, 3-247
Enabling capabilities,		     Renaming a, 3-286
    3-109			     system error, 3-356
Enabling software interrupt	   File access, 2-7
    system, 3-98		   File author,
End-of-file, 3-283		     Returning, 3-130
ENQ JSYS, 3-99			     setting, 3-313


			       Index-4


				INDEX


File byte size, 		   Form JFN,
  resetting, 3-306		     long, 3-147
File date and time, 3-282	     Short, 3-139
  setting, 3-311		   Format,
File descriptor block, 2-9	     Date/time, 2-69
  Returning, 3-135		   Free file page,
File designator, 1-4		     Finding 1'st, 3-111
File entries,			   Freezing a process, 3-111
  Making FACT, 3-97		   Functions,
File handle, 2-3		     Accounting, 2-1
File input buffer,		     device-control, 3-199
  Clearing, 3-28		     IPCF, 3-229
  testing, 3-314		     mountable-structure,
File output buffer,		       3-181
  Clearing, 3-28		     MT device, 3-228
  testing, 3-334, 3-335 	     Network, 3-236
File page,
  Finding 1'st free, 3-111
  Finding 1'st used, 3-112
File pages,			   GACCT JSYS, 3-114
  updating, 3-374		   GACTF JSYS, 3-115
File pointer,			   GCVEC JSYS, 3-115
  setting, 3-309		   GDSKC JSYS, 3-116
File specification, 2-1 	   GDSTS JSYS, 3-116
  Returning, 3-165		   GDVEC JSYS, 3-117
File status,			   GET JSYS, 3-118
  Returning, 3-156		   GETAB JSYS, 3-124
  setting, 3-353		   GETER JSYS, 3-125
File's account, 		   GETJI JSYS, 3-125
  Returning, 3-115		   GETNM JSYS, 3-127
Files,				   GETOK JSYS, 3-329
  Closing process, 3-36 	   GETOK% JSYS, 3-120
  Deleting, 3-75, 3-76		   Getting a fork handle,
  Expunging, 3-73		       3-127
  SAVE, 2-63			   Getting a save file, 3-118
Finding 1'st free file page,	   GEVEC JSYS, 3-127
    3-111			   GFRKH JSYS, 3-127
Finding 1'st used file page,	   GFRKS JSYS, 3-128
    3-112			   GFUST JSYS, 3-130
Flags,				   GIVOK% JSYS, 3-131
  setting monitor, 3-328	   GNJFN JSYS, 3-132
  testing monitor, 3-372	   GPJFN JSYS, 3-133
FLHST JSYS, 3-112		   GTDAL JSYS, 3-134
FLIN JSYS, 3-113		   GTDIR JSYS, 3-134
Floating-point input, 3-113	   GTFDB JSYS, 3-135
Floating-point output,		   GTHST% JSYS, 3-136
    3-113			   GTJFN JSYS, 3-139, 3-147
FLOUT JSYS, 3-113		   GTNCP JSYS, 3-154
Flushing an ARPANET host,	   GTRPI JSYS, 3-153
    3-112			   GTRPW JSYS, 3-156
Fork handle,			   GTSTS JSYS, 3-156
  Getting a, 3-127		   GTTYP JSYS, 3-157


			       Index-5


				INDEX


				   Input,
				     (Cont.)
				     Byte, 3-16, 3-251
HALTF JSYS, 3-158		     Double-precision, 3-80
Halting a process, 3-158	     Dump, 3-93
Halting system, 3-159		     Floating-point, 3-113
Handle, 			     random byte, 3-283
  File, 2-3			     simulating terminal,
  Getting a fork, 3-127 	       3-348
  Process, 1-6			     string, 3-315
  Process/file, 1-6		   Input buffer,
HFORK JSYS, 3-158		     Clearing file, 3-28
High-precision clock,		     testing file, 3-314
  Returning, 3-159		   Input designator,
Histogram,			     Primary, 3-271
  Pc, 3-330			   Inputting a number, 3-235
Host,				   Inputting date/time, 3-161,
  Flushing an ARPANET,		       3-163
    3-112			   Internal date/time,
Host information,		     Converting, 3-243
  Returning arpanet, 3-136	     Converting to, 3-160
Host number,			   Interrupt,
  Converting, 3-72		     Assigning terminal, 3-14
HPTIM JSYS, 3-159		     Dismissing, 3-73
HSYS JSYS, 3-159		   Interrupt channel,
				     Software, 2-51
				   Interrupt channel
				       activation, 3-6
I/O,				   Interrupt channels,
  TTY, 3-271, 3-276, 3-360	     Deactivating, 3-86
I/O mode,			   Interrupt mask,
  User, 3-378			     Returning, 3-284, 3-294
IDCNV JSYS, 3-160		     setting, 3-320
IDTIM JSYS, 3-161		   Interrupt priority,
IDTNC JSYS, 3-163		     Software, 2-52
IIC JSYS, 3-164 		   Interrupt system,
Inferior process,		     Clearing software, 3-35
  Creating an, 3-29		     disabling, 3-87
Information,			     Enabling software, 3-98
  Returning arpanet host,	     Software, 2-51
    3-136			   Interrupt table,
  Returning directory,		     Returning, 3-284
    3-134			     Software, 2-52
  Returning job, 3-125		   Interrupt table addresses,
  Returning NCP, 3-154		     setting, 3-319
  Returning page trap,		   Interrupt word,
    3-153			     setting terminal, 3-349
Initiating software		     Terminal, 3-293
    interrupts, 3-164		   Interrupts,
INLNM JSYS, 3-165		     Initiating software,
Input,				       3-164
  block-mode, 3-317		     Terminal, 2-53


			       Index-6


				INDEX


IPCF functions, 3-229		   JSYS,
IPCF message,			     (Cont.)
  Retrieving an, 3-173		     CHKAC, 3-34
  sending an, 3-175		     CIS, 3-35
				     CLOSF, 3-35
				     CLZFF, 3-36
				     COMND, 3-37
JFN, 3-132, 3-133, 3-139,	     CRDIR, 3-59
    3-147, 3-156, 3-165 	     CRJOB, 3-65
JFN,				     CRLNM, 3-71
  long form, 3-147		     CVHST, 3-72
  Releasing a, 3-285		     CVSKT, 3-73
  setting primary, 3-340	     DEBRK, 3-73
  Short form, 3-139		     DELDF, 3-73
JFN mode word, 3-276		     DELF, 3-75
JFN'S,				     DELNF, 3-76
  swapping, 3-354		     DEQ, 3-77
JFNS JSYS, 3-165		     DEVST, 3-79
Job,				     DFIN, 3-80
  Attaching a, 3-12		     DFOUT, 3-80
  Creating a new, 3-65		     DIAG, 3-81
  Detaching a, 3-92		     DIBE, 3-86
  Killing a, 3-168		     DIC, 3-86
  Logging in a, 3-170		     DIR, 3-87
Job information,		     DIRST, 3-88
  Returning, 3-125		     DISMS, 3-88
Job parameters, 3-302		     DOBE, 3-89
Job priority,			     DSKAS, 3-89
  setting, 3-322		     DSKOP, 3-90
Job storage block, 3-290	     DTACH, 3-92
Job's account,			     DTI, 3-92
  Returning, 3-114		     DUMPI, 3-93
JSYS,				     DUMPO, 3-94
  ACCES, 3-1			     DVCHR, 3-96
  ADBRK, 3-3			     EFACT, 3-97
  AIC, 3-6			     EIR, 3-98
  ALLOC, 3-7			     ENQ, 3-99
  ARCF, 3-8			     ENQC, 3-104
  ASND, 3-11			     EPCAP, 3-109
  ASNSQ, 3-12			     ERSTR, 3-109
  ATI, 3-14			     ESOUT, 3-110
  ATNVT, 3-15			     FFFFP, 3-111
  ATTACH, 3-12			     FFORK, 3-111
  BIN, 3-16			     FFUFP, 3-112
  BKJFN, 3-17			     FLHST, 3-112
  BOOT, 3-17			     FLIN, 3-113
  BOUT, 3-26			     FLOUT, 3-113
  CACCT, 3-27			     GACCT, 3-114
  CFBIF, 3-28			     GACTF, 3-115
  CFBOF, 3-28			     GCVEC, 3-115
  CFORK, 3-29			     GDSKC, 3-116
  CHFDB, 3-30			     GDSTS, 3-116


			       Index-7


				INDEX


JSYS,				   JSYS,
  (Cont.)			     (Cont.)
  GDVEC, 3-117			     NIN, 3-235
  GET, 3-118			     NODE, 3-236
  GETAB, 3-124			     NOUT, 3-241
  GETER, 3-125			     ODCNV, 3-243
  GETJI, 3-125			     ODTIM, 3-244
  GETNM, 3-127			     ODTNC, 3-246
  GETOK, 3-329			     OPENF, 3-247
  GETOK%, 3-120 		     PBIN, 3-251
  GEVEC, 3-127			     PBOUT, 3-252
  GFRKH, 3-127			     PEEK, 3-252
  GFRKS, 3-128			     PLOCK, 3-253
  GFUST, 3-130			     PMAP, 3-254
  GIVOK%, 3-131 		     PMCTL, 3-258
  GNJFN, 3-132			     PPNST, 3-261
  GPJFN, 3-133			     PRARG, 3-262
  GTDAL, 3-134			     PSOUT, 3-263
  GTDIR, 3-134			     RCDIR, 3-263
  GTFDB, 3-135			     RCM, 3-267
  GTHST%, 3-136 		     RCUSR, 3-267
  GTJFN, 3-139, 3-147		     RCVIM, 3-269
  GTNCP, 3-154			     RCVOK%, 3-270
  GTRPI, 3-153			     RDTTY, 3-271
  GTRPW, 3-156			     RELD, 3-273
  GTSTS, 3-156			     RELSQ, 3-274
  GTTYP, 3-157			     RESET, 3-274
  HALTF, 3-158			     RFACS, 3-275
  HFORK, 3-158			     RFBSZ, 3-275
  HPTIM, 3-159			     RFCOC, 3-276
  HSYS, 3-159			     RFMOD, 3-276
  IDCNV, 3-160			     RFORK, 3-277
  IDTIM, 3-161			     RFPOS, 3-278
  IDTNC, 3-163			     RFPTR, 3-278
  IIC, 3-164			     RFRKH, 3-279
  INLNM, 3-165			     RFSTS, 3-279
  JFNS, 3-165			     RFTAD, 3-282
  KFORK, 3-168			     RIN, 3-283
  LGOUT, 3-168			     RIR, 3-284
  LNMST, 3-169			     RIRCM, 3-284
  LOGIN, 3-170			     RLJFN, 3-285
  LPINI, 3-171			     RMAP, 3-286
  MDDT%, 3-171			     RNAMF, 3-286
  METER%, 3-172 		     ROUT, 3-288
  MRECV, 3-173			     RPACS, 3-289
  MSEND, 3-175			     RPCAP, 3-290
  MSFRK, 3-180			     RSCAN, 3-290
  MSTR, 3-181			     RTFRK, 3-292
  MTALN, 3-198			     RTIW, 3-293
  MTOPR, 3-199			     RUNTM, 3-293
  MTU%, 3-228			     RWM, 3-294
  MUTIL, 3-229			     RWSET, 3-294


			       Index-8


				INDEX


JSYS,				   JSYS,
  (Cont.)			     (Cont.)
  SACTF, 3-295			     STO, 3-350
  SAVE, 3-295			     STPAR, 3-351
  SCTTY, 3-296			     STPPN, 3-352
  SCVEC, 3-298			     STSTS, 3-353
  SDSTS, 3-300			     STTYP, 3-353
  SDVEC, 3-300			     SWJFN, 3-354
  SETER, 3-301			     SWTRP%, 3-354
  SETJB, 3-302			     SYERR, 3-356
  SETNM, 3-304			     SYSGT, 3-356
  SETSN, 3-304			     TBADD, 3-357
  SEVEC, 3-305			     TBDEL, 3-357
  SFACS, 3-305			     TBLUK, 3-357
  SFBSZ, 3-306			     TEXTI, 3-360
  SFCOC, 3-307			     TFORK, 3-364
  SFMOD, 3-307			     THIBR, 3-367
  SFORK, 3-308			     TIME, 3-368
  SFPOS, 3-309			     TIMER, 3-368
  SFPTR, 3-309			     TLINK, 3-370
  SFRKV, 3-310			     TMON, 3-372
  SFTAD, 3-311			     TTMSG, 3-373
  SFUST, 3-313			     TWAKE, 3-374
  SIBE, 3-314			     UFPGS, 3-374
  SIN, 3-315			     USAGE, 3-375
  SINM, 3-317			     USRIO, 3-378
  SINR, 3-318			     UTEST, 3-379
  SIR, 3-319			     UTFRK, 3-380
  SIRCM, 3-320			     VACCT, 3-381
  SIZEF, 3-321			     WAIT, 3-382
  SJPRI, 3-322			     WFORK, 3-382
  SKED%, 3-322			     WILD%, 3-383
  SKPIR, 3-327
  SMON, 3-328
  SNDIM, 3-330
  SNOOP, 3-330			   KFORK JSYS, 3-168
  SOBE, 3-334			   Killing a job, 3-168
  SOBF, 3-335			   Killing a process, 3-168
  SOUT, 3-335
  SOUTM, 3-337
  SOUTR, 3-338
  SPACS, 3-339			   LGOUT JSYS, 3-168
  SPJFN, 3-340			   Linking,
  SPLFK, 3-341			     terminal, 3-370
  SPOOL, 3-342			   LNMST JSYS, 3-169
  SPRIW, 3-344			   Loading VFU, 3-171
  SSAVE, 3-344			   Logging in a job, 3-170
  STAD, 3-346			   Logical name,
  STCMP, 3-346			     Creating a, 3-71
  STDEV, 3-347			     Returning a, 3-165
  STI, 3-348			     Translating a, 3-169
  STIW, 3-349			   Logical names, 2-3


			       Index-9


				INDEX


LOGIN JSYS, 3-170		   MT:, 2-38
Long form JFN, 3-147		   MTA:, 2-33
LPINI JSYS, 3-171		   MTALN JSYS, 3-198
LPT:, 2-33			   MTOPR JSYS, 3-199
				   MTU% JSYS, 3-228
				   MUTIL JSYS, 3-229
 
Making FACT file entries,
    3-97
Manipulating a spooled		   Name,
    device, 3-342		     Creating a logical, 3-71
Manipulation,			     Private, 3-304
  Process, 3-308		     Returning a logical,
Mapping,			       3-165
  Page, 3-254, 3-255, 3-256,	     Returning program, 3-127
    3-257			     System, 3-304
Mask,				     Translating a logical,
  Returning interrupt,		       3-169
    3-284, 3-294		   Name string,
  setting interrupt, 3-320	     translating device, 3-347
MDDT,				     translating directory,
  entering, 3-171		       3-352
MDDT% JSYS, 3-171		   Names,
Memory, 			     Logical, 2-3
  Acquiring physical, 3-253	   NCP information,
Message,			     Returning, 3-154
  Retrieving an IPCF, 3-173	   Network functions, 3-236
  sending an IPCF, 3-175	   New job,
Meter values,			     Creating a, 3-65
  Returning EBOX/MBOX,		   NIN JSYS, 3-235
    3-172			   NODE JSYS, 3-236
METER% JSYS, 3-172		   Nonshareable save, 3-295
Mode,				   NOUT JSYS, 3-241
  setting device, 3-351 	   Number,
  User I/O, 3-378		     Converting host, 3-72
Mode word,			     Converting socket, 3-73
  JFN, 3-276			     Inputting a, 3-235
Modes,				     Outputting a, 3-241
  setting terminal, 3-307	     Project-programmer, 3-261,
  Software data, 2-47		       3-352
Monitor flags,			     setting terminal, 3-353
  setting, 3-328		     Translating directory,
  testing, 3-372		       3-88
Most recent error,		   NVT connection,
  Returning, 3-125		     Creating, 3-15
Mountable-structure
    functions, 3-181
MRECV JSYS, 3-173
MSEND JSYS, 3-175		   ODCNV JSYS, 3-243
MSFRK JSYS, 3-180		   ODTIM JSYS, 3-244
MSTR JSYS, 3-181		   ODTNC JSYS, 3-246
MT device functions, 3-228


			       Index-10


				INDEX


Offline expiration date and	   Pages,
    time, 3-282 		     updating file, 3-374
Online expiration date and	   Panic channels, 2-53
    time, 3-282 		   Parameters,
OPENF JSYS, 3-247		     job, 3-302
Opening a file, 3-247		   Parsing,
Operations,			     Command, 3-37
  Process, 2-59, 3-128, 	   PBIN JSYS, 3-251
    3-133, 3-153, 3-158,	   PBOUT JSYS, 3-252
    3-168, 3-173, 3-175,	   PCDP:, 2-29
    3-180, 3-277, 3-341,	   PCDR:, 2-28
    3-364, 3-374, 3-380,	   PEEK JSYS, 3-252
    3-382			   Performance analysis,
Output, 			     System, 3-330
  block-mode, 3-337		   Physical memory,
  Byte, 3-26, 3-252		     Acquiring, 3-253
  Double-precision, 3-80	   Physical/logical tape-drive
  Dump, 3-94			       association, 3-198
  Floating-point, 3-113 	   PLOCK JSYS, 3-253
  simulating terminal,		   PMAP JSYS, 3-254
    3-350			   PMCTL JSYS, 3-258
  string, 3-335 		   Pointer,
Output buffer,			     Backing up, 3-17
  Clearing file, 3-28		     Byte, 1-5
  testing file, 3-334,		     setting file, 3-309
    3-335			     setting terminal, 3-309
Output designator,		   PPNST JSYS, 3-261
  Primary, 3-271		   PRARG JSYS, 3-262
Outputting a number, 3-241	   Primary input designator,
Outputting date/time, 3-244,	       3-271
    3-246			   Primary JFN,
Outputting error strings,	     setting, 3-340
    3-110			   Primary output designator,
Overflow trapping, 3-354	       3-271
				   Priority,
				     setting job, 3-322
				     setting process, 3-344
PA1050 entry vector,		     Software interrupt, 2-52
  Returning, 3-115		   Priority control word,
Page,				     scheduler, 3-322
  Finding 1'st free file,	   Private name, 3-304
    3-111			   Process,
  Finding 1'st used file,	     Creating an inferior,
    3-112			       3-29
Page access, 3-286		     Dismissing a, 3-86, 3-88,
Page accessibility,		       3-89
  setting, 3-339		     Freezing a, 3-111
Page mapping, 3-254, 3-255,	     halting a, 3-158
    3-256, 3-257		     killing a, 3-168
Page trap information,		     splicing a, 3-341
  Returning, 3-153		     starting a, 3-180



			       Index-11


				INDEX


Process,			   Recent error,
  (Cont.)			     Returning most, 3-125
  waking a, 3-374		   Redefining controlling
Process blocking,		       terminal, 3-296
  elapsed time, 3-367		   RELD JSYS, 3-273
Process capabilities, 2-56	   Releasing a JFN, 3-285
Process entry vector,		   Releasing devices, 3-273
  Returning, 3-127		   Releasing working set,
Process execution,		       3-294
  resuming, 3-380		   RELSQ JSYS, 3-274
Process files,			   Renaming a file, 3-286
  Closing, 3-36 		   Rescan buffer, 3-290
Process handle, 1-6		   Reserving a channel, 3-81
Process manipulation, 3-308	   RESET JSYS, 3-274
Process operations, 2-59,	   Resetting file byte size,
    3-128, 3-133, 3-153,	       3-306
    3-158, 3-168, 3-173,	   Restart time,
    3-175, 3-180, 3-277,	     returning elapsed system,
    3-341, 3-364, 3-374,	       3-368
    3-380, 3-382		   Resuming process execution,
Process priority,		       3-380
  setting, 3-344		   Retrieving an IPCF message,
Process status, 3-279,		       3-173
    3-281			   Returning a logical name,
Process termination,		       3-165
  waiting for, 3-382		   Returning arpanet host
Process timing, 3-368		       information, 3-136
Process/file handle, 1-6	   Returning device
Program,			       characteristics, 3-96
  Access-control, 3-131 	   Returning device status,
  access-control, 3-329 	       3-116
  Sample, 2-5			   Returning directory
Program name,			       information, 3-134
  Returning, 3-127		   Returning disk allocation,
Project-programmer number,	       3-134
    3-261, 3-352		   Returning disk usage, 3-116
PSOUT JSYS, 3-263		   Returning EBOX/MBOX meter
				       values, 3-172
				   Returning elapsed system
				       restart time, 3-368
Queue,				   Returning file author,
  Assigning ARPANET, 3-12	       3-130
				   Returning file descriptor
				       block, 3-135
				   Returning file
Random byte input, 3-283	       specification, 3-165
RCDIR JSYS, 3-263		   Returning file status,
RCM JSYS, 3-267 		       3-156
RCUSR JSYS, 3-267		   Returning file's account,
RCVIM JSYS, 3-269		       3-115
RCVOK% JSYS, 3-270		   Returning high-precision
RDTTY JSYS, 3-271		       clock, 3-159


			       Index-12


				INDEX


Returning interrupt mask,	   RUNTM JSYS, 3-293
    3-284, 3-294		   RWM JSYS, 3-294
Returning interrupt table,	   RWSET JSYS, 3-294
    3-284
Returning job information,
    3-125
Returning job's account,	   SACTF JSYS, 3-295
    3-114			   Sample program, 2-5
Returning most recent error,	   Save,
    3-125			     nonshareable, 3-295
Returning NCP information,	     sharable, 3-344
    3-154			   Save file,
Returning PA1050 entry		     Getting a, 3-118
    vector, 3-115		   SAVE files, 2-63
Returning page trap		   SAVE JSYS, 3-295
    information, 3-153		   Scheduler control, 3-322
Returning process entry 	   Scheduler priority control
    vector, 3-127		       word, 3-322
Returning program name, 	   SCTTY JSYS, 3-296
    3-127			   SCVEC JSYS, 3-298
Returning RMS entry vector,	   SDSTS JSYS, 3-300
    3-117			   SDVEC JSYS, 3-300
Returning system table, 	   Searching,
    3-124, 3-356		     table, 3-357
Returning terminal type,	   Sending an IPCF message,
    3-157			       3-175
Returning trap words, 3-156	   Set,
RFACS JSYS, 3-275		     Releasing working, 3-294
RFBSZ JSYS, 3-275		   SETER JSYS, 3-301
RFCOC JSYS, 3-276		   SETJB JSYS, 3-302
RFMOD JSYS, 3-276		   SETNM JSYS, 3-304
RFORK JSYS, 3-277		   SETSN JSYS, 3-304
RFPOS JSYS, 3-278		   Setting AC'S, 3-305
RFPTR JSYS, 3-278		   Setting device mode, 3-351
RFRKH JSYS, 3-279		   Setting file author, 3-313
RFSTS JSYS, 3-279		   Setting file date and time,
RFTAD JSYS, 3-282		       3-311
RIN JSYS, 3-283 		   Setting file pointer, 3-309
RIR JSYS, 3-284 		   Setting file status, 3-353
RIRCM JSYS, 3-284		   Setting interrupt mask,
RLJFN JSYS, 3-285		       3-320
RMAP JSYS, 3-286		   Setting interrupt table
RMS entry vector, 3-300 	       addresses, 3-319
  Returning, 3-117		   Setting job priority, 3-322
RNAMF JSYS, 3-286		   Setting monitor flags,
ROUT JSYS, 3-288		       3-328
RPACS JSYS, 3-289		   Setting page accessibility,
RPCAP JSYS, 3-290		       3-339
RSCAN JSYS, 3-290		   Setting primary JFN, 3-340
RTFRK JSYS, 3-292		   Setting process priority,
RTIW JSYS, 3-293		       3-344
Runtime, 3-293			   Setting system date, 3-346


			       Index-13


				INDEX


Setting terminal interrupt	   Software interrupt system,
    word, 3-349 		     (Cont.)
Setting terminal modes, 	     Clearing, 3-35
    3-307			     Enabling, 3-98
Setting terminal number,	   Software interrupt table,
    3-353			       2-52
Setting terminal pointer,	   Software interrupts,
    3-309			     Initiating, 3-164
SEVEC JSYS, 3-305		   Source/destination
SFACS JSYS, 3-305		       designator, 1-3
SFBSZ JSYS, 3-306		   SOUT JSYS, 3-335
SFCOC JSYS, 3-307		   SOUTM JSYS, 3-337
SFMOD JSYS, 3-307		   SOUTR JSYS, 3-338
SFORK JSYS, 3-308		   SPACS JSYS, 3-339
SFPOS JSYS, 3-309		   Special designator, 1-5
SFPTR JSYS, 3-309		   Specification,
SFRKV JSYS, 3-310		     File, 2-1
SFTAD JSYS, 3-311		     Returning file, 3-165
SFUST JSYS, 3-313		   SPJFN JSYS, 3-340
Sharable save, 3-344		   SPLFK JSYS, 3-341
Short form JFN, 3-139		   Splicing a process, 3-341
SIBE JSYS, 3-314		   SPOOL JSYS, 3-342
Simulating terminal input,	   Spooled device,
    3-348			     Manipulating a, 3-342
Simulating terminal output,	   SPRIW JSYS, 3-344
    3-350			   SSAVE JSYS, 3-344
SIN JSYS, 3-315 		   STAD JSYS, 3-346
SINM JSYS, 3-317		   Standard,
SINR JSYS, 3-318		     Date/time, 1-6
SIR JSYS, 3-319 		   Starting a process, 3-180
SIRCM JSYS, 3-320		   Status,
Size,				     Process, 3-279, 3-281
  resetting file byte,		     Returning device, 3-116
    3-306			     Returning file, 3-156
SIZEF JSYS, 3-321		     setting file, 3-353
SJPRI JSYS, 3-322		   STCMP JSYS, 3-346
SKED% JSYS, 3-322		   STDEV JSYS, 3-347
SKPIR JSYS, 3-327		   STI JSYS, 3-348
SMON JSYS, 3-328		   STIW JSYS, 3-349
SNDIM JSYS, 3-330		   STO JSYS, 3-350
SNOOP JSYS, 3-330		   Storage block,
SOBE JSYS, 3-334		     Job, 3-290
SOBF JSYS, 3-335		   STPAR JSYS, 3-351
Socket number,			   STPPN JSYS, 3-352
  Converting, 3-73		   String,
Software data modes, 2-47	     Translating device, 3-79
Software interrupt channel,	     translating device name,
    2-51			       3-347
Software interrupt priority,	     translating directory
    2-52			       name, 3-352
Software interrupt system,	   String comparison,
    2-51			     wild, 3-383


			       Index-14


				INDEX


String input, 3-315		   Tables,
String output, 3-335		     System, 2-20
Strings,			   Tape-drive association,
  comparing, 3-346		     physical/logical, 3-198
  Outputting error, 3-110	   TBADD JSYS, 3-357
  Translating error, 3-109	   TBDEL JSYS, 3-357
STSTS JSYS, 3-353		   TBLUK JSYS, 3-357
STTYP JSYS, 3-353		   Terminal,
Swapping JFN'S, 3-354		     Redefining controlling,
SWJFN JSYS, 3-354		       3-296
SWTRP% JSYS, 3-354		   Terminal codes,
SYERR JSYS, 3-356		     Deassigning, 3-92
Syserr, 3-356			   Terminal input,
SYSGT JSYS, 3-356		     simulating, 3-348
System, 			   Terminal interrupt,
  Archive/virtual disk, 	     Assigning, 3-14
    2-70			   Terminal interrupt word,
  Clearing software		       3-293
    interrupt, 3-35		     setting, 3-349
  disabling interrupt, 3-87	   Terminal interrupts, 2-53
  Enabling software		   Terminal linking, 3-370
    interrupt, 3-98		   Terminal modes,
  halting, 3-159		     setting, 3-307
  Software interrupt, 2-51	   Terminal number,
System accounting, 3-375	     setting, 3-353
System date,			   Terminal output,
  setting, 3-346		     simulating, 3-350
System error file, 3-356	   Terminal pointer,
System name, 3-304		     setting, 3-309
System performance analysis,	   Terminal type,
    3-330			     returning, 3-157
System restart time,		   Termination,
  returning elapsed, 3-368	     waiting for process,
System table,			       3-382
  Returning, 3-124		   Testing file input buffer,
  returning, 3-356		       3-314
System tables, 2-20		   Testing file output buffer,
				       3-334, 3-335
				   Testing monitor flags,
				       3-372
Table,				   TEXTI JSYS, 3-360
  Returning interrupt,		   TFORK JSYS, 3-364
    3-284			   THIBR JSYS, 3-367
  Returning system, 3-124	   Time,
  returning system, 3-356	     file date and, 3-282
  Software interrupt, 2-52	     offline expiration date
Table addresses,		       and, 3-282
  setting interrupt, 3-319	     online expiration date
Table entry,			       and, 3-282
  adding a, 3-357		     returning elapsed system
  deleting a, 3-357		       restart, 3-368
Table searching, 3-357		     setting file date and,


			       Index-15


				INDEX


Time,				   Used file page,
  (Cont.)			     Finding 1'st, 3-112
    3-311			   User I/O mode, 3-378
TIME JSYS, 3-368		   USRIO JSYS, 3-378
Time process blocking,		   UTEST JSYS, 3-379
  elapsed, 3-367		   UTFRK JSYS, 3-380
TIMER JSYS, 3-368
Timing,
  Process, 3-368
TLINK JSYS, 3-370		   VACCT JSYS, 3-381
TMON JSYS, 3-372		   Values,
To internal date/time,		     Returning EBOX/MBOX meter,
  Converting, 3-160		       3-172
Translating a logical name,	   Vector,
    3-169			     compatibility package
Translating device name 	       entry, 3-298
    string, 3-347		     Entry, 2-65, 3-305
Translating device string,	     Returning PA1050 entry,
    3-79			       3-115
Translating directory name	     Returning process entry,
    string, 3-352		       3-127
Translating directory		     Returning RMS entry,
    number, 3-88		       3-117
Translating error strings,	     RMS entry, 3-300
    3-109			   Verifying accounts, 3-381
Trap information,		   VFU,
  Returning page, 3-153 	     Loading, 3-171
Trap words,
  Returning, 3-156
Trapping,
  overflow, 3-354		   WAIT JSYS, 3-382
  underflow, 3-354		   Waiting for process
TTMSG JSYS, 3-373		       termination, 3-382
TTY I/O, 3-271, 3-276,		   Waking a process, 3-374
    3-360			   WFORK JSYS, 3-382
TTY:, 2-39			   Wild string comparison,
TWAKE JSYS, 3-374		       3-383
Type,				   WILD% JSYS, 3-383
  returning terminal, 3-157	   Word,
				     JFN mode, 3-276
				     scheduler priority
				       control, 3-322
UFPGS JSYS, 3-374		     setting terminal
Underflow trapping, 3-354	       interrupt, 3-349
Up pointer,			     Terminal interrupt, 3-293
  Backing, 3-17 		   Words,
Updating file pages, 3-374	     CCOC, 3-276, 3-307
Usage,				     Returning trap, 3-156
  Returning disk, 3-116 	   Working set,
USAGE JSYS, 3-375		     Releasing, 3-294




			       Index-                         d Tag Table                   