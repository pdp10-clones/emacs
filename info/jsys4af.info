
File: JSYSAF	Node: Top	Up: (DIR)

This file contains chapter 3 of the Monitor Calls Reference Manual 
(version 4-Prelimnary), JSYS'S A* to F*, in INFO format.

* Menu:

* ACCES: (JSYS4AF)ACCES, (552) Specifies access to a directory 3-1
* ADBRK: (JSYS4AF)ADBRK, (570) Controls address breaks 3-3
* AIC: (JSYS4AF)AIC, (131) Activates software interrupt channels 3-5
* ALLOC: (JSYS4AF)ALLOC, (520) Allocates a device 3-5
* ARCF: (JSYS4AF)ARCF, (247) Archive/virtual disk operations x-xx
* ASND: (JSYS4AF)ASND, (70) Assigns a device 3-6
* ASNSQ: (JSYS4AF)ASNSQ, (752) Assigns ARPANET special message queue x-xx
* ATNVT: (JSYS4AF)ATNVT, (274) Creates ARPANET Network Virtual Terminal Connection x-xx
* ATACH: (JSYS4AF)ATACH, (116) Attachs a terminal to a job 3-7
* ATI: (JSYS4AF)ATI, (137) Assigns a terminal code to an interrupt channel 3-8
* BIN: (JSYS4AF)BIN, (50) Performs byte input 3-9
* BKJFN: (JSYS4AF)BKJFN, (42) Backs up pointer by one byte 3-10
* BOOT: (JSYS4AF)BOOT, (562) Performs functions required for loading front-end software 3-10
* BOUT: (JSYS4AF)BOUT, (51) Performs byte output 3-14
* CACCT: (JSYS4AF)CACCT, (4) Changes account designator 3-15
* CFIBF: (JSYS4AF)CFIBF, (100) Clears the input buffer 3-15
* CFOBF: (JSYS4AF)CFOBF, (101) Clears the output buffer 3-16
* CFORK: (JSYS4AF)CFORK, (152) Creates an inferior process 3-16
* CHFDB: (JSYS4AF)CHFDB, (64) Changes a File Descriptor Block 3-17
* CHKAC: (JSYS4AF)CHKAC, (521) Checks access to a file 3-18
* CIS: (JSYS4AF)CIS, (141) Clears the interrupt system 3-19
* CLOSF: (JSYS4AF)CLOSF, (22) Closes a file 3-20
* CLZFF: (JSYS4AF)CLZFF, (34) Closes the process' files 3-21
* COMND: (JSYS4AF)COMND, (544) Parses a command 3-22
* CRDIR: (JSYS4AF)CRDIR, (240) Creates, changes, or deletes a directory 3-38
* CRJOB: (JSYS4AF)CRJOB, (2) Creates a job 3-42
* CRLNM: (JSYS4AF)CRLNM, (502) Defines or deletes a logical name 3-47
* CVHST: (JSYS4AF)CVHST, (276) Converts ARPANET host number to primary name x-xx
* CVSKT: (JSYS4AF)CVSKT, (275) Converts ARPANET local socket to absolute form x-xx
* DEBRK: (JSYS4AF)DEBRK, (136) Dismisses current software interrupt 3-48
* DELDF: (JSYS4AF)DELDF, (67) Expunges deleted files 3-48
* DELF: (JSYS4AF)DELF, (26) Deletes files 3-49
* DELNF: (JSYS4AF)DELNF, (317) Retains specified number of generations of a file 3-50
* DEQ: (JSYS4AF)DEQ, (514) Removes request from resource queue 3-51
* DEVST: (JSYS4AF)DEVST, (121) Translates a device designator to a string 3-53
* DFIN: (JSYS4AF)DFIN, (234) Inputs double-precision floating point number 3-53
* DFOUT: (JSYS4AF)DFOUT, (235) Outputs double-precision floating point number 3-54
* DIAG: (JSYS4AF)DIAG, (530) Reserves or releases hardware channels 3-55
* DIBE: (JSYS4AF)DIBE, (212) Dismisses until input buffer is empty 3-56
* DIC: (JSYS4AF)DIC, (133) Deactivates software interrupt channels 3-57
* DIR: (JSYS4AF)DIR, (130) Disables software interrupt system 3-57
* DIRST: (JSYS4AF)DIRST, (41) Translates a directory number to a string 3-58
* DISMS: (JSYS4AF)DISMS, (167) Dismisses the process 3-59
* DOBE: (JSYS4AF)DOBE, (104) Dismisses until output buffer is empty 3-59
* DSKAS: (JSYS4AF)DSKAS, (244) Assigns disk addresses 3-60
* DSKOP: (JSYS4AF)DSKOP, (242) Specifies disk transfers in hardware terms 3-61
* DTACH: (JSYS4AF)DTACH, (115) Detaches a terminal from a job 3-62
* DTI: (JSYS4AF)DTI, (140) Deassigns a terminal code 3-62
* DUMPI: (JSYS4AF)DUMPI, (65) Reads data in unbuffered data mode 3-63
* DUMPO: (JSYS4AF)DUMPO, (66) Writes data in unbuffered data mode 3-64
* DVCHR: (JSYS4AF)DVCHR, (117) Retrieves device characteristics 3-65
* EFACT: (JSYS4AF)EFACT, (5) Makes an entry in the FACT file 3-66
* EIR: (JSYS4AF)EIR, (126) Enables software interrupt system 3-67
* ENQ: (JSYS4AF)ENQ, (513) Places request in resource queue 3-67
* ENQC: (JSYS4AF)ENQC, (515) Obtains status of resource queue 3-73
* EPCAP: (JSYS4AF)EPCAP, (151) Enables process capabilities 3-76
* ERSTR: (JSYS4AF)ERSTR, (11) Converts error number to string 3-77
* ESOUT: (JSYS4AF)ESOUT, (313) Outputs an error string 3-78
* FFFFP: (JSYS4AF)FFFFP, (31) Finds first free page in file 3-78
* FFORK: (JSYS4AF)FFORK, (154) Freezes processes 3-79
* FFUFP: (JSYS4AF)FFUFP, (211) Finds first used page in file 3-79
* FLHST: (JSYS4AF)FLHST, (277) Flushes an ARPANET host x-xx
* FLIN: (JSYS4AF)FLIN, (232) Inputs floating-point number 3-80
* FLOUT: (JSYS4AF)FLOUT, (233) Outputs floating-point number 3-80
* GACCT: (JSYS4GM)GACCT, (546) Gets current account designator 3-81
* GACTF: (JSYS4GM)GACTF, (37) Gets account designator of file 3-81
* GCVEC: (JSYS4GM)GCVEC, (300) Gets entry vector of compatibility package 3-82
* GDSKC: (JSYS4GM)GDSKC, (214) Gets disk count 3-83
* GDSTS: (JSYS4GM)GDSTS, (145) Gets device's status 3-83
* GDVEC: (JSYS4GM)GDVEC, (542) Gets entry vector of RMS 3-84
* GET: (JSYS4GM)GET, (200) Gets a save file 3-84
* GETAB: (JSYS4GM)GETAB, (10) Gets a word from a monitor table 3-85
* GETER: (JSYS4GM)GETER, (12) Returns the last error in a process 3-86
* GETJI: (JSYS4GM)GETJI, (507) Gets specified job information 3-86
* GETNM: (JSYS4GM)GETNM, (177) Returns the program name currently being used 3-87
* GETOK%: (JSYS4GM)GETOK%, (574) Requests access to a protected resource x-xx
* GEVEC: (JSYS4GM)GEVEC, (205) Gets entry vector 3-88
* GFRKH: (JSYS4GM)GFRKH, (164) Gets process handle 3-88
* GFRKS: (JSYS4GM)GFRKS, (166) Gets process structure 3-89
* GFUST: (JSYS4GM)GFUST, (550) Returns author and last writer name strings 3-90
* GIVOK%: (JSYS4GM)GIVOK%, (576) Grants access to a protected resource x-xx
* GJINF: (JSYS4GM)GJINF, (13) Gets current job information 3-91
* GNJFN: (JSYS4GM)GNJFN, (17) Gets the next JFN 3-91
* GPJFN: (JSYS4GM)GPJFN, (206) Gets the primary JFNs 3-92
* GTAD: (JSYS4GM)GTAD, (227) Gets current date and time 3-93
* GTDAL: (JSYS4GM)GTDAL, (305) Gets disk allocation of a directory 3-93
* GTDIR: (JSYS4GM)GTDIR, (241) Gets information of directory entry 3-94
* GTFDB: (JSYS4GM)GTFDB, (63) Gets a File Descriptor Block 3-95
* GTJFN Long Form: (JSYS4GM)GTJFN-long, (20) Gets a JFN Short Form 3-96 Long Form 3-103
* GTJFN Short Form: (JSYS4GM)GTJFN-short, (20) Gets a JFN Short Form 3-96 Long Form 3-103
* GTRPI: (JSYS4GM)GTRPI, (172) Get trap information 3-107
* GTRPW: (JSYS4GM)GTRPW, (171) Gets trap words 3-108
* GTSTS: (JSYS4GM)GTSTS, (24) Gets a file's status 3-109
* GTTYP: (JSYS4GM)GTTYP, (303) Gets the terminal type number 3-109
* HALTF: (JSYS4GM)HALTF, (170) Halts the current process 3-110
* HFORK: (JSYS4GM)HFORK, (162) Halts a process 3-110
* HPTIM: (JSYS4GM)HPTIM, (501) Returns values of high precision clocks 3-111
* HSYS: (JSYS4GM)HSYS, (307) Halts the system 3-111
* IDCNV: (JSYS4GM)IDCNV, (223) Inputs date and time conversion 3-112
* IDTIM: (JSYS4GM)IDTIM, (221) Inputs date and time 3-113
* IDTNC: (JSYS4GM)IDTNC, (231) Inputs date/time without converting 3-115
* IIC: (JSYS4GM)IIC, (132) Initiates software interrupts on specified channels 3-116
* INLNM: (JSYS4GM)INLNM, (503) Lists job's logical names 3-117
* JFNS: (JSYS4GM)JFNS, (30) Translates a JFN to a string 3-117
* KFORK: (JSYS4GM)KFORK, (153) Kills a process 3-119
* LGOUT: (JSYS4GM)LGOUT, (3) Kills a job 3-120
* LNMST: (JSYS4GM)LNMST, (504) Converts a logical name to a string 3-121
* LOGIN: (JSYS4GM)LOGIN, (1) Logs in a job 3-121
* LPINI: (JSYS4GM)LPINI, (547) Loads VFU or translation RAM 3-122
* MRECV: (JSYS4GM)MRECV, (511) Receives an IPCF message 3-123
* MSEND: (JSYS4GM)MSEND, (510) Sends an IPCF message 3-125
* MSFRK: (JSYS4GM)MSFRK, (312) Starts a process in monitor mode 3-129
* MSTR: (JSYS4GM)MSTR, (555) Performs structure-dependent functions 3-129
* MTALN: (JSYS4GM)MTALN, (774) Associates magnetic tape drive with logical unit number 3-142
* MTOPR: (JSYS4GM)MTOPR, (77) Performs device-dependent functions 3-142
* MTU%: (JSYS4GM)MTU%, (600) Performs various functions for MT: devices x-xx
* MUTIL: (JSYS4GM)MUTIL, (512) Performs IPCF control functions 3-153
* NIN: (JSYS4NR)NIN, (225) Inputs an integer number 3-158
* NODE: (JSYS4NR)NODE, (567) Performs network utility functions 3-158
* NOUT: (JSYS4NR)NOUT, (224) Outputs an integer number 3-158
* ODCNV: (JSYS4NR)ODCNV, (222) Outputs date and time conversion 3-159
* ODTIM: (JSYS4NR)ODTIM, (220) Outputs date and time 3-160
* ODTNC: (JSYS4NR)ODTNC, (230) Outputs date/time without converting 3-162
* OPENF: (JSYS4NR)OPENF, (21) Opens a file 3-163
* PBIN: (JSYS4NR)PBIN, (73) Inputs the next byte 3-166
* PBOUT: (JSYS4NR)PBOUT, (74) Outputs the next byte 3-167
* PEEK: (JSYS4NR)PEEK, (311) Obtains monitor data 3-167
* PLOCK: (JSYS4NR)PLOCK, (561) Locks physical pages 3-168
* PMAP: (JSYS4NR)PMAP, (56) Maps pages 3-168.1
* PMCTL: (JSYS4NR)PMCTL, (560) Controls physical memory 3-171
* PPNST: (JSYS4NR)PPNST, (557) Translates project-programmer number to string 3-173
* PRARG: (JSYS4NR)PRARG, (545) Reads/sets process argument block 3-174
* PSOUT: (JSYS4NR)PSOUT, (76) Outputs a string 3-174
* RCDIR: (JSYS4NR)RCDIR, (553) Translates string to directory number 3-175
* RCM: (JSYS4NR)RCM, (134) Reads the channel word mask 3-178
* RCVIM: (JSYS4NR)RCVIM, (751) Retrieves message from ARPANET special message queue x-xx
* RCVOK%: (JSYS4NR)RCVOK%, (575) Retrieves access request from GETOK queue x-xx
* RCUSR: (JSYS4NR)RCUSR, (554) Translates string to user number 3-179
* RDTTY: (JSYS4NR)RDTTY, (523) Reads data from primary input designator 3-180
* RELD: (JSYS4NR)RELD, (71) Releases a device 3-182
* RELSQ: (JSYS4NR)RELSQ, (753) Deassigns ARPANET special message queue x-xx
* RESET: (JSYS4NR)RESET, (147) Resets/initializes the current process 3-183
* RFACS: (JSYS4NR)RFACS, (161) Reads process' ACs 3-183
* RFBSZ: (JSYS4NR)RFBSZ, (45) Reads files's byte size 3-184
* RFCOC: (JSYS4NR)RFCOC, (112) Reads file's control character output 3-184
* RFMOD: (JSYS4NR)RFMOD, (107) Reads a file's mode 3-185
* RFORK: (JSYS4NR)RFORK, (155) Resumes a process 3-185
* RFPOS: (JSYS4NR)RFPOS, (111) Reads terminal's position 3-186
* RFPTR: (JSYS4NR)RFPTR, (43) Reads file's pointer position 3-187
* RFRKH: (JSYS4NR)RFRKH, (165) Releases a process handle 3-187
* RFSTS: (JSYS4NR)RFSTS, (156) Reads a process' status 3-188
* RFTAD: (JSYS4NR)RFTAD, (533) Reads file's time and dates 3-189
* RIN: (JSYS4NR)RIN, (54) Performs random input 3-190
* RIR: (JSYS4NR)RIR, (144) Reads software interrupt table addresses 3-191
* RIRCM: (JSYS4NR)RIRCM, (143) Reads inferior reserved channel mask 3-191
* RLJFN: (JSYS4NR)RLJFN, (23) Releases JFNs 3-192
* RMAP: (JSYS4NR)RMAP, (61) Obtains a handle on a page 3-192
* RNAMF: (JSYS4NR)RNAMF, (35) Renames a file 3-193
* ROUT: (JSYS4NR)ROUT, (55) Performs random output 3-194
* RPACS: (JSYS4NR)RPACS, (57) Reads a page's accessibility 3-195
* RPCAP: (JSYS4NR)RPCAP, (150) Reads process capabilities 3-196
* RSCAN: (JSYS4NR)RSCAN, (500) Accepts a new string or uses the last string as input 3-196

* RTFRK: (JSYS4NR)RTFRK, (322) Returns the handle of a process suspended because of a monitor call intercept 3-198
* RTIW: (JSYS4NR)RTIW, (173) Reads terminal interrupt word 3-198
* RUNTM: (JSYS4NR)RUNTM, (15) Returns runtime of process or job 3-199
* RWM: (JSYS4NR)RWM, (135) Reads waiting channel interrupt word mask 3-199
* RWSET: (JSYS4NR)RWSET, (176) Releases the working set 3-200
* SACTF: (JSYS4SZ)SACTF, (62) Sets account designator of file 3-200
* SAVE: (JSYS4SZ)SAVE, (202) Saves a file as nonsharable 3-201
* SCTTY: (JSYS4SZ)SCTTY, (324) Changes controlling terminal 3-202
* SCVEC: (JSYS4SZ)SCVEC, (301) Sets entry vector of compatibility package 3-203
* SDSTS: (JSYS4SZ)SDSTS, (146) Sets device's status 3-204
* SDVEC: (JSYS4SZ)SDVEC, (543) Sets entry vector of RMS 3-205
* SETER: (JSYS4SZ)SETER, (336) Sets the last error in a process 3-206
* SETJB: (JSYS4SZ)SETJB, (541) Sets job parameters 3-206
* SETNM: (JSYS4SZ)SETNM, (210) Sets program name 3-208
* SETSN: (JSYS4SZ)SETSN, (506) Sets system name for a process 3-208
* SEVEC: (JSYS4SZ)SEVEC, (204) Sets entry vector 3-208
* SFACS: (JSYS4SZ)SFACS, (160) Sets process' ACs 3-209
* SFBSZ: (JSYS4SZ)SFBSZ, (46) Sets file's byte size 3-209
* SFCOC: (JSYS4SZ)SFCOC, (113) Sets file's control character output 3-210
* SFMOD: (JSYS4SZ)SFMOD, (110) Sets a file's mode 3-211
* SFORK: (JSYS4SZ)SFORK, (157) Starts a process 3-211
* SFPOS: (JSYS4SZ)SFPOS, (526) Sets terminal's position 3-212
* SFPTR: (JSYS4SZ)SFPTR, (27) Sets file's pointer position 3-212
* SFRKV: (JSYS4SZ)SFRKV, (201) Starts process using its entry vector 3-213
* SFTAD: (JSYS4SZ)SFTAD, (534) Sets file's time and dates 3-214
* SFUST: (JSYS4SZ)SFUST, (551) Sets author and last writer name strings 3-215
* SIBE: (JSYS4SZ)SIBE, (102) Skips if input buffer is empty 3-216
* SIN: (JSYS4SZ)SIN, (52) Performs string input 3-216
* SINM: (JSYS4SZ)SINM, (571) Reads data from block-mode terminals x-xx
* SINR: (JSYS4SZ)SINR, (531) Performs record input 3-218
* SIR: (JSYS4SZ)SIR, (125) Sets software interrupt table addresses 3-219
* SIRCM: (JSYS4SZ)SIRCM, (142) Sets inferior reserved channel mask 3-220
* SIZEF: (JSYS4SZ)SIZEF, (36) Gets the size of a file 3-221
* SJPRI: (JSYS4SZ)SJPRI, (245) Sets job's priority 3-221
* SKED%: (JSYS4SZ)SKED%, (577) Performs services relating to the class scheduler x-xx
* SKPIR: (JSYS4SZ)SKPIR, (127) Tests the state of the software interrupt system 3-222
* SNDIM: (JSYS4SZ)SNDIM, (750) Sends a message to ARPANET special message queue x-xx
* SMON: (JSYS4SZ)SMON, (6) Sets monitor flags 3-222
* SNOOP: (JSYS4SZ)SNOOP, (516) Performs system analysis 3-223

* SOBE: (JSYS4SZ)SOBE, (103) Skips if output buffer is empty 3-227
* SOBF: (JSYS4SZ)SOBF, (175) Skips if output buffer is full 3-227
* SOUT: (JSYS4SZ)SOUT, (53) Performs string output 3-228
* SOUTM: (JSYS4SZ)SOUTM, (572) Writes data to block mode terminals x-xx
* SOUTR: (JSYS4SZ)SOUTR, (532) Performs record output 3-229
* SPACS: (JSYS4SZ)SPACS, (60) Sets a page's accessibility 3-230
* SPJFN: (JSYS4SZ)SPJFN, (207) Sets the primary JFNs 3-231
* SPLFK: (JSYS4SZ)SPLFK, (314) Splices a process structure 3-232
* SPOOL: (JSYS4SZ)SPOOL, (517) Defines and initializes input spooling 3-232
* SPRIW: (JSYS4SZ)SPRIW, (243) Sets the priority word 3-234
* SSAVE: (JSYS4SZ)SSAVE, (203) Saves a file as sharable 3-235
* STAD: (JSYS4SZ)STAD, (226) Sets system date and time 3-236
* STCMP: (JSYS4SZ)STCMP, (540) Compares two strings 3-237
* STDEV: (JSYS4SZ)STDEV, (120) Translates string to device designator 3-237
* STI: (JSYS4SZ)STI, (114) Simulates terminal input 3-238
* STIW: (JSYS4SZ)STIW, (174) Sets terminal interrupt word 3-239
* STO: (JSYS4SZ)STO, (246) Simulates terminal output 3-240
* STPAR: (JSYS4SZ)STPAR, (217) Sets terminal parameters 3-241
* STPPN: (JSYS4SZ)STPPN, (556) Translates string to project-programmer number 3-242
* STSTS: (JSYS4SZ)STSTS, (25) Sets a file's status 3-242
* STTYP: (JSYS4SZ)STTYP, (302) Sets the terminal type number 3-243
* SWJFN: (JSYS4SZ)SWJFN, (47) Swaps two JFNs 3-244
* SWTRP%: (JSYS4SZ)SWTRP%, (573) Traps for arithmetic underflow or overflow conditions x-xx
* SYERR: (JSYS4SZ)SYERR, (527) Writes data to the system error file 3-244
* SYSGT: (JSYS4SZ)SYSGT, (16) Returns information for a system table 3-245
* TBADD: (JSYS4SZ)TBADD, (536) Adds entry to command table 3-245
* TBDEL: (JSYS4SZ)TBDEL, (535) Deletes entry from command table 3-246
* TBLUK: (JSYS4SZ)TBLUK, (537) Looks up entry in command table 3-246
* TEXTI: (JSYS4SZ)TEXTI, (524) Reads input from a terminal or a file 3-248
* TFORK: (JSYS4SZ)TFORK, (321) Sets and removes monitor call intercepts 3-252
* THIBR: (JSYS4SZ)THIBR, (770) Blocks the current job 3-254
* TIME: (JSYS4SZ)TIME, (14) Returns time system has been up 3-254
* TIMER: (JSYS4SZ)TIMER, (522) Sets time limit for a job 3-255
* TLINK: (JSYS4SZ)TLINK, (216) Controls terminal linking 3-256
* TMON: (JSYS4SZ)TMON, (7) Tests monitor flags 3-258
* TTMSG: (JSYS4SZ)TTMSG, (775) Sends a message to a terminal 3-259
* TWAKE: (JSYS4SZ)TWAKE, (771) Wakes a specified job 3-259
* UFPGS: (JSYS4SZ)UFPGS, (525) Updates file's pages 3-260
* USAGE: (JSYS4SZ)USAGE, (564) Writes entries into the accounting data file 3-260
* USRIO: (JSYS4SZ)USRIO, (310) Places program in user I/O mode 3-262
* UTEST: (JSYS4SZ)UTEST, (563) Test monitor routines 3-263
* UTFRK: (JSYS4SZ)UTFRK, (323) Resumes a process suspended because of a monitor call intercept 3-264
* VACCT: (JSYS4SZ)VACCT, (566) Validates an account 3-265
* WAIT: (JSYS4SZ)WAIT, (306) Dismisses process until interrupt occurs 3-266
* WFORK: (JSYS4SZ)WFORK, (163) Waits for processes to terminate 3-266
* WILD%: (JSYS4SZ)WILD%, (565) Compares wild and non-wild strings x-xx

Node: ACCESS	Next: ADBRK	Up: Top
			     ACCES     JSYS 552

   Gives a particular type of access to a given directory.  The  possible
   types of accesses are:

	1.  Connecting to a directory on a given structure.

	2.  Gaining owner and group access rights  to  directories  on	a
	    structure  without actually connecting to a directory on that
	    structure.

	3.  Relinquishing owner and group access rights to directories on
	    a  structure  without  disconnecting from a directory on that
	    structure.

   Access cannot be given to a regulated structure unless the  MSTR  JSYS
   has	been first used to increment the mount count.  All structures are
   regulated by default  except  the  primary  structure  (PS:	 on  most
   systems)  or  any  structure that has been made non-regulated with the
   MSTR JSYS.  Access rights and all JFNs on the regulated structure must
   be released before the mount count can be decremented.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
			       enabled.
   ACCEPTS IN AC1:  B0(AC%CON) connect	 the   job   to   the	specified
			       directory.  After successful completion of
			       the call, the job is connected to and  has
			       owner  access  to  the  directory, and its
			       default directory becomes this directory.

		    B1(AC%OWN) give the job owner access to the specified
			       directory  and group access to directories
			       in  the	same  groups  as  the	specified
			       directory.   The job's connected directory
			       is unchanged.   This  function  cannot  be
			       given  for another job or for a files-only
			       directory.

		    B2(AC%REM) relinquish the owner access (obtained with

   (ACCES)
   

			       the  AC%OWN  function)  to  the	specified
			       directory  and	the   group   access   to
			       directories  in the same group.	The job's
			       connected directory  is	unchanged.   This
			       function  cannot  be given for another job
			       or  for	a  files-only	directory.    The
			       settings of B0 and B1 are ignored if B2 is
			       on and the job number  given  is  for  the
			       current job.

		    B18-B35    length of the argument block

	      AC2:  address of the argument block

   RETURNS     +1:  always

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

 	0    .ACDIR	    Byte pointer to ASCIZ string  containing  the
 			    structure  and  directory  name  or  a 36-bit
 			    directory number.  The ASCIZ string  must  be
 			    of the form structure:<directory>.

 	1    .ACPSW	    Byte pointer to ASCIZ string  containing  the
 			    password  of  the  specified  directory.  The
 			    password is not required if the directory  is
 			    the  job's	logged-in directory on a domestic
 			    structure  and  if	the  directory	does  not
 			    require a password for the owner.

 	2    .ACJOB	    Number (decimal) of job or -1 for the current
			    job.  The process must have WHEEL or OPERATOR
			    capability enabled to  give  a  specific  job
			    number other than its own.

   The ACCES monitor call can be given for another job	if  the  type  of
   access  being  requested is for connecting the job (AC%CON) and if the
   process executing the call has WHEEL or OPERATOR capability enabled.

   The ACCES monitor call is used to implement the CONNECT,  ACCESS,  and
   END-ACCESS commands of the TOPS-20 Command Language.

   Generates an illegal instruction interrupt on error conditions below.

   ACCES ERROR MNEMONICS:

   ACESX1:   argument block too small

   ACESX3:   password is required

   ACESX4:   function not allowed for another job

   ACESX5:   no function specified for ACCES

   (ACCES)
   

   ACESX6:   directory is not accessed

   ACESX7:   directory is "files-only" and cannot be accessed

   CNDIX1:   invalid password

   CNDIX5:   job is not logged in

   STRX01:   structure is not mounted

   STRX02:   insufficient system resources

   STRX03:   no such directory name

   STRX04:   ambiguous directory specification

   STRX09:   prior structure mount required

   LGINX2:   directory is "files-only" and cannot be logged into

   CAPX1:    WHEEL or OPERATOR capability required

   RCDIX2:   invalid directory specification

   ARGX07:   invalid job number

   ARGX08:   no such job


Node: ADBRK	Previous: ACCESS	Next: AIC	Up: Top
			     ADBRK     JSYS 570

   Controls address breaks.  An address break  is  the	suspension  of	a
   process when a specified location is referenced in a given manner.

   RESTRICTIONS:     Not available on 2020 hardware.

   ACCEPTS IN AC1:   function code in the left half and process handle in
		     the right half

	      AC2:   arguments for the

	      AC3:   specified function

   RETURNS     +1:   always

   This JSYS is useful when debugging a program.  For  example,  consider
   the	problem  of  debugging	a  program  consisting	of a fork running
   several inferior forks mapped to the  same  address	space.	 One  (or
   more)  of  the  inferior forks is erroneously referencing a particular
   address.  To find out which fork(s) are referencing that address,  the
   user would do the following:

   (ADBRK)
   

 	1.  Set up  the  software  interrupt  system  for  interrupts  on
 	    channel 19.

 	2.  Perform the ADBRK .ABSET function for each inferior  process,
 	    using  the	handle	of  the  inferior process and the address
 	    erroneously being referenced.

 	3.  When a channel 19 interrupt occurs, perform an RFSTS JSYS for
 	    each  inferior  process.   The  interrupted  process(es) that
 	    caused the address break(s)  will  have  a	code  7  (.RFABK)
 	    returned in its (their) status word(s).

 	4.  Perform the ADBRK  .ABGAD  function  for  each  process  that
 	    caused an address break.  This will return the address of the
 	    instruction that erroneously referenced the break address.

 	5.  Perform the RFORK JSYS to restart the process(es)  halted  by
 	    address break(s).

 	6.  Continue running the program and  repeating  the  last  three
 	    steps  until  the program completes execution or it no longer
 	    generates address breaks.

   The ADBRK JSYS may also be used  to	locate	which  instruction  in	a
   process is setting a location to the wrong value.

   The available functions are as follows:

	Code	Symbol			Meaning

	 0	.ABSET	  Set address break.

	 1	.ABRED	  Read address break.

	 2	.ABCLR	  Clear address break.

	 3	.ABGAD	  Return address of break instruction.

   Each function is described in the paragraphs below.

   Setting address breaks - .ABSET
       

   This function initializes the address break facility for the specified
   process.   When  the process references the location in the manner for
   which the break has been set, it is suspended.  Its superior  receives
   a software interrupt on channel 19 (.ICIFT) if it has enabled for that
   channel.  After processing the interrupt,  the  superior  process  can
   resume the inferior by executing the RFORK monitor call.

   Only one address break can be in effect for a process at any one time,
   and	the  break  affects  only  the	process  for which it is set.  If
   another process references the location on which a break is set, it is
   in  no  way	affected by the break.	When an address break is set in a

   (ADBRK)
   

   page shared among processes and each process is to be  suspended  when
   it  references  the location, the ADBRK call must be executed for each
   process.

   Breaks cannot be specified for the accumulators.

   The .ABSET function requires the following arguments to be given:

	AC2:  address of location on which to break

	AC3:  flag word indicating the type  of  reference  on	which  to
	      break.  The following flags are currently defined:

	      B0(AB%RED)  Break on a read reference.

	      B1(AB%WRT)  Break on a write reference.

	      B2(AB%XCT)  Break  on  an   execute   (instruction   fetch)
			  reference.

   Reading address breaks - .ABRED
       

   This function returns the current address break  information  for  the
   specified   process.   It  returns  the  following  information  on	a
   successful return:

	AC2:  address of location on which a break is set

	AC3:  flag word indicating the type of	reference  on  which  the
	      break  will  occur.   The  following  flags  are	currently
	      defined:

	      B0(AB%RED)  Break will occur on a read reference.

	      B1(AB%WRT)  Break will occur on a write reference.

	      B2(AB%XCT)  Break will occur  on	an  execute  (instruction
			  fetch) reference.

   If no address break has been set for the process, the contents of  AC2
   and AC3 are zero on return.

   Clearing address breaks - .ABCLR
       

   This function removes any address break that was set for the specified
   process.   A  program  can also remove a break by executing the .ABSET
   function with AC2 and AC3 containing zero.

   Returning the address of the break instruction - .ABGAD
           

   This function returns in AC2 the address of the location on which  the
   process  encountered  a  break.   When the location on which the break

   (ADBRK)
   

   occurred is in a JSYS routine, the address returned is a  monitor  PC,
   not	the  address  of the JSYS.  The program can obtain the address of
   the JSYS by executing an RFSTS monitor call.

   Generates an illegal instruction interrupt on error conditions below.

   ADBRK ERROR MNEMONICS:

   ABRKX1:   address break not available on this system

   ARGX02:   invalid function

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX8:   illegal to manipulate an execute-only process


Node: AIC	Previous: ADBRK 	Next: ALLOC	Up: Top
			      AIC     JSYS 131

   Activates specific software interrupt  channels.   (Refer  to  Section
   2.5.)

   ACCEPTS IN AC1:  process handle

	      AC2:  36-bit word
		    Bit n on means activate channel n

   RETURNS     +1:  always

   The DIC monitor call can be	used  to  deactivate  specified  software
   interrupt channels.

   Generates an illegal instruction interrupt on error conditions below.

   AIC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

   FRKHX8:   illegal to manipulate an execute-only process


Node: ALLOC	Previous: AIC 	Next: ARCF	Up: Top
			     ALLOC     JSYS 520

   Allocates a device to a particular job or to the device  pool  of  the
   monitor's resource allocator.  A device under control of the monitor's
   resource allocator cannot be opened or assigned by any job other  than
   the one to which it is currently allocated.	When the allocated device
   is deassigned, it is returned to the monitor's resource allocator.

   RESTRICTIONS:    requires WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  function code (.ALCAL)

	      AC2:  device designator

	      AC3:  job number, -1, or -2

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   If AC3 contains a job number, then the designated device is	allocated
   to that job.

   If AC3 contains -1, then the device is returned to the pool of devices
   available  to  all  users of the system (i.e., the device is no longer
   allocated).	This is the initial state of all devices.

   If AC3 contains -2,	then  the  device  is  assigned  to  the  monitor
   resource allocator's pool of devices.

   When a non-allocated device (i.e., a device not under control  of  the
   resource  allocator) is assigned or opened by a job, the device cannot
   be taken by the resource allocator.	However, the  resource	allocator
   can	allocate the device to the job that currently has it.  Thus, when
   the job releases  the  device,  it  will  be  given	to  the  resource
   allocator.	The  allocator receives an IPCF packet when the device is
   returned to it.  The flag word (.IPCFL) of the packet descriptor block
   has	a  code of 1(.IPCCC) in the IP%CFC field (bits 30-32).	This code
   indicates the message was sent by the monitor.  The first word of  the
   packet data block contains the resource allocator's code .IPCSA.  Each
   following word contains the designator of the returned device.  Thus,

	     .IPCFL/<.IPCCC>B32

	     DATA/.IPCSA
	     DATA+1/device designator
	     DATA+2/device designator

   The ALLOC monitor call requires the process to have WHEEL or  OPERATOR
   capability enabled.

   ALLOC ERROR MNEMONICS:

   ALCX1:    invalid function

   (ALLOC)
   

   ALCX2:    WHEEL or OPERATOR capability required

   ALCX3:    device is not assignable

   ALCX4:    invalid job number

   ALCX5:    device already assigned to another job

   ALCX6:    device assigned to user job, but will be given to allocator
	     when released

   DEVX1:    Invalid device designator


Node: ARCF	Previous: ALLOC 	Next: ASND	Up: Top
			     ARCF     JSYS 247

   Performs all operations pertaining to the  archive  and  virtual  disk
   systems.   This includes requesting archival and migration, requesting
   retrieval, and setting archive status and tape information for a file.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
 		    enabled.
   ACCEPTS IN AC1:  JFN

 	      AC2:  Function code.  The  available  functions  and  their
 		    argument blocks are described below.

 	      AC3:  (Function dependent, normally 0)

 	Code	Symbol			     Function

 	 0	.ARRAR	  Sets/clears AR%RAR  (in  .FBBBT  of  the  FDB),
 			  activating  or  deactivating a user request for
 			  archival.  The value .ARSET  (1)  in	AC3  will
 			  request  an archive while .ARCLR (0) will clear
 			  the request.	Setting AR%NDL (in .FBBBT of  the
 			  FDB)	with  .ARSET  in  AC3  requests  that the
 			  contents of the file not be flushed  from  disk
 			  upon archival.

 	 1	.ARRIV	  Sets/clears AR%RIV  (in  .FBBBT  of  the  FDB),
 			  activating  or deactivating a system request to
 			  migrate a file from disk to  tape.   The  value
 			  .ARSET  in  AC3  will  request  migration while
 			  .ARCLR will clear the request.   This  function
 			  requires  WHEEL  or OPERATOR capabilities to be
 			  enabled.

 	 2	.AREXM	  Sets/clears AR%EXM  (in  .FBBBT  of  the  FDB),
 			  activating   or   deactivating  exemption  from
 			  involuntary  migration.   .ARCLR  (0)  in   AC3

   (ARCF)
   

 			  clears  AR%EXM  while  .ARSET  in  AC3 will set
 			  AR%EXM.   This  function  requires   WHEEL   or
 			  OPERATOR capabilities to be enabled.

 	 3	.ARRFR	  Request a file's contents  to  be  restored  to
 			  disk.  Normally, .ARRFR returns without waiting
 			  for the contents of the file to be restored  to
 			  disk.

 			  Options for AC3

 			  B1   AR%WAT	 Wait (ARCF  JSYS  blocks)  until
 					 the file is restored.

 	4	.ARDIS	  Discard tape information.   Clears  FB%ARC  (if
 			  set),   .FBTP1,  .FBTP2,  .FBTSN,  .FBTFN,  and
 			  .FBTDT.   The  file  must  be  online  for  the
 			  function to succeed.

 			  Options for AC3  (Requires  WHEEL  or  OPERATOR
 			  privileges	enabled    to	 use	functions
 			  separately.)

 			  B0   AR%CR1	 Clear information for run 1
 			  B1   AR%CR2	 Clear information for run 2

 	5	.ARSST	  Set tape  information  for  a  file.	 Requires
 			  enabled  WHEEL  or  OPERATOR	privileges.   AC3
 			  contains a pointer  to  an  argument	block  as
 			  follows:

 			  Word	 Symbol   Contents

 			   0	 .AROFL   Flags:

 					  B0(AR%01)  Set information  for
 						     run 1

 					  B1(AR%02)  Set information  for
 						     run 2

 					  B2(AR%OFL) Delete disk contents
 						     of  file  when done.
 						     Requires  both  sets
 						     of  tape information
 						     to be set.

 					  B3(AR%ARC) Set  FB%ARC  in  the
 						     FDB   (archive   the
 						     file)

 					  B4(AR%CRQ) Clear archive and/or
 						     migration	 requests
 						     (clear  AR%RAR   and
 						     AR%RIV).

   (ARCF)
   

 			   1	 .ARTP1   Tape 1 identification

 			   2	 .ARSF1   TSN 1,,TFN  1  -  Tape  saveset
 					  number  in  the  left  half and
 					  tape file number in  the  right
 					  half.

 			   3	 .ARTP2   Tape 2 identification

 			   4	 .ARSF2   TSN  2,,TFN  2  -  similar   to
 					  .ARSF1

 			   5	 .ARODT   time and date of tape write  in
 					  internal   format;   0  implies
 					  present time

 			   6	 .ARPSZ   Number of pages  in  the  file.
 					  This	word  can  be set only if
 					  AR%01 and AR%02 are set first.

 	This function is used to set information for the  first,  second,
 	or  both  tape	runs.	AR%01  and  AR%02  are used together when
 	restoring files to disk via DUMPER'S RESTORE command.

 	6	.ARRST	  Restore contents of a file to disk.  AC3  is	a
 			  JFN for a temporary file that contains the data
 			  for a currently offline archived  file.   After
 			  copying   .FBADR,   .FBBSY   and   .FBSIZ,  the
 			  temporary file is deleted.  Both files must  be
 			  on  the  same  device  or structure and enabled
 			  WHEEL or OPERATOR capabilities are required.

 	7	.ARGST	  Get tape information for file.  AC3 contains	a
 			  pointer  to an argument block that has the same
 			  format as the block for .ARSST.

       10	.ARRFL	  The restore for  this  file  has  failed.   Set
 			  AR%RFL  in  FBBBT  to  notify a waiting process
 			  that the retrieval request cannot be completed.
 			  Requires     enabled	  WHEEL    or	 OPERATOR
 			  capabilities.

       11	.ARNAR	  Resist involuntary migration.  Sets  or  clears
 			  AR%NAR  in  .FBBBT.	Using  .ARSET in AC3 will
 			  cause resist to be set, while using .ARCLR will
 			  clear resist.

   ARCF ERROR MNEMONICS:

   CAPX1:    WHEEL or OPERATOR capabilities required

   ARGX02:   Invalid function code

   ARCFX2:   File already has archive status

   (ARCF)
   

   ARCFX3:   Cannot perform  ARCF  functions  on  non-multiple	directory
   devices

   ARCFX4:   File is not online

   ARCFX5:   Files are not on the same device or structure

   ARCFX6:   File does not have archive status

   ARCFX7:   Invalid parameter for .ARSST

   ARCFX8:   Archive not complete

   ARCFX9:   File not offline

   ARCX10:   Archive prohibited

   ARCH11:   Archive requested, modification prohibited

   ARCH12:   Archive requested, delete prohibited

   ARCX13:   Archive system request not completed

   ARCX14:   Restore failed

   ARCX15:   Migration prohibited

   ARCX16:   Cannot exempt offline, archived, or archive pending files

   ARCX17:   FDB improper format for ARCF

   ARCX18:   Retrieval wait cannot be fulfilled for waiting process

   ARCX19:   Migration already pending


Node: ASND	Previous: ARCF 	Next: ASNSQ	Up: Top
			      ASND     JSYS 70

   Assigns a device to the caller.  The successful return is given if the
   device is already assigned to the caller.

   ACCEPTS IN AC1:  device designator

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The RELD call can be used to release devices assigned to the caller.

   ASND ERROR MNEMONICS:

   (ASND)
   

   DEVX1:    invalid device designator

   DEVX2:    device already assigned to another job

   ASNDX1:   device is not assignable

   ASNDX2:   illegal to assign this device

   ASNDX3:   no such device

   DSMX1:    file(s) not closed


Node: ASNSQ	Previous: ASND 	Next: ATACH	Up: Top
			     ASNSQ     JSYS 752

   Assigns a special message queue to a job.

   RESTRICTIONS:    for  ARPANET  systems  only.   Requires  NET   WIZARD
 		    capabilities enabled.

   ACCEPTS IN AC1:  mask
 	      AC2:  header value

   RETURNS     +1:  failure, error code in AC1

 	       +2:  success, special message queue assigned with  special
 		    queue handle in AC1.

   ASNSQ ERROR MNEMONICS:

   NTWZX1:   NET WIZARD capability required

   ASNSX1:   Insufficient system resources
 	     (all special queues in use)

   ASNSX2:   Link(s) assigned to another special queue


Node: ATACH	Previous: ASNSQ 	Next: ATI	Up: Top
			     ATACH     JSYS 116

   Detaches the specified job from its controlling terminal (if any)  and
   optionally	attaches   it	to   a	 new   controlling  terminal.	A
   console-attached entry is appended to the accounting data file.

   RESTRICTIONS:    some   functions   requires   WHEEL    or	 OPERATOR
			       capabilities enabled.

   (ATACH)
   

   ACCEPTS IN AC1:  B0(AT%CCJ) generate a CTRL/C interrupt to the  lowest
			       process	in  the job that is enabled for a
			       CTRL/C interrupt if the job  is	currently
			       attached to another terminal.  If this bit
			       is not set or if the job is currently  not
			       attached  to  another  terminal,  the  job
			       simply  continues  running  when   it   is
			       attached.

		    B1(AT%NAT) do  not	 attach.    Prevents   both   the
			       detaching of the job from its terminal and
			       the attaching of a remote job to the local
			       terminal.   Is  a  no-op unless the remote
			       job has a controlling terminal,	in  which
			       case   the  remote  job	is  detached  and
			       remains	detached.   This  bit  in  effect
			       makes ATACH like a remote DTACH.

		    B2(AT%TRM) attach  the  given  job	to  the  terminal
			       specified in AC4.  If this bit is not set,
			       the job is  attached  to  the  controlling
			       terminal of the caller.

 		    B18-B35    job number (decimal) of the desired job
 		    (AT%JOB)

 	      AC2:  user number (e.g., 500000,,256) under which  the  job
 		    to	be attached is logged in.  The user number can be
 		    obtained with the RCUSR monitor call.

 	      AC3:  byte pointer to  an  ASCIZ	password  string  in  the
 		    caller's address space.

 	      AC4:  number (octal) of the terminal to be attached to  the
 		    specified	job.	This   argument  is  required  if
 		    B2(AT%TRM) is set.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success.  If  there  is  a	logged-in  job	currently
		    attached  to  the  specified terminal, it is detached
		    with primary I/O not redirected.  Thus, if a  process
		    has  primary  I/O  from  the controlling terminal, it
		    will block when it	attempts  primary  I/O	and  will
		    continue  when  it	is  reattached and a character is
		    typed.  If there is a job  not  logged  in	currently
		    attached  to  the  specified  terminal,  the job goes
		    away.

   It is legal to attach to a job that has a controlling terminal if

	1.  The job is logged in under the same  user  name  as  the  job
	    executing the ATACH.

   (ATACH)
   

	2.  The job executing the ATACH supplies the correct password  of
	    the job it is attaching to.

	3.  The job executing the ATACH has WHEEL or OPERATOR  capability
	    enabled.

	4.  The job executing the ATACH has ownership of the job  because
	    it	created the job (and maintained ownership) with the CRJOB
	    call.

   If the controlling terminal is a PTY, a password is	not  required  if
   either:

	1.  The owner  of  the	PTY  has  WHEEL  or  OPERATOR  capability
	    enabled.

	2.  The specified job is logged in with  the  same  name  as  the
	    owner of the PTY.

   The DTACH monitor call can be used to detach the controlling  terminal
   from the current job.

   ATACH ERROR MNEMONICS:

   ATACX1:   invalid job number

   ATACX2:   job already attached

   ATACX3:   incorrect user number

   ATACX4:   invalid password

   ATACX5:   this job has no controlling terminal


Node: ATI	Previous: ATACH 	Next: ATNVT	Up: Top
			      ATI     JSYS 137

   Assigns a terminal code to a software interrupt  channel.   (Refer  to
   Section  2.5.)  This  call  also  sets  the	corresponding  bit in the
   process' terminal interrupt mask.  (Refer to the STIW and RTIW monitor
   calls.)

   ACCEPTS IN AC1:  terminal code (refer to Section 2.5.6)  in	the  left
		    half and channel number in the right half

   RETURNS     +1:  always

   If there is no controlling terminal (i.e., if the  job  is  detached),
   the	assignments  are remembered and will be in effect when a terminal
   becomes attached.

   (ATI)
   

   The DTI monitor call can be used to deassign a terminal code.

   Generates an illegal instruction interrupt on error conditions below.

   ATI ERROR MNEMONICS:

   TERMX1:   invalid terminal code

   ATIX1:    invalid software interrupt channel number

   ATIX2:    control-C capability required



Node: ATNVT	Previous: ATI 	Next: BIN	Up: Top
			     ATNVT     JSYS 274

   Creates the Network Virtual Terminal (NVT) connection.

   Attach two jfns to an NVT.
   For Ethernet, same calling convention as for the ARPANET.

   Local change: After successfully setting up the NVT, the port's
   data mode is set to .PM32 and its byte size to 8-bit. 

   RESTRICTIONS:    for use with ARPANET only

   ACCEPTS IN AC1:  flag bits in the left half and the JFN of the  opened
 		    receive connection in the right half

 	      AC2:  JFN of the opened send connection

   RETURNS     +1:  failure, with error code in AC1

 	       +2:  success, with terminal designator  specific  to  this
 		    NVT in AC1

   Flags for AC1:

   Bit				 Meaning

   B2	     If set, this bit indicates New TELNET protocol.
 	     If clear, this bit indicates old TELNET protocol.

   ATNVT ERROR MNEMONICS:

   ATNX1:    invalid receive JFN

   ATNX2:    receive JFN is not open for read

   ATNX3:    receive JFN is not open

   ATNX4:    receive JFN is not a network connection

   ATNX5:    receive JFN has been used

   ATNX6:    receive connection has been refused

   ATNX7:    invalid send JFN

   (ATNVT)
   

   ATNX8:    send JFN is not open for write

   ATNX9:    send JFN is not open

   ATNX10:   send JFN is not a network connection

   ATNX11:   send JFN has been used

   ATNX12:   send connection has been refused

   ATNX13:   insufficient system resources (no NVTs)


Node: BIN	Previous: ATNVT 	Next: BKJFN	Up: Top
			      BIN     JSYS 50

   Inputs the next byte from the specified source.  When the byte is read
   from  a  file, the file must first be opened, and the size of the byte
   given, with the OPENF call.	When the byte  is  read  from  memory,	a
   pointer to the byte is given.  This pointer is updated after the call.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  always, with the byte right-justified in AC2

   If the end of file is reached, AC2 contains 0  instead  of  the  byte.
   The	program  can  process  this  end-of-file condition if an ERJMP or
   ERCAL is the next instruction following the BIN call.

   The BOUT monitor call can be used to output a byte sequentially  to	a
   destination.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   BIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   IOX1:     file is not open for reading

   IOX4:     end of file reached

   IOX5:     device or data error

   (BKJFN)
   


Node: BKJFN	Previous: BIN 	Next: BOOT	Up: Top
			     BKJFN     JSYS 42

   Backs up the source designator's pointer by one byte.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC1, if pertinent.
		    (This return actually decrements the pointer.)

   The BKJFN call, when referring to a terminal,  can  be  executed  only
   once  to back up one character (i.e., the terminal's pointer cannot be
   backed up twice).  The call, when referring to other designators,  can
   be executed more than once in succession.

   BKJFN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   BKJFX1:   illegal to back up terminal pointer twice

   SFPTX2:   illegal to reset pointer for this file

   SFPTX3:   invalid byte number

   TTYX01:   line is not active


Node: BOOT	Previous: BKJFN 	Next: BOUT	Up: Top
			     BOOT     JSYS 562

   Performs basic maintenance and utility functions required for  loading
   and dumping the communications front-end software via the DTE-20.  The
   TOPS-20 system process responsible for performing these functions uses
   a DIGITAL-supplied protocol to implement them.

   On 2040,2050, and 2060 hardware, the BOOT JSYS is  used  to	load  and
   dump  a  PDP-11 connected to a DTE20.  On 2020 hardware, the BOOT JSYS
   loads and dumps a KMC11, dumps line counters, and  stops  DDCMP  on	a
   line.

   RESTRICTIONS:    requires  WHEEL  or  OPERATOR  capabilities  enabled.
		    Some functions are specific to 2020 hardware.

   (BOOT)
   

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS     +1:  always

   The available functions and their argument blocks are described below.

	Code	Symbol			     Meaning

	 0	.BTROM	  Activate the	hardware  ROM  bootstrap  in  the
			  communications front end.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

	1	.BTLDS	  Load a secondary  bootstrap  program	into  the
			  communications   front   end.    The	secondary
			  bootstrap, with a maximum size  of  256  PDP-11
			  words,  is loaded using the ROM bootstrap.  The
			  data to be loaded must be packed as two  16-bit
			  PDP-11  words  left  justified  in  each 36-bit
			  TOPS-20 word.   The  entire  bootstrap  program
			  must	be  loaded at once, and the caller blocks
			  until the transfer is complete.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

			  2    .BTSEC	 Address of bootstrap program  to
					 be loaded

	2	.BTLOD	  Load the communications front-end memory  using
			  the  previously  loaded  secondary  or tertiary
			  bootstrap program.  The  bootstrap  program  in
			  the  front  end  must abide by the protocol for
			  DTE-20 transfers:  the first two bytes of  data
			  supplied  by	the caller must be a count of the
			  remaining number of data bytes.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

   (BOOT)
   

			  2		 Not used and must be zero.

			  3    .BTFLG	 User-supplied flag word

					 B0(BT%BEL)  Send a  doorbell  to
						     the   front  end  to
						     indicate  when   the
						     setup   is  complete
						     and the transfer can
						     begin.

			  4    .BTCNT	 Number of bytes to transfer

			  5    .BTLPT	 Pointer to data to be loaded

	3	.BTDMP	  Dump the communications front-end memory  using
			  the  ROM  bootstrap  program.   The caller must
			  activate the ROM  bootstrap  (function  .BTROM)
			  before   dumping   memory.   Subsequent  .BTDMP
			  functions  to  dump  memory  start  where   the
			  previous   dump   terminated	 unless  the  ROM
			  bootstrap  is  activated  again  by  a   .BTROM
			  function.  The caller blocks until the transfer
			  is complete.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

			  2		 Not used and must be zero.

			  3    .BTFLG	 User-supplied flag  word.   This
					 word  is  not	used  and must be
					 zero.

			  4    .BTCNT	 Number of bytes to transfer

			  5    .BTDPT	 Pointer to where the data is  to
					 be dumped in the TOPS-20

	4	.BTIPR	  Initialize the protocol to be  used  with  this
			  communications  front  end.	After  successful
			  execution of this function,  the  TOPS-20  will
			  process interrupts from the given DTE-20.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTPRV	 Version number of  the  protocol
					 to be used

   (BOOT)
   

 					 For	 multi-drop	terminals
 					 (VT62's)   on	 a   2020,   this
 					 function will generate and  link
 					 a  DDCMP Station Table.  It will
 					 startup    a	 terminal     not
 					 previously  known  to the system
 					 and must be issued once for each
 					 terminal being started up.

 					 Argument Block

 			  0    .BTPRT	 Drop,,line

 			  1    .BTPRV	 Version number of protocol to be
 					 used  (see  description  of BOOT
 					 function code 6)

	5	.BTTPR	  Stop the protocol  currently	running  on  this
			  communications  front  end.	After  successful
			  execution of this function,  the  TOPS-20  will
			  ignore interrupts from the given DTE-20.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

 	6	.BTSTS	  Return the status type of the protocol  running
 			  on this communications front end.  Also returns
 			  the name of the adjacent DECNET node	for  this
 			  front end.

 			  Argument Block

 			  0    .BTDTE	 DTE-20 number

 			  1    .BTCOD	 Returned protocol  version  type
 					 If  no protocol is running, this
 					 word contains -1.
 			  Possible protocol types are:

 			  Symbol	 Meaning

 			  .VN20F (0)	 RSX20F protocol
 			  .VNMCB (1)	 MCB DECNET protocol
 			  .VNDDC (2)	 DDCMP protocol
 			  .VNMOP (3)	 MOP (DDCMP maintenance) mode
 			  .VNCNL (4)	 Controller loopback
 			  .VNCBL (5)	 Cable loopback

	7	.BTBEL	  Block until a signal (doorbell) to the  TOPS-20
			  is  initiated  by the communications front end.
			  This function is used to synchronize the caller
			  with the bootstrap program in the front end.

   (BOOT)
   

			  Argument Block

			  0    .BTDTE	 DTE-20 number

	10	.BTRMP	  Read data from  the  communications  front  end
			  using   the	previously  loaded  secondary  or
			  tertiary  bootstrap  program.   The	bootstrap
			  program  must  abide by the protocol for DTE-20
			  transfers.  The first two bytes of data will be
			  interpreted  as a count of the remaining number
			  of bytes of data.

			  Argument Block

			  0    .BTDTE	 DTE-20 number

			  1    .BTERR	 Error status flags  returned  on
					 failure of the call

			  2		 Not used and must be zero.

			  3    .BTFLG	 User-supplied flag word

					 B0(BT%BEL)  Send    a	   signal
						     (doorbell)   to  the
						     TOPS-20 to  indicate
						     the    transfer   is
						     finished.

			  4    .BTCNT	 Maximum  number  of   bytes   to
					 transfer.     After   successful
					 execution of this function, this
					 word  is  updated to reflect the
					 actual    number    of     bytes
					 transferred.

			  5    .BTMPT	 Pointer to where data is  to  be
					 placed

	11	.BTKML	  Load a KMC11 (2020 only).  This  function  will
			  optionally  load  the  CRAM, DRAM, and the four
			  UNIBUS registers.  Before the KMC11 is  loaded,
			  the  system  verifies  that  each bit in UNIBUS
			  registers can be set and cleared.   Before  the
			  DRAM	is  loaded, the system verifies that each
			  bit in the entire DRAM can be set and  cleared.
			  After the CRAM, DRAM, and registers are loaded,
			  they are verified to ensure that the	data  was
			  properly  loaded.   If the register data is not
			  supplied, the UNIBUS registers will be  cleared
			  before the KMC11 is started.

			  Argument Block

			  0    .BTKMC	 KMC11 address

   (BOOT)
   

			  1    .BTKER	 Error flags returned

					 B0 (BT%CVE)  CRAM  verify  error
						      (right half is bad)

					 B1 (BT%DVE)  DRAM  verify  error
						      (right half is bad)

					 B2 (BT%RVE)  Register	   verify
						      error  (right  half
						      is bad)

			  2    .BTKCC	 Count of CRAM data

			  3    .BTKCP	 Pointer  to  CRAM  data  (16-bit
					 data)

			  4    .BTKDC	 Count of DRAM data

			  5    .BTKDP	 Pointer  to  DRAM  data   (8-bit
					 data)

			  6    .BTKRC	 Count of register data

			  7    .BTKRP	 Pointer to register data (16-bit
					 data)

			  8    .BTKSA	 Right-halfword    is	 starting
					 address

					 B0 (BT%KSA)  Right-halfword   is
						      set;  start KMC11

	12	.BTKMS	  Dump a KMC11 (2020 only).  This  function  will
			  optionally  dump  the CRAM, DRAM, and registers
			  if space is provided.  The registers are  SEL0,
			  SEL2, SEL4, SEL6, INDATA, OUTDATA, INBA, OUTBA,
			  and MISC*400+NPR.

			  Argument Block

			  0    .BTKMC	 KMC11 address

			  1    .BTKER	 Error flags returned

					 B0 (BT%CVE)  CRAM  verify  error
						      (right half is bad)

					 B1 (BT%DVE)  DRAM  verify  error
						      (right half is bad)

					 B2 (BT%RVE)  Register	   verify
						      error  (right  half
						      is bad)
			  2    .BTKCC	 Count of CRAM data

   (BOOT)
   

			  3    .BTKCP	 Pointer  to  CRAM  data  (16-bit
					 data)

			  4    .BTKDC	 Count of DRAM data

			  5    .BTKDP	 Pointer  to  DRAM  data   (8-bit
					 data)

			  6    .BTKRC	 Count of register data

			  7    .BTKRP	 Pointer to register data (16-bit
					 data)

	13	.BTRLC	  Return  line	counters.    All   counters   are
			  positive numbers.

			  Argument Block

			  0    .BTPRT	 Port number

			  1    .BTSCC	 Status count counter

			  2    .BTSCP	 Status count pointer

			  3    .BTRCC	 Receive count counter

			  4    .BTRCP	 Receive count pointer

			  5    .BTTCC	 Transmit count counter

			  6    .BTTCP	 Transmit count pointer

	14	.BTCLI	  Convert line id to port number

 			  Argument Block

 			  0    .BTPRT	 Port number
 			  1    .BTLID	 Pointer to ASCIZ line id

 	15	.BTCPN	  Convert NSP port number to line id

 			  Argument Block

 			  0    .BTPRT	 Port number
 			  1    .BTLID	 Pointer to ASCIZ line id

 	16	.BTSTA	  Set the stations polling  state  to  ACTIVE  to
 			  cause  the  terminal to be polled, or set it to
 			  IDLE to prevent the terminal from being polled.
 			  (VT62 on 2020 only)

 			  Argument Block

 			  0    .BTPRT	 Drop,,Line
 			  1    .BTCOD	 Returned protocol  version  type

   (BOOT)
   

 					 (see	 description	of   Boot
 					 function code 6)

 					 0     .BTACT	  Set line active

 					 1     .BTIDL	  Set line idle

 	17	.BTSSP	  Set the startup  priority  value.   This  value
 			  will	specify  the  relative frequency at which
 			  startups are attempted.  That is, for  a  value
 			  of N each active station will be polled N times
 			  for each DDCMP start.  This is used to  prevent
 			  unresponsive	  stations   from   deteriorating
			  performance of a  multi-drop	line.	(VT62  on
			  2020 only)

			  Argument Block

			  0    .BTPRT	 Line
			  1    .BTSPR	 Start priority count

	20	.BTSTP	  Set the polling priority.   This  parameter  is
			  maintained  in the Station Table to specify the
			  realtive polling priority  of  a  station.   If
			  this	feature  is not used, all priority values
			  will default to 1 and polling will proceed in a
			  round robin manner.  (VT62 on 2020 only)

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTPRI	 priority value

					 Typical  range  1  (high)  to	5
					 (low)

	21	.BTSDD	  Send a DDCMP message.  A DDCMP message  wil  be
			  queued  for transmission on the specified line.
			  (VT62 on 2020 only)

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTMSG	 Address of message
			  2    .BTLEN	 Byte count of message

	22	.BTRDD	  Receive a DDCMP  message.   An  item	from  the
			  DDCMP  input	queue  will be returned or .BTLEN
			  will be set to zero  if  the	queue  is  empty.
			  Items  on  the  queue  will  be  data segments,
			  completion   postings,   or	status	 postings
			  (station  going  up  or  down).   (VT62 on 2020
			  only)
   (BOOT)
   

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTMSG	 Address of buffer
			  2    .BTLEN	 Size of user buffer

					 For  data  messages,  the   byte
					 count of the message is returned
					 in .BTLEN.  If the buffer is too
					 small,  the JSYS will fail.  For
					 completion	postings,     the
					 following  will  be  returned in
					 .BTLEN:

					 BT%CTL  (1B0)	+  .BTSUP  (1)	-
					 station came up

					 BT%CTL  (1B0)	+  .BTSDW  (2)	-
					 station went down

					 BT%CTL  (1B0)	+  .BTCMP  (3)	-
					 transmit complete

					 BT%CTL (1B0) + .BTSSF	(4)  -	a
					 startup failed

					 .BTPRT will contain the drop  of
					 the	station    this   message
					 pertains to.

	23	.BTCHN	  Set the  interrupt  channel  so  that  software
			  interrupts will be generated when input data is
			  available.  (VT62 on 2020 only)

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTSIC	 Software interrupt channel

	24	.BTSLS	  Set type of  line  service  to  be  done  on	a
			  synchronous communications line.

			  Argument Block

			  0    .BTPRT	 Drop,,line
			  1    .BTCOD	 Define protocol

					 Protocol values may be:

					 0     .BTNSP	  NSP protocol	B
					 1     .BTDCP	  DDCMP protocol

   The error status flag returned in word .BTERR on  failure  of  a  BOOT
   call  are  front-end  reload  status bits recorded in the SYSERR error
   (BOOT)
   

   file.  (Refer to the TOPS-20 Error Detection, Recovery, and	Reporting
   Reference Manual for an explanation of these status bits.)

   Generates an illegal instruction interrupt on error conditions below.

   BOOT ERROR MNEMONICS:

   BOTX01:   invalid DTE-20 number

   BOTX02:   invalid byte size

   BOTX03:   invalid protocol version number

   BOTX04:   byte count is not positive

   BOTX05:   protocol initialization failed

   CAPX1:    WHEEL or OPERATOR capability required

   ARGX02:   invalid function


Node: BOUT	Previous: BOOT		Next: CACCT	Up: Top
			      BOUT     JSYS 51

   Outputs a byte sequentially to the specified  destination.	When  the
   byte is written to a file, the file must first be opened, and the size
   of the byte given, with the OPENF call.  When the byte is  written  to
   memory,  a pointer to the location in which to write the byte is given
   in AC1.  This pointer is updated after the call.

   ACCEPTS IN AC1:  destination designator

	      AC2:  the byte to be output, right-justified

   RETURNS     +1:  always

   The BIN monitor call can be used to input a byte sequentially  from	a
   source.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)

   BOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned
   (BOUT)
   

   DESX5:    file is not open

   IOX2:     file is not open for writing

   IOX5:     device or data error

   IOX6:     illegal to write beyond absolute end of file

   IOX11:    quota exceeded or disk full


Node: CACCT	Previous: BOUT	Next: CFIBF	Up: Top
			      CACCT     JSYS 4

   Changes the account for the current job.

  ACCEPTS IN AC1:  account number (decimal) in bits 3-35 if bits 0-2 are
		    5.	 Otherwise  contains  a  byte  pointer to the new
		    account string in the address space of caller.  If	a
		    null byte is not seen, the string is terminated after
		    39 characters are processed.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC1

   The CACCT call sets the current account for the job to  the	specified
   account.   Subsequent  session  charges  will  be to this new account.
   This call also validates the account given if the  account  validation
   facility  is  enabled.  (Refer to the .SFAVR function of the SMON/TMON
   monitor call.)

   The GACCT monitor call can be used  to  return  the	account  for  the
   current job.

   CACCT ERROR MNEMONICS:

   CACTX1:   invalid account identifier

   CACTX2:   job is not logged in

   VACCX0:   Invalid account

   VACCX1:   Account string exceeds 39 characters


Node: CFIBF	Previous: CACCT	Next: CFOBF	Up: Top
			     CFIBF     JSYS 100
   (CFIBF)
   

   Clears the designated file input buffer.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  always

   Is a no-op if the source designator is not associated with a terminal.

   The CFOBF monitor call can be used to clear a designated  file  output
   buffer.

   Generates an illegal instruction interrupt on error conditions below.

   CFIBF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: CFOBF	Previous: CFIBF	Next: CFORK	Up: Top
			     CFOBF     JSYS 101

   Clears the designated file output buffer.

   ACCEPTS IN AC1:  destination designator

   RETURNS     +1:  always

   Is a no-op if the destination designator  is  not  associated  with	a
   terminal.

   The CFIBF call can be used to clear a designated file input buffer.

   Generates an illegal instruction interrupt on error conditions below.

   CFOBF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job
   (CFOBF)
   

   TTYX01:   line is not active


Node: CFORK	Previous: CFOBF	Next: CHFDB	Up: Top
			     CFORK     JSYS 152

   Creates a process inferior to this process. (Refer to Section 2.6.2.)

   ACCEPTS IN AC1:  B0(CR%MAP) make the inferior process' map the same as
			       the  current  process'  map  by	means  of
			       indirect pointers.  If this bit is not on,
			       the inferior process will have no pages in
			       its map.  If desired, the creating process
			       may  then  use PMAP or GET to add pages to
			       the inferior's map.

		    B1(CR%CAP) make the  inferior  process'  capabilities
			       the same as the current process'.  If this
			       bit is not on, the inferior process has no
			       special capabilities.

		    B3(CR%ACS) set the inferior  process'  ACs	from  the
			       block  whose  address  is in AC2.  If this
			       bit is not on, the inferior  process'  ACs
			       are set to 0.

		    B4(CR%ST)  set the PC of the inferior process to  the
			       value  in  the right half of AC1 and start
			       the process.  If this bit is not  on,  the
			       inferior  process  is not started, and the
			       right half of AC1 is ignored.

		    B18-B35    PC value for the inferior process if CR%ST
		    (CR%PCV)   is on.

	      AC2:  address of 20 (octal) word	block  (optional).   This
		    block   contains  the  AC  values  for  the  inferior
		    process.  (Refer to bit CR%ACS above.)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, relative process handle in AC1

   The inferior process receives the same primary input and output  JFN's
   as  the  current  process.	However,  the primary input and/or output
   files may be changed with the SPJFN monitor call.

   The CR%MAP argument in AC1 allows the inferior to see the same address
   space  as  that  of the superior.  The inferior process will have read
   and write access to the  superior's	address  space.   The  pages  are
   shared, and changes made by one process will be seen by the other.
   (CFORK)
   

  CFORK creates a virgin process if CR%ST and CR%MAP are not set.   Note
  that  loading parameters in the AC's using CR%ACS does not make this a
  non-virgin process.	Setting CR%ST and either CR%ACS or CR%MAP creates
  a non-virgin process.

  CFORK creates an execute-only process if bit CR%MAP	is  set  and  the
  creating  process  is an execute-only process.  This is the only other
  way to create an execute-only process besides using the GET JSYS.

   The KFORK monitor call can be used to kill one or more processes.

   CFORK ERROR MNEMONICS:

   FRKHX6:   all relative process handles in use

  FRKHX8:   illegal to manipulate an execute-only process

   CFRKX3:   insufficient system resources


Node: CHFDB	Previous: CFORK	Next: CHKAC	Up: Top
			     CHFDB     JSYS 64

   Changes certain words in the  file  descriptor  block  (FDB)  for  the
   specified  file.   (Refer  to  Section  2.2.8  for  the format of this
   block.)

   ACCEPTS IN AC1:  B0(CF%NUD) do not wait  for  the  disk  copy  of  the
			       directory  to  be  updated.  The specified
			       changes	are  made  to  the  directory  in
			       memory  and  are  written to the disk as a
			       part of the normal monitor  disk  updating
			       procedure.     (See    below    for   more
			       information.)

		    B9-B17     index  into  FDB  indicating  word  to  be
		    (CF%DSP)   changed

		    B18-B35    JFN
		    (CF%JFN)

	      AC2:  mask indicating bits to be changed.   If  changing	a
		    count value (in AC3), use -1 as a mask.

	      AC3:  new values for changed bits.  These  values  must  be
		    given  in the bit positions corresponding to the mask
		    given in AC2.

   RETURNS     +1:  always

  The following table lists the JSYS's that are used to  set  the  words
  and bits of the FDB:
   (CHFDB)
   

   Word	  Bits	    JSYS

  .FBHDR	  none	    unchangeable

  .FBCTL	  B0-B1     CHFDB

		  FB%NEX    unchangeable

		  FB%DEL    CHFDB

		  B4-B5     unchangeable

		  B6	    reserved

		  FB%DIR    unchangeable

		  FB%NOD    CHFDB (owner/write access)

		  B9-B10    unchangeable

		  FB%ARC    ARCF

		  FB%INV    CHFDB

		  FB%OFF    ARCF

		  FB%CTL    CHFDB (owner)

  .FBEXL	  none	    unchangeable

  .FBADR	  none	    unchangeable

  .FBPRT	  B18-B35   CHFDB (owner)

  .FBCRE	  all	    CHFDB (WHEEL/OPERATOR)

  .FBAUT	  all	    SFUST

  .FBGEN	  none	    unchangeable

  .FBACT	  all	    SACTF

  .FBBYV	  FB%RET    CHFDB (owner)

		  FB%BSZ    CHFDB (owner/write access)

		  FB%MOD    CHFDB (owner/write access)

		  FB%PGC    CHFDB (WHEEL/OPERATOR)

  .FBSIZ	  all	    CHFDB (owner/write access)

  .FBCRV	  all	    CHFDB (owner/write access)

  .FBWRT	  all	    CHFDB (owner/write access)
   (CHFDB)
   

  .FBREF	  all	    CHFDB (owner/write access)

  .FBCNT	  all	    CHFDB (WHEEL/OPERATOR)

  .FBBK0	  none	    unchangeable

  .FBBK1	  none	    unchangeable

  .FBBK2	  none	    unchangeable

  .FBBBT	  B0-B5     ARCF

		  AR%1ST    CHFDB (WHEEL/OPERATOR)

		  AR%RFL    ARCF

		  AR%PSZ    DELF

  .FBNET	  all	    SFTAD

  .FBUSW	  all	    CHFDB (owner)

  .FBGNL	  none	    unchangeable

  .FBNAM	  none	    unchangeable

  .FBEXT	  none	    unchangeable

  .FBLWR	  all	    SFUST

  .FBTDT	  all	    ARCF

  .FBFET	  all	    SFTAD

  .FBTP1	  all	    ARCF

  .FBSS1	  all	    ARCF

  .FBTP2	  all	    ARCF

  .FBSS2	  all	    ARCF

   Because each CHFDB call changes only one  word  in  the  FDB,  several
   calls must be executed to change several words.  Each call causes disk
   I/O, and to keep this I/O to a minimum, the	program  should  set  bit
   CF%NUD on each call.  The setting of this bit on each call permits the
   program to run faster by allowing several changes to be  made  to  the
   FDB	with  minimum disk I/O.  To ensure that all the changes have been
   written to the disk, the program can issue the last	CHFDB  call  with
   bit	CF%NUD off.  Also, if the program requires the FDB on the disk to
   be updated after each call, it should execute each CHFDB call with bit
   CF%NUD off.
   (CHFDB)
   

   The GTFDB monitor call can be used to return the file descriptor block
   for	a  specified  file.  The GFUST monitor call can be used to return
   the name strings of the author of the file and the user who last wrote
   the file.  The GACTF call can be used to obtain the account designator
   of the file.

   Generates an illegal instruction interrupt on error conditions below.

   CHFDB ERROR MNEMONICS:

   CFDBX1:   invalid displacement

   CFDBX2:   illegal to change specified bits

   CFDBX3:   write or owner access required

   CFDBX4:   invalid value for specified bits

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators
   (CHKAC)
   


Node: CHKAC	Previous: CHFDB	Next: CIS	Up: Top
			     CHKAC     JSYS 521

   Checks if a user is allowed access to  files  in  a	given  directory.
   This  monitor  call	is  used to determine if the user will be able to
   access files having a given protection code if the user is  logged  in
   with the given capabilities and connected to the directory.

   ACCEPTS IN AC1:  length of the argument block in the right  half.   If
		    B0(CK%JFN)	is  on, word .CKAUD of the argument block
		    contains a JFN.

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success,  access  check  is   completed,   with   AC1
		    containing	-1 if access is allowed or 0 if access is
		    not allowed.

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

	0    .CKAAC	    Code of desired access to files.

	1    .CKALD	    Byte pointer to user name string,  or  36-bit
			    user  number  of  user  whose access is being
			    checked.

	2    .CKACD	    Byte pointer to directory name  string  (with
			    punctuation),  or  36-bit directory number to
			    which user whose access is being  checked  is
			    connected.

	3    .CKAEC	    Enabled capabilities of user whose access  is
			    being checked.  (Refer to Section 2.6.1.)

	4    .CKAUD	    Byte pointer to directory name  string  (with
			    punctuation),  or  36-bit directory number of
			    the  directory  containing	the  files  being
			    accessed.	If  B0(CK%JFN) of AC1 is on, this
			    word  contains  a  JFN  for  the  file  being
			    accessed.

	5    .CKAPR	    Protection	of  the  files	being	accessed.
			    (Refer  to	Section  2.2.6.) This word is not
			    required if a JFN is supplied in word .CKAUD.

   Access codes are as follows:

	0    .CKARD    read existing files
	1    .CKAWR    write existing files
	2    .CKAEX    execute existing files
	3    .CKAAP    append to existing files
   (CHKAC)
   

	4    .CKADL    obtain directory listing of existing files
	6    .CKADR    read the directory
	10   .CKACN    connect to the directory
	11   .CKACF    create files in the directory

   CHKAC ERROR MNEMONICS:

   CKAX1:    argument block too small

   CKAX2:    invalid directory number

   CKAX3:    invalid access code

   CKAX4:    file is not on disk


Node: CIS	Previous: CHKAC	Next: CLOSF	Up: Top
			      CIS     JSYS 141

   Clears the software interrupt system for the current process.   Clears
   all interrupts in progress and all waiting interrupts.

   RETURNS     +1:  always


Node: CLOSF	Previous: CIS	Next: CLZFF	Up: Top
			     CLOSF     JSYS 22

   Closes a specific file or all files.

   ACCEPTS IN AC1:  B0(CO%NRJ) do not release the JFN

		    B6(CZ%ABT) abort  any  output  operations	currently
			       being  done.   Close  the  file but do not
			       perform any  cleanup  operations  normally
			       associated  with  closing a file (e.g., do
			       not output remaining buffers or write tape
			       marks  if  output  to  a  magnetic tape is
			       aborted).  If output to a  new  disk  file
			       that   has   not  been  closed  (i.e.,  is
			       nonexistent)  is  aborted,  the	file   is
			       closed and then expunged.

		    B7(CZ%NUD) do not update the copy of the directory on
			       the  disk.   (Refer to CF%NUD of the CHFDB
			       call description for further information.)

		    B18-B35    JFN of the file being closed
		    (CO%JFN)
   (CLOSF)
   

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   If AC1 contains -1, all files (and all JFN's) at or below this process
   (with  the exception of the primary I/O files and files that cannot be
   closed by this process) are closed.	This action is identical to  that
   taken  on  a  CLZFF call with AC1 containing the process handle .FHSLF
   (400000).

   The OPENF monitor call can be used to open a specific file.

   CLOSF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   CLSX1:    file is not open

   CLSX2:    file cannot be closed by this process

   CLSX3:    file still mapped

   CLSX4:    device still active

   ENQX20:   locked JFN cannot be closed

   IOX11:    quota exceeded or disk full

   All output errors may occur.


Node: CLZFF	Previous: CLOSF	Next: COMND	Up: Top
			     CLZFF     JSYS 34

   Closes process' files.  Closes all files and/or releases all JFN's  at
   and/or below a specified process.

   ACCEPTS IN AC1:  B0(CZ%NIF) do not close files of inferior processes

		    B1(CZ%NSF) do not close files of this process

		    B2(CZ%NRJ) do not release JFNs

		    B3(CZ%NCL) do not  close  any  files;   only  release
			       non-open JFNs
   (CLZFF)
   

		    B4(CZ%UNR) unrestrict files  opened  with  restricted
			       access	for   specified   process.    The
			       specified process must be the same  as  or
			       inferior  to  the  process  executing  the
			       call.

		    B5(CZ%ARJ) wait until file can be closed, then  close
			       it, and release JFNs

		    B6(CZ%ABT) abort  any  output  operations	currently
			       being  done.   Close  the  file but do not
			       perform any  cleanup  operations  normally
			       associated  with  closing a file (e.g., do
			       not output remaining buffers or write tape
			       marks  if  output  to  a  magnetic tape is
			       aborted).  If output to a  new  disk  file
			       that   has   not  been  closed  (i.e.,  is
			       nonexistent)  is  aborted,  the	file   is
			       closed and then expunged.

		    B7(CZ%NUD) do not update the copy of the directory on
			       the  disk.   (Refer to CF%NUD of the CHFDB
			       call description for further information.)

		    B18-B35    process handle
		    (CZ%PRH)

   RETURNS     +1:  always.  No action is taken if the call is in any way
		    illegal.

   If AC1  contains  only  the	process  handle  .FHSLF,  the  action  is
   identical to that taken on a CLOSF call with AC1 containing -1.

   Generates an illegal instruction interrupt on error conditions below.

   CLZFF ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of  multiple process handle

   IOX11:    quota exceeded or disk full


Node: COMND	Previous: CLZFF	Next: CRDIR	Up: Top
			     COMND     JSYS 544

   Parses one field of a command that  is  either  typed  by  a  user  or
   contained in a file.  When this monitor call is used to read a command
   from a terminal, it provides the following features:
   (COMND)
   

	1.  Allows the input of a command (including the guide words)  to
	    be given in abbreviated, recognition (ESC and CTRL/F), and/or
	    full input mode.

	2.  Allows the user to edit his input with  the  DELETE,  CTRL/U,
	    CTRL/W, and CTRL/R editing keys.

	3.  Allows fields of the command to be defaulted  if  an  ESC  or
	    CTRL/F  is	typed at the beginning of any field or if a field
	    is omitted entirely.

	4.  Allows a help message to be given if a question mark  (?)  is
	    typed at the beginning of any field.

	5.  Allows input of an indirect file (@file)  that  contains  the
	    fields for all or the remainder of the command.

	6.  Allows a recall of the correct portion of  the  last  command
	    (i.e.,  up	to  the beginning of the field where an error was
	    detected) if the next command line begins with  CTRL/H.   The
	    correct  portion  of the command is retyped, and the user can
	    then continue typing from that point.

	7.  Allows input of a line to be continued onto the next line  if
	    the  user types a hyphen (-) immediately preceding a carriage
	    return.  (The carriage return is  invisible  to  the  program
	    executing  the  COMND call, although it is stored in the text
	    buffer.) The hyphen can be typed by  the  user  while  he  is
	    typing  a  comment.   The  comment is then continued onto the
	    next line.

   The COMND call allows the command line that	is  input  to  contain	a
   comment if the comment is preceded by either an exclamation point or a
   semicolon and the previous field has been terminated.  When the  COMND
   call  inputs  an  exclamation  point  after	a  field  that	has  been
   terminated, it ignores all text on the remainder of the line or up  to
   the	next  exclamation  point.  When the COMND call inputs a semicolon
   after a field that has been terminated, it ignores  all  text  on  the
   remainder of the line.

   When an indirect file is given on the command line, it can be given at
   the	beginning  of any field.  However, it must be the last item typed
   on the line, and its contents must complete the current command.   The
   user  must  terminate  his  input  of  the  indirect  file  (after any
   recognition is performed) with a carriage  return.	If  he	does  not
   terminate  his  input,  the	message  ?INDIRECT  FILE NOT CONFIRMED is
   output.  Also, if the user types a question mark (instead of the  file
   specification  of  the  indirect file) after he types the @ character,
   the message FILESPEC OF INDIRECT FILE is output.   The  indirect  file
   itself  should  not	contain  an  ESC  or  carriage	return;  if these
   characters are included, they will be treated as spaces.  The contents
   of  the  indirect file are placed in the text buffer but are not typed
   on the user's terminal.

   As the user types his command, the characters are placed in a  command
								  
   (COMND)
   

   text buffer.  This buffer can also include the command line prompt, if
    
   any.  Several byte pointers and counts reflect the  current	state  of
   the parsing of the command.	These pointers and counts are as follows:

	1.  Byte pointer to the beginning of  the  prompting-text  buffer
	    (.CMRTY).  This pointer is also called the CTRL/R buffer byte
	    pointer since it indicates the initial part of the text  that
	    will  be  output  on  a  CTRL/R.   (The remainder of the text
	    output on a CTRL/R is what the user had typed before he typed
	    CTRL/R.)  The  buffer  containing  the  prompt  need  not  be
	    contiguous with the buffer containing the  remainder  of  the
	    command  line.   Typically this pointer is to a string in the
	    literals area.

	2.  Byte pointer to the beginning of the user's  input	(.CMBFP).
	    This is the limit back to which the user can edit.

	3.  Byte pointer to the beginning of the next field to be  parsed
	    (.CMPTR).

	4.  Count of  the  space  remaining  in  the  text  input  buffer
	    (.CMCNT).

	5.  Count of the number of characters in the buffer that have not
	    yet been parsed (.CMINC).

   The illustration below is a logical arrangement of the  byte  pointers
   and	counts.  Remember that the prompting-text buffer does not have to
   be adjacent to the text buffer.

						       .CMCNT

		!=======================================================!
		!	 !		!		  !		!
		!	 !		!		  !		!
		!=======================================================!
		^	 ^		^
		!	 !		!
		!	 !		!	 .CMINC
		!	 !		!
		!	 !		!
		!	 .CMBFP 	.CMPTR
		.CMRTY

   These byte pointers and other information are contained in  a  command
								  
   state  block,  whose  address  is  given  as  an argument to the COMND
     
   monitor call.  The .CMINI function initializes these pointers.

   Parsing of a command is performed field by field and by default begins
   when  the user types a carriage return, ESC, CTRL/F, or question mark.
   These characters are called action characters because they  cause  the
   (COMND)
   

   system  to  act  on	the command as typed so far.  A field can also be
   terminated  with  a	space,	tab,   slash,	comma,	 or   any   other
   nonalphanumeric  character.	Normally, the parsing does not begin, and
   the COMND call does not return control to the program, until an action
   character  is typed.  However, if B8(CM%WKF) is on in word .CMFLG when
   the COMND call  is  executed,  parsing  begins  after  each	field  is
   terminated.

   The command is parsed by repeated COMND calls.   Each  call	specifies
   the	type  of  field expected to be parsed by supplying an appropriate
   function code and any data needed for the function.	This  information
   is  given in a function descriptor block.  On successful completion of
		    
   each call, the current byte pointers and the counts are updated in the
   command state block, and any data obtained for the field is returned.

   The program executing  the  COMND  call  should  not  reset	the  byte
   pointers  in the command state block after it completes the parsing of
   each command.  It should set up the state block once at the	beginning
   and then use the .CMINI function when it begins parsing each line of a
   command.  This is true because  the	.CMINI	function  implements  the
   CTRL/H  error  recovery  feature  in addition to initializing the byte
   pointers in the state block and printing the prompt for the line.   If
   the	program  resets  the pointers, the CTRL/H feature is not possible
   because the pointers from the  previous  command  are  not  available.
   When a CTRL/H is input, the .CMINI function allows error recovery from
   the last command only if both (1) the pointer to the beginning of  the
   user's  input (.CMBFP) is not equal to the pointer to the beginning of
   the next field to be parsed (.CMPTR) and (2) the last character parsed
   in the previous command was not an end-of-line character.

   The design of the COMND call allows the user to delete his typed input
   with  the  DELETE,  CTRL/W,	and  CTRL/U  keys without regard to field
   boundaries.	When the user deletes into a field that has already  been
   parsed,  the  COMND call returns to the program with B3(CM%RPT) set in
   word .CMFLG.  This return informs the program to  forget  the  current
   state  of  the  command and to reparse from the beginning of the line.
   Because the complete line as typed and corrected by the user is in the
   text  buffer, the parse can be repeated and will yield the same result
   up to the point of the change.

   The calling sequence to the COMND call is as follows:

   ACCEPTS IN AC1:  address of the command state block

	      AC2:  address of the first alternative function  descriptor
		    block

   RETURNS     +1:  always (unless a reparse is needed and the right half
		    of .CMFLG is nonzero), with
		    AC1 containing  flags  in  the  left  half,  and  the
			address  of  the command state block in the right
			half.  The flags are copied from word  .CMFLG  in
			the command state block.
		    AC2 containing either the data obtained for the field
			or an error code if the field could not be parsed
   (COMND)
   

			(CM%NOP is on).
		    AC3 containing in the left half the  address  of  the
			function  descriptor block given in the call, and
			in the right half the  address	of  the  function
			descriptor  block  actually  used  (i.e., the one
			that matched the input).

   The format of the command state block is shown below.

	   0			    17 18			35
	  !=======================================================!
   .CMFLG !	    Flag Bits	      ! Reparse Dispatch Address  !
	  !-------------------------------------------------------!
   .CMIOJ !	    Input JFN	      !        Output JFN	  !
	  !-------------------------------------------------------!
   .CMRTY !		 Byte Pointer to CTRL/R Text		  !
	  !-------------------------------------------------------!
   .CMBFP !	     Byte Pointer to Start of Text Buffer	  !
	  !-------------------------------------------------------!
   .CMPTR !	   Byte Pointer to Next Input To Be Parsed	  !
	  !-------------------------------------------------------!
   .CMCNT !		Count of Space Left in Buffer		  !
	  !-------------------------------------------------------!
   .CMINC !	     Count of Characters Left in Buffer 	  !
	  !-------------------------------------------------------!
   .CMABP !		 Byte Pointer to Atom Buffer		  !
	  !-------------------------------------------------------!
   .CMABC !		     Size of Atom Buffer		  !
	  !-------------------------------------------------------!
   .CMGJB !	       Address of GTJFN Argument Block		  !
	  !=======================================================!

			    Command State Block
			      

   Word      Symbol		      Meaning

     0	     .CMFLG    Flag bits  in  the  left  half,	and  the  reparse
		       dispatch  address  in  the  right half.	Some flag
		       bits can be set by the program executing the COMND
		       call;   others  can be set by the COMND call after
		       its execution.  The bits that can be  set  by  the
		       program	are described following the Command State
		       Block description.  The bits that can  be  set  by
		       COMND   are   described	 following  the  Function
		       Descriptor Block description.

		       The reparse dispatch address is	the  location  to
		       which  control is automatically transferred when a
		       reparse of the command is needed because the  user
		       edited  past  the  current pointer (i.e., the user
		       edited characters that were already  parsed).   If
		       this field is zero, the COMND call sets B3(CM%RPT)
		       in the left half of this word  and  gives  the  +1
   (COMND)
   

		       return when a reparse is needed.  The program must
		       then test CM%RPT and, if on, must reenter the code
		       that  parses the first field of the command.  When
		       the reparse dispatch address is given, control  is
		       transferred automatically to that address.

		       The code at the reparse	dispatch  address  should
		       initialize  the	program's  state  to  what it was
		       after   the   last    .CMINI    function.     This
		       initialization  should include resetting the stack
		       pointer, closing and releasing any  JFNs  acquired
		       since  the  last .CMINI function, and transferring
		       control to the code immediately following the last
		       .CMINI function call.

     1	     .CMIOJ    Input JFN in the left half, and output JFN in  the
		       right half.  These designators identify the source
		       for the input of the command and  the  destination
		       for   the   output   of	 the  typescript.   These
		       designators are usually	.PRIIN	(for  input)  and
		       .PRIOU (for output).

     2	     .CMRTY    Byte   pointer	to   the   beginning	of    the
		       prompting-text.

     3	     .CMBFP    Byte pointer to the beginning of the user's input.
		       The user cannot edit back past this pointer.

     4	     .CMPTR    Byte pointer to the beginning of the next field to
		       be parsed.

     5	     .CMCNT    Count of the space remaining in the  buffer  after
		       the .CMPTR pointer.

     6	     .CMINC    Count of the number of unparsed characters in  the
		       buffer after the .CMPTR pointer.

     7	     .CMABP    Byte pointer  to  the  atom  buffer,  a	temporary
		       storage buffer that contains the last field parsed
		       by the COMND call.  The terminator of the field is
		       not  placed  in	this  buffer.  The atom buffer is
		       terminated with a null.

     10      .CMABC    Count of the number  of	characters  in	the  atom
		       buffer.	This count should be at least as large as
		       the largest field expected to be parsed.

     11      .CMGJB    Address of a GTJFN  argument  block.   This  block
		       must  be at least 16(octal) words long and must be
		       writable.   If  a  longer  GTJFN  block	is  being
		       reserved,  the  count  in  the  right half of word
		       .GJF2 of the GTJFN argument block must be  greater
		       than four.  This block is usually filled in by the
		       COMND call with arguments for the  GTJFN  call  if
		       the  specified function is requesting a JFN (i.e.,
   (COMND)
   

		       functions .CMIFI, .CMOFI, and .CMFIL).	The  user
		       should  store  data  in	this  block on the .CMFIL
		       function only.

  The flag bits that can be set by the user in the  left  half  of  word
  .CMFLG  in  the  Command  State Block are described below.  These bits
  apply to the parsing of the entire command and are preserved by  COMND
  after  execution.   See  the  end of the COMND JSYS discussion for the
  bits that are returned by COMND in the left half of word .CMFLG.

		 Bits Supplied in State Block on COMND Call
		        

      Bit    Symbol		      Meaning

       6     CM%RAI	    Convert lowercase input to uppercase.

       7     CM%XIF	    Do	not  recognize	 the   @   character   as
			    designating   an   indirect   file;   instead
			    consider   the    character    as	 ordinary
			    punctuation.   A  program  sets  this  bit to
			    prevent the input of an indirect file.

       8     CM%WKF	    Begin parsing after each field is  terminated
			    instead  of  only  after  an action character
			    (carriage return, ESC, CTRL/F, question mark)
			    is	typed.	 For example, a program sets this
			    bit    if	 it    must    change	 terminal
			    characteristics   (e.g.,  it  must	turn  off
			    echoing because a password may be  input)  in
			    the  middle  of  a	command.  However, use of
			    this bit is not recommended because  terminal
			    wakeup occurs after each field is terminated,
			    thereby  increasing  system  overhead.    The
			    recommended   method   of  changing  terminal
			    characteristics within a command is to  input
			    the     field     requiring    the	  special
			    characteristic on the next line with its  own
			    prompt.    For   example,  if  a  program  is
			    accepting a  password,  it	should	turn  off
			    echoing after the .CMCFM function of the main
			    command and perform the  .CMINI  function  to
			    type  the prompt requesting a password on the
			    next line.

   The format of the function descriptor block is shown below.

	  0	      8 9	   17 18		       35
	 !=======================================================!
	 !  function   !  function   ! address of next function  !
   .CMFNP!    code     !    flags    !	   descriptor block	 !
	 !-------------------------------------------------------!
   .CMDAT!		Data for specific function		 !
	 !-------------------------------------------------------!
   (COMND)
   

   .CMHLP!	    Byte pointer to help text for field 	 !
	 !-------------------------------------------------------!
   .CMDEF!	  Byte pointer to default string for field	 !
	 !-------------------------------------------------------!
  .CMBRK!	       Pointer to 4-word break mask		 !
	 !=======================================================!

			 Function Descriptor Block
			   

   Word      Symbol		      Meaning

     0	     .CMFNP    Function  code  and  pointer  to   next	 function
		       descriptor block.
		       B0-B8(CM%FNC)   Function code
		       B9-B17(CM%FFL)  Function-specific flags
		       B18-B35(CM%LST) Address	of  the   next	 function
				       descriptor block

     1	     .CMDAT    Data for the specific function, if any.

     2	     .CMHLP    Byte pointer to the  help  text	for  this  field.
		       This  word  can	be  zero  if  the  program is not
		       supplying its own help text.  CM%HPP must  be  set
		       (in word 0) in order for this pointer to be used.

     3	     .CMDEF    Byte pointer to the default string for this field.
		       This  word  can	be  zero  if  the  program is not
		       supplying its own default string.

    4	     .CMBRK    Pointer to a  4-word  break  mask  that	specifies
		       which  characters  constitute  end of field.  Word
		       .CMBRK is ignored unless CM%BRK (B13) is on.

   The individual words in the function descriptor block are described in
   the following paragraphs.

   Words .CMFNP and .CMDAT of the function descriptor block
           

   Word .CMFNP contains the function code for the expected  field  to  be
   parsed,  and  word .CMDAT contains any additional data needed for that
   function.  The function codes, along with any required  data  for  the
   functions, are described below.

   Code      Symbol		      Meaning

    0	     .CMKEY    Parse a keyword, such as  a  command  name.   Word
		       .CMDAT  contains  the  address of a keyword symbol
		       table in the format described in the TBLUK monitor
		       call  description  (i.e., alphabetical).  The data
		       bits that can be defined in the right half of  the
		       first word of the argument pointed to by the table
		       entries (when B0-B6 of the first word are off  and
		       B7(CM%FW) is on) are as follows:
   (COMND)
   

		       B35(CM%INV)    Suppress this keyword in	the  list
				      output on a ?.  The program can set
				      this bit to include entries in  the
				      table   that  should  be	invisible
				      because  they  are  not	preferred
				      keywords.   For  example,  this bit
				      can be set  to  allow  the  keyword
				      LIST  to	be valid, even though the
				      preferred  keyword  may  be  PRINT.
				      The   LIST  keyword  would  not  be
				      listed in the output given on a  ?.
				      This    bit   is	 also	used   in
				      conjunction with the CM%ABR bit  to
				      suppress	an  abbreviation  in  the
				      output given on a ?.

		       B34(CM%NOR)    Do not recognize this keyword  even
				      if  an  exact match is typed by the
				      user and suppress  its  listing  in
				      the  list output on a ?.	(Refer to
				      the TBLUK call description for more
				      information on using this bit.)

		       B33(CM%ABR)    Consider	this  keyword	a   valid
				      abbreviation  for  another entry in
				      the table.  The right half of  this
				      table  entry  points to the keyword
				      for which this is an  abbreviation.
				      The  program  can  set  this bit to
				      include entries in the  table  that
				      are  less  than  the minimum unique
				      abbreviation.   For  example,  this
				      bit can be set to include the entry
				      ST (for START) in  the  table.   If
				      the   user   then  types	ST  as	a
				      keyword, it will be accepted  as	a
				      valid   abbreviation   even  though
				      there   may   be	 other	 keywords
				      beginning with ST.  To suppress the
				      output of this abbreviation in  the
				      list typed on a ?, the program must
				      also set the CM%INV bit.

		       On a successful return, AC2 contains  the  address
		       of the table entry where the keyword was found.

    1	     .CMNUM    Parse a number.	Word .CMDAT  contains  the  radix
		       (from  2  to  10)  of the number.  On a successful
		       return, AC2 contains the number.

    2	     .CMNOI    Parse a guide word string, but do  not  return  an
		       error  if  no  guide  word  is input.  An error is
		       returned only if a guide word is input  that  does
		       not  match  the one expected by the COMND call.	A
		       guide word field must be delimited by parentheses.
   (COMND)
   

		       Word  .CMDAT  contains  a byte pointer to an ASCIZ
		       string.	 This  string  does   not   contain   the
		       parentheses  of	the  guide word.  Guide words are
		       output if the user terminated the  previous  field
		       with  ESC.   Guide  words  are not output, nor can
		       they be input, if the user has caused parsing into
		       the next field.

    3	     .CMSWI    Parse a switch.	A switch field must begin with	a
		       slash  and  can	be  terminated	with  a  colon in
		       addition to any of the  legal  terminators.   Word
		       .CMDAT  contains  the  address of a switch keyword
		       symbol table.  (Refer to the  TBLUK  monitor  call
		       description  for  the  format  of  the table.) The
		       entries in the table do not contain the	slash  of
		       the  switch  keywords;	however,  they should end
		       with a colon if the switch requires a value.   The
		       data  bits  CM%INV, CM%NOR, and CM%ABR defined for
		       the .CMKEY  function  can  also	be  set  on  this
		       function.   On  a  successful return, AC2 contains
		       the address of the table entry  where  the  switch
		       keyword was found.

    4	     .CMIFI    Parse an input file specification.  This  function
		       causes  the  COMND call to execute a GTJFN call to
		       attempt to parse the specification for an existing
		       file, using no default fields.  The .CMGJB address
		       (word 11 in  the  command  state  block)  must  be
		       supplied,  but  the  GTJFN  block should be empty.
		       (Data stored in the block will be  overwritten  by
		       the  COMND  JSYS.   Also,  certain GTJFN flags are
		       set.) On a successful return, AC2 contains the JFN
		       assigned.   Hyphens  are  treated  as alphanumeric
		       characters for this function

		       See note following .CMFIL function.

    5	     .CMOFI    Parse an output file specification.  This function
		       causes  the  COMND call to execute a GTJFN call to
		       attempt to parse the specification  for	either	a
		       new  or	an existing file.  The default generation
		       number is the generation number	of  the  existing
		       file plus 1.  The .CMGJB address must be supplied,
		       but the GTJFN block should be empty.  (Data stored
		       in  the	block  will  be  overwritten by the COMND
		       JSYS.  Also, certain GTJFN flags are  set.)  On	a
		       successful  return, AC2 contains the JFN assigned.
		       Hyphens are treated as alphanumeric characters for
		       this function.

		       See note following .CMFIL function.

    6	     .CMFIL    Parse a general	(arbitrary)  file  specification.
		       This  function  causes the COMND call to execute a
   (COMND)
   

		       GTJFN to attempt to parse  the  specification  for
		       the  file.   The  .CMGJB address must be supplied,
		       but data stored in  certain  words  of  the  GTJFN
		       block  will  be	overwritten by the COMND JSYS and
		       certain GTJFN flags will be set (see note  below).
		       On  a  successful  return,  AC2	contains  the JFN
		       assigned.  Hyphens  are	treated  as  alphanumeric
		       characters for this function.

		       Note that portions of  the  GTJFN  block  used  by
		       functions   .CMOFI,   .CMIFI,   and   .CMFIL   are
		       controlled by COMND.   The  following  list  shows
		       which  words  are  under  the control of COMND and
		       which words are under the control of the user:

		       GTJFN	  Controlled	Characteristics
		       Word(s)	  by

		       .GJGEN	  COMND

						1.  .CMOFI   sets   flags
						    GJ%FOU,  GJ%MSG,  and
						    GJ%XTN and clears all
						    other flags.

						2.  .CMIFI   sets    flag
						    GJ%OLD,   and  GJ%XTN
						    and clears all  other
						    flags.

						3.  .CMOFI   and   .CMIFI
						    zero  the  right half
						    of word .GJGEN

						4.  .CMFIL   sets    flag
						    GJ%XTN   and   clears
						    GJ%FCM

		       .GJSRC	  COMND 	None

		       .GJDEV -
		       .GJJFN	  COMND/
				  USER		Functions   .CMIFI    AND
						.CMOFI give COMND control
						of these  words.   .CMFIL
						gives the user control of
						these words.
		       .GJF2 -
		       .GJATR	  COMND 	None

    7	     .CMFLD    Parse an arbitrary field.  This function is useful
		       for fields not normally handled by the COMND call.
		       The   input,   as   delimited   by    the    first
		       nonalphanumeric character, is copied into the atom
		       buffer;	the delimiter is not  copied.	Note  the
   (COMND)
   

		       following:

		       1.  This function will parse a null field

		       2.  Hyphens are treated as alphanumeric characters
			   for this function

		       3.  No validation is performed (such  as  filename
			   validation)

		       4.  No standard help  message  is  available  (see
			   below)

		       5.  The FLDBK. and BRMSK. macros may be	used  for
			   including  other characters in the field (like
			   "*").

    10	     .CMCFM    Confirm.  This function	waits  for  the  user  to
		       confirm	the  command  with  a carriage return and
		       should be used at the end  of  parsing  a  command
		       line.

    11	     .CMDIR    Parse a	directory  name.   Login  and  files-only
		       directories  are  allowed.   Word  .CMDAT contains
		       data  bits  for	this  function.   The	currently
		       defined bit is as follows:

		       B0(CM%DWC)     Allow  wildcard  characters  to  be
				      typed in a directory name.

		       On a successful return, AC2  contains  the  36-bit
		       directory number.

    12	     .CMUSR    Parse a user name.   Only  login  directories  are
		       allowed.  On a successful return, AC2 contains the
		       36-bit user number.

    13	     .CMCMA    Comma.  Sets B1(CM%NOP-no parse) in word .CMFLG of
		       the  command state block and returns if a comma is
		       not the next item in the input.	Blanks can appear
		       on  either  side  of  the comma.  This function is
		       useful for parsing a list of arguments.

   14	     .CMINI    Initialize the command line (e.g., set up internal
		       monitor	pointers,  type the prompt, and check for
		       CTRL/H).  This function	should	be  used  at  the
		       beginning  of  parsing a command line but not when
		       reparsing a line.  Otherwise, the  CTRL/H  feature
		       will not work.

		       To use this function, the  user	first  moves  the
		       appropriate  data into the command state block and
		       then issues .CMINI.  If, at any	time  during  the
   (COMND)
   

		       parsing	of  a  line,  an  error occurs, .CMINI is
		       issued again to reinitialize the  line.	 However,
		       for  the 2'nd thru N'th invocation of .CMINI for a
		       given line, the user should  not  alter	the  byte
		       pointers and character counts in the command state
		       block.  To do so would disable the CTRL/H feature.
		       This feature allows the user program, on parsing a
		       bad atom, to print an error message,  reissue  the
		       prompt,	and  parse the command line again without
		       forcing the user to retype the entire line.

		       If .CMINI reads a CTRL/H  character,  .CMINI  will
		       reset  all  byte  pointers  and	character  counts
		       except the .CMINC count to their  original  state.
		       .CMINI  will set the .CMINC count to the number of
		       characters in the  buffer  up  to  the  bad  atom.
		       These  characters  are  output to the terminal and
		       parsed again.  Control then passes to the  reparse
		       address	(if provided) and normal parsing resumes.
		       The effect on the program is as if  the	bad  atom
		       had never been typed.

    15	     .CMFLT    Parse a floating-point number.	On  a  successful
		       return, AC2 contains the floating-point number.

    16	     .CMDEV    Parse a device name.  On a successful return,  AC2
		       contains the device designator.

    17	     .CMTXT    Parse the input	text  up  to  the  next  carriage
		       return,	place  the  text  in the atom buffer, and
		       return.	If an ESC or CTRL/F is typed,  it  causes
		       the  terminal bell to ring (because recognition is
		       not available with this function) and is otherwise
		       ignored.    If  a  ?   is  typed,  an  appropriate
		       response is given, and the ? is	not  included  in
		       the  atom  buffer.   (A	? can  be included in the
		       input text if it is preceded by a CTRL/V.)

    20	     .CMTAD    Parse a date and/or time field  according  to  the
		       setting	of bits CM%IDA and CM%ITM.  The user must
		       input the field as  requested.	Any  date  format
		       allowed by the IDTIM call can be input.	If a date
		       is not input, it is  assumed  to  be  the  current
		       date.  If a time is not input, it is assumed to be
		       00:00:01.  When both the date and time fields  are
		       input,  they  must  be  separated  by  one or more
		       spaces.	If the fields are input separately,  they
		       must  be  terminated  with  a  space  or  carriage
		       return.	Word .CMDAT contains  bits  in	the  left
		       half  and an address in the right half as data for
		       the function.  The bits are:

		       B0(CM%IDA) Parse a date
		       B1(CM%ITM) Parse a time
		       B2(CM%NCI) Do not convert the date and/or time  to
   (COMND)
   

				  internal  format.   (Refer  to  Section
				  2.8.2.)

		       The address in the right half is the beginning  of
		       a  3-word block in the caller's address space.  On
		       a successful  return,  this  block  contains  data
		       returned  from the IDTNC call executed by COMND if
		       B2(CM%NCI) was on in the COMND call (i.e., if  the
		       input  date  and/or  time  field  was  not  to  be
		       converted to internal format).  If B2(CM%NCI)  was
		       off in the COMND call, on a successful return, AC2
		       contains the internal date and time format.

    21	     .CMQST    Parse a quoted string up to the terminating quote.
		       The  delimiters	for  the  string  must	be double
		       quotation marks and are not  copied  to	the  atom
		       buffer.	 A double quotation mark is input as part
		       of the string if two double quotation marks appear
		       together.   This  function  is useful if the legal
		       field terminators and the action characters are to
		       be  included  as part of a string.  The characters
		       ?, ESC, and  CTRL/F  are  not  treated  as  action
		       characters  and	are included in the string stored
		       in the atom buffer.  Carriage return is an invalid
		       character in a quoted string and causes B1(CM%NOP)
		       to be set on return.

    22	     .CMUQS    Parse  an  unquoted  string  up	to  one  of   the
		       specified  break characters.  Word .CMDAT contains
		       the  address  of  a  4-word  block  of  128  break
		       character mask bits.  (Refer to word .RDBRK of the
		       TEXTI call description for an explanation  of  the
		       mask.)  The  characters	scanned are not placed in
		       the atom buffer.  On return, .CMPTR is pointing to
		       the  break character.  This function is useful for
		       parsing a string with an arbitrary delimiter.  The
		       characters  ?,  ESC, and CTRL/F are not treated as
		       action characters (unless they  are  specified  in
		       the  mask)  and	can  be  included  in the string.
		       Carriage return can also be included if it is  not
		       one of the specified break characters.

    23	     .CMTOK    Parse the  input  and  compare  it  with  a  given
		       string.	 Word .CMDAT contains the byte pointer to
		       the given string.  This function  sets  B1(CM%NOP)
		       in  word  .CMFLG  of  the  command state block and
		       returns if the next input characters do not  match
		       the given string.  Leading blanks in the input are
		       ignored.  This  function  is  useful  for  parsing
		       single or multiple character operators (e.g., + or
		       **).

    24	     .CMNUX    Parse  a  number  and  terminate  on   the   first
		       non-numeric  character.	 Word .CMDAT contains the
		       radix  (from  2	to  10)  of  the  number.   On	a
   (COMND)
   

		       successful  return, AC2 contains the number.  This
		       function is useful for parsing a number	that  may
		       not  be	terminated with a nonalphabetic character
		       (e.g., 100PRINT FILEA).

		       Note that non-numeric identifiers can begin with a
		       digit  (e.g.,  1SMITH  as  a  user  name).  When a
		       non-numeric identifier  and  a  number  appear  as
		       alternates  for a field, the order of the function
		       descriptor  blocks  is  important.    The   .CMNUX
		       function,  if  given first, would accept the digit
		       in the non-numeric identifier as  a  valid  number
		       instead	 of  as  the  beginning  character  of	a
		       non-numeric identifier.

    25	     .CMACT    Parse an account string.  The input, as	delimited
		       by  the first nonalphanumeric character, is copied
		       into  the  atom	buffer;   the  delimiter  is  not
		       copied.	 No  verification is performed nor is any
		       standard help message available.

   26	     .CMNOD    Parse a network node name.  A node  name  consists
		       of up to six alphanumeric characters followed by 2
		       colons ("::").  Lowercase characters are converted
		       to  uppercase characters.  The node name is copied
		       into the atom buffer  without  the  colons.   Note
		       that  this  function does not verify the existence
		       of the node.

   In addition to the  .CMFNP  word  of  the  function	descriptor  block
   containing  the  function  code  in	bits 0-8 (CM%FNC), this word also
   contains function-specific flag bits in bits  9-17  (CM%FFL)  and  the
   address of another function descriptor block in bits 18-35 (CM%LST).

   The flag bits that can be set in bits 9-17 (CM%FFL) are as follows:

   Bit	     Symbol		      Meaning

    14	     CM%PO     The field is to be parsed  only	and  the  field's
		       existence   is  not  to	be  verified.	This  bit
		       currently  applies  to  the  .CMDIR   and   .CMUSR
		       functions   and	 is  ignored  for  the	remaining
		       functions.  On  return,	COMND  sets  B1(CM%NOP-no
		       parse)  only  if  the  field  typed  is not in the
		       correct syntax.	Also, data returned  in  AC2  may
		       not be correct.

    15	     CM%HPP    A byte pointer to a program-supplied help  message
		       for this field is given in word 2 (.CMHLP) of this
		       function descriptor block.

    16	     CM%DPP    A  byte	pointer  to  a	program-supplied  default
		       string  for this field is given in word 3 (.CMDEF)
		       of this function descriptor block.
   (COMND)
   

    17	     CM%SDH    The output of the default help message  is  to  be
		       suppressed  if  the  user  types  a question mark.
		       (See below for the default messages.)

   The address of another function descriptor block can be given in  bits
   18-35  (CM%LST) of the .CMFNP word.	The use of this second descriptor
   block is described below.

   Usually one COMND call is executed for  each  field	in  the  command.
   However,  for some fields, more than one type of input may be possible
   (e.g., after a keyword field, the next field could be a  switch  or	a
   filename  field).   In  these cases, all the possibilities for a field
   must be tried in an order selected to test unambiguous cases first.

   When the COMND call	cannot	parse  the  field  as  indicated  by  the
   function code, it does one of two things:

	1.  It sets the current pointer and counts  such  that	the  next
	    call  will	attempt  to  parse the same input over again.  It
	    then returns with B1(CM%NOP) set in  the  left  half  of  the
	    .CMFLG  word in the command state block.  The caller can then
	    issue another COMND call  with  a  function  code  indicating
	    another  of the possible fields.  After the execution of each
	    call, the caller should test the CM%NOP flag to  see  if  the
	    field was parsed successfully.

	2.  If an address of another function descriptor block	is  given
	    in	CM%LST,  the  COMND  call  moves to this descriptor block
	    automatically and attempts to parse the field as indicated by
	    the  function  code contained in B0-B8(CM%FNC) in word .CMFNP
	    of that block.  If the COMND call fails to	parse  the  field
	    using  this new function code, it moves to a third descriptor
	    block if one is given.  This sequence continues until  either
	    the  field	is successfully parsed or the end of the chain of
	    function blocks is reached.  Upon  completion  of  the  COMND
	    call,  AC3	contains  the  addresses  of  the  first and last
	    function blocks used.

   By specifying a chained list of function blocks, the program can  have
   the	COMND  call  automatically  check all possible alternatives for a
   field and not have  to  issue  a  separate  call  for  each	one.   In
   addition,  if  the user types a question mark, a list is output of all
   the alternatives for the field as indicated by the  list  of  function
   descriptor blocks.

   Word .CMHLP of the function descriptor block
         

   This word contains a byte pointer to a program-supplied help  text  to
   be output if the user types a question mark when entering his command.
   The	default  help  message	is  appended  to  the	output	 of   the
   program-supplied message if B17(CM%SDH) is not set.	If B17(CM%SDH) is
   set, only the program-supplied message is output.  If this word in the
   descriptor  block is zero, only the default message is output when the
   user types a question mark.	Bit 15(CM%HPP) must  be  set  in  word	0
   (.CMFNP) of the function descriptor block for this pointer to be used.
   (COMND)
   

   The default help message depends on the particular function being used
   to  parse  the  current field.  The table below lists the default help
   message for each function available in the COMND call.

			   Default Help Messages
			     

   Function		    Message

   .CMKEY (keyword)	    ONE OF THE FOLLOWING
			    followed by the alphabetical  list	of  valid
			    keywords.	If the user types a question mark
			    in the middle of the field, only the keywords
			    that   can	 possibly   match  the	field  as
			    currently typed are output.   If  no  keyword
			    can possibly match the currently typed field,
			    the message
			    KEYWORD  (NO  DEFINED  KEYWORDS  MATCH   THIS
			    INPUT)
			    is output.

   .CMNUM (number)	    The help message output depends on the  radix
			    specified  in .CMDAT in the descriptor block.
			    If the radix is octal, the help message is
				 OCTAL NUMBER
			    If the radix is decimal, the help message is
				 DECIMAL NUMBER
			    If the radix is any  other	radix,	the  help
			    message is
				 A NUMBER IN BASE nn
			    where nn is the radix.

   .CMNOI (guide word)	    None

   .CMSWI (switch)	    ONE OF THE FOLLOWING
			    followed by the alphabetical  list	of  valid
			    switch keywords.  The same rules apply as for
			    .CMKEY function.  (See above.)

   .CMIFI (input file)	    The help  message	output	 depends  on  the
   .CMOFI (output file)     settings of certain bits in the  GTJFN  call.
   .CMFIL (any file)	    If bit GJ%OLD is off and bit  GJ%FOU  is  on,
			    the help message is
				 OUTPUT FILESPEC
			    Otherwise, the help message is
				 INPUT FILESPEC

   .CMFLD (any field)	    None

   .CMCFM (confirm)	    CONFIRM WITH CARRIAGE RETURN

   .CMDIR (directory)	    DIRECTORY NAME

   .CMUSR (user)	    USER NAME

   .CMCMA (comma)	    COMMA
   (COMND)
   

   .CMINI (initialize)	    None

   .CMFLT (floating point)  NUMBER

   .CMDEV (device)	    DEVICE NAME

   .CMTXT (text)	    TEXT STRING

   .CMTAD (date)	    The help message depends on the bits  set  in
			    .CMDAT in the descriptor block.  If CM%IDA is
			    set, the help message is
				 DATE
			    If CM%ITM is set, the help message is
				 TIME
			    If both are set, the help message is
				 DATE AND TIME

   .CMQST (quoted)	    QUOTED STRING

   .CMUQS (unquoted)	    None

   .CMTOK (token)	    None

   .CMNUX (number)	    Same as .CMNUM

   .CMACT (account)	    None

   .CMNOD (node)	    NODE NAME

   Word .CMDEF of the function descriptor block
         

   This word contains a byte pointer to the ASCIZ string to  be  used  as
   the	default  for  this  field.   For  this pointer to be used, bit 16
   (CM%DPP) must be set in word 0 (.CMFNP) of the descriptor block.   The
   string  is  output  to  the destination, as well as copied to the text
   buffer, if the user types an ESC or	CTRL/F	as  the  first	non-blank
   character  in  the  field.	If  the user types a carriage return, the
   string is copied  to  the  atom  buffer  but  is  not  output  to  the
   destination.

   When the caller supplies a list of  function  descriptor  blocks,  the
   byte  pointer  for  the  default  string must be included in the first
   block.  The CM%DPP bit and the pointer  for	the  default  string  are
   ignored  when  they appear in subsequent blocks.  However, the default
   string can be worded so that it will apply to any of  the  alternative
   fields.   The  effect  is  the same as if the user had typed the given
   string.

   Defaults for fields of a file specification can also be supplied  with
   the	.CMFIL	function.  If both the byte pointer to the default string
   and the GTJFN defaults have been provided, the COMND default  will  be
   used first and then, if necessary, the GTJFN defaults.
		  The  function  descriptor  block,  whose
		  address  is  given in AC2, can be set up
		  by the FLDDB. and FLDBK. macros  defined
		  in  MACSYM.	(See  end of COMND section
		  for a description of these macros.)

  Word .CMBRK of the function descriptor block
        

  This word contains a pointer to  a  4-word  user-specified  mask  that
  determines  which characters constitute end of field.  The leftmost 32
  bits of each word correspond to a character	in  the  ASCII	collating
  sequence  (in  ascending  order).   If  the	bit  is  on  for  a given
  character, typing that character will cause the COMND  JSYS	to  treat
  the characters typed so far as a separate field and parse it according
  to the function being used.	CM%BRK (B13) must be on in the first word
  of the function descriptor block or COMND will ignore word .CMBRK.

  Ordinarily, the user would rely  on	COMND's  default  masks  (varying
  according to function) to specify which characters signal end of field
  and thus would not be concerned  with  word	.CMBRK	of  the  function
  block.   However,  for special purposes such as allowing "*" or "%" to
  be part of a field rather  than  a  field  delimiter,  the  user  must
  specify  his  own  mask.   (In  this example, the bits for "*" and "%"
  would be off in the mask word.) The user may inspect  COMND's  default
  masks (defined in MONSYM) for help in designing a custom mask.

  The following is a list of the COMND functions that use masks:

  Mask 	     COMND	 Changeable
  Symbols	     Function	 by User

  KEYB0. - KEYB3.   .CMKEY	 Yes
  DEVB0. - DEVB3.   .CMDEV	 Yes (only if parse-only)
  FLDB0. - FLDB3.   .CMFLD	 Yes
  EOLB0. - EOLB3.   .CMTXT	 Yes
  KEYB0. - KEYB3.   .CMSWI	 Yes
  User specified    .CMDAT	 Yes
  USRB0. - USRB3.   .CMUSR	 No
  FILB0. - FILB3.   .CMFIL	 No
  FILB0. - FILB3.   .CMIFI	 No
  FILB0. - FILB3.   .CMOFI	 No
  internal	     .CMNUM	 No
  FILB0. - FILB3.   .CMDIR	 No
  internal	     .CMFLT	 No
  ACTB0. - ACTB3.   .CMACT	 No

  COMND will ignore any break masks that  are	specified  for	functions
  that do not allow user-modified masks.

  Note that specifying a zero mask with CM%BRK set will  cause  the  TTY
  line buffer to fill up and generate an error.

   On a successful return, the COMND call returns flag bits in	the  left
   half  of  AC1  and preserves the address of the command state block in
   the right half of AC1.  These flag bits are copied from word .CMFLG in
   the command state block and are described as follows.
   (COMND)
   

			Bits Returned on COMND Call
			    

   Bit	     Symbol		      Meaning

    0	     CM%ESC    An ESC was typed by the user as the terminator for
		       this field.

    1	     CM%NOP    The field could not be parsed because it  did  not
		       conform	to  the  specified function(s).  An error
		       code is returned in AC2.

    2	     CM%EOC    The field was terminated with a carriage return.

    3	     CM%RPT    Characters already  parsed  need  to  be  reparsed
		       because	the  user edited them.	This bit does not
		       need to be examined if the program has supplied	a
		       reparse	dispatch  address  in  the  right half of
		       .CMFLG in the command state block.

    4	     CM%SWT    A switch field was terminated with a colon.   This
		       bit is on if the user either used recognition on a
		       switch that ends with a colon or typed a colon  at
		       the end of the switch.

    5	     CM%PFE    The previous field was terminated with an ESC.

   When a field cannot be parsed, B1(CM%NOP) is set in AC1,  and  one  of
   the	following error codes is returned in AC2.  Note that if a list of
   function descriptor blocks is given and an error code is returned, the
   error  is  associated  with	the last function descriptor block in the
   list.

   NPXAMB:   ambiguous

   NPXNSW:   not a switch - does not begin with slash

   NPXNOM:   does not match switch or keyword

   NPXNUL:   null switch or keyword given

   NPXINW:   invalid guide word

   NPXNC:    not confirmed

   NPXICN:   invalid character in number

   NPXIDT:   invalid device terminator

   NPXNQS:   not a quoted string - does not begin with double quote

   NPXNMT:   does not match token

   NPXNMD:   does not match directory or user name

   NPXCMA:   comma not given
   (COMND)
   

   COMX18:   invalid character in node name

   COMX19:   too many characters in node name

  Macros
  

  Several macros (defined in MACSYM) are available  to  make  using  the
  COMND JSYS more convenient.	These macros are as follows:

  FLDDB.(TYP,FLGS,DATA,HLPM,DEFM,LST)

	  where:

	  TYP  = function type
	  FLGS = function flags
	  DATA = function-specific data
	  HLPM = help message
	  DEFM = default text
	  LST  = additional invocations of the FLDDB. macro (used only if
		 multiple function blocks are required)

	  This macro generates function descriptor blocks for COMND.  For
	  example, the following code would perform a .CMINI function:

	  MOVEI T1,STEBLK	     ;Get address of COMND state block
	  MOVEI T2,[FLDDB.(.CMINI)]  ;Get address of function block
	  COMND

	  The following code would perform a  .CMKEY  function	(assuming
	  that the keyword table started at address CMDTAB:

	  MOVEI T1,STEBLK	     ;Get address of COMND state block
	  MOVEI T2,[FLDDB(.CMKEY,<CM%DPP+CM%+CM%HPP>,CMDTAB,
		   <help text>,<default text>)]
	  COMND

  FLDBK.(TYP,FLGS,DATA,HLPM,DEFM,BRKADR,LST)

	  This is exactly the same as FLDDB. except that a provision  has
	  been	made  for  the	address  of  the  first  word of a 4-word
	  character mask (BRKADR).   This  version  is	for  use  when	a
	  user-specified character mask is required.

  BRMSK.(INI0,INI1,INI2,INI3,ALLOW,DISALLOW)

	  where:

	  INI0 =     first word of character mask
	  INI1 =     second word of character mask
	  INI2 =     third word of character mask
	  INI3 =     fourth word of character mask
	  ALLOW =    characters to allow in the mask
	  DISALLOW = characters to disallow in the mask

	  This macro generates 4-word character masks for use with  those
   (COMND)
   

	  COMND  functions  that  allow the user to specify his own mask.
	  For example, executing the following code would  allow  "*"  in
	  the predefined mask for the .CMFLD function (FLDB0 thru BLDB3):

	  BRMSK.(FLDB0.,FLDB1.,FLDB2.,FLDB3.,<*>,)

	  Also, the BRMSK. macro may be invoked within the FLDBK. macro:

	  FLDBK.(TYP,FLGS,DATA,HLPM,DEFM,[
		 BRMSK.(INI0,INI1,INI2,INI3,ALLOW,DISALLOW)],LST)

   The COMND call causes other monitor calls to be executed, depending on
   the	particular  function  that  is requested.  Failure of these calls
   usually results in the failure to parse the requested field.  In these
   cases, the relevant error code can be obtained via the GETER and ERSTR
   monitor calls.

	Any TBLUK error can occur on the keyword and switch functions.

	Any NIN/NOUT  and  FLIN/FLOUT  error  can  occur  on  the  number
	functions.

	Any  GTJFN  error  except  for	GJFX37	can  occur  on	the  file
	specification functions.

	Any IDTNC error can occur on the date/time function.

	Any RCDIR or RCUSR error can occur  on	the  directory	and  user
	functions.

	Any STDEV error can occur on the device function.

   Generates an illegal instruction interrupt on error conditions below.

   COMND ERROR MNEMONICS:

   COMNX1:   invalid COMND function code

   COMNX2:   field too long for internal buffer

   COMNX3:   command too long for internal buffer

   COMNX5:   invalid string pointer argument

   COMNX8:   number base out of range 2-10

   COMNX9:   end of input file reached

   COMX10:   invalid default string

   COMX11:   invalid CMRTY pointer

   COMX12:   invalid CMBFP pointer
   (COMND)
   

   COMX13:   invalid CMPTR pointer

   COMX14:   invalid CMABP pointer

   COMX15:   invalid default string pointer

   COMX16:   invalid help message pointer

   COMX17:   invalid byte pointer in function block


Node: CRDIR	Previous: COMND	Next: CRJOB	Up: Top
			     CRDIR     JSYS 240

   Creates, changes, or deletes a directory entry.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
  ACCEPTS IN AC1:  byte pointer to ASCIZ string containing the structure
		    and  directory name.  The string must be of the form:
		    structure:<directory>.

	      AC2:  B0(CD%LEN)	set length of the argument block  to  the
				value  given in word .CDLEN.  This bit is
				not used in  TOPS-20  version  3  and  is
				provided for future releases.

		    B1(CD%PSW)	set password from argument block

		    B2(CD%LIQ)	set  working  disk  storage  limit   from
				argument block

		    B3(CD%PRV)	set capability bits from argument block

		    B4(CD%MOD)	set mode bits from argument block

		    B5(CD%LOQ)	set permanent  disk  storage  limit  from
				argument block

		    B6(CD%NUM)	set directory number from argument  block
				(valid only when creating a directory)

		    B7(CD%FPT)	set default file protection from argument
				block

		    B8(CD%DPT)	set directory  protection  from  argument
				block

		    B9(CD%RET)	set default retention count from argument
				block

		    B10(CD%LLD) set last LOGIN date from argument block
   (CRDIR)
   

		    B11(CD%UGP) set user groups from argument block

		    B12(CD%DGP) set directory groups from argument block

		    B13(CD%SDQ) set  subdirectory  quota  from	 argument
				block

		    B14(CD%CUG) set  user  groups  assignable	by   this
				directory from argument block

		    B15(CD%DAC) set default account from argument block

		    B17(CD%DEL) delete this directory entry

		    B18-B35	address of the argument block
		    (CD%APB)

	      AC3:  byte pointer to ASCIZ string containing the  password
		    of	the  directory.   This pointer is required when a
		    nonprivileged user is  changing  parameters  for  his
		    directory.

   RETURNS     +1:  always, with directory number in AC1

   This monitor call requires the  process  to	have  WHEEL  or  OPERATOR
   capability enabled unless one of the following conditions is true:

	1.  The specified directory is one to which the caller has  owner
	    access  and  the  caller is changing any one of the following
	    parameters:

		 password (.CDPSW)
		 default file protection (.CDFPT)
		 directory protection (.CDDPT)
		 default retention count (.CDRET)
		 default account (.CDDAC)

	    This feature is installation  dependent  and  is  enabled  by
	    issuing function .SFCRD of the SMON monitor call.

	2.  The specified directory is inferior to the one to  which  the
	    caller is currently connected and the caller has owner access
	    to this inferior directory.

   Refer to Section 2.2.6 for the description of owner access.

   The format of the argument block is as follows:

      Word   Symbol		      Meaning

	0    .CDLEN	    flag bits in the left half, and length of the
			    argument   block  in  the  right  half.   The
			    following bits are defined:
   (CRDIR)
   

			    B0(CD%NSQ)	When restoring this directory, do
					not	update	  its	 superior
					directory's  quotas   (permanent,
					working, and subdirectory quotas)
					to account  for  this  directory.
					If  this bit is off, the superior
					directory's quotas  are  updated.
					This  bit is set by the DLUSER or
					DUMPER	program  to  retain   the
					superior  directory's quotas when
					restoring   its   subdirectories.
					The  process  must  have WHEEL or
					OPERATOR  capability  enabled  to
					set this bit.

			    B1(CD%NCE)	When restoring or  reconstructing
					this directory, do not change any
					directory   parameters	 if   the
					directory   currently  exists  on
					disk;  set the parameters only if
					the directory does not exist.  If
					this bit is  off,  the	directory
					parameters  as saved are restored
					for the directory.  This  bit  is
					set   by  the  DLUSER  or  DUMPER
					program to restore or reconstruct
					directories    from   out-of-date
					files  without	causing  existing
					directories  to  revert  to older
					parameters.   The  process   must
					have WHEEL or OPERATOR capability
					enabled to set this bit.

	1    .CDPSW	    pointer to password string, which is a string
			    from 1 to 39 alphanumeric characters.

	2    .CDLIQ	    maximum number of pages that can be used  for
			    working disk storage (also known as logged-in
			    quota).

	3    .CDPRV	    capabilities  for  this  user.    (Refer   to
			    Section 2.6.1 for the capability bits.)

	4    .CDMOD	    mode word.

			    B0(CD%DIR)	directory name can only  be  used
					for   connecting  to  (i.e.,  the
					directory   is	  a    files-only
					directory).   If this bit is off,
					the directory name  can  be  used
					for logging in and connecting to.

			    B1(CD%ANA)	accounts are alphanumeric.   This
					bit  is  not used and is provided
					for  compatibility  with  systems
   (CRDIR)
   

					earlier than TOPS-20 version 3.

			    B2(CD%RLM)	all the messages  from	the  file
					<SYSTEM>MAIL.TXT   are	 repeated
					each time the user logs  in.   If
					this   bit   is   off,	only  the
					messages not  previously  printed
					are output when the user logs in.

			    B7(CD%DAR)	If on, this  bit  indicates  that
					when  the  online expiration date
					has  been  reached,   the   files
					concerned   should   be  archived
					rather than migrated  to  virtual
					disk.	 This  bit  is	currently
					reserved and is not implemented.

	5    .CDLOQ	    maximum number of pages that can be used  for
			    permanent	disk   storage	 (also	known  as
			    logged-out quota).

	6    .CDNUM	    directory number, valid only when creating	a
			    directory.	An error code is returned if user
			    changes the number of an  existing	directory
			    (CRDIX2)   or   gives   a  non-unique  number
			    (CRDIX8).

	7    .CDFPT	    default    file    protection    (18    bits,
			    right-justified).

	10   .CDDPT	    directory	   protection	   (18	    bits,
			    right-justified).

	11   .CDRET	    default number of generations of a file to be
			    retained  in the directory (retention count).
			    Valid numbers are 0 to 63, with  0	being  an
			    infinite number.

	12   .CDLLD	    date of last login.

	13   .CDUGP	    pointer to user group list.

	14   .CDDGP	    pointer to directory group list.

	15   .CDSDQ	    maximum number of  directories  that  can  be
			    created  inferior  to  this  directory.  This
			    parameter allows a user to create directories
			    with the BUILD command.

	16   .CDCUG	    pointer  to  user  group  list.   This   list
			    contains  the group numbers that can be given
			    to directories inferior to this one.

	17   .CDDAC	    pointer to default account for this user.
   (CRDIR)
   

	20   .CDDNE	    default online expiration date and time.  May
			    be	 an  explicit  date  and  time	(internal
			    format) or an interval (in days).  In  either
			    case,  the	specified  date/interval  may not
			    exceed the system maximum.	This parameter is
			    read  if  CD%NED  (1B2)  or  CD%FED  (1B3) in
			    .CDLEN  are  set.	If  a  new  directory  is
			    created  and this parameter is not specified,
			    the system default is used.

			    An unprivileged user may modify his defaults,
			    but  only  to  a  value less than or equal to
			    those which are currently  specified  or  the
			    system maximum, whichever is greater.

			    This word is currently reserved  and  is  not
			    implemented.

	21   .CDDFE	    default  offline  expunge  date   and   time.
			    Otherwise similar to .CDDNE (above).

			    This word is currently reserved  and  is  not
			    implemented.

  The format of  each	group  list  is  a  table  with  the  first  word
  containing  a  count of the number of words (including the count word)
  in the table and each subsequent word containing a group number.

  When CRDIR is being executed to create a directory, bits 0-17  of  AC2
  may	optionally be on or off.  If a particular bit is on, it indicates
  that the corresponding  argument  in  the  argument	block  should  be
  examined.  If the bit is off, it indicates that the argument should be
  defaulted.  The following table lists the bits and  the  corresponding
  argument defaults:

	Bits		     Argument Defaults
	B2(CD%LIQ)  maximum working disk file storage to 250 pages
	B3(CD%PRV)  no special capabilities
	B4(CD%MOD)  directory name that can be used for  logging  in  and
		    that  lists  the  messages from <SYSTEM>MAIL.TXT only
		    once
	B5(CD%LOQ)  maximum permanent disk file storage to 250 pages
	B6(CD%NUM)  the  first	unused	directory  number.    B6   should
		    normally be off.
	B7(CD%FPT)  default file protection to 777700
	B8(CD%DPT)  directory protection to 777700
	B9(CD%RET)  default file retention count to 1
	B10(CD%LLD) never logged in
	B11(CD%UGP) no user groups
	B12(CD%DGP) no directory groups
	B13(CD%SDQ) no ability to create inferior directories
	B14(CD%CUG) no assignable user groups for inferior directories
	B15(CD%DAC) no default account

   When CRDIR is being executed to change a directory and any  of  B0-B17
   (CRDIR)
   

   of AC2 is off, the corresponding parameter is not affected.

   When CRDIR is being executed to delete a directory,	the  settings  of
   B0-B17  of  AC2 are ignored.  A CRDIR call cannot be given to delete a
   directory that has directories inferior to it.

   The GTDIR call can be used to obtain the directory information.

   Generates an illegal instruction interrupt on error conditions below.

   CRDIR ERROR MNEMONICS:

   CRDIX1:   WHEEL or OPERATOR capability required

   CRDIX2:   illegal to change number of old directory

   CRDIX3:   insufficient system resources (Job Storage Block full)

   CRDIX4:   superior directory full

   CRDIX5:   directory name not given

   CRDIX6:   directory file is mapped

   CRDIX7:   file(s) open in directory

   CRDIX8:   invalid directory number

   CRDIX9:   internal format of directory is incorrect

   CRDI10:   maximum directory number exceeded; index table needs
	     expanding

   CRDI11:   invalid terminating bracket on directory

   CRDI12:   structure is not mounted

   CRDI13:   request exceeds superior directory working quota

   CRDI14:   request exceeds superior directory permanent quota

   CRDI15:   request exceeds superior directory subdirectory quota

   CRDI16:   invalid user group

   CRDI17:   illegal to create non-files-only subdirectory under
	     files only directory

   CRDI18:   illegal to delete logged-in directory

   CRDI19:   illegal to delete connected directory

   CRDI20:   WHEEL, OPERATOR, or requested capability required

   CRDI21:   working space insufficient for current allocation
   (CRDIR)
   

   CRDI22:   subdirectory quota insufficient for existing subdirectories

   CRDI23:   superior directory does not exist

   CRDI24:   invalid subdirectory quota


Node: CRJOB	Previous: CRDIR	Next: CRLNM	Up: Top
			      CRJOB     JSYS 2

   Creates a new job and optionally logs it in.  This monitor call causes
   the functions that are normally performed when a job is created (e.g.,
   assignment of  a  JSB,  the	primary  I/O  designators,  and  the  job
   controlling terminal) to be performed for the new job.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  flag bits

	      AC2:  address of argument block

	      AC3:  (optional) If CRJOB is to be used to release  control
		    over  a  job previously created with CRJOB (bit 17 in
		    AC1 must be on), then AC3 contains the job number  of
		    the previously created job.

   RETURNS     +1:  failure, with error code in AC1

	       +2:  success, with the number of the new job in AC1

   The flag bits defined in the left half of AC1 are as follows:

   Bit	   Symbol			    Meaning

   0	   CJ%LOG      Log in the new job.  If this bit is off,  the  new
		       job is created but not logged in.

   1	   CJ%NAM      Set the user name and password from  the  argument
		       block.	If  this bit is off, the user name of the
		       caller is given to the new job.

   2-3	   CJ%ACT      Set the account of the new job to the following:

		       Code    Symbol		     Meaning

		       0       .CJUCA	 Use current account of caller.

		       1       .CJUAA	 Use account  from  the  argument
					 block.

		       2       .CJUDA	 Use  default  account	of   user
					 whose job is being created.
   (CRJOB)
   

  4	   CJ%ETF      If set, place the TOPS-20 command processor in the
		       top-level  process  of  the  new job.  The command
		       processor will read  its  program  argument  block
		       (see below) at the time it is started.

		       CJ%FIL and CJ%ETF interact in the following ways:

		       1.  If CJ%FIL is on and CJ%ETF is on, then  a  job
			   is  created	with  a top process consisting of
			   the TOPS-20 command processor and an  inferior
			   process  consisting	of the file pointed to by
			   word .CJFIL.

		       2.  IF CJ%FIL is off and CJ%ETF is on, then a  job
			   is  created	with  a top process consisting of
			   the TOPS-20 command	processor.   No  inferior
			   process is created.

		       3.  If CJ%FIL is on and CJ%ETF is off, then a  job
			   is  created	with  a top process consisting of
			   the	file  pointed  to  by  word  .CJFIL.   No
			   inferior process is created.

		       The format of the program  argument  block  is  as
		       follows:

		       Word		Contents

			0	 Count of words in block,  not	including
				 this word.

			1	 1B0+3B6+2B12+CR%PRA - indicates this  is
				 a  program argument block created by the
				 CRJOB JSYS

			2	 1B0 + offset1 - offset1 is the offset in
				 this  block  of the first argument being
				 passed.

			3	 1B0 + offset2 - offset2 is the offset in
				 this  block of the second argument being
				 passed.

			n	 (offset1) This argument is a copy of the
				 flag  bits  from  word .CJEXF (word 10 -
				 flags	 for   the    command	 language
				 processor) of the CRJOB argument block.

			n+1	 (offset2)   This    argument	 contains
				 information   about  the  process  being
				 started - process  handle,,entry  vector
				 offset.  The entry vector offset is from
				 word  .CJSVF  (word  4)  of  the   CRJOB
				 argument block.
   (CRJOB)
   

		       The program argument block is created by the CRJOB
		       monitor	call  and  is  passed to the process by a
		       PRARG  monitor  call  (performed   internally   by
		       CRJOB).	 The  user  does  not  specify any of the
		       information in the program  argument  block.   The
		       user  can,  by  invoking  the  PRARG monitor call,
		       return the block and examine its contents.

   5	   CJ%FIL      Move (via a GET call) the file pointed to  in  the
		       argument  block into a process in the new job.  If
		       B4(CJ%ETF) is off,  the	file  is  placed  in  the
		       top-level  process  of the new job.  If B4(CJ%ETF)
		       is  on,	the  file  is  placed  in   the   process
		       designated  in  the  Command  Language Processor's
		       PRARG argument block.  (See below.)  If B5(CJ%FIL)
		       is off, no file is moved into a process of the new
		       job, and the top-level process of the new  job  is
		       the Command Language Processor.

   6	   CJ%ACS      Load the ACs from the value in the argument block.
		       The  ACs  are  loaded only if a program other than
		       the Command Language Processor is being run.

   7	   CJ%OWN      Maintain ownership of the  new  job.   This  means
		       that  the  new  job cannot be logged out until the
		       caller releases ownership of it.  If this  bit  is
		       off, control of the new job is released.

   8	   CJ%WTA      Do not start the new  job  until  it  is  attached
		       (using  ATACH JSYS) to a terminal.  If this bit is
		       off, the new job is started.

   9	   CJ%NPW      Do not check the password given when the  new  job
		       is logged in.  If this bit is off, the password is
		       checked unless the new job is being logged in with
		       the  same user name as the caller or with WHEEL or
		       OPERATOR capability enabled.

   10	   CJ%NUD      Do not update the date of LOGIN for  user  logging
		       in  to  the new job.  If this bit is off, the date
		       of LOGIN is updated unless the user is logging  in
		       with  the  same	user  name  as the caller or with
		       WHEEL or OPERATOR capability enabled.

   11	   CJ%SPJ      Set (via a  SPJFN  call)  the  primary  input  and
		       output  designators from the argument block before
		       starting the job.  The primary I/O designators are
		       not  changed  for  a Command Language Processor in
		       the top-level process of the new  job;	they  are
		       changed	only for inferior processes.  If this bit
		       is off, the primary I/O designators of the new job
		       are the job's controlling terminal.

   12	   CJ%CAP      Set the new job's allowed user capabilities (right
		       half)  to  be  the  same as the caller's currently
   (CRJOB)
   

		       enabled capabilities, until the new job is  logged
		       in.   If this bit is off, the new job has the user
		       capabilities associated with the user whose job is
		       being created.

   13	   CJ%CAM      Set the new job's allowed capabilities to  be  the
		       combination  of (AND function) the capability mask
		       in the argument	block  and  the  new  job's  user
		       capabilities.  If this bit is off, the new job has
		       the capabilities associated with  the  user  whose
		       job is being created.

   14	   CJ%SLO      Send  a	IPCF  message  to  the	PID  supplied  in
		       argument block when the new job is logged out.  If
		       this bit is off, no message is sent when  the  new
		       job is logged out.

		       The IPCF logout message has the following format:

		       Word		   Contents

			0	 0,,.IPCLO
			1	 N,,# of job logged out.  N is the  count
				 of  the  remaining words in this message
				 (currently 10 octal).
			2	 flags,,reserved
				 Bits	Symbol	 Meaning
				  B0	SP%BAT	 job  is  controlled   by
						 batch
				  B1	SP%DFS	 spooling is deferred.
				  B2	SP%ELO	 the job executed LGOUT
				  B3	SP%FLO	 the job  was  forced  to
						 logout.   If this bit is
						 on, check Word 8 of  the
						 IPCF message (gives code
						 of most  recent  monitor
						 call error).  B3 will be
						 on only if  job  has  an
						 interrupt  to be handled
						 by MEXEC(Mini-EXEC).
				  B4	SP%OLO	 the job was  logged  out
						 by  another job.  Word 6
						 of  the   IPCF   message
						 contains  the job number
						 of the job that did  the
						 logout.

			3	 job connect time
			4	 job CPU time
			5	 TTY number  of  job  at  logout  (-1  if
				 detached)
			6	 job number  of  the  job  that  did  the
				 logout
			7	 reserved
			10	 code of the  most  recent  monitor  call
   (CRJOB)
   

				 error

   17	   CJ%DSN      Release ownership of the  previously  created  job
		       whose  number  is  in  AC3.  If this bit is on, it
		       overrides the setting of all other  bits  in  AC1,
		       and  no	change	is made to the job's status other
		       than the change in ownership.

   The format of the argument block (whose address is given in AC2) is as
   follows:

   Word 	Symbol			     Meaning

    0		.CJNAM	  Byte pointer to the user name string.

    1		.CJPSW	  Byte pointer to the password string.

    2		.CJACT	  5B2 + numeric account number or byte pointer to
			  account string.

    3		.CJFIL	  Byte pointer to the name  of	the  file  to  be
			  moved  (via  a  GET call) into a process of the
			  new job.  The new job must have read access  to
			  the  file.   The process into which the file is
			  placed depends on the setting of B4(CJ%ETF).

    4		.CJSFV	  Offset in the entry vector to use as the  start
			  address  of the file pointed to by word .CJFIL.
			  This offset is the argument to the  SFRKV  call
			  used to start the process.

    5		.CJTTY	  Terminal   designator   of   the   new    job's
			  controlling  terminal.   This  terminal must be
			  assigned by the caller.  The terminal  is  then
			  released  and  assigned to the new job.  If the
			  new  job  is	to  be	 detached,   the   .NULIO
			  designator (377777) is given.

   6		.CJTIM	  connect-time for new	job  before  a	LGOUT  is
			  forced  on  it;   0  indicates  no limit.  This
			  function is currently not implemented.

   7		.CJACS	  Address of a 16-word block whose  contents  are
			  to  be loaded in the new job's ACs if a program
			  other than the Command  Language  Processor  is
			  being run.

   10		.CJEXF	  Flag bits to be passed to the Command  Language
			  Processor  in  the top-level process of the new
			  job.	The bits are:

			  B0	 Suppress  the	herald	printed  by   the
				 Command Language Processor.

			  B1	 Move the file pointed to by word  .CJFIL
   (CRJOB)
   

				 into  the process whose handle is in the
				 PRARG block.  (See below.)

			  B2	 Start the process at the offset  in  the
				 entry vector given in word .CJSFV.  This
				 process is  started  after  the  Command
				 Language Processor is initialized.

			  B3	 Output the text  printed  when  a  LOGIN
				 command is given (e.g., system messages,
				 job number, terminal number).

			  This word is copied  into  the  PRARG  argument
			  block passed to the Command Language Processor.
			  (See Below.)

   11		.CJPRI	  Primary input and output  designators  for  the
			  inferior  processes  of  the	new  job.   These
			  designators must refer to  device  designators.
			  The Command Language Processor in the top-level
			  process of the new job executes a SPJFN call to
			  set these designators.

   12		.CFCPU	  Runtime limit for the new job.  When this limit
			  is  reached,	an  interrupt is generated (via a
			  TIMER call), and the Command Language Processor
			  will	execute  a LGOUT call for the new job.	A
			  zero in this word means  there  is  no  runtime
			  limit on the job.

   13		.CJCAM	  Capability mask for the new job.  This mask  is
			  used only if CJ%CAM is set.

    14		.CJSLO	  PID to which an IPCF message is to be sent when
			  the new job is logged out.

  When CRJOB creates a new job, it also creates the  top-level  process,
  and	this  process  is always a virgin process.  Thus, an execute-only
  program can be RUN as the top-level fork.

   The CRJOB call causes other monitor calls to be executed, depending on
   the particular function that is performed.

	Any GTJFN and OPENF errors can occur when obtaining the specified
	file.

	Any SFRKV error can  occur  when  starting  the  program  in  the
	specified file.

	Any LOGIN and account validation errors can occur when logging in
	the job.

   CRJOB ERROR MNEMONICS:

   CRJBX1:   invalid parameter or function bit combination
   (CRJOB)
   

   CRJBX2:   illegal for created job to enter MINI-EXEC

   CRJBX4:   terminal is not available

   CRJBX5:   unknown name for LOGIN

   CRJBX6:   insufficient system resources


Node: CRLNM	Previous: CRJOB	Next: CVHST	Up: Top
			     CRLNM     JSYS 502

   Defines or deletes a logical name assignment.  Logical names are  used
   to specify a set of default values for each field requested by a GTJFN
   monitor call.  When a logical name is passed to the	GTJFN  call,  any
   fields  not specified by the user are supplied from the fields defined
   in the logical name definition.  (Refer to Section 2.2.2  and  to  the
   INLNM  and  LNMST  monitor  call  descriptions for more information on
   logical names.)

   ACCEPTS IN AC1:  function code

	      AC2:  byte pointer to the logical name

	      AC3:  byte pointer to the logical name definition string

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC3

   The codes for the functions are as follows:

	0    .CLNJ1  delete one logical name from the job

	1    .CLNS1  delete one logical name from the system

	2    .CLNJA  delete all logical names from the job

	3    .CLNSA  delete all logical names from the system

	4    .CLNJB  create a logical name for the job

	5    .CLNSY  create a logical name for the system

   CRLNM ERROR MNEMONICS:

   CRLNX1:   logical name is not defined

   CRLNX2:   WHEEL or OPERATOR capability required

   CRLNX3:   invalid function
   (CRLNM)
   

   GJFX4:    invalid character in filename

   GJFX5:    field cannot be longer than 39 characters

   GJFX6:    device field not in a valid position

   GJFX7:    directory field not in a valid position

   GJFX8:    directory terminating delimiter is not preceded by a  valid
	     beginning delimiter

   GJFX9:    more than one name field is not allowed

   GJFX10:   generation number is not numeric

   GJFX11:   more than one generation number field is not allowed

   GJFX12:   more than one account field is not allowed

   GJFX13:   more than one protection field is not allowed

   GJFX14:   invalid protection

   GJFX15:   invalid confirmation character

   GJFX22:   insufficient system resources (Job Storage Block full)

   GJFX31:   invalid wildcard designator



Node: CVHST	Previous: CRLNM	Next: CVSKT	Up: Top
			     CVHST     JSYS 276

  Converts a host number to a primary name.

  RESTRICTIONS:    for use with ARPANET only

	      ACCEPTS IN AC1: destination designator for the ASCIZ string

	      AC2:  host number

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, host name string returned to area designated
		    by AC1

  CVHST ERROR MNEMONICS:

  CVHST1:   no string for that host number
   (CVSKT)
   


Node: CVSKT	Previous: CVHST	Next: DEBRK	Up: Top
			     CVSKT     JSYS 275

  Converts a local socket number to absolute form.

  RESTRICTIONS:    for use with ARPANET only

	      ACCEPTS IN AC1: JFN

  RETURNS     +1:  failure, error code in AC1

	       +2:  success, absolute socket number in AC2

  CVSKT ERROR MNEMONICS:

  CVHST1:   no string for that host number
  CVSKX1:   invalid JFN

  CVSKX2:   local socket invalid in this context


Node: DEBRK	Previous: CVSKT	Next: DELDF	Up: Top
			     DEBRK     JSYS 136

   Dismisses the current  software  interrupt  routine	in  progress  and
   resumes  the process at the location specified by the PC stored in the
   priority level table.  (Refer to Section 2.5.7.)

   RETURNS     +1:  if no software interrupt is currently in progress and
		    if an ERJMP or ERCAL instruction follows the DEBRK

   Generates an illegal instruction interrupt on error conditions below.

   DEBRK ERROR MNEMONICS:

   DBRKX1:    no interrupts in progress


Node: DELDF	Previous: DEBRK	Next: DELF	Up: Top
			     DELDF     JSYS 67

   Reclaims space by expunging disk  files  that  have	been  marked  for
   deletion  with  DELF.  This call first checks the user's access to the
   directory, verifying that the user is allowed to  expunge  files  from
   it.

  When a file with archive status is deleted and expunged,  DELDF  sends
  an  IPCF  message to GALAXY.  This message contains all archive status
   (DELDF)
   

  informatiion which includes tape information as well  as  the  present
  file  name,	user  who  expunged the file and the time at which it was
  expunged.

   RESTRICTIONS:	       some functions require WHEEL  or  OPERATOR
			       capabilities enabled.
   ACCEPTS IN AC1:  B0(DD%DTF) delete temporary files (;T) also

		    B1(DD%DNF) delete nonexistent files that are not  now
			       opened

		    B2(DD%RST) rebuild the symbol table

		    B3(DD%CHK) check internal consistency  of  directory.
			       If  an  error  occurs,  the  symbol  table
			       should be rebuilt.  If B2(DD%RST) is  also
			       set,  it  is  ignored,  and the DELDF call
			       must be executed again with B2(DD%RST)  on
			       to rebuild the symbol table.

	      AC2:  directory number

   RETURNS     +1:  always

   The directory number given must be that of  the  user's  connected  or
   logged-in   directory   unless  the	process  has  WHEEL  or  OPERATOR
   capability enabled.

   If errors still occur after the symbol table is rebuilt,  the  process
   should  restore  the  directory  from magnetic tape or the user should
   request help from the operator.

   Generates an illegal instruction interrupt on error conditions below.

   DELDF ERROR MNEMONICS:

   DELDX1:   WHEEL or OPERATOR capability required

   DELDX2:   invalid directory number

   DELFX2:   file cannot be expunged because it is currently open

   DELFX4:   directory symbol table could not be rebuilt

   DELFX5:   directory symbol table needs rebuilding

   DELFX6:   internal format of directory is incorrect

   DELFX7:   FDB formatted incorrectly; file not deleted

   DELFX8:   FDB not found; file not deleted
   (DELF)
   


Node: DELF	Previous: DELDF	Next: DELNF	Up: Top
			      DELF     JSYS 26

   Deletes the specified disk file and (if the file is	closed)  releases
   the JFN.  The file is not expunged immediately but is marked for later
   expunging by the system or with the DELDF or LGOUT monitor call.

   RESTRICTIONS:	       some functions require WHEEL  or  OPERATOR
			       capabilities enabled.
   ACCEPTS IN AC1:  B0(DF%NRJ) do not release the JFN

		    B1(DF%EXP) expunge the contents of	the  file.   This
			       also   deletes	the   FDB  entry  in  the
			       directory.   B0(DF%NRJ)	 and   B1(DF%EXP)
			       cannot be set simultaneously.

		    B2(DF%FGT) expunge the file but do not  deassign  its
			       addresses.  The process must have WHEEL or
			       OPERATOR capability enabled  to	set  this
			       bit.   This  bit  should be set only by an
			       operator or system specialist to delete	a
			       file  that  has	a damaged or inconsistent
			       index block.

		    B3(DF%DIR) delete and expunge a directory file.   The
			       process	 must	have  WHEEL  or  OPERATOR
			       capability enabled to set this bit.   This
			       bit  should  be set only by an operator or
			       specialist to delete a bad directory.

		   B4(DF%ARC)  allow a file with  archive  status  to  be
			       deleted.

		   B5(DF%CNO)  delete and expunge  the	contents  of  the
			       file  but preserve the file's name and FDB
			       as they were (with the  exception  of  the
			       page  count  and  the page table address).
			       Setting this bit will cause  the  DELF  to
			       fail  if  bit AR%NDL is set in word .FBBBT
			       of the FDB or if a complete  set  of  tape
			       backup information is not in the FDB.

		    B18-B35    JFN of the file being deleted
		    (DF%JFN)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, JFN is released unless B0(DF%NRJ) is  on  or
		    the file is opened.

   By setting B0(DF%NRJ), the user can delete multiple files by giving	a
   JFN to GNJFN that represents a group of files and processing each file
   in the group.

   The DELF call takes the  +1	return	if  the  JFN  is  assigned  to	a
   (DELF)
   

   non-directory device.

   DELF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DESX9:    invalid operation for this device

   DELFX1:   delete access required

   DELFX2:   file cannot be expunged because it is currently opened

   DELFX3:   system scratch area depleted; file not deleted

   DELFX4:   directory symbol table could not be rebuilt

   DELFX5:   directory symbol table needs rebuilding

   DELFX6:   internal format of directory is incorrect

   DELFX7:   FDB formatted incorrectly; file not deleted

   DELFX8:   FDB not found; file not deleted

   DELFX9:   file is not a directory file

   DELF10:   directory still contains subdirectory

   DLFX10:   cannot delete directory; file still mapped

   DLFX11:   cannot delete directory file in this manner

   WHELX1:   WHEEL or OPERATOR capability required


Node: DELNF	Previous: DELF	Next: DEQ	Up: Top
			     DELNF     JSYS 317

   Deletes all but the specified number of generations of  a  disk  file.
   The	files  are  marked  for deletion and are expunged at a later time
   either automatically by the system or explicitly  with  the	DELDF  or
   LGOUT call.

   ACCEPTS IN AC1:	       B0(DF%NRJ) do not release the JFN

		    B4(DF%ARC) allow a file with  archive  status  to  be
   (DELNF)
   

			       deleted.

		    B5(DF%CNO) delete and expunge  the	contents  of  the
			       file  but preserve the file's name and FDB
			       as they were (with the  exception  of  the
			       page  count  and  the page table address).
			       Setting this bit will cause  the  DELF  to
			       fail  if  bit AR%NDL is set in word .FBBBT
			       of the FDB or if a complete  set  of  tape
			       backup information is not in the FDB.

		     B18-B35   JFN of the file being deleted

   AC2: 		       the number of generations to retain

	      RETURNS	  +1:  failure, error code in AC1

			  +2:  success, with the number of files  deleted
			       in AC2

   Starting at the file specified by the JFN, the DELNF  call  decrements
   the	generation  number,  first  retaining  the  specified  number  of
   generations before deleting the remaining generations.

   DELNF ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   DELFX1:   delete access required


Node: DEQ	Previous: DELNF	Next: DEVST	Up: Top
			      DEQ     JSYS 514

   Removes a request for a specific resource from  the	queue  associated
   with that resource.	The request is removed whether or not the process
   has a lock for the resource or is only waiting in the  queue  for  the
   resource.

   This call can be used to remove any number of requests.  If one of the
   requests  cannot be dequeued, the dequeueing procedure continues until
   all requests that can be have been dequeued.  An error return is given
   for	the  last  request found that could not be dequeued.  The process
   can then execute the ENQC call to determine the current status of each
   request.   However,	if  the  process  attempts to dequeue more pooled
   resources than it originally allocated, the error return is taken  and
   (DEQ)
   

   none of the pooled resources are dequeued.

   Refer to the TOPS-20 Monitor Calls User's Guide for	an  overview  and
   description of the Enqueue/Dequeue facility.

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument  block	(required  only  for  the
		    .DEQDR function)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

      Code   Symbol			   Meaning

	0    .DEQDR	    Remove the specified requests from the queue.
			    This  function  is	the only one requiring an
			    argument block.

	1    .DEQDA	    Remove all requests for this process from the
			    queues.   This  action is taken on a RESET or
			    LGOUT call.  The error return is taken if the
			    process has not given an ENQ call.

	2    .DEQID	    Remove all requests that  correspond  to  the
			    specified	request   identifier(ID).    This
			    function allows  the  process  to  release	a
			    class  of locks in one call without itemizing
			    each lock in an argument block.  It is useful
			    when  dequeueing  in  one call the same locks
			    that were enqueued in one call.  To use  this
			    function,	the  process  places  the  18-bit
			    request ID in AC2.

   The format of the argument block for function .DEQDR is  identical  to
   that  given	on  the  ENQ  call.   (Refer  to  the  ENQ  monitor  call
   description.) However, the .ENQID word of the argument  block  is  not
   used on a DEQ call and must be zero.

   DEQ ERROR MNEMONICS:

   ENQX1:    invalid function

   ENQX2:    level number too small

   ENQX3:    request and lock level numbers do not match

   ENQX4:    number of pool and lock resources do not match

   ENQX6:    requested locks are not all locked

   ENQX7:    no ENQ on this lock
   (DEQ)
   

   ENQX9:    invalid number of blocks specified

   ENQX10:   invalid argument block length

   ENQX11:   invalid software interrupt channel number

   ENQX13:   indirect or indexed byte pointer not allowed

   ENQX14:   invalid byte size

   ENQX15:   ENQ/DEQ capability required

   ENQX16:   WHEEL or OPERATOR capability required

   ENQX17:   invalid JFN

   ENQX18:   quota exceeded

   ENQX19:   string too long

   ENQX20:   locked JFN cannot be closed

   ENQX21:   job is not logged in

   DESX8:    file is not on disk


Node: DEVST	Previous: DEQ	Next: DFIN	Up: Top
			     DEVST     JSYS 121

  Translates the given device	designator  to	its  corresponding  ASCIZ
  device   name   string.    The   string  returned  contains	only  the
  alphanumeric device name;  it does not contain a colon.

   ACCEPTS IN AC1:  destination designator

	      AC2:  device designator

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, updated string pointer in AC1, if pertinent

   The STDEV monitor call can be  used	to  translate  a  string  to  its
   corresponding device designator.

   DEVST ERROR MNEMONICS:

   DEVX1:    invalid device designator

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job
   (DEVST)
   

   DESX3:    JFN is not assigned

   IOX11:    quota exceeded or disk full


Node: DFIN	Previous: DEVST	Next: DFOUT	Up: Top
			     DFIN     JSYS 234

  Inputs  a  double-precision,  floating-point   number,   rounding   if
  necessary.	 Currently   this   call   stores   the  number  in  KA10
  double-precision floating-point format.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  failure, error code in AC4 and updated string pointer
		    in AC1, if pertinent.

	       +2:  success,  double-precision,   floating-point   number
		    (extended  format where necessary) in AC2 and AC3 and
		    updated string pointer in AC1, if pertinent.

   DFIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   FLINX1:   first character is not blank or numeric

   FLINX2:   number too small

   FLINX3:   number too large

   FLINX4:   invalid format


Node: DFOUT	Previous: DFIN	Next: DIAG	Up: Top
			     DFOUT     JSYS 235

  Outputs a double-precision,	floating-point	number.   Currently  this
  call  outputs a number stored in KA10 double-precision, floating-point
  format.

   ACCEPTS IN AC1:  destination designator
   (DFOUT)
   

	      AC2:  a normalized double-precision

	      AC3:  floating-point   number   in   either   extended   or
		    non-extended range.

	      AC4:  format control word.  (Refer to Section 2.8.1.2.)

   RETURNS     +1:  failure, error code in AC4 and updated string pointer
		    in AC1, if pertinent.

	       +2:  success, updated string pointer in AC1, if pertinent.

   DFOUT ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   FLOTX1:   column overflow in field 1 or 2

   FLOTX2:   column overflow in field 3

   FLOTX3:   invalid format specified

   IOX11:    quota exceeded or disk full


Node: DIAG	Previous: DFOUT	Next: DIBE	Up: Top
			     DIAG     JSYS 530

   Reserves a channel and either a single device or all devices  attached
   to  that  channel.	This call is also used to release the channel and
   its devices.  When the request is made, no new activity  is	initiated
   on  the  requested channel, and the monitor waits for current activity
   on all devices connected to the channel to complete.  When the channel
   becomes idle, the process requesting the channel continues running.

   The DIAG JSYS can also be used to get and  release  memory.	 The  get
   memory  function is used by the system program TGHA for performing its
   spare bit substitution.

   Reserving or Releasing a Channel and Device(s).

   RESTRICTIONS:    requires WHEEL, OPERATOR, or MAINTENANCE capabilities
		    enabled.

  ACCEPTS IN AC1:  negative length of the argument  block  in	the  left
		    half,  and address of the argument block in the right
   (DIAG)
   

		    half.

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

   Function  Symbol    Meaning

       1     .DGACU    Assign the channel and a single device.	Force the
		       device	to  be	released  after  the  time  limit
		       specified.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address
		       2       time limit in milliseconds

       2     .DGACH    Assign the channel and all devices.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address

       3     .DGRCH    Release the channel and all assigned devices.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address

       4     .DGSCP    Set up the channel  program.   The  data  transfer
		       must  be in one page.  The user page pointed to by
		       the channel control word is locked in memory.  The
		       Exec  Process  Table location corresponding to the
		       channel is updated with the  appropriate  physical
		       address channel control word.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address
		       2       channel control word
   (DIAG)
   

       5     .DGRCP    Release the channel program.  The page pointed  to
		       by  the	channel  control  word	for the specified
		       channel	is  unlocked.	This  function	 is   not
		       required before specifying a new channel program.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address

       6     .DGGCS    Return the status of the  channel.   The  argument
		       block contains the logout area for the channel.

		       Argument block:

		       Word    Contents

		       0       function code
		       1       device address
		       2-5     4-word channel logout area

       100   .DGGEM    Get memory (for TGHA).

		       Argument block:

		       Word    Contents

		       0       function code
		       1       first page in user address space
		       2       first physical memory page
		       3       number of pages
		       4       user  address  of   AR/ARX   parity   trap
			       routines

       Upon successful return, this function accomplishes the following:

		       1.  TOPS-20 has requested that all  of  the  front
			   ends refrain from accessing common memory.

		       2.  The hardware PI system has  been  turned  off;
			   no scheduling can occur.

		       3.  The time base and  interval	timer  have  been
			   turned off.

		       4.  All DTE byte transfers have completed.

   (DIAG)
   

		       5.  All RH20 activity has ceased.

		       6.  The designated pages of the	process'  address
			   space   have   been	set  up  to  address  the
			   designated physical memory.	Note that this is
			   not	the  same  as  your  having requested the
			   pages  with	PLOCK.	 With  the   get   memory
			   function,  the  data  in  the  physical memory
			   pages have been retained, and the ownership of
			   the pages is unchanged.

		       7.  The CST0 entries for each  of  the  designated
			   physical  pages  have  been	saved  and set as
			   follows:

		       8.  The age is set  to  the  present  age  of  the
			   requesting process.

		       9.  The process use field is set to all ones.

		      10.  The modified bit is set to one.

		      11.  The entire address  space  of  the  requesting
			   process has been locked in memory.  (Actually,
			   only the pages that existed at the time of the
			   DIAG  call are locked.  Therefore, the process
			   must ensure that all of  the  pages	it  needs
			   exist and are private when DIAG is executed.)

		      12.  The monitor has set up proper dispatch if TGHA
			   specified an AR/ARX trap address.

       101   .DGREM    Release memory (for TGHA)

		       Argument block:

		       Word    Contents

		       0       function code

      102   .DGPDL    Inform  the  monitor  that  a  device   previously
		       unknown	to  it	is  now available for use (is now
		       online).  For devices interfaced through the  DX20
		       (TX01, TX03, TX05, TU70, TU72).

		       Argument block:
   (DIAG)
   

		       Word    Contents

		       0       function code
		       1       channel number
		       2       unit number
		       3       controller number (-1 if no controller)
		       4       alternate path channel number
		       5       alternate path unit number (should be same
			       as primary path unit number)
		       6       alternate path controller number (-1 if no
			       controller)

   The device  address	given  in  some  of  the  argument  blocks  is	a
   machine-dependent  specification  for  the  channel	and  device to be
   assigned.  The devices that can be assigned must be	attached  to  the
   RH20  controller  and  must	be  mounted  by a process with the WHEEL,
   OPERATOR, or MAINTENANCE capability enabled.  The format of the device
   address word is

	  0	    2 3       9 10     23 24	 29 30		35
	 !=======================================================!
	 !  address  ! device  !    0	 !  unit   !   subunit	 !
	 !   type    !	code   !	 !	   !		 !
	 !=======================================================!

   DIAG ERROR MNEMONICS:

   DIAGX1:   invalid function

   DIAGX2:   device is not assigned

   DIAGX3:   argument block too small

   DIAGX4:   invalid device type

   DIAGX5:   WHEEL, OPERATOR, or MAINTENANCE capability required

   DIAGX6:   invalid channel command list

   DIAGX7:   illegal to do I/O across page boundary

   DIAGX8:   no such device

   DIAGX9:   unit does not exist

   DIAG10:   subunit does not exist

   DIAG11:   Device is already on-line
   (DIBE)
   


Node: DIBE	Previous: DIAG	Next: DIC	Up: Top
			     DIBE     JSYS 212

   Dismisses the process until the designated file input buffer is empty.

   ACCEPTS IN AC1:  file designator

   RETURNS     +1:  always

   Returns immediately	if  the  designator  is  not  associated  with	a
   terminal.

   The DOBE monitor call can be used to dismiss  the  process  until  the
   designated file output buffer is empty.

   Generates an illegal instruction interrupt on error conditions below.

   DIBE ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: DIC	Previous: DIBE	Next: DIR	Up: Top
			      DIC     JSYS 133

   Deactivates the specified  software	interrupt  channels.   (Refer  to
   Section 2.5.1.)

   ACCEPTS IN AC1:  process handle

	      AC2:  36-bit word
		    Bit n means deactivate channel n

   RETURNS     +1:  always

   Software interrupt requests to deactivated channels are ignored except
   for	interrupts generated on panic channels.  Panic channel interrupts
   are passed to the closest  superior	process  that  has  the  specific
   channel enabled.

   The AIC monitor call is used to activate specified software	interrupt
   channels.

   Generates an illegal instruction interrupt on error conditions below.
   (DIC)
   

   DIC ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: DIR	Previous: DIC	Next: DIRST	Up: Top
			      DIR     JSYS 130

   Disables the software interrupt system for a process.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   If software interrupt  requests  are  generated  while  the	interrupt
   system  is  disabled, the requests are remembered and take effect when
   the interrupt system is reenabled unless an intervening  CIS  call  is
   executed.   However,  interrupts  on  panic	channels  will	still  be
   generated even though the system is disabled.   In  addition,  if  the
   CTRL/C  terminal code is assigned to a channel, it will still generate
   an interrupt  that  cannot  be  disabled  with  a  DIR  call.   CTRL/C
   interrupts  can  be	disabled by deactivating the channel to which the
   code is assigned or by the monitor.

   The EIR monitor call can be used  to  enable  the  software	interrupt
   system for a process.

   Generates an illegal instruction interrupt on error conditions below.

   DIR ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: DIRST	Previous: DIR	Next: DISMS	Up: Top
			     DIRST     JSYS 41
   (DIRST)
   

   Translates the specified  36-bit  user  or  directory  number  to  its
   corresponding  string  and writes it to the given destination.  When a
   user number is given, the string returned is  the  corresponding  user
   name  without  any punctuation.  When a directory number is given, the
   string returned is the  corresponding  structure  and  directory  name
   including punctuation (i.e., structure:<directory>).

   ACCEPTS IN AC1:  destination designator

	      AC2:  user or directory number

   RETURNS     +1:  failure, with error code in AC1.

	       +2:  success,  string  written  to  destination,   updated
		    string pointer, if pertinent, in AC1

   The RCDIR monitor call can be used to translate a directory string  to
   its	corresponding  directory  number.   The RCUSR monitor call can be
   used to translate a user name string to its corresponding user number.

   DIRST ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DELFX6:   internal format of directory is incorrect

   DIRX1:    invalid directory number

   DIRX2:    insufficient system resources

   DIRX3:    internal format of directory is incorrect

   STRX01:   structure is not mounted

   IOX11:    quota exceeded or disk full


Node: DISMS	Previous: DIRST	Next: DOBE	Up: Top
			     DISMS     JSYS 167

   Dismisses this process for the specified amount of time.

   ACCEPTS IN AC1:  number of milliseconds for which the process is to be
		    dismissed

   RETURNS     +1:  when the elapsed time is up
   (DISMS)
   

   The maximum number of milliseconds that a process can be dismissed  is
   2^26  milliseconds.	 If  a	number	is given that is greater than the
   maximum, it is ignored and the maximum dismiss  time  is  given.   The
   time  resolution  is  limited  to  the  scheduling frequency (about 20
   milliseconds).


Node: DOBE	Previous: DISMS	Next: DSKAS	Up: Top
			     DOBE     JSYS 104

   Dismisses the process until	the  designated  file  output  buffer  is
   empty.

   ACCEPTS IN AC1:  destination designator

   RETURNS     +1:  always

   Returns immediately if designator is not associated with a terminal.

   The DIBE monitor call can be used to dismiss  the  process  until  the
   designated file input buffer is empty.

   Generates an illegal instruction interrupt on error conditions below.

   DOBE ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   DEVX2:    device already assigned to another job

   TTYX01:   line is not active


Node: DSKAS	Previous: DOBE	Next: DSKOP	Up: Top
			     DSKAS     JSYS 244

   Assigns or deassigns specific disk addresses.

   RESTRICTIONS:	       requires WHEEL  or  OPERATOR  capabilities
			       enabled.
   ACCEPTS IN AC1:  B0(DA%DEA) deassign the specified  address.   If  the
			       address	is  currently  assigned,  control
			       returns to the next instruction	following
			       the  call (+1 return).  If the address was
			       not previously assigned, a BUGCHK occurs.
   (DSKAS)
   

		    B1(DA%ASF) assign a  free  page  near  the	specified
			       address.    Assignment	is  on	the  same
			       cylinder  as  the  specified  address,  if
			       possible, or on a nearby cylinder.  If the
			       specified address is 0, a page is assigned
			       on  a  cylinder	that is at least one-half
			       free.  If the assignment is  not  possible
			       because	the disk is full, control returns
			       to  the	next  instruction  following  the
			       call.

		    B2(DA%CNV) convert the specified address according to
			       the setting of B3(DA%HWA).

		    B3(DA%HWA) the  specified  address	is   a	 hardware
			       address.    If	this   bit  if	off,  the
			       specified address is a software address.

		    B4(DA%INI) initialize  a  private  copy  of  the  bit
			       table.

		    B5(DA%WRT) write the private copy of the bit table to
			       a new bit table file.

		    B18-B35    disk address
		    (DA%ADR)

	      AC2:  device designator of structure.  If DA%CNV is  on  in
		    AC1, this argument is not required.

   RETURNS     +1:  failure,  address  already	assigned  or  cannot   be
		    assigned

	       +2:  success, address assigned in AC1

   Generates an illegal instruction interrupt on error conditions below.

   DSKAS ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required


Node: DSKOP	Previous: DSKAS	Next: DTACH	Up: Top
			     DSKOP     JSYS 242

   Allows  the	process  to  reference	physical  disk	 addresses   when
   performing  disk transfers.	This monitor call requires the process to
   have WHEEL, OPERATOR, or MAINTENANCE capability enabled  to	read  and
   write  data.   However,  a  process	with  only MAINTENANCE capability
   enabled can write data only if it is using physical addresses (.DOPPU)
   and writing to a unit that is not part of a mounted structure.
   (DSKOP)
   

   RESTRICTIONS:		   requires	WHEEL	  or	 OPERATOR
				   capabilities  enabled.  Some functions
				   can	be  performed  with   MAINTENANCE
				   capabilities enabled.

   ACCEPTS IN AC1:  B0-B1(DOP%AT)  field  indicating  the  address  type.
				   For	  physical   channel   and   unit
				   addresses, the value of the	field  is
				   1(.DOPPU) and the remainder of AC1 is
				      B2-B6(DOP%CN) channel number
				      B7-B12(DOP%UN) unit number
				      B13-B35(DOP%UA) unit address
				   For	a  structure   and   a	 relative
				   address,  the  value  of  the field is
				   2(.DOPSR) and the remainder of AC1 is
				      B2-B10(DOP%SN) structure designator
				       flag  (0  is  structure	 PS:).	A
				       value of -1 means the structure is
				       indicated    by	  the	structure
				       designator  (refer to Section 2.4)
				       in AC4.
				      B11-B35(DOP%RA) relative address

				   Any other values for  this  field  are
				   illegal.

	      AC2:  control flags in the left half and	a  count  of  the
		    number  of	words to transfer in the right half.  The
		    control flags are

		    B11(DOP%IL)  inhibit error logging
		    B12(DOP%IR)  inhibit error recovery
		    B14(DOP%WR)  write data to the disk.  If this bit  is
				 off, read data from the disk.
		    B18-B35	 word count.  Since the  transfer  cannot
		    (DOP%CT)	 cross a page boundary, the count must be
				 less  than  or  equal	to  1000  (octal)
				 words.

	      AC3:  address in caller's address space from which data  is
		    written or into which data is read.

	      AC4:  device designator of the  structure.   This  word  is
		    used if the value given for DOP%SN is -1.

   RETURNS     +1:  always, AC1 is nonzero if an error occurred  or  zero
		    if no error occurred.

   If an error occurs and DOP%IL is on in the call, no error  logging  is
   performed.	If  DOP%IL  is	off, the standard system error logging is
   performed.

   If an error occurs and DOP%IR is on in the call,  no  retries  or  ECC
   corrections,  if  applicable,  are  attempted.   If DOP%IR is off, the
   standard system error recovery procedure is followed.
   (DSKOP)
   

   Generates an illegal instruction interrupt on error conditions below.

   DSKOP ERROR MNEMONICS:

   WHELX1:   WHEEL or OPERATOR capability required

   DSKOX1:   channel number too large

   DSKOX2:   unit number too large

   DSKOX3:   invalid structure number

   DSKOX4:   invalid address type specified


Node: DTACH	Previous: DSKOP	Next: DTI	Up: Top
			     DTACH     JSYS 115

   Detaches the controlling terminal from the current  job.   (The  ATACH
   call  with bit 1 (AT%NAT) of AC2 set can be used to detach a job other
   than the current job.) A console-detached entry  is	appended  to  the
   accounting data file.

   RETURNS     +1:  always

   The DTACH call is a no-op if the job is already detached.

   The ATACH monitor call is used to attach the controlling terminal to a
   specified job.


Node: DTI	Previous: DTACH	Next: DUMPI	Up: Top
			      DTI     JSYS 140

   Deassigns a terminal code.

   ACCEPTS IN AC1:  terminal code; refer to Section 2.5.6

   RETURNS     +1:  always

   The DTI call is a  no-op  if  the  specified  terminal  code  was  not
   assigned by the current process.

   The ATI monitor call is used to assign a terminal code.

   Generates an illegal instuction interrupt on error conditions below.

   DTI ERROR MNEMONICS:
   (DTI)
   

   TERMX1:   invalid terminal code


Node: DUMPI	Previous: DTI	Next: DUMPO	Up: Top
			     DUMPI     JSYS 65

   Reads data words into memory in unbuffered data mode.  The  file  must
   be  open  for data mode 17.	(Refer to Section 2.4.2.2 for information
   about unbuffered magnetic tape I/O.)

   ACCEPTS IN AC1:  JFN

	      AC2:  B0(DM%NWT)	do not wait for completion  of	requested
				operation

		    B18-B35	address of command list in memory
		    (DM%PTR)

   RETURNS     +1:  failure, error code  in  AC1,  pointer  to	offending
		    command in AC2

	       +2:  success, pointer in AC2 updated to last command

   The use of B0(DM%NWT) allows data operations  to  be  double  buffered
   with  a resulting increase in speed.  When this bit is on, DUMPI/DUMPO
   returns immediately after the request  is  queued.	This  allows  the
   program  to	overlap  computations  with I/O transfers.  If the second
   request is then made, the program is blocked until the  first  request
   is  completed.   Generally,	for  a sequence of overlapped DUMPI/DUMPO
   calls, return from the Nth call indicates that the Nth-1  request  has
   completed  and  that  the Nth request is now in progress.  This bit is
   implemented only for magnetic tape.

   The GDSTS call  can	be  used  after  the  transfer	is  completed  to
   determine the number of words read.

   If an error occurs on the Nth request, the failure return is given  on
   the Nth+1 call, and the Nth+1 request is ignored.  This means that the
   program will discover an error on a request only after making the next
   request.   The  next  request is ignored to prevent improper operation
   and must be reissued after the error has been  processed.   The  GDSTS
   call can be executed to determine the cause for the error.

   COMMAND LIST FORMAT

   Three types of entries may occur in the command list.

	1.  IOWD n, loc - Causes n words to be transferred from the  file
	    to	locations  loc	through  loc+n-1  of  the process address
	    space.  The  next  command	is  obtained  from  the  location
	    following  the  IOWD.   For  mag-tape files, 1 IOWD word will
	    read 1 physical tape record.  For labeled mag-tape files, the
   (DUMPI)
   

	    data format must be "U".

	    The IOWD pseudo-op generates XWD -n,loc-1.

	2.  XWD 0, y - Causes the next command to be taken from  location
	    y.	Referred to as a GOTO word.

	3.  0 - Terminates the command list.

   DUMPI ERROR MNEMONICS:

   DUMPX1:   command list error

   DUMPX2:   JFN is not open in dump mode

   DUMPX3:   address error (too big or crosses end of memory)

   DUMPX4:   access error (cannot read or write data in memory)

   DUMPX5:   no-wait dump mode not supported for this device

   DUMPX6:   dump mode not supported for this device

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   IOX1:     file is not opened for reading

   IOX4:     end of file reached

   IOX5:     device or data error


Node: DUMPO	Previous: DUMPI	Next: DVCHR	Up: Top
			     DUMPO     JSYS 66

   Writes data words from memory in unbuffered data mode.  The file  must
   be  open  for data mode 17.	(Refer to Section 2.4.2.2 for information
   about unbuffered magnetic tape I/O.)

   ACCEPTS IN AC1:  JFN

	      AC2:  B0(DM%NWT)	do not wait for completion  of	requested
				operation
   (DUMPO)
   

		    B18-B35	address of command list in memory
		    (DM%PTR)

   RETURNS     +1:  failure, error code  in  AC1,  pointer  to	offending
		    command in AC2

	       +2:  success, pointer in AC2 updated to last command

   The use of B0(DM%NWT) allows data operations  to  be  double  buffered
   with  a resulting increase in speed.  When this bit is on, DUMPI/DUMPO
   returns immediately after the request  is  queued.	This  allows  the
   program  to	overlap  computations  with I/O transfers.  If the second
   request is then made, the program is blocked until the  first  request
   is  completed.   Generally,	for  a sequence of overlapped DUMPI/DUMPO
   calls, return from the Nth call indicates that the Nth-1  request  has
   completed  and  that  the Nth request is now in progress.  This bit is
   implemented only for magnetic tape.

   COMMAND LIST FORMAT

   Three types of entries may occur in the command list.

	1.  IOWD n, loc - Causes n words from loc through loc+n-1  to  be
	    transferred  from the process address space to the file.  The
	    next command is obtained  from  the  location  following  the
	    IOWD.   For mag-tape files, 1 IOWD word will write 1 physical
	    tape record.  For labeled mag-tape	files,	the  data  format
	    must be "U".

					NOTE

		Dump mode output to a labeled tape can	override  the
		block-size  limit  specified  in  the  GTJFN.  If any
		write produces a block in  excess  of  the  specified
		block-size  parameter, then the file can only be read
		in dump mode.

	    The IOWD pseudo-op generates XWD -n,loc-1.

	2.  XWD 0, y - Causes the next command to be taken from  location
	    y.	Referred to as a GOTO word.

	3.  0 - Terminates the command list.

   The GDSTS call  can	be  used  after  the  transfer	is  completed  to
   determine the number of words written.

   DUMPO ERROR MNEMONICS:
   (DUMPO)
   

   DUMPX1:   command list error

   DUMPX2:   JFN is not open in dump mode

   DUMPX3:   address error (too big or crosses end of memory)

   DUMPX4:   access error (cannot read or write data in memory)

   DUMPX5:   no-wait dump mode not supported for this device

   DUMPX6:   dump mode not supported for this device

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer

   DESX5:    file is not open

   IOX2:     file is not opened for writing

   IOX5:     device or data error

   IOX11:    quota exceeded or disk full


Node: DVCHR	Previous: DUMPO	Next: EFACT	Up: Top
			     DVCHR     JSYS 117

   Returns the device characteristics of the specified device.

   ACCEPTS IN AC1:  JFN or device designator

   RETURNS     +1:  always, with

		    AC1 containing the device designator (even if  a  JFN
		    was given).
		    AC2 containing the device characteristics word.
		    AC3 containing the job number to which the device  is
		    assigned  in the left half and the unit number in the
		    right half.  If the device is a structure or does not
		    have units, the right half is -1.

  The left half of AC3 contains -1 if the device is not assigned to  any
  job or -2 if the device allocator has ownership of the device.

			Device Characteristics Word
			  

   Bit		  Symbol	      Meaning
   (DVCHR)
   

   0		  DV%OUT	 device can do output
   1		  DV%IN 	 device can do input
   2		  DV%DIR	 device has a directory
   3		  DV%AS 	 device is assignable with ASND
   4		  DV%MDD	 device has multiple directories
		    Device Characteristics Word (Cont.)
		       

   5		  DV%AV 	 device is available or assigned to this
				 job
   6		  DV%ASN	 device is assigned by ASND
   8		  DV%MNT	 device is mounted
   9-17 	  DV%TYP	 device type
				   0	   .DVDSK	  disk
				   2	   .DVMTA	  magnetic tape
				   7	   .DVLPT	  line printer
				   10	   .DVCDR	  card reader
				   11	   .DVFE	  front-end
							  pseudo-device
				   12	   .DVTTY	  terminal
				   13	   .DVPTY	  pseudo-terminal
				   15	   .DVNUL	  null device
				   16	   .DVNET	  ARPA network
   20-35	  DV%MOD	 data mode in which device can be opened
				   B20	    DV%M17	  dump mode
				   B27	    DV%M10	  image mode
				   B35	    DV%M0	  normal mode

   Generates an illegal instruction interrupt on error conditions below.

   DVCHR ERROR MNEMONICS:

   DEVX1:    invalid device designator

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    invalid use of terminal designator or string pointer


Node: EFACT	Previous: DVCHR	Next: EIR	Up: Top
			      EFACT     JSYS 5

   Makes an entry in the FACT file.  The EFACT monitor call  is  obsolete
   and	provided only for existing programs that make entries in the FACT
   file.  New programs should use the USAGE monitor call to make  entries
   in the new USAGE file.

   RESTRICTIONS:    requires WHEEL or OPERATOR capabilities enabled.
   ACCEPTS IN AC1:  LH:  negative size of entry
		    RH:  pointer to beginning  of  entry  (size  bits  of
			 entry	will  be  updated  by the system from the
   (EFACT)
   

			 negative size specified)

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The EFACT call returns successfully without making  an  entry  in  the
   FACT file if the monitor flag SF%FAC (refer to SMON and TMON calls) is
   not set.

   The EFACT monitor call can be executed only by the  monitor	or  by	a
   process that has WHEEL or OPERATOR capability enabled.

   EFACT ERROR MNEMONICS:

   EFCTX1:   WHEEL or OPERATOR capability required

   EFCTX2:   entry cannot be longer than 64 words

   EFCTX3:   fatal error when accessing FACT file


Node: EIR	Previous: EFACT	Next: ENQ	Up: Top
			      EIR     JSYS 126

   Enables the software  interrupt  system  for  a  process.   (Refer  to
   Section 2.5.)

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   The DIR monitor call can be used to	disable  the  software	interrupt
   system for a process.

   Generates an illegal instruction interrupt on error conditions below.

   EIR ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process

   FRKHX3:   invalid use of multiple process handle

  FRKHX8:   illegal to manipulate an execute-only process


Node: ENQ	Previous: EIR	Next: ENQC	Up: Top
			      ENQ     JSYS 513
   (ENQ)
   

   Requests access to a specific resource by placing  a  request  in  the
   queue  for that resource.  This call can be used to request any number
   of resources.

   Refer to the TOPS-20 Monitor Calls User's Guide for	an  overview  and
   description of the Enqueue/Dequeue facility.

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions are as follows:

      Code   Symbol			   Meaning

	0    .ENQBL	    Queue the  requests  and  block  the  process
			    until  all requested locks are acquired.  The
			    error return is taken only if the call is not
			    correctly specified.

	1    .ENQAA	    Queue the requests and acquire the locks only
			    if	all  requested	resources are immediately
			    available.	No requests are  queued  and  the
			    error  return  is  taken  if  any  one of the
			    resources is not available.

	2    .ENQSI	    Queue  the	requests.    If   all	requested
			    resources  are  immediately  available,  this
			    function is identical to the .ENQBL function.
			    If	 all   resources   are	 not  immediately
			    available, the  request  is  queued  and  the
			    error  return  (ENQX6:) is taken.  A software
			    interrupt  will  occur  when  all	requested
			    resources have been given to the process.

	3    .ENQMA	    Modify the	access	of  a  previously  queued
			    request.  (Refer to EN%SHR below.) The access
			    of each lock in this request is compared with
			    the  access  of  each  lock in the previously
			    queued request.  If the two accesses are  the
			    same,  no  action is taken.  If the access in
			    this request is shared and the access in  the
			    previous request is exclusive, the successful
			    return is  taken.	If  the  access  in  this
			    request  is  exclusive  and the access in the
			    previous request is shared, the error  return
			    is taken unless this process is the only user
			    of the lock.  In this  case,  the  successful
			    return  is	taken.	 The error return is also
   (ENQ)
   

			    taken if

			    1.	Any one of the specified locks	does  not
				have a pending request.

			    2.	Any one  of  the  specified  locks  is	a
				pooled resource.

			    Each  lock	specified  is  checked,  and  the
			    access  is	changed  for  all locks that were
			    given correctly.   If  the	error  return  is
			    taken, the user must execute the ENQC call to
			    determine the current state of each lock.

   The format of the argument block is as follows:

      Word   Symbol			   Meaning

	0    .ENQLN	    length  of	the  header  and  the  number  of
			    requested  locks in the left half, and length
			    of argument block in the right half.

	1    .ENQID	    software interrupt channel number in the left
			    half, and the request ID in the right half.

	2    .ENQLV	    flags and level number in the left half,  and
			    JFN,  -1,  -2, or -3 in the right half.  (See
			    below.)

	3    .ENQUC	    pointer to a  string  or  a  5B2+33-bit  user
			    code.

	4    .ENQRS	    number of resources in pool in the left  half
			    and  number  of  resources	requested  in the
			    right half, or 0 in the left half and a group
			    number in the right half.

	5    .ENQMS	    address of a resource mask block.
		.
		.
		.

      n-4		    flags and level number in the left half,  and
			    JFN, -1, -2, or -3 in the right half.

      n-3		    pointer to a  string  or  a  5B2+33-bit  user
			    code.

      n-2		    number of resources in pool in the left  half
			    and  number  of  resources	requested  in the
			    right half, or 0 in the left half and a group
			    number in the right half.

      n-1		    address of a resource mask block.
   (ENQ)
   

   The argument block is divided into two logical sections:  a header and
   individual  requests  for  each desired lock.  Words .ENQLN and .ENQID
   form the header.  Word .ENQLV through word .ENQMS form the  individual
   request  and are repeated for each lock being requested.  The words in
   the argument block are described in the following paragraphs.

   .ENQLN

   The length of the header (.ENHLN) is contained in bits  0  through  5.
   Currently,  the length of the header is two words.  (Note that a given
   length of zero or one is assumed to be equal to a length of two.)  The
   number  of  locks  being  requested	(.ENNLK)  is  contained in bits 6
   through 17, and the length of the argument block (.ENALN) is contained
   in bits 18 through 35.

   .ENQID

   The software interrupt channel specifies the number of the channel  on
   which  to generate an interrupt with the .ENQSI function.  The request
   ID is an 18-bit user-generated value used to identify  the  particular
   resource.   This  ID currently is not used by the system but is stored
   for future expansion of the facility.

   .ENQLV

   The following flags are defined:

      B0(EN%SHR)  Access to this resource is to be shared.  If	this  bit
		  is not set, access to the resource is to be exclusive.

      B1(EN%BLN)  Ignore the level number associated with this	resource.
		  Sequencing   errors	in  level  numbers  will  not  be
		  considered  fatal,  and  execution  of  the  call  will
		  continue.  If a sequencing error occurs, the successful
		  return will be taken, and AC1  will  contain	an  error
		  code indicating the sequencing error that occurred.

      B2(EN%NST)  Allow ownership of this lock to be nested to any  level
		  within  a  process.	This  means  that  a  process can
		  request this resource again even though it already owns
		  it.	If  the  process  has a request in the resource's
		  queue or if the process  already  owns  the  lock,  the
		  ownership  of the lock is nested to a depth one greater
		  than the current depth.  If the process does not have a
		  request  in  the  resource's queue, the setting of this
		  bit has no effect, and the execution of  the	ENQ  call
		  continues.   When  a process has a nested lock, it must
		  DEQ the resource as many times as it	ENQed  it  before
		  the resource becomes available to other processes.

      B3(EN%LTL)  Allow a long-term lock on this resource.  This notifies
		  the  system  that  this  resource  will  be  locked and
		  unlocked many times in a short period of time.  Setting
		  this bit permits a program to run faster if it is doing
		  multiple locks and unlocks on the same resource because
   (ENQ)
   

		  the argument block data is not deleted immediately from
		  the ENQ/DEQ data base when  a  DEQ  call  is	executed.
		  Thus,  the  time  required  to  re-create  the  data is
		  reduced.

      B9-B17	  Level number associated with this resource.
      (EN%LVL)

   The request is not queued and the error return is taken if  EN%BLN  is
   not set and

	1.  A resource with a level number less  than  or  equal  to  the
	    highest numbered resource requested so far is specified.

	2.  The level number of the current request does  not  match  the
	    level number supplied on previous requests for this resource.

   The right half of .ENQLV specifies the type of access desired for  the
   resource.   If  a  JFN  is  given, the file associated with the JFN is
   subject to the standard access protection of the  system.   If  -1  is
   given,  the resource can be accessed only by processes of the job.  If
   -2 is given, the resource can be accessed by any job  on  the  system.
   (The process must have ENQ capability enabled to specify -2.) If -3 is
   given, the resource can be accessed only by processes that have  WHEEL
   or OPERATOR capability enabled.

   .ENQUC

   This word is either a byte pointer to a string or a 33-bit user  code,
   either of which serves to uniquely identify the resource to all users.
   This quantity is the second part of the resource name.  (JFN, -1,  -2,
   or  -3  is  the  first part of the resource name.) The system makes no
   association between these identifiers and any physical resource.

   The string can be comprised of bytes of any size from 1 to 36 bits  in
   length  and	is  terminated	by a null byte.  The byte size desired is
   specified by the pointer to the string.  The  maximum  length  of  the
   string (including the terminating null byte) is 50 words long.

   .ENQRS

   This word is used to  allocate  multiple  resources	from  a  pool  of
   identical  resources.   The total number of resources in the pool is a
   parameter agreed upon by all users.	All requests for the same  pooled
   resource  must  agree  with	the original count or the error return is
   taken.  The number of resources being requested from the pool must  be
   greater  than  zero if a pool exists and must be smaller than or equal
   to the number in the pool.  If the left half of this word is zero, the
   system assumes only one resource of the specific type exists.  In this
   case, if the right half of this word is positive, it is interpreted as
   the	number	of  the  group of users who can simultaneously access the
   resource.

   .ENQMS
   (ENQ)
   

   Obtains a single  lock  representing  many  specific  resources.   For
   example,  a	lock  can  be obtained on a particular data base, and the
   specific resources requested can be individual records  in  that  data
   base.

  This word contains an address of a mask block, consisting of  a  count
  word  and  a  group	of  mask words.  The first word of the mask block
  contains a count (in the right half-word) of the number  of	words  in
  the block, including the count word.  The remaining words each contain
  36 mask bits, where each bit represents a  specific	resource  of  the
  lock.  The maximum length of the mask block is 16 words.  All requests
  for the resources associated with the mask block must specify the same
  length  for	the block or an error return is taken.	Also, when a mask
  block is specified, the ENQ call must request exclusive access to  the
  resource  and the left half of word .ENQRS of the lock request must be
  zero.

   The set of resources comprising the lock is a parameter agreed upon by
   all users.

   A process can obtain exclusive access to all or some of  the  specific
   resources  comprising  the  lock.   When  a process requires exclusive
   access to all of the resources, it executes an ENQ call (for exclusive
   access)  and  does not specify a mask block.  A successful return will
   be given if there are no other processes that have issued an ENQ  call
   for	that  lock.   Otherwise,  the  process blocks until the requested
   resources are available.

   When a process requires exclusive  access  to  some	of  the  specific
   resources  comprising the lock, it sets up the mask block and sets the
   bits corresponding to the specific resources it wants  to  lock.   The
   process then executes an ENQ call for exclusive access.  On successful
   execution of the ENQ call, the process has an exclusive lock  for  the
   resources  represented by the bits on in the mask.  The process blocks
   if another process owns an exclusive lock on  the  resource	and  that
   process' ENQ call did not specify a mask block.

   Once a mask block has been set up for a  set  of  specific  resources,
   subsequent  requests for a different set of resources will be honored.
   The set of resources being requested is considered  different  if  the
   bits  on in one process' mask block are not any of the same bits on in
   another process' mask block.  When a subsequent request is  given  for
   resources that are currently locked by a process, the process with the
   request blocked until the last of the currently  locked  resources  is
   dequeued by the owner of the lock.

   A process can dequeue all or part of the original  ENQ  call  request.
   When  a DEQ call is executed, the bits on in the mask block of the DEQ
   call are compared with the bits on in  the  original  ENQ  call.   The
   resources  not  being dequeued remain locked and must be dequeued by a
   subsequent DEQ call.  This action allows a process to lock a number of
   resources  all  at once and then to release individual resources as it
   finishes with them.	However, a process cannot execute subsequent  ENQ
   calls  to  request  additional  resources  from those requested in its
   original ENQ call.
   (ENQ)
   

   ENQ ERROR MNEMONICS:

   ENQX1:    invalid function

   ENQX2:    level number too small

   ENQX3:    request and lock level numbers do not match

   ENQX4:    number of pool and lock resources do not match

   ENQX5:    lock already requested

   ENQX6:    requested locks are not all locked

   ENQX8:    invalid access change requested

   ENQX9:    invalid number of blocks specified

   ENQX10:   invalid argument block length

   ENQX11:   invalid software interrupt channel number

   ENQX12:   invalid number of resources requested

   ENQX13:   indirect or indexed byte pointer not allowed

   ENQX14:   invalid byte size

   ENQX15:   ENQ/DEQ capability required

   ENQX16:   WHEEL or OPERATOR capability required

   ENQX17:   invalid JFN

   ENQX18:   quota exceeded

   ENQX19:   string too long

   ENQX20:   locked JFN cannot be closed

   ENQX22:   invalid mask block length

   ENQX23:   mismatched mask block lengths

   DESX8:    file is not on disk


Node: ENQC	Previous: ENQ	Next: EPCAP	Up: Top
			     ENQC     JSYS 515

   Returns  the  current  status  of  the  given  resource  and   obtains
   information	about  the  state  of the queues.  This monitor call also
   (ENQC)
   

   allows privileged processes to manipulate access rights to the  queues
   and to perform other utility functions on the queue structure.

   Refer to the TOPS-20 Monitor Calls User's Guide for	an  overview  and
   description of the Enqueue/Dequeue facility.

   The ENQC monitor call has two calling sequences, depending on  whether
   the	process is obtaining status information or is modifying the queue
   structure.

   Obtaining Status Information
     

   RESTRICTIONS:    some functions require WHEEL or OPERATOR capabilities
		    enabled.
   ACCEPTS IN AC1:  function code (.ENQCS)

	      AC2:  address of argument block

	      AC3:  address of block in which to place status

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The function .ENQCS returns the status of the specified resources.

   The argument block is identical in format to the ENQ and DEQ  argument
   blocks.  (Refer to the ENQ monitor call description.)

   The status block has a 3-word entry for each resource specified in the
   argument  block.   This  entry  reflects  the  current  status  of the
   resource and has the following format:

	  0			   17 18		       35
	 !=======================================================!
	 !	  flag bits indicating status of resource	 !
	 !=======================================================!
	 !		     36-bit time stamp			 !
	 !=======================================================!
	 ! # of processes with lock  !	      request ID	 !
	 !=======================================================!

   The following flag bits are currently defined.

	B0(EN%QCE) An error has occurred in  the  corresponding  resource
		   request  and  bits  18-35 contain an appropriate error
		   code.

	B1(EN%QCO) This process owns the lock.

	B2(EN%QCQ) This  process  is  in  the  queue  waiting  for   this
		   resource.   This  bit  is  set  if  B1(EN%QCO)  is set
		   because a request remains in the  queue  until  a  DEQ
   (ENQC)
   

		   call is given.

	B3(EN%QCX) The lock has been allocated for exclusive access.

	B4(EN%QCB) This process is in the  queue  waiting  for	exclusive
		   access to the resource.  This bit is off if B2(EN%QCQ)
		   is off.

	B9-B17	   The level number of the resource.
	(EN%LVL)

	B18-B35    Job	number	of  the  owner	of  the lock.  For  locks
	(EN%JOB)   with shared access, this value will be the job  number
		   of  one  of	the sharers.  However, this value will be
		   the current job's number if the current job is one  of
		   the	sharers.   If the lock is not owned, the value is
		   -1.	If B0(EN%QCE) is  on,  this  field  contains  the
		   appropriate error code.

   The time stamp indicates the last time a process was given  access  to
   the resource.  The time is in the universal date-time standard.  If no
   process currently has access to the resource, the word is zero.

   The number returned in the left half of the third word  indicates  the
   number of processes that currently have the resource locked for either
   exclusive access or shared access.

   The request ID is either the request ID of the current process if that
   process is in the queue or the request ID of the owner of the lock.

   Modifying the Queue Structure
      

   ACCEPTS IN AC1:  function code

	      AC2:  address of argument block

   RETURNS     +1:  failure, error code in AC1

	       +2:  success

   The available functions, along with their argument block formats,  are
   as follows:

	Function  Argument Block		     Meaning

	.ENQCG	  One word containing	   Return the ENQ/DEQ quota for
		  a job number in the	   the specified job. The quota
		  right half. The left	   is returned in AC1.
		  half is ignored.

	.ENQCC	  One word containing	   Change the ENQ/DEQ quota for
		  the new quota in the	   the specified job. The process
		  left half and a job	   executing the call must have
		  number in the right	   WHEEL capability enabled or an
		  half. 		   error code is returned.
   (ENQC)
   

	.ENQCD	  A block of n words.	   Dump the ENQ/DEQ locks and
		  The first word is the    queue entries into the
		  length of the block (n). argument block. The process
		  Remaining words contain  executing the call must have
		  the returned		   WHEEL capability enabled or an
		  data. (See below.)	   error code is returned.

   The data returned in the argument block is data  concerning	both  the
   ENQ/DEQ  locks  and the queues.  The data concerning the locks is in a
   4-word block of the following format:

	       0	   8 9		17 18			    35
	      !=======================================================!
      .ENQDF  !    flags    !level number ! OFN, 40000+job#, -2, or -3!
	      !=======================================================!
      .ENQDR  !  total resources in pool  ! # of resources remaining  !
	      !=======================================================!
      .ENQDT  ! 	  time stamp of last request locked	      !
	      !=======================================================!
      .ENQDC  !       user code of lock or beginning of string	      !
	      !=======================================================!

   If there are no pooled resources, word .ENQDR has the format:

	       0			17 18			    35
	      !=======================================================!
      .ENQDR  ! 	    0		  !	  group number	      !
	      !=======================================================!

   The data concerning the queues is in a 2-word block of  the	following
   format:

	       0	   8 9		17 18			    35
	      !=======================================================!
      .ENQDF  !    flags    !software chan! job # creator queue entry !
	      !=======================================================!
      .ENQDI  !group # or number requested!	   request ID	      !
	      !=======================================================!

   The flags returned in the first word of each block are as follows:

      B0(EN%QCL) This block concerns data about the locks.  If	this  bit
		 is off, the block concerns data about the queues.

      B1(EN%QCO) This process owns the lock.

      B2(EN%QCT) This lock contains a text string.

      B3(EN%QCX) This lock is for exclusive access.
   (ENQC)
   

      B4(EN%QCB) This  process	is  blocked  until  exclusive  access  is
		 available.

   ENQC ERROR MNEMONICS:

   ENQX1:    invalid function

   ENQX2:    level number too small

   ENQX3:    request and lock level numbers do not match

   ENQX4:    number of pool and lock resources do not match

   ENQX5:    lock already requested

   ENQX6:    requested locks are not all locked

   ENQX7:    no ENQ on this lock

   ENQX8:    invalid access change requested

   ENQX9:    invalid number of blocks specified

   ENQX10:   invalid argument block length

   ENQX11:   invalid software interrupt channel number

   ENQX12:   invalid number of resources requested

   ENQX13:   indirect or indexed byte pointer not allowed

   ENQX14:   invalid byte size

   ENQX15:   ENQ/DEQ capability required

   ENQX16:   WHEEL or OPERATOR capability required

   ENQX17:   invalid JFN

   ENQX18:   quota exceeded

   ENQX19:   string too long

   ENQX20:   locked JFN cannot be closed

   ENQX21:   job is not logged in

   DESX8:    file is not on disk


Node: EPCAP	Previous: ENQC	Next: ERSTR	Up: Top
			     EPCAP     JSYS 151
   (EPCAP)
   

   Enables the capabilities for the specified process.	(Refer to Section
   2.6.1 for a description of the capability word.)

   ACCEPTS IN AC1:  process handle

	      AC2:  capabilities possible for the specified process

	      AC3:  capabilities to enable for the specified process

   RETURNS     +1:  always

   The capabilities in bits 0-8 and bits 18-35 of AC2  are  matched  with
   the	corresponding capabilities of the process executing the call.  If
   the executing process does  not  have  the  capability  available,  it
   cannot be enabled for the specified process (i.e., an AND operation is
   performed).

   The contents of AC2 are ignored if the process handle in  AC1  is  for
   the current process.

   The RPCAP monitor call can be used to obtain  the  capabilities  of	a
   process.

   Generates an illegal instruction interrupt on error conditions below.

   EPCAP ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process


Node: ERSTR	Previous: EPCAP	Next: ESOUT	Up: Top
			     ERSTR     JSYS 11

   Translates a TOPS-20 error number to its corresponding text string and
   writes  the string to the specified destination.  This error number is
   the one returned in an AC (usually in AC1) on  a  JSYS  error  and  is
   associated  with  a	unique error mnemonic and text string.	The error
   numbers begin at 600010 and are defined in the system file MONSYM.MAC.
   (Refer  to  Appendix  A  for the list of error numbers, mnemonics, and
   text strings.)

   ACCEPTS IN AC1:  destination designator

	      AC2:  LH:  process handle
		    RH:  error number, or -1 for the most recent error
			 in the specified process.  If an error number is
			 specified, .FHSLF should be specified in AC1.

	      AC3:  LH:  a negative  count of the maximum number of bytes
			 in the string to be transferred,  or  0  for  no
   (ERSTR)
   

			 limit
		    RH:  0

   RETURNS     +1:  failure, undefined error number

	       +2:  failure,  string  size  out  of  bounds  or   invalid
		    destination designator

	       +3:  success

  Note that if an error code (i.e.  not -1) is given in the  right  half
  of  AC2,  then  the	fork  handle  in  the  left  half  of  AC2 has no
  significance to the JSYS.  (It will return an error, however,  if  the
  fork handle is not a legitimate handle.)

   Generates an illegal instruction interrupt on error conditions below.

   ERSTR ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   FRKHX1:   invalid process handle

   IOX11:    quota exceeded or disk full


Node: ESOUT	Previous: ERSTR	Next: FFFFP	Up: Top
			     ESOUT     JSYS 313

   Outputs an error string.  This monitor call is used for  reporting  an
   error  in  the  input  from the primary input stream in order to cause
   re-synchronization  of  the	input  transaction.   This  mechanism  is
   convenient  for  communication with a user who made a typing error and
   may have continued to type ahead.  It also standardizes the format  of
   error messages.

   ACCEPTS IN AC1:  byte pointer to a  string  in  the	caller's  address
		    space.    The   string  is	terminated  with  a  null
		    character.

   RETURNS     +1:  always, updated string pointer in AC1

   The ESOUT call waits for the primary output buffer to empty	and  then
   outputs a carriage return, line feed, and question mark to the primary
   output designator.  Next  it  clears  the  primary  input  buffer  and
   outputs the error string to the primary output designator.

   Can cause several  software	interrupts  or	process  terminations  on
   certain  file  conditions.	(Refer	to  bit  OF%HER of the OPENF call
   description.)
   (FFFFP)
   


Node: FFFFP	Previous: ESOUT	Next: FFORK	Up: Top
			     FFFFP     JSYS 31

   Finds the first free page in the specified file.  A free page  is  one
   that  is  marked  as  not  being in use.  The FFFFP call is useful for
   finding a nonused page in a file before a PMAP call is  executed  that
   writes into that page.

  ACCEPTS IN AC1:  starting page number in left half, JFN in right half.

   RETURNS     +1:  always, with the JFN in the left half of AC1 and  the
		    page  number  in the right half of AC1, or a fullword
		    -1 in AC1 if there is no free page.

   Generates an illegal instruction interrupt on error conditions below.

   FFFFP ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    illegal use of terminal designator or string pointer

   DESX5:    file is not open


Node: FFORK	Previous: FFFFP	Next: FFUFP	Up: Top
			     FFORK     JSYS 154

   Freezes one or more processes.

   ACCEPTS IN AC1:  process handle

   RETURNS     +1:  always

   This suspends the processes (as soon as they are  stoppable	from  the
   monitor's  point  of view) in such a way that they can be continued at
   the place they were suspended.   However,  they  do	not  have  to  be
   continued;  they could be killed.

   The FFORK call is a no-op if the referenced process is already frozen.

   The RFORK monitor call can be used to resume one or more processes.

   Generates an illegal instruction interrupt on error conditions below.

   FFORK ERROR MNEMONICS:

   FRKHX1:   invalid process handle

   FRKHX2:   illegal to manipulate a superior process
   (FFORK)
   

   FRKHX3:   invalid use of multiple process handle


Node: FFUFP	Previous: FFORK	Next: FLHST	Up: Top
			     FFUFP     JSYS 211

   Finds the first used page of the file at or beyond the specified  page
   number.

   ACCEPTS IN AC1:  JFN in the left half, and the starting page number in
		    the right half

   RETURNS     +1:  failure, error code in AC1

	       +2:  success, page number in the right half of  AC1.   The
		    left half of AC1 is unchanged.

   FFUFP ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX3:    JFN is not assigned

   DESX4:    illegal use of terminal designator or string pointer

   DESX7:    JFN cannot refer to output wildcard designators

   FFUFX1:   file is not open

   FFUFX2:   file is not on multiple-directory device

   FFUFX3:   no used page found


Node: FLHST	Previous: FFUFP	Next: FLIN	Up: Top
			     FLHST     JSYS 277

  "Flushes" an ARPANET host.  Causes  the  NCP  tables  containing  that
  host's  status  information	to be purged of all information regarding
  previous or partially terminated connections between the  sending  and
  receiving  hosts  of  the  connection.  All connections to the flushed
  host are closed.

  RESTRICTIONS:    for ARPANET systems only.  Requires OPERATOR,  WHEEL,
		    or NET WIZARD capabilities enabled.

  ACCEPTS IN AC1:  number of host to be flushed

  RETURNS     +1:  always
   (FLIN)
   


Node: FLIN	Previous: FLHST	Next: FLOUT	Up: Top
			     FLIN     JSYS 232

   Inputs a floating-point number from the specified source.   This  call
   ignores  leading  spaces  and  terminates  on the first character that
   cannot be part of a floating point number.  If  that  character  is	a
   carriage return followed by a line feed, the line feed is also input.

   ACCEPTS IN AC1:  source designator

   RETURNS     +1:  failure, error code in AC3 and updated string pointer
		    in AC1, if pertinent

	       +2:  success, single-precision, floating-point  number  in
		    AC2 and updated string pointer in AC1, if pertinent

   FLIN ERROR MNEMONICS:

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX5:    file is not open

   FLINX1:   first character is not blank or numeric

   FLINX2:   number too small

   FLINX3:   number too large

   FLINX4:   invalid format


Node: FLOUT	Previous: FLIN	Next: (JSYS4GM)GACCT	Up: Top
			     FLOUT     JSYS 233

   Outputs a floating-point number to the specified destination.

   ACCEPTS IN AC1:  destination designator

	      AC2:  normalized, single-precision, floating-point number

	      AC3:  format control word.  (Refer to Section 2.8.1.2.)

   RETURNS     +1:  failure, error code in AC3 and updated string pointer
		    in AC1, if pertinent

	       +2:  success, updated string pointer in AC1, if pertinent

   FLOUT ERROR MNEMONICS:
   (FLOUT)
   

   DESX1:    invalid source/destination designator

   DESX2:    terminal is not available to this job

   DESX3:    JFN is not assigned

   DESX4:    file is not open

   FLOTX1:   column overflow in field 1 or 2

   FLOTX2:   column overflow in field 3

   FLOTX3:   invalid format specified

   IOX11:    quota exceeded or disk full


